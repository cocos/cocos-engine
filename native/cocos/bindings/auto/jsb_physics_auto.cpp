// clang-format off

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.1.0
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

/****************************************************************************
 Copyright (c) 2022 Xiamen Yaji Software Co., Ltd.

 http://www.cocos.com

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated engine source code (the "Software"), a limited,
 worldwide, royalty-free, non-assignable, revocable and non-exclusive license
 to use Cocos Creator solely to develop games on your target platforms. You shall
 not use Cocos Creator software for developing other software or tools that's
 used for developing games. You are not granted to publish, distribute,
 sublicense, and/or sell copies of Cocos Creator.

 The software or tools in this License Agreement are licensed, not sold.
 Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
****************************************************************************/

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-variable"
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-variable"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4101)
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static 
#endif



#include <stdio.h>


#include "bindings/jswrapper/SeApi.h"
#include "bindings/manual/jsb_conversions.h"
#include "bindings/manual/jsb_global.h"


#include "bindings/auto/jsb_physics_auto.h"



se::Class* __jsb_cc_physics_World_class = nullptr;
se::Object* __jsb_cc_physics_World_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_physics_World) 

// js_ctor
static bool js_new_cc_physics_World(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::physics::World *result;
    result = (cc::physics::World *)new cc::physics::World();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_physics_World, __jsb_cc_physics_World_class, js_delete_cc_physics_World)

static bool js_delete_cc_physics_World(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_physics_World) 

static bool js_cc_physics_World_setGravity(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "World_setGravity,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "World_setGravity,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "World_setGravity,4,SWIGTYPE_float"); 
    (arg1)->setGravity(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_setGravity) 

static bool js_cc_physics_World_setAllowSleep(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "World_setAllowSleep,2,SWIGTYPE_bool"); 
    (arg1)->setAllowSleep(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_setAllowSleep) 

static bool js_cc_physics_World_step(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "World_step,2,SWIGTYPE_float"); 
    (arg1)->step(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_step) 

static bool js_cc_physics_World_emitEvents(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->emitEvents();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_emitEvents) 

static bool js_cc_physics_World_syncSceneToPhysics(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->syncSceneToPhysics();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_syncSceneToPhysics) 

static bool js_cc_physics_World_syncSceneWithCheck(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->syncSceneWithCheck();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_syncSceneWithCheck) 

static bool js_cc_physics_World_setCollisionMatrix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "World_setCollisionMatrix,2,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "World_setCollisionMatrix,3,SWIGTYPE_uint32_t"); 
    
    (arg1)->setCollisionMatrix(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_setCollisionMatrix) 

static bool js_cc_physics_World_getTriggerEventPairs(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    ccstd::vector< std::shared_ptr< cc::physics::TriggerEventPair > > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< std::shared_ptr< cc::physics::TriggerEventPair > > *) &(arg1)->getTriggerEventPairs();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "World_getTriggerEventPairs, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_getTriggerEventPairs) 

static bool js_cc_physics_World_getContactEventPairs(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    ccstd::vector< std::shared_ptr< cc::physics::ContactEventPair > > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< std::shared_ptr< cc::physics::ContactEventPair > > *) &(arg1)->getContactEventPairs();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "World_getContactEventPairs, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_getContactEventPairs) 

static bool js_cc_physics_World_raycast(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    cc::physics::RaycastOptions *arg2 = 0 ;
    cc::physics::RaycastOptions temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "World_raycast,2,SWIGTYPE_p_cc__physics__RaycastOptions");
    arg2 = &temp2;
    
    result = (bool)(arg1)->raycast(*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_raycast) 

static bool js_cc_physics_World_raycastClosest(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    cc::physics::RaycastOptions *arg2 = 0 ;
    cc::physics::RaycastOptions temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "World_raycastClosest,2,SWIGTYPE_p_cc__physics__RaycastOptions");
    arg2 = &temp2;
    
    result = (bool)(arg1)->raycastClosest(*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_raycastClosest) 

static bool js_cc_physics_World_raycastResult(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    ccstd::vector< cc::physics::RaycastResult > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::physics::RaycastResult > *) &(arg1)->raycastResult();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "World_raycastResult, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_raycastResult) 

static bool js_cc_physics_World_raycastClosestResult(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    cc::physics::RaycastResult *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::physics::RaycastResult *) &(arg1)->raycastClosestResult();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "World_raycastClosestResult, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_raycastClosestResult) 

static bool js_cc_physics_World_createConvex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    cc::physics::ConvexDesc *arg2 = 0 ;
    cc::physics::ConvexDesc temp2 ;
    uint32_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "World_createConvex,2,SWIGTYPE_p_cc__physics__ConvexDesc");
    arg2 = &temp2;
    
    result = (arg1)->createConvex(*arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "World_createConvex, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_createConvex) 

static bool js_cc_physics_World_createTrimesh(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    cc::physics::TrimeshDesc *arg2 = 0 ;
    cc::physics::TrimeshDesc temp2 ;
    uint32_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "World_createTrimesh,2,SWIGTYPE_p_cc__physics__TrimeshDesc");
    arg2 = &temp2;
    
    result = (arg1)->createTrimesh(*arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "World_createTrimesh, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_createTrimesh) 

static bool js_cc_physics_World_createHeightField(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    cc::physics::HeightFieldDesc *arg2 = 0 ;
    cc::physics::HeightFieldDesc temp2 ;
    uint32_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "World_createHeightField,2,SWIGTYPE_p_cc__physics__HeightFieldDesc");
    arg2 = &temp2;
    
    result = (arg1)->createHeightField(*arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "World_createHeightField, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_createHeightField) 

static bool js_cc_physics_World_createMaterial(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    uint16_t arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    uint8_t arg6 ;
    uint8_t arg7 ;
    bool result;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "World_createMaterial,2,SWIGTYPE_uint16_t"); 
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "World_createMaterial,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "World_createMaterial,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "World_createMaterial,5,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "World_createMaterial,6,SWIGTYPE_uint8_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "World_createMaterial,7,SWIGTYPE_uint8_t"); 
    
    result = (bool)(arg1)->createMaterial(arg2,arg3,arg4,arg5,arg6,arg7);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_createMaterial) 

static bool js_cc_physics_World_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_destroy) 

bool js_register_cc_physics_World(se::Object* obj) {
    auto* cls = se::Class::create("World", obj, nullptr, _SE(js_new_cc_physics_World)); 
    
    
    cls->defineFunction("setGravity", _SE(js_cc_physics_World_setGravity)); 
    cls->defineFunction("setAllowSleep", _SE(js_cc_physics_World_setAllowSleep)); 
    cls->defineFunction("step", _SE(js_cc_physics_World_step)); 
    cls->defineFunction("emitEvents", _SE(js_cc_physics_World_emitEvents)); 
    cls->defineFunction("syncSceneToPhysics", _SE(js_cc_physics_World_syncSceneToPhysics)); 
    cls->defineFunction("syncSceneWithCheck", _SE(js_cc_physics_World_syncSceneWithCheck)); 
    cls->defineFunction("setCollisionMatrix", _SE(js_cc_physics_World_setCollisionMatrix)); 
    cls->defineFunction("getTriggerEventPairs", _SE(js_cc_physics_World_getTriggerEventPairs)); 
    cls->defineFunction("getContactEventPairs", _SE(js_cc_physics_World_getContactEventPairs)); 
    cls->defineFunction("raycast", _SE(js_cc_physics_World_raycast)); 
    cls->defineFunction("raycastClosest", _SE(js_cc_physics_World_raycastClosest)); 
    cls->defineFunction("raycastResult", _SE(js_cc_physics_World_raycastResult)); 
    cls->defineFunction("raycastClosestResult", _SE(js_cc_physics_World_raycastClosestResult)); 
    cls->defineFunction("createConvex", _SE(js_cc_physics_World_createConvex)); 
    cls->defineFunction("createTrimesh", _SE(js_cc_physics_World_createTrimesh)); 
    cls->defineFunction("createHeightField", _SE(js_cc_physics_World_createHeightField)); 
    cls->defineFunction("createMaterial", _SE(js_cc_physics_World_createMaterial)); 
    cls->defineFunction("destroy", _SE(js_cc_physics_World_destroy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_physics_World));
    
    
    cls->install();
    JSBClassType::registerClass<cc::physics::World>(cls);
    
    __jsb_cc_physics_World_proto = cls->getProto();
    __jsb_cc_physics_World_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_physics_RigidBody_class = nullptr;
se::Object* __jsb_cc_physics_RigidBody_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_physics_RigidBody) 

// js_ctor
static bool js_new_cc_physics_RigidBody(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::physics::RigidBody *result;
    result = (cc::physics::RigidBody *)new cc::physics::RigidBody();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_physics_RigidBody, __jsb_cc_physics_RigidBody_class, js_delete_cc_physics_RigidBody)

static bool js_delete_cc_physics_RigidBody(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_physics_RigidBody) 

static bool js_cc_physics_RigidBody_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    cc::physics::ERigidBodyType arg3 ;
    uint32_t arg4 ;
    int32_t temp3 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RigidBody_initialize,2,SWIGTYPE_p_cc__Node"); 
    // %typemap(in) enum SWIGTYPE (int32_t temp3)
    ok &= sevalue_to_native(args[1], &temp3);
    SE_PRECONDITION2(ok, false, "RigidBody_initialize,3,SWIGTYPE_cc__physics__ERigidBodyType");
    arg3 = (cc::physics::ERigidBodyType)temp3;
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "RigidBody_initialize,4,SWIGTYPE_uint32_t"); 
    
    (arg1)->initialize(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_initialize) 

static bool js_cc_physics_RigidBody_onEnable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_onEnable) 

static bool js_cc_physics_RigidBody_onDisable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_onDisable) 

static bool js_cc_physics_RigidBody_onDestroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onDestroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_onDestroy) 

static bool js_cc_physics_RigidBody_isAwake(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->isAwake();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_isAwake) 

static bool js_cc_physics_RigidBody_isSleepy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->isSleepy();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_isSleepy) 

static bool js_cc_physics_RigidBody_isSleeping(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->isSleeping();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_isSleeping) 

static bool js_cc_physics_RigidBody_setType(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    cc::physics::ERigidBodyType arg2 ;
    int32_t temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "RigidBody_setType,2,SWIGTYPE_cc__physics__ERigidBodyType");
    arg2 = (cc::physics::ERigidBodyType)temp2;
    (arg1)->setType(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_setType) 

static bool js_cc_physics_RigidBody_setMass(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_setMass,2,SWIGTYPE_float"); 
    (arg1)->setMass(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_setMass) 

static bool js_cc_physics_RigidBody_setLinearDamping(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_setLinearDamping,2,SWIGTYPE_float"); 
    (arg1)->setLinearDamping(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_setLinearDamping) 

static bool js_cc_physics_RigidBody_setAngularDamping(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_setAngularDamping,2,SWIGTYPE_float"); 
    (arg1)->setAngularDamping(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_setAngularDamping) 

static bool js_cc_physics_RigidBody_useGravity(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "RigidBody_useGravity,2,SWIGTYPE_bool"); 
    (arg1)->useGravity(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_useGravity) 

static bool js_cc_physics_RigidBody_useCCD(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "RigidBody_useCCD,2,SWIGTYPE_bool"); 
    (arg1)->useCCD(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_useCCD) 

static bool js_cc_physics_RigidBody_setLinearFactor(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_setLinearFactor,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_setLinearFactor,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_setLinearFactor,4,SWIGTYPE_float"); 
    (arg1)->setLinearFactor(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_setLinearFactor) 

static bool js_cc_physics_RigidBody_setAngularFactor(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_setAngularFactor,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_setAngularFactor,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_setAngularFactor,4,SWIGTYPE_float"); 
    (arg1)->setAngularFactor(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_setAngularFactor) 

static bool js_cc_physics_RigidBody_setAllowSleep(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "RigidBody_setAllowSleep,2,SWIGTYPE_bool"); 
    (arg1)->setAllowSleep(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_setAllowSleep) 

static bool js_cc_physics_RigidBody_wakeUp(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->wakeUp();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_wakeUp) 

static bool js_cc_physics_RigidBody_sleep(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->sleep();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_sleep) 

static bool js_cc_physics_RigidBody_clearState(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->clearState();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_clearState) 

static bool js_cc_physics_RigidBody_clearForces(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->clearForces();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_clearForces) 

static bool js_cc_physics_RigidBody_clearVelocity(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->clearVelocity();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_clearVelocity) 

static bool js_cc_physics_RigidBody_setSleepThreshold(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_setSleepThreshold,2,SWIGTYPE_float"); 
    (arg1)->setSleepThreshold(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_setSleepThreshold) 

static bool js_cc_physics_RigidBody_getSleepThreshold(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getSleepThreshold();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_getSleepThreshold) 

static bool js_cc_physics_RigidBody_getLinearVelocity(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    cc::Vec3 result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getLinearVelocity();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RigidBody_getLinearVelocity, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_getLinearVelocity) 

static bool js_cc_physics_RigidBody_setLinearVelocity(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_setLinearVelocity,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_setLinearVelocity,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_setLinearVelocity,4,SWIGTYPE_float"); 
    (arg1)->setLinearVelocity(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_setLinearVelocity) 

static bool js_cc_physics_RigidBody_getAngularVelocity(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    cc::Vec3 result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getAngularVelocity();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RigidBody_getAngularVelocity, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_getAngularVelocity) 

static bool js_cc_physics_RigidBody_setAngularVelocity(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_setAngularVelocity,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_setAngularVelocity,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_setAngularVelocity,4,SWIGTYPE_float"); 
    (arg1)->setAngularVelocity(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_setAngularVelocity) 

static bool js_cc_physics_RigidBody_applyForce(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyForce,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyForce,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyForce,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyForce,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyForce,6,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg7, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyForce,7,SWIGTYPE_float"); 
    (arg1)->applyForce(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_applyForce) 

static bool js_cc_physics_RigidBody_applyLocalForce(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyLocalForce,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyLocalForce,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyLocalForce,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyLocalForce,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyLocalForce,6,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg7, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyLocalForce,7,SWIGTYPE_float"); 
    (arg1)->applyLocalForce(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_applyLocalForce) 

static bool js_cc_physics_RigidBody_applyImpulse(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyImpulse,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyImpulse,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyImpulse,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyImpulse,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyImpulse,6,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg7, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyImpulse,7,SWIGTYPE_float"); 
    (arg1)->applyImpulse(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_applyImpulse) 

static bool js_cc_physics_RigidBody_applyLocalImpulse(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyLocalImpulse,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyLocalImpulse,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyLocalImpulse,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyLocalImpulse,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyLocalImpulse,6,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg7, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyLocalImpulse,7,SWIGTYPE_float"); 
    (arg1)->applyLocalImpulse(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_applyLocalImpulse) 

static bool js_cc_physics_RigidBody_applyTorque(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyTorque,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyTorque,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyTorque,4,SWIGTYPE_float"); 
    (arg1)->applyTorque(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_applyTorque) 

static bool js_cc_physics_RigidBody_applyLocalTorque(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyLocalTorque,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyLocalTorque,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "RigidBody_applyLocalTorque,4,SWIGTYPE_float"); 
    (arg1)->applyLocalTorque(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_applyLocalTorque) 

static bool js_cc_physics_RigidBody_getGroup(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getGroup();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RigidBody_getGroup, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_getGroup) 

static bool js_cc_physics_RigidBody_setGroup(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RigidBody_setGroup,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setGroup(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_setGroup) 

static bool js_cc_physics_RigidBody_getMask(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getMask();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RigidBody_getMask, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_getMask) 

static bool js_cc_physics_RigidBody_setMask(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RigidBody_setMask,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setMask(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_setMask) 

static bool js_cc_physics_RigidBody_getObjectID(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::physics::RigidBody const *)arg1)->getObjectID();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RigidBody_getObjectID, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_getObjectID) 

bool js_register_cc_physics_RigidBody(se::Object* obj) {
    auto* cls = se::Class::create("RigidBody", obj, nullptr, _SE(js_new_cc_physics_RigidBody)); 
    
    
    cls->defineFunction("initialize", _SE(js_cc_physics_RigidBody_initialize)); 
    cls->defineFunction("onEnable", _SE(js_cc_physics_RigidBody_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_cc_physics_RigidBody_onDisable)); 
    cls->defineFunction("onDestroy", _SE(js_cc_physics_RigidBody_onDestroy)); 
    cls->defineFunction("isAwake", _SE(js_cc_physics_RigidBody_isAwake)); 
    cls->defineFunction("isSleepy", _SE(js_cc_physics_RigidBody_isSleepy)); 
    cls->defineFunction("isSleeping", _SE(js_cc_physics_RigidBody_isSleeping)); 
    cls->defineFunction("setType", _SE(js_cc_physics_RigidBody_setType)); 
    cls->defineFunction("setMass", _SE(js_cc_physics_RigidBody_setMass)); 
    cls->defineFunction("setLinearDamping", _SE(js_cc_physics_RigidBody_setLinearDamping)); 
    cls->defineFunction("setAngularDamping", _SE(js_cc_physics_RigidBody_setAngularDamping)); 
    cls->defineFunction("useGravity", _SE(js_cc_physics_RigidBody_useGravity)); 
    cls->defineFunction("useCCD", _SE(js_cc_physics_RigidBody_useCCD)); 
    cls->defineFunction("setLinearFactor", _SE(js_cc_physics_RigidBody_setLinearFactor)); 
    cls->defineFunction("setAngularFactor", _SE(js_cc_physics_RigidBody_setAngularFactor)); 
    cls->defineFunction("setAllowSleep", _SE(js_cc_physics_RigidBody_setAllowSleep)); 
    cls->defineFunction("wakeUp", _SE(js_cc_physics_RigidBody_wakeUp)); 
    cls->defineFunction("sleep", _SE(js_cc_physics_RigidBody_sleep)); 
    cls->defineFunction("clearState", _SE(js_cc_physics_RigidBody_clearState)); 
    cls->defineFunction("clearForces", _SE(js_cc_physics_RigidBody_clearForces)); 
    cls->defineFunction("clearVelocity", _SE(js_cc_physics_RigidBody_clearVelocity)); 
    cls->defineFunction("setSleepThreshold", _SE(js_cc_physics_RigidBody_setSleepThreshold)); 
    cls->defineFunction("getSleepThreshold", _SE(js_cc_physics_RigidBody_getSleepThreshold)); 
    cls->defineFunction("getLinearVelocity", _SE(js_cc_physics_RigidBody_getLinearVelocity)); 
    cls->defineFunction("setLinearVelocity", _SE(js_cc_physics_RigidBody_setLinearVelocity)); 
    cls->defineFunction("getAngularVelocity", _SE(js_cc_physics_RigidBody_getAngularVelocity)); 
    cls->defineFunction("setAngularVelocity", _SE(js_cc_physics_RigidBody_setAngularVelocity)); 
    cls->defineFunction("applyForce", _SE(js_cc_physics_RigidBody_applyForce)); 
    cls->defineFunction("applyLocalForce", _SE(js_cc_physics_RigidBody_applyLocalForce)); 
    cls->defineFunction("applyImpulse", _SE(js_cc_physics_RigidBody_applyImpulse)); 
    cls->defineFunction("applyLocalImpulse", _SE(js_cc_physics_RigidBody_applyLocalImpulse)); 
    cls->defineFunction("applyTorque", _SE(js_cc_physics_RigidBody_applyTorque)); 
    cls->defineFunction("applyLocalTorque", _SE(js_cc_physics_RigidBody_applyLocalTorque)); 
    cls->defineFunction("getGroup", _SE(js_cc_physics_RigidBody_getGroup)); 
    cls->defineFunction("setGroup", _SE(js_cc_physics_RigidBody_setGroup)); 
    cls->defineFunction("getMask", _SE(js_cc_physics_RigidBody_getMask)); 
    cls->defineFunction("setMask", _SE(js_cc_physics_RigidBody_setMask)); 
    cls->defineFunction("getObjectID", _SE(js_cc_physics_RigidBody_getObjectID)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_physics_RigidBody));
    
    
    cls->install();
    JSBClassType::registerClass<cc::physics::RigidBody>(cls);
    
    __jsb_cc_physics_RigidBody_proto = cls->getProto();
    __jsb_cc_physics_RigidBody_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_physics_SphereShape_class = nullptr;
se::Object* __jsb_cc_physics_SphereShape_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_physics_SphereShape) 

// js_ctor
static bool js_new_cc_physics_SphereShape(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::physics::SphereShape *result;
    result = (cc::physics::SphereShape *)new cc::physics::SphereShape();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_physics_SphereShape, __jsb_cc_physics_SphereShape_class, js_delete_cc_physics_SphereShape)

static bool js_delete_cc_physics_SphereShape(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_physics_SphereShape) 

static bool js_cc_physics_SphereShape_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SphereShape_initialize,2,SWIGTYPE_p_cc__Node"); 
    (arg1)->initialize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_initialize) 

static bool js_cc_physics_SphereShape_onEnable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_onEnable) 

static bool js_cc_physics_SphereShape_onDisable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_onDisable) 

static bool js_cc_physics_SphereShape_onDestroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onDestroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_onDestroy) 

static bool js_cc_physics_SphereShape_setMaterial(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    uint16_t arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    uint8_t arg6 ;
    uint8_t arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SphereShape_setMaterial,2,SWIGTYPE_uint16_t"); 
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "SphereShape_setMaterial,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "SphereShape_setMaterial,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "SphereShape_setMaterial,5,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "SphereShape_setMaterial,6,SWIGTYPE_uint8_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "SphereShape_setMaterial,7,SWIGTYPE_uint8_t"); 
    
    (arg1)->setMaterial(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_setMaterial) 

static bool js_cc_physics_SphereShape_setAsTrigger(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "SphereShape_setAsTrigger,2,SWIGTYPE_bool"); 
    (arg1)->setAsTrigger(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_setAsTrigger) 

static bool js_cc_physics_SphereShape_setCenter(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SphereShape_setCenter,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "SphereShape_setCenter,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "SphereShape_setCenter,4,SWIGTYPE_float"); 
    (arg1)->setCenter(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_setCenter) 

static bool js_cc_physics_SphereShape_updateEventListener(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    cc::physics::EShapeFilterFlag arg2 ;
    int32_t temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "SphereShape_updateEventListener,2,SWIGTYPE_cc__physics__EShapeFilterFlag");
    arg2 = (cc::physics::EShapeFilterFlag)temp2;
    (arg1)->updateEventListener(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_updateEventListener) 

static bool js_cc_physics_SphereShape_getAABB(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::geometry::AABB *) &(arg1)->getAABB();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SphereShape_getAABB, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_getAABB) 

static bool js_cc_physics_SphereShape_getBoundingSphere(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    cc::geometry::Sphere *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::geometry::Sphere *) &(arg1)->getBoundingSphere();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SphereShape_getBoundingSphere, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_getBoundingSphere) 

static bool js_cc_physics_SphereShape_getGroup(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getGroup();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SphereShape_getGroup, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_getGroup) 

static bool js_cc_physics_SphereShape_setGroup(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SphereShape_setGroup,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setGroup(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_setGroup) 

static bool js_cc_physics_SphereShape_getMask(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getMask();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SphereShape_getMask, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_getMask) 

static bool js_cc_physics_SphereShape_setMask(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SphereShape_setMask,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setMask(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_setMask) 

static bool js_cc_physics_SphereShape_getObjectID(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::physics::SphereShape const *)arg1)->getObjectID();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SphereShape_getObjectID, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_getObjectID) 

static bool js_cc_physics_SphereShape_setRadius(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SphereShape_setRadius,2,SWIGTYPE_float"); 
    (arg1)->setRadius(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_setRadius) 

bool js_register_cc_physics_SphereShape(se::Object* obj) {
    auto* cls = se::Class::create("SphereShape", obj, nullptr, _SE(js_new_cc_physics_SphereShape)); 
    
    
    cls->defineFunction("initialize", _SE(js_cc_physics_SphereShape_initialize)); 
    cls->defineFunction("onEnable", _SE(js_cc_physics_SphereShape_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_cc_physics_SphereShape_onDisable)); 
    cls->defineFunction("onDestroy", _SE(js_cc_physics_SphereShape_onDestroy)); 
    cls->defineFunction("setMaterial", _SE(js_cc_physics_SphereShape_setMaterial)); 
    cls->defineFunction("setAsTrigger", _SE(js_cc_physics_SphereShape_setAsTrigger)); 
    cls->defineFunction("setCenter", _SE(js_cc_physics_SphereShape_setCenter)); 
    cls->defineFunction("updateEventListener", _SE(js_cc_physics_SphereShape_updateEventListener)); 
    cls->defineFunction("getAABB", _SE(js_cc_physics_SphereShape_getAABB)); 
    cls->defineFunction("getBoundingSphere", _SE(js_cc_physics_SphereShape_getBoundingSphere)); 
    cls->defineFunction("getGroup", _SE(js_cc_physics_SphereShape_getGroup)); 
    cls->defineFunction("setGroup", _SE(js_cc_physics_SphereShape_setGroup)); 
    cls->defineFunction("getMask", _SE(js_cc_physics_SphereShape_getMask)); 
    cls->defineFunction("setMask", _SE(js_cc_physics_SphereShape_setMask)); 
    cls->defineFunction("getObjectID", _SE(js_cc_physics_SphereShape_getObjectID)); 
    cls->defineFunction("setRadius", _SE(js_cc_physics_SphereShape_setRadius)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_physics_SphereShape));
    
    
    cls->install();
    JSBClassType::registerClass<cc::physics::SphereShape>(cls);
    
    __jsb_cc_physics_SphereShape_proto = cls->getProto();
    __jsb_cc_physics_SphereShape_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_physics_BoxShape_class = nullptr;
se::Object* __jsb_cc_physics_BoxShape_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_physics_BoxShape) 

// js_ctor
static bool js_new_cc_physics_BoxShape(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::physics::BoxShape *result;
    result = (cc::physics::BoxShape *)new cc::physics::BoxShape();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_physics_BoxShape, __jsb_cc_physics_BoxShape_class, js_delete_cc_physics_BoxShape)

static bool js_delete_cc_physics_BoxShape(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_physics_BoxShape) 

static bool js_cc_physics_BoxShape_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BoxShape_initialize,2,SWIGTYPE_p_cc__Node"); 
    (arg1)->initialize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_initialize) 

static bool js_cc_physics_BoxShape_onEnable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_onEnable) 

static bool js_cc_physics_BoxShape_onDisable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_onDisable) 

static bool js_cc_physics_BoxShape_onDestroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onDestroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_onDestroy) 

static bool js_cc_physics_BoxShape_setMaterial(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    uint16_t arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    uint8_t arg6 ;
    uint8_t arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BoxShape_setMaterial,2,SWIGTYPE_uint16_t"); 
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "BoxShape_setMaterial,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "BoxShape_setMaterial,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "BoxShape_setMaterial,5,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "BoxShape_setMaterial,6,SWIGTYPE_uint8_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "BoxShape_setMaterial,7,SWIGTYPE_uint8_t"); 
    
    (arg1)->setMaterial(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_setMaterial) 

static bool js_cc_physics_BoxShape_setAsTrigger(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "BoxShape_setAsTrigger,2,SWIGTYPE_bool"); 
    (arg1)->setAsTrigger(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_setAsTrigger) 

static bool js_cc_physics_BoxShape_setCenter(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "BoxShape_setCenter,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "BoxShape_setCenter,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "BoxShape_setCenter,4,SWIGTYPE_float"); 
    (arg1)->setCenter(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_setCenter) 

static bool js_cc_physics_BoxShape_updateEventListener(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    cc::physics::EShapeFilterFlag arg2 ;
    int32_t temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "BoxShape_updateEventListener,2,SWIGTYPE_cc__physics__EShapeFilterFlag");
    arg2 = (cc::physics::EShapeFilterFlag)temp2;
    (arg1)->updateEventListener(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_updateEventListener) 

static bool js_cc_physics_BoxShape_getAABB(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::geometry::AABB *) &(arg1)->getAABB();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BoxShape_getAABB, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_getAABB) 

static bool js_cc_physics_BoxShape_getBoundingSphere(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    cc::geometry::Sphere *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::geometry::Sphere *) &(arg1)->getBoundingSphere();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BoxShape_getBoundingSphere, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_getBoundingSphere) 

static bool js_cc_physics_BoxShape_getGroup(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getGroup();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BoxShape_getGroup, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_getGroup) 

static bool js_cc_physics_BoxShape_setGroup(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BoxShape_setGroup,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setGroup(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_setGroup) 

static bool js_cc_physics_BoxShape_getMask(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getMask();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BoxShape_getMask, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_getMask) 

static bool js_cc_physics_BoxShape_setMask(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BoxShape_setMask,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setMask(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_setMask) 

static bool js_cc_physics_BoxShape_getObjectID(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::physics::BoxShape const *)arg1)->getObjectID();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BoxShape_getObjectID, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_getObjectID) 

static bool js_cc_physics_BoxShape_setSize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "BoxShape_setSize,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "BoxShape_setSize,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "BoxShape_setSize,4,SWIGTYPE_float"); 
    (arg1)->setSize(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_setSize) 

bool js_register_cc_physics_BoxShape(se::Object* obj) {
    auto* cls = se::Class::create("BoxShape", obj, nullptr, _SE(js_new_cc_physics_BoxShape)); 
    
    
    cls->defineFunction("initialize", _SE(js_cc_physics_BoxShape_initialize)); 
    cls->defineFunction("onEnable", _SE(js_cc_physics_BoxShape_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_cc_physics_BoxShape_onDisable)); 
    cls->defineFunction("onDestroy", _SE(js_cc_physics_BoxShape_onDestroy)); 
    cls->defineFunction("setMaterial", _SE(js_cc_physics_BoxShape_setMaterial)); 
    cls->defineFunction("setAsTrigger", _SE(js_cc_physics_BoxShape_setAsTrigger)); 
    cls->defineFunction("setCenter", _SE(js_cc_physics_BoxShape_setCenter)); 
    cls->defineFunction("updateEventListener", _SE(js_cc_physics_BoxShape_updateEventListener)); 
    cls->defineFunction("getAABB", _SE(js_cc_physics_BoxShape_getAABB)); 
    cls->defineFunction("getBoundingSphere", _SE(js_cc_physics_BoxShape_getBoundingSphere)); 
    cls->defineFunction("getGroup", _SE(js_cc_physics_BoxShape_getGroup)); 
    cls->defineFunction("setGroup", _SE(js_cc_physics_BoxShape_setGroup)); 
    cls->defineFunction("getMask", _SE(js_cc_physics_BoxShape_getMask)); 
    cls->defineFunction("setMask", _SE(js_cc_physics_BoxShape_setMask)); 
    cls->defineFunction("getObjectID", _SE(js_cc_physics_BoxShape_getObjectID)); 
    cls->defineFunction("setSize", _SE(js_cc_physics_BoxShape_setSize)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_physics_BoxShape));
    
    
    cls->install();
    JSBClassType::registerClass<cc::physics::BoxShape>(cls);
    
    __jsb_cc_physics_BoxShape_proto = cls->getProto();
    __jsb_cc_physics_BoxShape_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_physics_CapsuleShape_class = nullptr;
se::Object* __jsb_cc_physics_CapsuleShape_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_physics_CapsuleShape) 

// js_ctor
static bool js_new_cc_physics_CapsuleShape(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::physics::CapsuleShape *result;
    result = (cc::physics::CapsuleShape *)new cc::physics::CapsuleShape();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_physics_CapsuleShape, __jsb_cc_physics_CapsuleShape_class, js_delete_cc_physics_CapsuleShape)

static bool js_delete_cc_physics_CapsuleShape(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_physics_CapsuleShape) 

static bool js_cc_physics_CapsuleShape_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CapsuleShape_initialize,2,SWIGTYPE_p_cc__Node"); 
    (arg1)->initialize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_initialize) 

static bool js_cc_physics_CapsuleShape_onEnable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_onEnable) 

static bool js_cc_physics_CapsuleShape_onDisable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_onDisable) 

static bool js_cc_physics_CapsuleShape_onDestroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onDestroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_onDestroy) 

static bool js_cc_physics_CapsuleShape_setMaterial(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    uint16_t arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    uint8_t arg6 ;
    uint8_t arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CapsuleShape_setMaterial,2,SWIGTYPE_uint16_t"); 
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "CapsuleShape_setMaterial,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "CapsuleShape_setMaterial,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "CapsuleShape_setMaterial,5,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "CapsuleShape_setMaterial,6,SWIGTYPE_uint8_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "CapsuleShape_setMaterial,7,SWIGTYPE_uint8_t"); 
    
    (arg1)->setMaterial(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_setMaterial) 

static bool js_cc_physics_CapsuleShape_setAsTrigger(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "CapsuleShape_setAsTrigger,2,SWIGTYPE_bool"); 
    (arg1)->setAsTrigger(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_setAsTrigger) 

static bool js_cc_physics_CapsuleShape_setCenter(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "CapsuleShape_setCenter,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "CapsuleShape_setCenter,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "CapsuleShape_setCenter,4,SWIGTYPE_float"); 
    (arg1)->setCenter(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_setCenter) 

static bool js_cc_physics_CapsuleShape_updateEventListener(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    cc::physics::EShapeFilterFlag arg2 ;
    int32_t temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "CapsuleShape_updateEventListener,2,SWIGTYPE_cc__physics__EShapeFilterFlag");
    arg2 = (cc::physics::EShapeFilterFlag)temp2;
    (arg1)->updateEventListener(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_updateEventListener) 

static bool js_cc_physics_CapsuleShape_getAABB(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::geometry::AABB *) &(arg1)->getAABB();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CapsuleShape_getAABB, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_getAABB) 

static bool js_cc_physics_CapsuleShape_getBoundingSphere(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    cc::geometry::Sphere *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::geometry::Sphere *) &(arg1)->getBoundingSphere();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CapsuleShape_getBoundingSphere, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_getBoundingSphere) 

static bool js_cc_physics_CapsuleShape_getGroup(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getGroup();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CapsuleShape_getGroup, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_getGroup) 

static bool js_cc_physics_CapsuleShape_setGroup(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CapsuleShape_setGroup,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setGroup(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_setGroup) 

static bool js_cc_physics_CapsuleShape_getMask(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getMask();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CapsuleShape_getMask, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_getMask) 

static bool js_cc_physics_CapsuleShape_setMask(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CapsuleShape_setMask,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setMask(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_setMask) 

static bool js_cc_physics_CapsuleShape_getObjectID(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::physics::CapsuleShape const *)arg1)->getObjectID();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CapsuleShape_getObjectID, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_getObjectID) 

static bool js_cc_physics_CapsuleShape_setRadius(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "CapsuleShape_setRadius,2,SWIGTYPE_float"); 
    (arg1)->setRadius(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_setRadius) 

static bool js_cc_physics_CapsuleShape_setCylinderHeight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "CapsuleShape_setCylinderHeight,2,SWIGTYPE_float"); 
    (arg1)->setCylinderHeight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_setCylinderHeight) 

static bool js_cc_physics_CapsuleShape_setDirection(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    cc::physics::EAxisDirection arg2 ;
    int32_t temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "CapsuleShape_setDirection,2,SWIGTYPE_cc__physics__EAxisDirection");
    arg2 = (cc::physics::EAxisDirection)temp2;
    (arg1)->setDirection(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_setDirection) 

bool js_register_cc_physics_CapsuleShape(se::Object* obj) {
    auto* cls = se::Class::create("CapsuleShape", obj, nullptr, _SE(js_new_cc_physics_CapsuleShape)); 
    
    
    cls->defineFunction("initialize", _SE(js_cc_physics_CapsuleShape_initialize)); 
    cls->defineFunction("onEnable", _SE(js_cc_physics_CapsuleShape_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_cc_physics_CapsuleShape_onDisable)); 
    cls->defineFunction("onDestroy", _SE(js_cc_physics_CapsuleShape_onDestroy)); 
    cls->defineFunction("setMaterial", _SE(js_cc_physics_CapsuleShape_setMaterial)); 
    cls->defineFunction("setAsTrigger", _SE(js_cc_physics_CapsuleShape_setAsTrigger)); 
    cls->defineFunction("setCenter", _SE(js_cc_physics_CapsuleShape_setCenter)); 
    cls->defineFunction("updateEventListener", _SE(js_cc_physics_CapsuleShape_updateEventListener)); 
    cls->defineFunction("getAABB", _SE(js_cc_physics_CapsuleShape_getAABB)); 
    cls->defineFunction("getBoundingSphere", _SE(js_cc_physics_CapsuleShape_getBoundingSphere)); 
    cls->defineFunction("getGroup", _SE(js_cc_physics_CapsuleShape_getGroup)); 
    cls->defineFunction("setGroup", _SE(js_cc_physics_CapsuleShape_setGroup)); 
    cls->defineFunction("getMask", _SE(js_cc_physics_CapsuleShape_getMask)); 
    cls->defineFunction("setMask", _SE(js_cc_physics_CapsuleShape_setMask)); 
    cls->defineFunction("getObjectID", _SE(js_cc_physics_CapsuleShape_getObjectID)); 
    cls->defineFunction("setRadius", _SE(js_cc_physics_CapsuleShape_setRadius)); 
    cls->defineFunction("setCylinderHeight", _SE(js_cc_physics_CapsuleShape_setCylinderHeight)); 
    cls->defineFunction("setDirection", _SE(js_cc_physics_CapsuleShape_setDirection)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_physics_CapsuleShape));
    
    
    cls->install();
    JSBClassType::registerClass<cc::physics::CapsuleShape>(cls);
    
    __jsb_cc_physics_CapsuleShape_proto = cls->getProto();
    __jsb_cc_physics_CapsuleShape_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_physics_PlaneShape_class = nullptr;
se::Object* __jsb_cc_physics_PlaneShape_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_physics_PlaneShape) 

// js_ctor
static bool js_new_cc_physics_PlaneShape(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::physics::PlaneShape *result;
    result = (cc::physics::PlaneShape *)new cc::physics::PlaneShape();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_physics_PlaneShape, __jsb_cc_physics_PlaneShape_class, js_delete_cc_physics_PlaneShape)

static bool js_delete_cc_physics_PlaneShape(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_physics_PlaneShape) 

static bool js_cc_physics_PlaneShape_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "PlaneShape_initialize,2,SWIGTYPE_p_cc__Node"); 
    (arg1)->initialize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_initialize) 

static bool js_cc_physics_PlaneShape_onEnable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_onEnable) 

static bool js_cc_physics_PlaneShape_onDisable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_onDisable) 

static bool js_cc_physics_PlaneShape_onDestroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onDestroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_onDestroy) 

static bool js_cc_physics_PlaneShape_setMaterial(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    uint16_t arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    uint8_t arg6 ;
    uint8_t arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "PlaneShape_setMaterial,2,SWIGTYPE_uint16_t"); 
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "PlaneShape_setMaterial,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "PlaneShape_setMaterial,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "PlaneShape_setMaterial,5,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "PlaneShape_setMaterial,6,SWIGTYPE_uint8_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "PlaneShape_setMaterial,7,SWIGTYPE_uint8_t"); 
    
    (arg1)->setMaterial(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_setMaterial) 

static bool js_cc_physics_PlaneShape_setAsTrigger(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "PlaneShape_setAsTrigger,2,SWIGTYPE_bool"); 
    (arg1)->setAsTrigger(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_setAsTrigger) 

static bool js_cc_physics_PlaneShape_setCenter(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "PlaneShape_setCenter,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "PlaneShape_setCenter,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "PlaneShape_setCenter,4,SWIGTYPE_float"); 
    (arg1)->setCenter(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_setCenter) 

static bool js_cc_physics_PlaneShape_updateEventListener(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    cc::physics::EShapeFilterFlag arg2 ;
    int32_t temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "PlaneShape_updateEventListener,2,SWIGTYPE_cc__physics__EShapeFilterFlag");
    arg2 = (cc::physics::EShapeFilterFlag)temp2;
    (arg1)->updateEventListener(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_updateEventListener) 

static bool js_cc_physics_PlaneShape_getAABB(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::geometry::AABB *) &(arg1)->getAABB();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PlaneShape_getAABB, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_getAABB) 

static bool js_cc_physics_PlaneShape_getBoundingSphere(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    cc::geometry::Sphere *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::geometry::Sphere *) &(arg1)->getBoundingSphere();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PlaneShape_getBoundingSphere, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_getBoundingSphere) 

static bool js_cc_physics_PlaneShape_getGroup(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getGroup();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PlaneShape_getGroup, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_getGroup) 

static bool js_cc_physics_PlaneShape_setGroup(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "PlaneShape_setGroup,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setGroup(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_setGroup) 

static bool js_cc_physics_PlaneShape_getMask(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getMask();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PlaneShape_getMask, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_getMask) 

static bool js_cc_physics_PlaneShape_setMask(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "PlaneShape_setMask,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setMask(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_setMask) 

static bool js_cc_physics_PlaneShape_getObjectID(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::physics::PlaneShape const *)arg1)->getObjectID();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PlaneShape_getObjectID, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_getObjectID) 

static bool js_cc_physics_PlaneShape_setConstant(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "PlaneShape_setConstant,2,SWIGTYPE_float"); 
    (arg1)->setConstant(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_setConstant) 

static bool js_cc_physics_PlaneShape_setNormal(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "PlaneShape_setNormal,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "PlaneShape_setNormal,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "PlaneShape_setNormal,4,SWIGTYPE_float"); 
    (arg1)->setNormal(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_setNormal) 

bool js_register_cc_physics_PlaneShape(se::Object* obj) {
    auto* cls = se::Class::create("PlaneShape", obj, nullptr, _SE(js_new_cc_physics_PlaneShape)); 
    
    
    cls->defineFunction("initialize", _SE(js_cc_physics_PlaneShape_initialize)); 
    cls->defineFunction("onEnable", _SE(js_cc_physics_PlaneShape_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_cc_physics_PlaneShape_onDisable)); 
    cls->defineFunction("onDestroy", _SE(js_cc_physics_PlaneShape_onDestroy)); 
    cls->defineFunction("setMaterial", _SE(js_cc_physics_PlaneShape_setMaterial)); 
    cls->defineFunction("setAsTrigger", _SE(js_cc_physics_PlaneShape_setAsTrigger)); 
    cls->defineFunction("setCenter", _SE(js_cc_physics_PlaneShape_setCenter)); 
    cls->defineFunction("updateEventListener", _SE(js_cc_physics_PlaneShape_updateEventListener)); 
    cls->defineFunction("getAABB", _SE(js_cc_physics_PlaneShape_getAABB)); 
    cls->defineFunction("getBoundingSphere", _SE(js_cc_physics_PlaneShape_getBoundingSphere)); 
    cls->defineFunction("getGroup", _SE(js_cc_physics_PlaneShape_getGroup)); 
    cls->defineFunction("setGroup", _SE(js_cc_physics_PlaneShape_setGroup)); 
    cls->defineFunction("getMask", _SE(js_cc_physics_PlaneShape_getMask)); 
    cls->defineFunction("setMask", _SE(js_cc_physics_PlaneShape_setMask)); 
    cls->defineFunction("getObjectID", _SE(js_cc_physics_PlaneShape_getObjectID)); 
    cls->defineFunction("setConstant", _SE(js_cc_physics_PlaneShape_setConstant)); 
    cls->defineFunction("setNormal", _SE(js_cc_physics_PlaneShape_setNormal)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_physics_PlaneShape));
    
    
    cls->install();
    JSBClassType::registerClass<cc::physics::PlaneShape>(cls);
    
    __jsb_cc_physics_PlaneShape_proto = cls->getProto();
    __jsb_cc_physics_PlaneShape_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_physics_TrimeshShape_class = nullptr;
se::Object* __jsb_cc_physics_TrimeshShape_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_physics_TrimeshShape) 

// js_ctor
static bool js_new_cc_physics_TrimeshShape(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::physics::TrimeshShape *result;
    result = (cc::physics::TrimeshShape *)new cc::physics::TrimeshShape();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_physics_TrimeshShape, __jsb_cc_physics_TrimeshShape_class, js_delete_cc_physics_TrimeshShape)

static bool js_delete_cc_physics_TrimeshShape(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_physics_TrimeshShape) 

static bool js_cc_physics_TrimeshShape_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TrimeshShape_initialize,2,SWIGTYPE_p_cc__Node"); 
    (arg1)->initialize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_initialize) 

static bool js_cc_physics_TrimeshShape_onEnable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_onEnable) 

static bool js_cc_physics_TrimeshShape_onDisable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_onDisable) 

static bool js_cc_physics_TrimeshShape_onDestroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onDestroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_onDestroy) 

static bool js_cc_physics_TrimeshShape_setMaterial(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    uint16_t arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    uint8_t arg6 ;
    uint8_t arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TrimeshShape_setMaterial,2,SWIGTYPE_uint16_t"); 
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "TrimeshShape_setMaterial,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "TrimeshShape_setMaterial,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "TrimeshShape_setMaterial,5,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "TrimeshShape_setMaterial,6,SWIGTYPE_uint8_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "TrimeshShape_setMaterial,7,SWIGTYPE_uint8_t"); 
    
    (arg1)->setMaterial(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_setMaterial) 

static bool js_cc_physics_TrimeshShape_setAsTrigger(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "TrimeshShape_setAsTrigger,2,SWIGTYPE_bool"); 
    (arg1)->setAsTrigger(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_setAsTrigger) 

static bool js_cc_physics_TrimeshShape_setCenter(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "TrimeshShape_setCenter,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "TrimeshShape_setCenter,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "TrimeshShape_setCenter,4,SWIGTYPE_float"); 
    (arg1)->setCenter(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_setCenter) 

static bool js_cc_physics_TrimeshShape_updateEventListener(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    cc::physics::EShapeFilterFlag arg2 ;
    int32_t temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TrimeshShape_updateEventListener,2,SWIGTYPE_cc__physics__EShapeFilterFlag");
    arg2 = (cc::physics::EShapeFilterFlag)temp2;
    (arg1)->updateEventListener(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_updateEventListener) 

static bool js_cc_physics_TrimeshShape_getAABB(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::geometry::AABB *) &(arg1)->getAABB();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TrimeshShape_getAABB, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_getAABB) 

static bool js_cc_physics_TrimeshShape_getBoundingSphere(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    cc::geometry::Sphere *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::geometry::Sphere *) &(arg1)->getBoundingSphere();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TrimeshShape_getBoundingSphere, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_getBoundingSphere) 

static bool js_cc_physics_TrimeshShape_getGroup(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getGroup();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TrimeshShape_getGroup, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_getGroup) 

static bool js_cc_physics_TrimeshShape_setGroup(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TrimeshShape_setGroup,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setGroup(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_setGroup) 

static bool js_cc_physics_TrimeshShape_getMask(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getMask();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TrimeshShape_getMask, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_getMask) 

static bool js_cc_physics_TrimeshShape_setMask(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TrimeshShape_setMask,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setMask(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_setMask) 

static bool js_cc_physics_TrimeshShape_getObjectID(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::physics::TrimeshShape const *)arg1)->getObjectID();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TrimeshShape_getObjectID, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_getObjectID) 

static bool js_cc_physics_TrimeshShape_setMesh(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TrimeshShape_setMesh,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setMesh(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_setMesh) 

static bool js_cc_physics_TrimeshShape_useConvex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "TrimeshShape_useConvex,2,SWIGTYPE_bool"); 
    (arg1)->useConvex(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_useConvex) 

bool js_register_cc_physics_TrimeshShape(se::Object* obj) {
    auto* cls = se::Class::create("TrimeshShape", obj, nullptr, _SE(js_new_cc_physics_TrimeshShape)); 
    
    
    cls->defineFunction("initialize", _SE(js_cc_physics_TrimeshShape_initialize)); 
    cls->defineFunction("onEnable", _SE(js_cc_physics_TrimeshShape_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_cc_physics_TrimeshShape_onDisable)); 
    cls->defineFunction("onDestroy", _SE(js_cc_physics_TrimeshShape_onDestroy)); 
    cls->defineFunction("setMaterial", _SE(js_cc_physics_TrimeshShape_setMaterial)); 
    cls->defineFunction("setAsTrigger", _SE(js_cc_physics_TrimeshShape_setAsTrigger)); 
    cls->defineFunction("setCenter", _SE(js_cc_physics_TrimeshShape_setCenter)); 
    cls->defineFunction("updateEventListener", _SE(js_cc_physics_TrimeshShape_updateEventListener)); 
    cls->defineFunction("getAABB", _SE(js_cc_physics_TrimeshShape_getAABB)); 
    cls->defineFunction("getBoundingSphere", _SE(js_cc_physics_TrimeshShape_getBoundingSphere)); 
    cls->defineFunction("getGroup", _SE(js_cc_physics_TrimeshShape_getGroup)); 
    cls->defineFunction("setGroup", _SE(js_cc_physics_TrimeshShape_setGroup)); 
    cls->defineFunction("getMask", _SE(js_cc_physics_TrimeshShape_getMask)); 
    cls->defineFunction("setMask", _SE(js_cc_physics_TrimeshShape_setMask)); 
    cls->defineFunction("getObjectID", _SE(js_cc_physics_TrimeshShape_getObjectID)); 
    cls->defineFunction("setMesh", _SE(js_cc_physics_TrimeshShape_setMesh)); 
    cls->defineFunction("useConvex", _SE(js_cc_physics_TrimeshShape_useConvex)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_physics_TrimeshShape));
    
    
    cls->install();
    JSBClassType::registerClass<cc::physics::TrimeshShape>(cls);
    
    __jsb_cc_physics_TrimeshShape_proto = cls->getProto();
    __jsb_cc_physics_TrimeshShape_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_physics_CylinderShape_class = nullptr;
se::Object* __jsb_cc_physics_CylinderShape_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_physics_CylinderShape) 

// js_ctor
static bool js_new_cc_physics_CylinderShape(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::physics::CylinderShape *result;
    result = (cc::physics::CylinderShape *)new cc::physics::CylinderShape();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_physics_CylinderShape, __jsb_cc_physics_CylinderShape_class, js_delete_cc_physics_CylinderShape)

static bool js_delete_cc_physics_CylinderShape(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_physics_CylinderShape) 

static bool js_cc_physics_CylinderShape_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CylinderShape_initialize,2,SWIGTYPE_p_cc__Node"); 
    (arg1)->initialize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_initialize) 

static bool js_cc_physics_CylinderShape_onEnable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_onEnable) 

static bool js_cc_physics_CylinderShape_onDisable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_onDisable) 

static bool js_cc_physics_CylinderShape_onDestroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onDestroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_onDestroy) 

static bool js_cc_physics_CylinderShape_setMaterial(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    uint16_t arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    uint8_t arg6 ;
    uint8_t arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CylinderShape_setMaterial,2,SWIGTYPE_uint16_t"); 
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "CylinderShape_setMaterial,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "CylinderShape_setMaterial,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "CylinderShape_setMaterial,5,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "CylinderShape_setMaterial,6,SWIGTYPE_uint8_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "CylinderShape_setMaterial,7,SWIGTYPE_uint8_t"); 
    
    (arg1)->setMaterial(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_setMaterial) 

static bool js_cc_physics_CylinderShape_setAsTrigger(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "CylinderShape_setAsTrigger,2,SWIGTYPE_bool"); 
    (arg1)->setAsTrigger(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_setAsTrigger) 

static bool js_cc_physics_CylinderShape_setCenter(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "CylinderShape_setCenter,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "CylinderShape_setCenter,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "CylinderShape_setCenter,4,SWIGTYPE_float"); 
    (arg1)->setCenter(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_setCenter) 

static bool js_cc_physics_CylinderShape_updateEventListener(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    cc::physics::EShapeFilterFlag arg2 ;
    int32_t temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "CylinderShape_updateEventListener,2,SWIGTYPE_cc__physics__EShapeFilterFlag");
    arg2 = (cc::physics::EShapeFilterFlag)temp2;
    (arg1)->updateEventListener(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_updateEventListener) 

static bool js_cc_physics_CylinderShape_getAABB(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::geometry::AABB *) &(arg1)->getAABB();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CylinderShape_getAABB, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_getAABB) 

static bool js_cc_physics_CylinderShape_getBoundingSphere(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    cc::geometry::Sphere *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::geometry::Sphere *) &(arg1)->getBoundingSphere();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CylinderShape_getBoundingSphere, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_getBoundingSphere) 

static bool js_cc_physics_CylinderShape_getGroup(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getGroup();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CylinderShape_getGroup, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_getGroup) 

static bool js_cc_physics_CylinderShape_setGroup(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CylinderShape_setGroup,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setGroup(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_setGroup) 

static bool js_cc_physics_CylinderShape_getMask(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getMask();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CylinderShape_getMask, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_getMask) 

static bool js_cc_physics_CylinderShape_setMask(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CylinderShape_setMask,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setMask(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_setMask) 

static bool js_cc_physics_CylinderShape_getObjectID(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::physics::CylinderShape const *)arg1)->getObjectID();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CylinderShape_getObjectID, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_getObjectID) 

static bool js_cc_physics_CylinderShape_setConvex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CylinderShape_setConvex,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setConvex(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_setConvex) 

static bool js_cc_physics_CylinderShape_setCylinder(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    float arg2 ;
    float arg3 ;
    cc::physics::EAxisDirection arg4 ;
    int32_t temp4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "CylinderShape_setCylinder,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "CylinderShape_setCylinder,3,SWIGTYPE_float"); 
    // %typemap(in) enum SWIGTYPE (int32_t temp4)
    ok &= sevalue_to_native(args[2], &temp4);
    SE_PRECONDITION2(ok, false, "CylinderShape_setCylinder,4,SWIGTYPE_cc__physics__EAxisDirection");
    arg4 = (cc::physics::EAxisDirection)temp4;
    (arg1)->setCylinder(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_setCylinder) 

bool js_register_cc_physics_CylinderShape(se::Object* obj) {
    auto* cls = se::Class::create("CylinderShape", obj, nullptr, _SE(js_new_cc_physics_CylinderShape)); 
    
    
    cls->defineFunction("initialize", _SE(js_cc_physics_CylinderShape_initialize)); 
    cls->defineFunction("onEnable", _SE(js_cc_physics_CylinderShape_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_cc_physics_CylinderShape_onDisable)); 
    cls->defineFunction("onDestroy", _SE(js_cc_physics_CylinderShape_onDestroy)); 
    cls->defineFunction("setMaterial", _SE(js_cc_physics_CylinderShape_setMaterial)); 
    cls->defineFunction("setAsTrigger", _SE(js_cc_physics_CylinderShape_setAsTrigger)); 
    cls->defineFunction("setCenter", _SE(js_cc_physics_CylinderShape_setCenter)); 
    cls->defineFunction("updateEventListener", _SE(js_cc_physics_CylinderShape_updateEventListener)); 
    cls->defineFunction("getAABB", _SE(js_cc_physics_CylinderShape_getAABB)); 
    cls->defineFunction("getBoundingSphere", _SE(js_cc_physics_CylinderShape_getBoundingSphere)); 
    cls->defineFunction("getGroup", _SE(js_cc_physics_CylinderShape_getGroup)); 
    cls->defineFunction("setGroup", _SE(js_cc_physics_CylinderShape_setGroup)); 
    cls->defineFunction("getMask", _SE(js_cc_physics_CylinderShape_getMask)); 
    cls->defineFunction("setMask", _SE(js_cc_physics_CylinderShape_setMask)); 
    cls->defineFunction("getObjectID", _SE(js_cc_physics_CylinderShape_getObjectID)); 
    cls->defineFunction("setConvex", _SE(js_cc_physics_CylinderShape_setConvex)); 
    cls->defineFunction("setCylinder", _SE(js_cc_physics_CylinderShape_setCylinder)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_physics_CylinderShape));
    
    
    cls->install();
    JSBClassType::registerClass<cc::physics::CylinderShape>(cls);
    
    __jsb_cc_physics_CylinderShape_proto = cls->getProto();
    __jsb_cc_physics_CylinderShape_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_physics_ConeShape_class = nullptr;
se::Object* __jsb_cc_physics_ConeShape_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_physics_ConeShape) 

// js_ctor
static bool js_new_cc_physics_ConeShape(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::physics::ConeShape *result;
    result = (cc::physics::ConeShape *)new cc::physics::ConeShape();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_physics_ConeShape, __jsb_cc_physics_ConeShape_class, js_delete_cc_physics_ConeShape)

static bool js_delete_cc_physics_ConeShape(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_physics_ConeShape) 

static bool js_cc_physics_ConeShape_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ConeShape_initialize,2,SWIGTYPE_p_cc__Node"); 
    (arg1)->initialize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_initialize) 

static bool js_cc_physics_ConeShape_onEnable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_onEnable) 

static bool js_cc_physics_ConeShape_onDisable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_onDisable) 

static bool js_cc_physics_ConeShape_onDestroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onDestroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_onDestroy) 

static bool js_cc_physics_ConeShape_setMaterial(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    uint16_t arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    uint8_t arg6 ;
    uint8_t arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ConeShape_setMaterial,2,SWIGTYPE_uint16_t"); 
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "ConeShape_setMaterial,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "ConeShape_setMaterial,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "ConeShape_setMaterial,5,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "ConeShape_setMaterial,6,SWIGTYPE_uint8_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "ConeShape_setMaterial,7,SWIGTYPE_uint8_t"); 
    
    (arg1)->setMaterial(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_setMaterial) 

static bool js_cc_physics_ConeShape_setAsTrigger(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "ConeShape_setAsTrigger,2,SWIGTYPE_bool"); 
    (arg1)->setAsTrigger(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_setAsTrigger) 

static bool js_cc_physics_ConeShape_setCenter(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ConeShape_setCenter,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "ConeShape_setCenter,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "ConeShape_setCenter,4,SWIGTYPE_float"); 
    (arg1)->setCenter(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_setCenter) 

static bool js_cc_physics_ConeShape_updateEventListener(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    cc::physics::EShapeFilterFlag arg2 ;
    int32_t temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "ConeShape_updateEventListener,2,SWIGTYPE_cc__physics__EShapeFilterFlag");
    arg2 = (cc::physics::EShapeFilterFlag)temp2;
    (arg1)->updateEventListener(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_updateEventListener) 

static bool js_cc_physics_ConeShape_getAABB(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::geometry::AABB *) &(arg1)->getAABB();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ConeShape_getAABB, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_getAABB) 

static bool js_cc_physics_ConeShape_getBoundingSphere(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    cc::geometry::Sphere *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::geometry::Sphere *) &(arg1)->getBoundingSphere();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ConeShape_getBoundingSphere, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_getBoundingSphere) 

static bool js_cc_physics_ConeShape_getGroup(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getGroup();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ConeShape_getGroup, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_getGroup) 

static bool js_cc_physics_ConeShape_setGroup(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ConeShape_setGroup,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setGroup(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_setGroup) 

static bool js_cc_physics_ConeShape_getMask(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getMask();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ConeShape_getMask, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_getMask) 

static bool js_cc_physics_ConeShape_setMask(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ConeShape_setMask,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setMask(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_setMask) 

static bool js_cc_physics_ConeShape_getObjectID(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::physics::ConeShape const *)arg1)->getObjectID();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ConeShape_getObjectID, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_getObjectID) 

static bool js_cc_physics_ConeShape_setConvex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ConeShape_setConvex,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setConvex(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_setConvex) 

static bool js_cc_physics_ConeShape_setCone(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    float arg2 ;
    float arg3 ;
    cc::physics::EAxisDirection arg4 ;
    int32_t temp4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ConeShape_setCone,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "ConeShape_setCone,3,SWIGTYPE_float"); 
    // %typemap(in) enum SWIGTYPE (int32_t temp4)
    ok &= sevalue_to_native(args[2], &temp4);
    SE_PRECONDITION2(ok, false, "ConeShape_setCone,4,SWIGTYPE_cc__physics__EAxisDirection");
    arg4 = (cc::physics::EAxisDirection)temp4;
    (arg1)->setCone(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_setCone) 

bool js_register_cc_physics_ConeShape(se::Object* obj) {
    auto* cls = se::Class::create("ConeShape", obj, nullptr, _SE(js_new_cc_physics_ConeShape)); 
    
    
    cls->defineFunction("initialize", _SE(js_cc_physics_ConeShape_initialize)); 
    cls->defineFunction("onEnable", _SE(js_cc_physics_ConeShape_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_cc_physics_ConeShape_onDisable)); 
    cls->defineFunction("onDestroy", _SE(js_cc_physics_ConeShape_onDestroy)); 
    cls->defineFunction("setMaterial", _SE(js_cc_physics_ConeShape_setMaterial)); 
    cls->defineFunction("setAsTrigger", _SE(js_cc_physics_ConeShape_setAsTrigger)); 
    cls->defineFunction("setCenter", _SE(js_cc_physics_ConeShape_setCenter)); 
    cls->defineFunction("updateEventListener", _SE(js_cc_physics_ConeShape_updateEventListener)); 
    cls->defineFunction("getAABB", _SE(js_cc_physics_ConeShape_getAABB)); 
    cls->defineFunction("getBoundingSphere", _SE(js_cc_physics_ConeShape_getBoundingSphere)); 
    cls->defineFunction("getGroup", _SE(js_cc_physics_ConeShape_getGroup)); 
    cls->defineFunction("setGroup", _SE(js_cc_physics_ConeShape_setGroup)); 
    cls->defineFunction("getMask", _SE(js_cc_physics_ConeShape_getMask)); 
    cls->defineFunction("setMask", _SE(js_cc_physics_ConeShape_setMask)); 
    cls->defineFunction("getObjectID", _SE(js_cc_physics_ConeShape_getObjectID)); 
    cls->defineFunction("setConvex", _SE(js_cc_physics_ConeShape_setConvex)); 
    cls->defineFunction("setCone", _SE(js_cc_physics_ConeShape_setCone)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_physics_ConeShape));
    
    
    cls->install();
    JSBClassType::registerClass<cc::physics::ConeShape>(cls);
    
    __jsb_cc_physics_ConeShape_proto = cls->getProto();
    __jsb_cc_physics_ConeShape_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_physics_TerrainShape_class = nullptr;
se::Object* __jsb_cc_physics_TerrainShape_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_physics_TerrainShape) 

// js_ctor
static bool js_new_cc_physics_TerrainShape(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::physics::TerrainShape *result;
    result = (cc::physics::TerrainShape *)new cc::physics::TerrainShape();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_physics_TerrainShape, __jsb_cc_physics_TerrainShape_class, js_delete_cc_physics_TerrainShape)

static bool js_delete_cc_physics_TerrainShape(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_physics_TerrainShape) 

static bool js_cc_physics_TerrainShape_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TerrainShape_initialize,2,SWIGTYPE_p_cc__Node"); 
    (arg1)->initialize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_initialize) 

static bool js_cc_physics_TerrainShape_onEnable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_onEnable) 

static bool js_cc_physics_TerrainShape_onDisable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_onDisable) 

static bool js_cc_physics_TerrainShape_onDestroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onDestroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_onDestroy) 

static bool js_cc_physics_TerrainShape_setMaterial(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    uint16_t arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    uint8_t arg6 ;
    uint8_t arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TerrainShape_setMaterial,2,SWIGTYPE_uint16_t"); 
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "TerrainShape_setMaterial,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "TerrainShape_setMaterial,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "TerrainShape_setMaterial,5,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "TerrainShape_setMaterial,6,SWIGTYPE_uint8_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "TerrainShape_setMaterial,7,SWIGTYPE_uint8_t"); 
    
    (arg1)->setMaterial(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_setMaterial) 

static bool js_cc_physics_TerrainShape_setAsTrigger(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "TerrainShape_setAsTrigger,2,SWIGTYPE_bool"); 
    (arg1)->setAsTrigger(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_setAsTrigger) 

static bool js_cc_physics_TerrainShape_setCenter(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "TerrainShape_setCenter,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "TerrainShape_setCenter,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "TerrainShape_setCenter,4,SWIGTYPE_float"); 
    (arg1)->setCenter(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_setCenter) 

static bool js_cc_physics_TerrainShape_updateEventListener(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    cc::physics::EShapeFilterFlag arg2 ;
    int32_t temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TerrainShape_updateEventListener,2,SWIGTYPE_cc__physics__EShapeFilterFlag");
    arg2 = (cc::physics::EShapeFilterFlag)temp2;
    (arg1)->updateEventListener(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_updateEventListener) 

static bool js_cc_physics_TerrainShape_getAABB(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::geometry::AABB *) &(arg1)->getAABB();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TerrainShape_getAABB, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_getAABB) 

static bool js_cc_physics_TerrainShape_getBoundingSphere(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    cc::geometry::Sphere *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::geometry::Sphere *) &(arg1)->getBoundingSphere();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TerrainShape_getBoundingSphere, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_getBoundingSphere) 

static bool js_cc_physics_TerrainShape_getGroup(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getGroup();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TerrainShape_getGroup, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_getGroup) 

static bool js_cc_physics_TerrainShape_setGroup(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TerrainShape_setGroup,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setGroup(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_setGroup) 

static bool js_cc_physics_TerrainShape_getMask(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getMask();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TerrainShape_getMask, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_getMask) 

static bool js_cc_physics_TerrainShape_setMask(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TerrainShape_setMask,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setMask(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_setMask) 

static bool js_cc_physics_TerrainShape_getObjectID(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::physics::TerrainShape const *)arg1)->getObjectID();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TerrainShape_getObjectID, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_getObjectID) 

static bool js_cc_physics_TerrainShape_setTerrain(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    uint32_t arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TerrainShape_setTerrain,2,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "TerrainShape_setTerrain,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "TerrainShape_setTerrain,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "TerrainShape_setTerrain,5,SWIGTYPE_float"); 
    (arg1)->setTerrain(arg2,arg3,arg4,arg5);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_setTerrain) 

bool js_register_cc_physics_TerrainShape(se::Object* obj) {
    auto* cls = se::Class::create("TerrainShape", obj, nullptr, _SE(js_new_cc_physics_TerrainShape)); 
    
    
    cls->defineFunction("initialize", _SE(js_cc_physics_TerrainShape_initialize)); 
    cls->defineFunction("onEnable", _SE(js_cc_physics_TerrainShape_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_cc_physics_TerrainShape_onDisable)); 
    cls->defineFunction("onDestroy", _SE(js_cc_physics_TerrainShape_onDestroy)); 
    cls->defineFunction("setMaterial", _SE(js_cc_physics_TerrainShape_setMaterial)); 
    cls->defineFunction("setAsTrigger", _SE(js_cc_physics_TerrainShape_setAsTrigger)); 
    cls->defineFunction("setCenter", _SE(js_cc_physics_TerrainShape_setCenter)); 
    cls->defineFunction("updateEventListener", _SE(js_cc_physics_TerrainShape_updateEventListener)); 
    cls->defineFunction("getAABB", _SE(js_cc_physics_TerrainShape_getAABB)); 
    cls->defineFunction("getBoundingSphere", _SE(js_cc_physics_TerrainShape_getBoundingSphere)); 
    cls->defineFunction("getGroup", _SE(js_cc_physics_TerrainShape_getGroup)); 
    cls->defineFunction("setGroup", _SE(js_cc_physics_TerrainShape_setGroup)); 
    cls->defineFunction("getMask", _SE(js_cc_physics_TerrainShape_getMask)); 
    cls->defineFunction("setMask", _SE(js_cc_physics_TerrainShape_setMask)); 
    cls->defineFunction("getObjectID", _SE(js_cc_physics_TerrainShape_getObjectID)); 
    cls->defineFunction("setTerrain", _SE(js_cc_physics_TerrainShape_setTerrain)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_physics_TerrainShape));
    
    
    cls->install();
    JSBClassType::registerClass<cc::physics::TerrainShape>(cls);
    
    __jsb_cc_physics_TerrainShape_proto = cls->getProto();
    __jsb_cc_physics_TerrainShape_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_physics_RevoluteJoint_class = nullptr;
se::Object* __jsb_cc_physics_RevoluteJoint_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_physics_RevoluteJoint) 

// js_ctor
static bool js_new_cc_physics_RevoluteJoint(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::physics::RevoluteJoint *result;
    result = (cc::physics::RevoluteJoint *)new cc::physics::RevoluteJoint();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_physics_RevoluteJoint, __jsb_cc_physics_RevoluteJoint_class, js_delete_cc_physics_RevoluteJoint)

static bool js_delete_cc_physics_RevoluteJoint(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_physics_RevoluteJoint) 

static bool js_cc_physics_RevoluteJoint_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RevoluteJoint *arg1 = (cc::physics::RevoluteJoint *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RevoluteJoint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RevoluteJoint_initialize,2,SWIGTYPE_p_cc__Node"); 
    (arg1)->initialize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RevoluteJoint_initialize) 

static bool js_cc_physics_RevoluteJoint_onEnable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RevoluteJoint *arg1 = (cc::physics::RevoluteJoint *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RevoluteJoint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RevoluteJoint_onEnable) 

static bool js_cc_physics_RevoluteJoint_onDisable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RevoluteJoint *arg1 = (cc::physics::RevoluteJoint *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RevoluteJoint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RevoluteJoint_onDisable) 

static bool js_cc_physics_RevoluteJoint_onDestroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RevoluteJoint *arg1 = (cc::physics::RevoluteJoint *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RevoluteJoint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onDestroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RevoluteJoint_onDestroy) 

static bool js_cc_physics_RevoluteJoint_setEnableCollision(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RevoluteJoint *arg1 = (cc::physics::RevoluteJoint *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RevoluteJoint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "RevoluteJoint_setEnableCollision,2,SWIGTYPE_bool"); 
    (arg1)->setEnableCollision(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RevoluteJoint_setEnableCollision) 

static bool js_cc_physics_RevoluteJoint_setConnectedBody(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RevoluteJoint *arg1 = (cc::physics::RevoluteJoint *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RevoluteJoint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RevoluteJoint_setConnectedBody,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setConnectedBody(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RevoluteJoint_setConnectedBody) 

static bool js_cc_physics_RevoluteJoint_getObjectID(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RevoluteJoint *arg1 = (cc::physics::RevoluteJoint *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RevoluteJoint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::physics::RevoluteJoint const *)arg1)->getObjectID();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RevoluteJoint_getObjectID, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RevoluteJoint_getObjectID) 

static bool js_cc_physics_RevoluteJoint_setPivotA(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RevoluteJoint *arg1 = (cc::physics::RevoluteJoint *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RevoluteJoint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RevoluteJoint_setPivotA,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "RevoluteJoint_setPivotA,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "RevoluteJoint_setPivotA,4,SWIGTYPE_float"); 
    (arg1)->setPivotA(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RevoluteJoint_setPivotA) 

static bool js_cc_physics_RevoluteJoint_setPivotB(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RevoluteJoint *arg1 = (cc::physics::RevoluteJoint *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RevoluteJoint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RevoluteJoint_setPivotB,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "RevoluteJoint_setPivotB,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "RevoluteJoint_setPivotB,4,SWIGTYPE_float"); 
    (arg1)->setPivotB(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RevoluteJoint_setPivotB) 

static bool js_cc_physics_RevoluteJoint_setAxis(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RevoluteJoint *arg1 = (cc::physics::RevoluteJoint *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RevoluteJoint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RevoluteJoint_setAxis,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "RevoluteJoint_setAxis,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "RevoluteJoint_setAxis,4,SWIGTYPE_float"); 
    (arg1)->setAxis(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RevoluteJoint_setAxis) 

bool js_register_cc_physics_RevoluteJoint(se::Object* obj) {
    auto* cls = se::Class::create("RevoluteJoint", obj, nullptr, _SE(js_new_cc_physics_RevoluteJoint)); 
    
    
    cls->defineFunction("initialize", _SE(js_cc_physics_RevoluteJoint_initialize)); 
    cls->defineFunction("onEnable", _SE(js_cc_physics_RevoluteJoint_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_cc_physics_RevoluteJoint_onDisable)); 
    cls->defineFunction("onDestroy", _SE(js_cc_physics_RevoluteJoint_onDestroy)); 
    cls->defineFunction("setEnableCollision", _SE(js_cc_physics_RevoluteJoint_setEnableCollision)); 
    cls->defineFunction("setConnectedBody", _SE(js_cc_physics_RevoluteJoint_setConnectedBody)); 
    cls->defineFunction("getObjectID", _SE(js_cc_physics_RevoluteJoint_getObjectID)); 
    cls->defineFunction("setPivotA", _SE(js_cc_physics_RevoluteJoint_setPivotA)); 
    cls->defineFunction("setPivotB", _SE(js_cc_physics_RevoluteJoint_setPivotB)); 
    cls->defineFunction("setAxis", _SE(js_cc_physics_RevoluteJoint_setAxis)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_physics_RevoluteJoint));
    
    
    cls->install();
    JSBClassType::registerClass<cc::physics::RevoluteJoint>(cls);
    
    __jsb_cc_physics_RevoluteJoint_proto = cls->getProto();
    __jsb_cc_physics_RevoluteJoint_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_physics_DistanceJoint_class = nullptr;
se::Object* __jsb_cc_physics_DistanceJoint_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_physics_DistanceJoint) 

// js_ctor
static bool js_new_cc_physics_DistanceJoint(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::physics::DistanceJoint *result;
    result = (cc::physics::DistanceJoint *)new cc::physics::DistanceJoint();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_physics_DistanceJoint, __jsb_cc_physics_DistanceJoint_class, js_delete_cc_physics_DistanceJoint)

static bool js_delete_cc_physics_DistanceJoint(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_physics_DistanceJoint) 

static bool js_cc_physics_DistanceJoint_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::DistanceJoint *arg1 = (cc::physics::DistanceJoint *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::DistanceJoint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DistanceJoint_initialize,2,SWIGTYPE_p_cc__Node"); 
    (arg1)->initialize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_DistanceJoint_initialize) 

static bool js_cc_physics_DistanceJoint_onEnable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::DistanceJoint *arg1 = (cc::physics::DistanceJoint *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::DistanceJoint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_DistanceJoint_onEnable) 

static bool js_cc_physics_DistanceJoint_onDisable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::DistanceJoint *arg1 = (cc::physics::DistanceJoint *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::DistanceJoint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_DistanceJoint_onDisable) 

static bool js_cc_physics_DistanceJoint_onDestroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::DistanceJoint *arg1 = (cc::physics::DistanceJoint *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::DistanceJoint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onDestroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_DistanceJoint_onDestroy) 

static bool js_cc_physics_DistanceJoint_setEnableCollision(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::DistanceJoint *arg1 = (cc::physics::DistanceJoint *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::DistanceJoint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "DistanceJoint_setEnableCollision,2,SWIGTYPE_bool"); 
    (arg1)->setEnableCollision(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_DistanceJoint_setEnableCollision) 

static bool js_cc_physics_DistanceJoint_setConnectedBody(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::DistanceJoint *arg1 = (cc::physics::DistanceJoint *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::DistanceJoint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DistanceJoint_setConnectedBody,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setConnectedBody(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_DistanceJoint_setConnectedBody) 

static bool js_cc_physics_DistanceJoint_getObjectID(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::DistanceJoint *arg1 = (cc::physics::DistanceJoint *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::DistanceJoint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::physics::DistanceJoint const *)arg1)->getObjectID();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DistanceJoint_getObjectID, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_DistanceJoint_getObjectID) 

static bool js_cc_physics_DistanceJoint_setPivotA(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::DistanceJoint *arg1 = (cc::physics::DistanceJoint *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::DistanceJoint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "DistanceJoint_setPivotA,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "DistanceJoint_setPivotA,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "DistanceJoint_setPivotA,4,SWIGTYPE_float"); 
    (arg1)->setPivotA(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_DistanceJoint_setPivotA) 

static bool js_cc_physics_DistanceJoint_setPivotB(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::DistanceJoint *arg1 = (cc::physics::DistanceJoint *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::DistanceJoint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "DistanceJoint_setPivotB,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "DistanceJoint_setPivotB,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "DistanceJoint_setPivotB,4,SWIGTYPE_float"); 
    (arg1)->setPivotB(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_DistanceJoint_setPivotB) 

bool js_register_cc_physics_DistanceJoint(se::Object* obj) {
    auto* cls = se::Class::create("DistanceJoint", obj, nullptr, _SE(js_new_cc_physics_DistanceJoint)); 
    
    
    cls->defineFunction("initialize", _SE(js_cc_physics_DistanceJoint_initialize)); 
    cls->defineFunction("onEnable", _SE(js_cc_physics_DistanceJoint_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_cc_physics_DistanceJoint_onDisable)); 
    cls->defineFunction("onDestroy", _SE(js_cc_physics_DistanceJoint_onDestroy)); 
    cls->defineFunction("setEnableCollision", _SE(js_cc_physics_DistanceJoint_setEnableCollision)); 
    cls->defineFunction("setConnectedBody", _SE(js_cc_physics_DistanceJoint_setConnectedBody)); 
    cls->defineFunction("getObjectID", _SE(js_cc_physics_DistanceJoint_getObjectID)); 
    cls->defineFunction("setPivotA", _SE(js_cc_physics_DistanceJoint_setPivotA)); 
    cls->defineFunction("setPivotB", _SE(js_cc_physics_DistanceJoint_setPivotB)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_physics_DistanceJoint));
    
    
    cls->install();
    JSBClassType::registerClass<cc::physics::DistanceJoint>(cls);
    
    __jsb_cc_physics_DistanceJoint_proto = cls->getProto();
    __jsb_cc_physics_DistanceJoint_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}




bool register_all_physics(se::Object* obj) {
    // Get the ns
    se::Value nsVal;
    if (!obj->getProperty("jsb.physics", &nsVal, true))
    {
        se::HandleObject jsobj(se::Object::createPlainObject());
        nsVal.setObject(jsobj);
        obj->setProperty("jsb.physics", nsVal);
    }
    se::Object* ns = nsVal.toObject();
    /* Register classes */
    js_register_cc_physics_World(ns); 
    js_register_cc_physics_RigidBody(ns); 
    js_register_cc_physics_SphereShape(ns); 
    js_register_cc_physics_BoxShape(ns); 
    js_register_cc_physics_CapsuleShape(ns); 
    js_register_cc_physics_PlaneShape(ns); 
    js_register_cc_physics_TrimeshShape(ns); 
    js_register_cc_physics_CylinderShape(ns); 
    js_register_cc_physics_ConeShape(ns); 
    js_register_cc_physics_TerrainShape(ns); 
    js_register_cc_physics_RevoluteJoint(ns); 
    js_register_cc_physics_DistanceJoint(ns); 
    
    /* Register global variables & global functions */
    
    
    
    return true;
}


#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif
// clang-format on
