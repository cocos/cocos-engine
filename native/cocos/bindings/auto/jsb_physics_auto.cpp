// clang-format off

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

/****************************************************************************
 Copyright (c) 2022-2023 Xiamen Yaji Software Co., Ltd.

 http://www.cocos.com

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights to
 use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 of the Software, and to permit persons to whom the Software is furnished to do so,
 subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
****************************************************************************/

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-variable"
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-variable"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4101)
#endif


#define SWIG_STD_MOVE(OBJ) std::move(OBJ)


#include <stdio.h>


#include "bindings/jswrapper/SeApi.h"
#include "bindings/manual/jsb_conversions.h"
#include "bindings/manual/jsb_global.h"


#include "bindings/auto/jsb_physics_auto.h"
#include "bindings/auto/jsb_cocos_auto.h"
#include "bindings/auto/jsb_geometry_auto.h"



se::Class* __jsb_cc_physics_World_class = nullptr;
se::Object* __jsb_cc_physics_World_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_physics_World) 

static bool js_new_cc_physics_World(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::physics::World *result;
    result = (cc::physics::World *)new cc::physics::World();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_physics_World, __jsb_cc_physics_World_class, js_delete_cc_physics_World)

static bool js_delete_cc_physics_World(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_physics_World) 

static bool js_cc_physics_World_setGravity(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setGravity(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_setGravity) 

static bool js_cc_physics_World_setAllowSleep(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAllowSleep(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_setAllowSleep) 

static bool js_cc_physics_World_step(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->step(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_step) 

static bool js_cc_physics_World_emitEvents(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    if (nullptr == arg1) return true;
    (arg1)->emitEvents();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_emitEvents) 

static bool js_cc_physics_World_syncSceneToPhysics(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    if (nullptr == arg1) return true;
    (arg1)->syncSceneToPhysics();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_syncSceneToPhysics) 

static bool js_cc_physics_World_syncSceneWithCheck(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    if (nullptr == arg1) return true;
    (arg1)->syncSceneWithCheck();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_syncSceneWithCheck) 

static bool js_cc_physics_World_setCollisionMatrix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setCollisionMatrix(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_setCollisionMatrix) 

static bool js_cc_physics_World_getTriggerEventPairs(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    ccstd::vector< std::shared_ptr< cc::physics::TriggerEventPair > > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< std::shared_ptr< cc::physics::TriggerEventPair > > *) &(arg1)->getTriggerEventPairs();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_getTriggerEventPairs) 

static bool js_cc_physics_World_getContactEventPairs(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    ccstd::vector< std::shared_ptr< cc::physics::ContactEventPair > > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< std::shared_ptr< cc::physics::ContactEventPair > > *) &(arg1)->getContactEventPairs();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_getContactEventPairs) 

static bool js_cc_physics_World_raycast(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    cc::physics::RaycastOptions *arg2 = 0 ;
    cc::physics::RaycastOptions temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (bool)(arg1)->raycast(*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_raycast) 

static bool js_cc_physics_World_raycastClosest(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    cc::physics::RaycastOptions *arg2 = 0 ;
    cc::physics::RaycastOptions temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (bool)(arg1)->raycastClosest(*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_raycastClosest) 

static bool js_cc_physics_World_raycastResult(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    ccstd::vector< cc::physics::RaycastResult > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::physics::RaycastResult > *) &(arg1)->raycastResult();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_raycastResult) 

static bool js_cc_physics_World_raycastClosestResult(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    cc::physics::RaycastResult *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    if (nullptr == arg1) return true;
    result = (cc::physics::RaycastResult *) &(arg1)->raycastClosestResult();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_raycastClosestResult) 

static bool js_cc_physics_World_createConvex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    cc::physics::ConvexDesc *arg2 = 0 ;
    cc::physics::ConvexDesc temp2 ;
    uint32_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (arg1)->createConvex(*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_createConvex) 

static bool js_cc_physics_World_createTrimesh(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    cc::physics::TrimeshDesc *arg2 = 0 ;
    cc::physics::TrimeshDesc temp2 ;
    uint32_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (arg1)->createTrimesh(*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_createTrimesh) 

static bool js_cc_physics_World_createHeightField(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    cc::physics::HeightFieldDesc *arg2 = 0 ;
    cc::physics::HeightFieldDesc temp2 ;
    uint32_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (arg1)->createHeightField(*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_createHeightField) 

static bool js_cc_physics_World_createMaterial(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    uint16_t arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    uint8_t arg6 ;
    uint8_t arg7 ;
    bool result;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (bool)(arg1)->createMaterial(arg2,arg3,arg4,arg5,arg6,arg7);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_createMaterial) 

static bool js_cc_physics_World_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::World *arg1 = (cc::physics::World *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::World>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_World_destroy) 

bool js_register_cc_physics_World(se::Object* obj) {
    auto* cls = se::Class::create("World", obj, nullptr, _SE(js_new_cc_physics_World)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("setGravity", _SE(js_cc_physics_World_setGravity)); 
    cls->defineFunction("setAllowSleep", _SE(js_cc_physics_World_setAllowSleep)); 
    cls->defineFunction("step", _SE(js_cc_physics_World_step)); 
    cls->defineFunction("emitEvents", _SE(js_cc_physics_World_emitEvents)); 
    cls->defineFunction("syncSceneToPhysics", _SE(js_cc_physics_World_syncSceneToPhysics)); 
    cls->defineFunction("syncSceneWithCheck", _SE(js_cc_physics_World_syncSceneWithCheck)); 
    cls->defineFunction("setCollisionMatrix", _SE(js_cc_physics_World_setCollisionMatrix)); 
    cls->defineFunction("getTriggerEventPairs", _SE(js_cc_physics_World_getTriggerEventPairs)); 
    cls->defineFunction("getContactEventPairs", _SE(js_cc_physics_World_getContactEventPairs)); 
    cls->defineFunction("raycast", _SE(js_cc_physics_World_raycast)); 
    cls->defineFunction("raycastClosest", _SE(js_cc_physics_World_raycastClosest)); 
    cls->defineFunction("raycastResult", _SE(js_cc_physics_World_raycastResult)); 
    cls->defineFunction("raycastClosestResult", _SE(js_cc_physics_World_raycastClosestResult)); 
    cls->defineFunction("createConvex", _SE(js_cc_physics_World_createConvex)); 
    cls->defineFunction("createTrimesh", _SE(js_cc_physics_World_createTrimesh)); 
    cls->defineFunction("createHeightField", _SE(js_cc_physics_World_createHeightField)); 
    cls->defineFunction("createMaterial", _SE(js_cc_physics_World_createMaterial)); 
    cls->defineFunction("destroy", _SE(js_cc_physics_World_destroy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_physics_World));
    
    
    cls->install();
    JSBClassType::registerClass<cc::physics::World>(cls);
    
    __jsb_cc_physics_World_proto = cls->getProto();
    __jsb_cc_physics_World_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_physics_RigidBody_class = nullptr;
se::Object* __jsb_cc_physics_RigidBody_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_physics_RigidBody) 

static bool js_new_cc_physics_RigidBody(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::physics::RigidBody *result;
    result = (cc::physics::RigidBody *)new cc::physics::RigidBody();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_physics_RigidBody, __jsb_cc_physics_RigidBody_class, js_delete_cc_physics_RigidBody)

static bool js_delete_cc_physics_RigidBody(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_physics_RigidBody) 

static bool js_cc_physics_RigidBody_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    cc::physics::ERigidBodyType arg3 ;
    uint32_t arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->initialize(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_initialize) 

static bool js_cc_physics_RigidBody_onEnable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_onEnable) 

static bool js_cc_physics_RigidBody_onDisable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_onDisable) 

static bool js_cc_physics_RigidBody_onDestroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    (arg1)->onDestroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_onDestroy) 

static bool js_cc_physics_RigidBody_isAwake(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->isAwake();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_isAwake) 

static bool js_cc_physics_RigidBody_isSleepy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->isSleepy();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_isSleepy) 

static bool js_cc_physics_RigidBody_isSleeping(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->isSleeping();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_isSleeping) 

static bool js_cc_physics_RigidBody_setType(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    cc::physics::ERigidBodyType arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->setType(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_setType) 

static bool js_cc_physics_RigidBody_setMass(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setMass(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_setMass) 

static bool js_cc_physics_RigidBody_setLinearDamping(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setLinearDamping(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_setLinearDamping) 

static bool js_cc_physics_RigidBody_setAngularDamping(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAngularDamping(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_setAngularDamping) 

static bool js_cc_physics_RigidBody_useGravity(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->useGravity(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_useGravity) 

static bool js_cc_physics_RigidBody_useCCD(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->useCCD(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_useCCD) 

static bool js_cc_physics_RigidBody_setLinearFactor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setLinearFactor(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_setLinearFactor) 

static bool js_cc_physics_RigidBody_setAngularFactor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAngularFactor(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_setAngularFactor) 

static bool js_cc_physics_RigidBody_setAllowSleep(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAllowSleep(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_setAllowSleep) 

static bool js_cc_physics_RigidBody_wakeUp(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    (arg1)->wakeUp();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_wakeUp) 

static bool js_cc_physics_RigidBody_sleep(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    (arg1)->sleep();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_sleep) 

static bool js_cc_physics_RigidBody_clearState(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    (arg1)->clearState();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_clearState) 

static bool js_cc_physics_RigidBody_clearForces(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    (arg1)->clearForces();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_clearForces) 

static bool js_cc_physics_RigidBody_clearVelocity(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    (arg1)->clearVelocity();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_clearVelocity) 

static bool js_cc_physics_RigidBody_setSleepThreshold(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setSleepThreshold(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_setSleepThreshold) 

static bool js_cc_physics_RigidBody_getSleepThreshold(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getSleepThreshold();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_getSleepThreshold) 

static bool js_cc_physics_RigidBody_getLinearVelocity(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    cc::Vec3 result;
    cc::Vec3 *temp ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getLinearVelocity();
    
    temp = ccnew cc::Vec3(result);
    ok &= nativevalue_to_se(temp, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_getLinearVelocity) 

static bool js_cc_physics_RigidBody_setLinearVelocity(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setLinearVelocity(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_setLinearVelocity) 

static bool js_cc_physics_RigidBody_getAngularVelocity(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    cc::Vec3 result;
    cc::Vec3 *temp ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getAngularVelocity();
    
    temp = ccnew cc::Vec3(result);
    ok &= nativevalue_to_se(temp, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_getAngularVelocity) 

static bool js_cc_physics_RigidBody_setAngularVelocity(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAngularVelocity(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_setAngularVelocity) 

static bool js_cc_physics_RigidBody_applyForce(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->applyForce(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_applyForce) 

static bool js_cc_physics_RigidBody_applyLocalForce(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->applyLocalForce(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_applyLocalForce) 

static bool js_cc_physics_RigidBody_applyImpulse(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->applyImpulse(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_applyImpulse) 

static bool js_cc_physics_RigidBody_applyLocalImpulse(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->applyLocalImpulse(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_applyLocalImpulse) 

static bool js_cc_physics_RigidBody_applyTorque(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->applyTorque(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_applyTorque) 

static bool js_cc_physics_RigidBody_applyLocalTorque(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->applyLocalTorque(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_applyLocalTorque) 

static bool js_cc_physics_RigidBody_getGroup(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getGroup();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_getGroup) 

static bool js_cc_physics_RigidBody_setGroup(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setGroup(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_setGroup) 

static bool js_cc_physics_RigidBody_getMask(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getMask();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_getMask) 

static bool js_cc_physics_RigidBody_setMask(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setMask(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_setMask) 

static bool js_cc_physics_RigidBody_getObjectID(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RigidBody *arg1 = (cc::physics::RigidBody *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RigidBody>(s);
    if (nullptr == arg1) return true;
    result = ((cc::physics::RigidBody const *)arg1)->getObjectID();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RigidBody_getObjectID) 

bool js_register_cc_physics_RigidBody(se::Object* obj) {
    auto* cls = se::Class::create("RigidBody", obj, nullptr, _SE(js_new_cc_physics_RigidBody)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("initialize", _SE(js_cc_physics_RigidBody_initialize)); 
    cls->defineFunction("onEnable", _SE(js_cc_physics_RigidBody_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_cc_physics_RigidBody_onDisable)); 
    cls->defineFunction("onDestroy", _SE(js_cc_physics_RigidBody_onDestroy)); 
    cls->defineFunction("isAwake", _SE(js_cc_physics_RigidBody_isAwake)); 
    cls->defineFunction("isSleepy", _SE(js_cc_physics_RigidBody_isSleepy)); 
    cls->defineFunction("isSleeping", _SE(js_cc_physics_RigidBody_isSleeping)); 
    cls->defineFunction("setType", _SE(js_cc_physics_RigidBody_setType)); 
    cls->defineFunction("setMass", _SE(js_cc_physics_RigidBody_setMass)); 
    cls->defineFunction("setLinearDamping", _SE(js_cc_physics_RigidBody_setLinearDamping)); 
    cls->defineFunction("setAngularDamping", _SE(js_cc_physics_RigidBody_setAngularDamping)); 
    cls->defineFunction("useGravity", _SE(js_cc_physics_RigidBody_useGravity)); 
    cls->defineFunction("useCCD", _SE(js_cc_physics_RigidBody_useCCD)); 
    cls->defineFunction("setLinearFactor", _SE(js_cc_physics_RigidBody_setLinearFactor)); 
    cls->defineFunction("setAngularFactor", _SE(js_cc_physics_RigidBody_setAngularFactor)); 
    cls->defineFunction("setAllowSleep", _SE(js_cc_physics_RigidBody_setAllowSleep)); 
    cls->defineFunction("wakeUp", _SE(js_cc_physics_RigidBody_wakeUp)); 
    cls->defineFunction("sleep", _SE(js_cc_physics_RigidBody_sleep)); 
    cls->defineFunction("clearState", _SE(js_cc_physics_RigidBody_clearState)); 
    cls->defineFunction("clearForces", _SE(js_cc_physics_RigidBody_clearForces)); 
    cls->defineFunction("clearVelocity", _SE(js_cc_physics_RigidBody_clearVelocity)); 
    cls->defineFunction("setSleepThreshold", _SE(js_cc_physics_RigidBody_setSleepThreshold)); 
    cls->defineFunction("getSleepThreshold", _SE(js_cc_physics_RigidBody_getSleepThreshold)); 
    cls->defineFunction("getLinearVelocity", _SE(js_cc_physics_RigidBody_getLinearVelocity)); 
    cls->defineFunction("setLinearVelocity", _SE(js_cc_physics_RigidBody_setLinearVelocity)); 
    cls->defineFunction("getAngularVelocity", _SE(js_cc_physics_RigidBody_getAngularVelocity)); 
    cls->defineFunction("setAngularVelocity", _SE(js_cc_physics_RigidBody_setAngularVelocity)); 
    cls->defineFunction("applyForce", _SE(js_cc_physics_RigidBody_applyForce)); 
    cls->defineFunction("applyLocalForce", _SE(js_cc_physics_RigidBody_applyLocalForce)); 
    cls->defineFunction("applyImpulse", _SE(js_cc_physics_RigidBody_applyImpulse)); 
    cls->defineFunction("applyLocalImpulse", _SE(js_cc_physics_RigidBody_applyLocalImpulse)); 
    cls->defineFunction("applyTorque", _SE(js_cc_physics_RigidBody_applyTorque)); 
    cls->defineFunction("applyLocalTorque", _SE(js_cc_physics_RigidBody_applyLocalTorque)); 
    cls->defineFunction("getGroup", _SE(js_cc_physics_RigidBody_getGroup)); 
    cls->defineFunction("setGroup", _SE(js_cc_physics_RigidBody_setGroup)); 
    cls->defineFunction("getMask", _SE(js_cc_physics_RigidBody_getMask)); 
    cls->defineFunction("setMask", _SE(js_cc_physics_RigidBody_setMask)); 
    cls->defineFunction("getObjectID", _SE(js_cc_physics_RigidBody_getObjectID)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_physics_RigidBody));
    
    
    cls->install();
    JSBClassType::registerClass<cc::physics::RigidBody>(cls);
    
    __jsb_cc_physics_RigidBody_proto = cls->getProto();
    __jsb_cc_physics_RigidBody_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_physics_SphereShape_class = nullptr;
se::Object* __jsb_cc_physics_SphereShape_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_physics_SphereShape) 

static bool js_new_cc_physics_SphereShape(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::physics::SphereShape *result;
    result = (cc::physics::SphereShape *)new cc::physics::SphereShape();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_physics_SphereShape, __jsb_cc_physics_SphereShape_class, js_delete_cc_physics_SphereShape)

static bool js_delete_cc_physics_SphereShape(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_physics_SphereShape) 

static bool js_cc_physics_SphereShape_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->initialize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_initialize) 

static bool js_cc_physics_SphereShape_onEnable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    if (nullptr == arg1) return true;
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_onEnable) 

static bool js_cc_physics_SphereShape_onDisable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    if (nullptr == arg1) return true;
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_onDisable) 

static bool js_cc_physics_SphereShape_onDestroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    if (nullptr == arg1) return true;
    (arg1)->onDestroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_onDestroy) 

static bool js_cc_physics_SphereShape_setMaterial(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    uint16_t arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    uint8_t arg6 ;
    uint8_t arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setMaterial(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_setMaterial) 

static bool js_cc_physics_SphereShape_setAsTrigger(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAsTrigger(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_setAsTrigger) 

static bool js_cc_physics_SphereShape_setCenter(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setCenter(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_setCenter) 

static bool js_cc_physics_SphereShape_updateEventListener(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    cc::physics::EShapeFilterFlag arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->updateEventListener(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_updateEventListener) 

static bool js_cc_physics_SphereShape_getAABB(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    if (nullptr == arg1) return true;
    result = (cc::geometry::AABB *) &(arg1)->getAABB();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_getAABB) 

static bool js_cc_physics_SphereShape_getBoundingSphere(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    cc::geometry::Sphere *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    if (nullptr == arg1) return true;
    result = (cc::geometry::Sphere *) &(arg1)->getBoundingSphere();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_getBoundingSphere) 

static bool js_cc_physics_SphereShape_getGroup(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getGroup();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_getGroup) 

static bool js_cc_physics_SphereShape_setGroup(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setGroup(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_setGroup) 

static bool js_cc_physics_SphereShape_getMask(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getMask();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_getMask) 

static bool js_cc_physics_SphereShape_setMask(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setMask(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_setMask) 

static bool js_cc_physics_SphereShape_getObjectID(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    if (nullptr == arg1) return true;
    result = ((cc::physics::SphereShape const *)arg1)->getObjectID();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_getObjectID) 

static bool js_cc_physics_SphereShape_setRadius(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::SphereShape *arg1 = (cc::physics::SphereShape *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::SphereShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRadius(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_SphereShape_setRadius) 

bool js_register_cc_physics_SphereShape(se::Object* obj) {
    auto* cls = se::Class::create("SphereShape", obj, nullptr, _SE(js_new_cc_physics_SphereShape)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("initialize", _SE(js_cc_physics_SphereShape_initialize)); 
    cls->defineFunction("onEnable", _SE(js_cc_physics_SphereShape_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_cc_physics_SphereShape_onDisable)); 
    cls->defineFunction("onDestroy", _SE(js_cc_physics_SphereShape_onDestroy)); 
    cls->defineFunction("setMaterial", _SE(js_cc_physics_SphereShape_setMaterial)); 
    cls->defineFunction("setAsTrigger", _SE(js_cc_physics_SphereShape_setAsTrigger)); 
    cls->defineFunction("setCenter", _SE(js_cc_physics_SphereShape_setCenter)); 
    cls->defineFunction("updateEventListener", _SE(js_cc_physics_SphereShape_updateEventListener)); 
    cls->defineFunction("getAABB", _SE(js_cc_physics_SphereShape_getAABB)); 
    cls->defineFunction("getBoundingSphere", _SE(js_cc_physics_SphereShape_getBoundingSphere)); 
    cls->defineFunction("getGroup", _SE(js_cc_physics_SphereShape_getGroup)); 
    cls->defineFunction("setGroup", _SE(js_cc_physics_SphereShape_setGroup)); 
    cls->defineFunction("getMask", _SE(js_cc_physics_SphereShape_getMask)); 
    cls->defineFunction("setMask", _SE(js_cc_physics_SphereShape_setMask)); 
    cls->defineFunction("getObjectID", _SE(js_cc_physics_SphereShape_getObjectID)); 
    cls->defineFunction("setRadius", _SE(js_cc_physics_SphereShape_setRadius)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_physics_SphereShape));
    
    
    cls->install();
    JSBClassType::registerClass<cc::physics::SphereShape>(cls);
    
    __jsb_cc_physics_SphereShape_proto = cls->getProto();
    __jsb_cc_physics_SphereShape_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_physics_BoxShape_class = nullptr;
se::Object* __jsb_cc_physics_BoxShape_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_physics_BoxShape) 

static bool js_new_cc_physics_BoxShape(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::physics::BoxShape *result;
    result = (cc::physics::BoxShape *)new cc::physics::BoxShape();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_physics_BoxShape, __jsb_cc_physics_BoxShape_class, js_delete_cc_physics_BoxShape)

static bool js_delete_cc_physics_BoxShape(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_physics_BoxShape) 

static bool js_cc_physics_BoxShape_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->initialize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_initialize) 

static bool js_cc_physics_BoxShape_onEnable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    if (nullptr == arg1) return true;
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_onEnable) 

static bool js_cc_physics_BoxShape_onDisable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    if (nullptr == arg1) return true;
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_onDisable) 

static bool js_cc_physics_BoxShape_onDestroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    if (nullptr == arg1) return true;
    (arg1)->onDestroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_onDestroy) 

static bool js_cc_physics_BoxShape_setMaterial(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    uint16_t arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    uint8_t arg6 ;
    uint8_t arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setMaterial(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_setMaterial) 

static bool js_cc_physics_BoxShape_setAsTrigger(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAsTrigger(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_setAsTrigger) 

static bool js_cc_physics_BoxShape_setCenter(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setCenter(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_setCenter) 

static bool js_cc_physics_BoxShape_updateEventListener(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    cc::physics::EShapeFilterFlag arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->updateEventListener(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_updateEventListener) 

static bool js_cc_physics_BoxShape_getAABB(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    if (nullptr == arg1) return true;
    result = (cc::geometry::AABB *) &(arg1)->getAABB();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_getAABB) 

static bool js_cc_physics_BoxShape_getBoundingSphere(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    cc::geometry::Sphere *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    if (nullptr == arg1) return true;
    result = (cc::geometry::Sphere *) &(arg1)->getBoundingSphere();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_getBoundingSphere) 

static bool js_cc_physics_BoxShape_getGroup(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getGroup();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_getGroup) 

static bool js_cc_physics_BoxShape_setGroup(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setGroup(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_setGroup) 

static bool js_cc_physics_BoxShape_getMask(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getMask();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_getMask) 

static bool js_cc_physics_BoxShape_setMask(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setMask(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_setMask) 

static bool js_cc_physics_BoxShape_getObjectID(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    if (nullptr == arg1) return true;
    result = ((cc::physics::BoxShape const *)arg1)->getObjectID();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_getObjectID) 

static bool js_cc_physics_BoxShape_setSize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::BoxShape *arg1 = (cc::physics::BoxShape *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::BoxShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setSize(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_BoxShape_setSize) 

bool js_register_cc_physics_BoxShape(se::Object* obj) {
    auto* cls = se::Class::create("BoxShape", obj, nullptr, _SE(js_new_cc_physics_BoxShape)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("initialize", _SE(js_cc_physics_BoxShape_initialize)); 
    cls->defineFunction("onEnable", _SE(js_cc_physics_BoxShape_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_cc_physics_BoxShape_onDisable)); 
    cls->defineFunction("onDestroy", _SE(js_cc_physics_BoxShape_onDestroy)); 
    cls->defineFunction("setMaterial", _SE(js_cc_physics_BoxShape_setMaterial)); 
    cls->defineFunction("setAsTrigger", _SE(js_cc_physics_BoxShape_setAsTrigger)); 
    cls->defineFunction("setCenter", _SE(js_cc_physics_BoxShape_setCenter)); 
    cls->defineFunction("updateEventListener", _SE(js_cc_physics_BoxShape_updateEventListener)); 
    cls->defineFunction("getAABB", _SE(js_cc_physics_BoxShape_getAABB)); 
    cls->defineFunction("getBoundingSphere", _SE(js_cc_physics_BoxShape_getBoundingSphere)); 
    cls->defineFunction("getGroup", _SE(js_cc_physics_BoxShape_getGroup)); 
    cls->defineFunction("setGroup", _SE(js_cc_physics_BoxShape_setGroup)); 
    cls->defineFunction("getMask", _SE(js_cc_physics_BoxShape_getMask)); 
    cls->defineFunction("setMask", _SE(js_cc_physics_BoxShape_setMask)); 
    cls->defineFunction("getObjectID", _SE(js_cc_physics_BoxShape_getObjectID)); 
    cls->defineFunction("setSize", _SE(js_cc_physics_BoxShape_setSize)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_physics_BoxShape));
    
    
    cls->install();
    JSBClassType::registerClass<cc::physics::BoxShape>(cls);
    
    __jsb_cc_physics_BoxShape_proto = cls->getProto();
    __jsb_cc_physics_BoxShape_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_physics_CapsuleShape_class = nullptr;
se::Object* __jsb_cc_physics_CapsuleShape_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_physics_CapsuleShape) 

static bool js_new_cc_physics_CapsuleShape(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::physics::CapsuleShape *result;
    result = (cc::physics::CapsuleShape *)new cc::physics::CapsuleShape();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_physics_CapsuleShape, __jsb_cc_physics_CapsuleShape_class, js_delete_cc_physics_CapsuleShape)

static bool js_delete_cc_physics_CapsuleShape(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_physics_CapsuleShape) 

static bool js_cc_physics_CapsuleShape_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->initialize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_initialize) 

static bool js_cc_physics_CapsuleShape_onEnable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    if (nullptr == arg1) return true;
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_onEnable) 

static bool js_cc_physics_CapsuleShape_onDisable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    if (nullptr == arg1) return true;
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_onDisable) 

static bool js_cc_physics_CapsuleShape_onDestroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    if (nullptr == arg1) return true;
    (arg1)->onDestroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_onDestroy) 

static bool js_cc_physics_CapsuleShape_setMaterial(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    uint16_t arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    uint8_t arg6 ;
    uint8_t arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setMaterial(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_setMaterial) 

static bool js_cc_physics_CapsuleShape_setAsTrigger(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAsTrigger(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_setAsTrigger) 

static bool js_cc_physics_CapsuleShape_setCenter(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setCenter(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_setCenter) 

static bool js_cc_physics_CapsuleShape_updateEventListener(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    cc::physics::EShapeFilterFlag arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->updateEventListener(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_updateEventListener) 

static bool js_cc_physics_CapsuleShape_getAABB(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    if (nullptr == arg1) return true;
    result = (cc::geometry::AABB *) &(arg1)->getAABB();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_getAABB) 

static bool js_cc_physics_CapsuleShape_getBoundingSphere(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    cc::geometry::Sphere *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    if (nullptr == arg1) return true;
    result = (cc::geometry::Sphere *) &(arg1)->getBoundingSphere();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_getBoundingSphere) 

static bool js_cc_physics_CapsuleShape_getGroup(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getGroup();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_getGroup) 

static bool js_cc_physics_CapsuleShape_setGroup(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setGroup(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_setGroup) 

static bool js_cc_physics_CapsuleShape_getMask(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getMask();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_getMask) 

static bool js_cc_physics_CapsuleShape_setMask(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setMask(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_setMask) 

static bool js_cc_physics_CapsuleShape_getObjectID(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    if (nullptr == arg1) return true;
    result = ((cc::physics::CapsuleShape const *)arg1)->getObjectID();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_getObjectID) 

static bool js_cc_physics_CapsuleShape_setRadius(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRadius(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_setRadius) 

static bool js_cc_physics_CapsuleShape_setCylinderHeight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setCylinderHeight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_setCylinderHeight) 

static bool js_cc_physics_CapsuleShape_setDirection(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CapsuleShape *arg1 = (cc::physics::CapsuleShape *) NULL ;
    cc::physics::EAxisDirection arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CapsuleShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->setDirection(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CapsuleShape_setDirection) 

bool js_register_cc_physics_CapsuleShape(se::Object* obj) {
    auto* cls = se::Class::create("CapsuleShape", obj, nullptr, _SE(js_new_cc_physics_CapsuleShape)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("initialize", _SE(js_cc_physics_CapsuleShape_initialize)); 
    cls->defineFunction("onEnable", _SE(js_cc_physics_CapsuleShape_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_cc_physics_CapsuleShape_onDisable)); 
    cls->defineFunction("onDestroy", _SE(js_cc_physics_CapsuleShape_onDestroy)); 
    cls->defineFunction("setMaterial", _SE(js_cc_physics_CapsuleShape_setMaterial)); 
    cls->defineFunction("setAsTrigger", _SE(js_cc_physics_CapsuleShape_setAsTrigger)); 
    cls->defineFunction("setCenter", _SE(js_cc_physics_CapsuleShape_setCenter)); 
    cls->defineFunction("updateEventListener", _SE(js_cc_physics_CapsuleShape_updateEventListener)); 
    cls->defineFunction("getAABB", _SE(js_cc_physics_CapsuleShape_getAABB)); 
    cls->defineFunction("getBoundingSphere", _SE(js_cc_physics_CapsuleShape_getBoundingSphere)); 
    cls->defineFunction("getGroup", _SE(js_cc_physics_CapsuleShape_getGroup)); 
    cls->defineFunction("setGroup", _SE(js_cc_physics_CapsuleShape_setGroup)); 
    cls->defineFunction("getMask", _SE(js_cc_physics_CapsuleShape_getMask)); 
    cls->defineFunction("setMask", _SE(js_cc_physics_CapsuleShape_setMask)); 
    cls->defineFunction("getObjectID", _SE(js_cc_physics_CapsuleShape_getObjectID)); 
    cls->defineFunction("setRadius", _SE(js_cc_physics_CapsuleShape_setRadius)); 
    cls->defineFunction("setCylinderHeight", _SE(js_cc_physics_CapsuleShape_setCylinderHeight)); 
    cls->defineFunction("setDirection", _SE(js_cc_physics_CapsuleShape_setDirection)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_physics_CapsuleShape));
    
    
    cls->install();
    JSBClassType::registerClass<cc::physics::CapsuleShape>(cls);
    
    __jsb_cc_physics_CapsuleShape_proto = cls->getProto();
    __jsb_cc_physics_CapsuleShape_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_physics_PlaneShape_class = nullptr;
se::Object* __jsb_cc_physics_PlaneShape_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_physics_PlaneShape) 

static bool js_new_cc_physics_PlaneShape(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::physics::PlaneShape *result;
    result = (cc::physics::PlaneShape *)new cc::physics::PlaneShape();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_physics_PlaneShape, __jsb_cc_physics_PlaneShape_class, js_delete_cc_physics_PlaneShape)

static bool js_delete_cc_physics_PlaneShape(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_physics_PlaneShape) 

static bool js_cc_physics_PlaneShape_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->initialize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_initialize) 

static bool js_cc_physics_PlaneShape_onEnable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    if (nullptr == arg1) return true;
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_onEnable) 

static bool js_cc_physics_PlaneShape_onDisable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    if (nullptr == arg1) return true;
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_onDisable) 

static bool js_cc_physics_PlaneShape_onDestroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    if (nullptr == arg1) return true;
    (arg1)->onDestroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_onDestroy) 

static bool js_cc_physics_PlaneShape_setMaterial(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    uint16_t arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    uint8_t arg6 ;
    uint8_t arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setMaterial(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_setMaterial) 

static bool js_cc_physics_PlaneShape_setAsTrigger(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAsTrigger(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_setAsTrigger) 

static bool js_cc_physics_PlaneShape_setCenter(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setCenter(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_setCenter) 

static bool js_cc_physics_PlaneShape_updateEventListener(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    cc::physics::EShapeFilterFlag arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->updateEventListener(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_updateEventListener) 

static bool js_cc_physics_PlaneShape_getAABB(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    if (nullptr == arg1) return true;
    result = (cc::geometry::AABB *) &(arg1)->getAABB();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_getAABB) 

static bool js_cc_physics_PlaneShape_getBoundingSphere(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    cc::geometry::Sphere *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    if (nullptr == arg1) return true;
    result = (cc::geometry::Sphere *) &(arg1)->getBoundingSphere();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_getBoundingSphere) 

static bool js_cc_physics_PlaneShape_getGroup(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getGroup();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_getGroup) 

static bool js_cc_physics_PlaneShape_setGroup(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setGroup(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_setGroup) 

static bool js_cc_physics_PlaneShape_getMask(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getMask();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_getMask) 

static bool js_cc_physics_PlaneShape_setMask(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setMask(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_setMask) 

static bool js_cc_physics_PlaneShape_getObjectID(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    if (nullptr == arg1) return true;
    result = ((cc::physics::PlaneShape const *)arg1)->getObjectID();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_getObjectID) 

static bool js_cc_physics_PlaneShape_setConstant(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setConstant(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_setConstant) 

static bool js_cc_physics_PlaneShape_setNormal(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::PlaneShape *arg1 = (cc::physics::PlaneShape *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::PlaneShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setNormal(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_PlaneShape_setNormal) 

bool js_register_cc_physics_PlaneShape(se::Object* obj) {
    auto* cls = se::Class::create("PlaneShape", obj, nullptr, _SE(js_new_cc_physics_PlaneShape)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("initialize", _SE(js_cc_physics_PlaneShape_initialize)); 
    cls->defineFunction("onEnable", _SE(js_cc_physics_PlaneShape_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_cc_physics_PlaneShape_onDisable)); 
    cls->defineFunction("onDestroy", _SE(js_cc_physics_PlaneShape_onDestroy)); 
    cls->defineFunction("setMaterial", _SE(js_cc_physics_PlaneShape_setMaterial)); 
    cls->defineFunction("setAsTrigger", _SE(js_cc_physics_PlaneShape_setAsTrigger)); 
    cls->defineFunction("setCenter", _SE(js_cc_physics_PlaneShape_setCenter)); 
    cls->defineFunction("updateEventListener", _SE(js_cc_physics_PlaneShape_updateEventListener)); 
    cls->defineFunction("getAABB", _SE(js_cc_physics_PlaneShape_getAABB)); 
    cls->defineFunction("getBoundingSphere", _SE(js_cc_physics_PlaneShape_getBoundingSphere)); 
    cls->defineFunction("getGroup", _SE(js_cc_physics_PlaneShape_getGroup)); 
    cls->defineFunction("setGroup", _SE(js_cc_physics_PlaneShape_setGroup)); 
    cls->defineFunction("getMask", _SE(js_cc_physics_PlaneShape_getMask)); 
    cls->defineFunction("setMask", _SE(js_cc_physics_PlaneShape_setMask)); 
    cls->defineFunction("getObjectID", _SE(js_cc_physics_PlaneShape_getObjectID)); 
    cls->defineFunction("setConstant", _SE(js_cc_physics_PlaneShape_setConstant)); 
    cls->defineFunction("setNormal", _SE(js_cc_physics_PlaneShape_setNormal)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_physics_PlaneShape));
    
    
    cls->install();
    JSBClassType::registerClass<cc::physics::PlaneShape>(cls);
    
    __jsb_cc_physics_PlaneShape_proto = cls->getProto();
    __jsb_cc_physics_PlaneShape_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_physics_TrimeshShape_class = nullptr;
se::Object* __jsb_cc_physics_TrimeshShape_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_physics_TrimeshShape) 

static bool js_new_cc_physics_TrimeshShape(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::physics::TrimeshShape *result;
    result = (cc::physics::TrimeshShape *)new cc::physics::TrimeshShape();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_physics_TrimeshShape, __jsb_cc_physics_TrimeshShape_class, js_delete_cc_physics_TrimeshShape)

static bool js_delete_cc_physics_TrimeshShape(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_physics_TrimeshShape) 

static bool js_cc_physics_TrimeshShape_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->initialize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_initialize) 

static bool js_cc_physics_TrimeshShape_onEnable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    if (nullptr == arg1) return true;
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_onEnable) 

static bool js_cc_physics_TrimeshShape_onDisable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    if (nullptr == arg1) return true;
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_onDisable) 

static bool js_cc_physics_TrimeshShape_onDestroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    if (nullptr == arg1) return true;
    (arg1)->onDestroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_onDestroy) 

static bool js_cc_physics_TrimeshShape_setMaterial(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    uint16_t arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    uint8_t arg6 ;
    uint8_t arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setMaterial(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_setMaterial) 

static bool js_cc_physics_TrimeshShape_setAsTrigger(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAsTrigger(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_setAsTrigger) 

static bool js_cc_physics_TrimeshShape_setCenter(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setCenter(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_setCenter) 

static bool js_cc_physics_TrimeshShape_updateEventListener(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    cc::physics::EShapeFilterFlag arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->updateEventListener(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_updateEventListener) 

static bool js_cc_physics_TrimeshShape_getAABB(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    if (nullptr == arg1) return true;
    result = (cc::geometry::AABB *) &(arg1)->getAABB();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_getAABB) 

static bool js_cc_physics_TrimeshShape_getBoundingSphere(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    cc::geometry::Sphere *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    if (nullptr == arg1) return true;
    result = (cc::geometry::Sphere *) &(arg1)->getBoundingSphere();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_getBoundingSphere) 

static bool js_cc_physics_TrimeshShape_getGroup(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getGroup();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_getGroup) 

static bool js_cc_physics_TrimeshShape_setGroup(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setGroup(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_setGroup) 

static bool js_cc_physics_TrimeshShape_getMask(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getMask();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_getMask) 

static bool js_cc_physics_TrimeshShape_setMask(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setMask(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_setMask) 

static bool js_cc_physics_TrimeshShape_getObjectID(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    if (nullptr == arg1) return true;
    result = ((cc::physics::TrimeshShape const *)arg1)->getObjectID();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_getObjectID) 

static bool js_cc_physics_TrimeshShape_setMesh(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setMesh(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_setMesh) 

static bool js_cc_physics_TrimeshShape_useConvex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TrimeshShape *arg1 = (cc::physics::TrimeshShape *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TrimeshShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->useConvex(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TrimeshShape_useConvex) 

bool js_register_cc_physics_TrimeshShape(se::Object* obj) {
    auto* cls = se::Class::create("TrimeshShape", obj, nullptr, _SE(js_new_cc_physics_TrimeshShape)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("initialize", _SE(js_cc_physics_TrimeshShape_initialize)); 
    cls->defineFunction("onEnable", _SE(js_cc_physics_TrimeshShape_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_cc_physics_TrimeshShape_onDisable)); 
    cls->defineFunction("onDestroy", _SE(js_cc_physics_TrimeshShape_onDestroy)); 
    cls->defineFunction("setMaterial", _SE(js_cc_physics_TrimeshShape_setMaterial)); 
    cls->defineFunction("setAsTrigger", _SE(js_cc_physics_TrimeshShape_setAsTrigger)); 
    cls->defineFunction("setCenter", _SE(js_cc_physics_TrimeshShape_setCenter)); 
    cls->defineFunction("updateEventListener", _SE(js_cc_physics_TrimeshShape_updateEventListener)); 
    cls->defineFunction("getAABB", _SE(js_cc_physics_TrimeshShape_getAABB)); 
    cls->defineFunction("getBoundingSphere", _SE(js_cc_physics_TrimeshShape_getBoundingSphere)); 
    cls->defineFunction("getGroup", _SE(js_cc_physics_TrimeshShape_getGroup)); 
    cls->defineFunction("setGroup", _SE(js_cc_physics_TrimeshShape_setGroup)); 
    cls->defineFunction("getMask", _SE(js_cc_physics_TrimeshShape_getMask)); 
    cls->defineFunction("setMask", _SE(js_cc_physics_TrimeshShape_setMask)); 
    cls->defineFunction("getObjectID", _SE(js_cc_physics_TrimeshShape_getObjectID)); 
    cls->defineFunction("setMesh", _SE(js_cc_physics_TrimeshShape_setMesh)); 
    cls->defineFunction("useConvex", _SE(js_cc_physics_TrimeshShape_useConvex)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_physics_TrimeshShape));
    
    
    cls->install();
    JSBClassType::registerClass<cc::physics::TrimeshShape>(cls);
    
    __jsb_cc_physics_TrimeshShape_proto = cls->getProto();
    __jsb_cc_physics_TrimeshShape_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_physics_CylinderShape_class = nullptr;
se::Object* __jsb_cc_physics_CylinderShape_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_physics_CylinderShape) 

static bool js_new_cc_physics_CylinderShape(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::physics::CylinderShape *result;
    result = (cc::physics::CylinderShape *)new cc::physics::CylinderShape();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_physics_CylinderShape, __jsb_cc_physics_CylinderShape_class, js_delete_cc_physics_CylinderShape)

static bool js_delete_cc_physics_CylinderShape(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_physics_CylinderShape) 

static bool js_cc_physics_CylinderShape_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->initialize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_initialize) 

static bool js_cc_physics_CylinderShape_onEnable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    if (nullptr == arg1) return true;
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_onEnable) 

static bool js_cc_physics_CylinderShape_onDisable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    if (nullptr == arg1) return true;
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_onDisable) 

static bool js_cc_physics_CylinderShape_onDestroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    if (nullptr == arg1) return true;
    (arg1)->onDestroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_onDestroy) 

static bool js_cc_physics_CylinderShape_setMaterial(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    uint16_t arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    uint8_t arg6 ;
    uint8_t arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setMaterial(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_setMaterial) 

static bool js_cc_physics_CylinderShape_setAsTrigger(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAsTrigger(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_setAsTrigger) 

static bool js_cc_physics_CylinderShape_setCenter(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setCenter(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_setCenter) 

static bool js_cc_physics_CylinderShape_updateEventListener(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    cc::physics::EShapeFilterFlag arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->updateEventListener(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_updateEventListener) 

static bool js_cc_physics_CylinderShape_getAABB(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    if (nullptr == arg1) return true;
    result = (cc::geometry::AABB *) &(arg1)->getAABB();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_getAABB) 

static bool js_cc_physics_CylinderShape_getBoundingSphere(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    cc::geometry::Sphere *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    if (nullptr == arg1) return true;
    result = (cc::geometry::Sphere *) &(arg1)->getBoundingSphere();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_getBoundingSphere) 

static bool js_cc_physics_CylinderShape_getGroup(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getGroup();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_getGroup) 

static bool js_cc_physics_CylinderShape_setGroup(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setGroup(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_setGroup) 

static bool js_cc_physics_CylinderShape_getMask(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getMask();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_getMask) 

static bool js_cc_physics_CylinderShape_setMask(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setMask(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_setMask) 

static bool js_cc_physics_CylinderShape_getObjectID(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    if (nullptr == arg1) return true;
    result = ((cc::physics::CylinderShape const *)arg1)->getObjectID();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_getObjectID) 

static bool js_cc_physics_CylinderShape_setConvex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setConvex(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_setConvex) 

static bool js_cc_physics_CylinderShape_setCylinder(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::CylinderShape *arg1 = (cc::physics::CylinderShape *) NULL ;
    float arg2 ;
    float arg3 ;
    cc::physics::EAxisDirection arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::CylinderShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->setCylinder(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_CylinderShape_setCylinder) 

bool js_register_cc_physics_CylinderShape(se::Object* obj) {
    auto* cls = se::Class::create("CylinderShape", obj, nullptr, _SE(js_new_cc_physics_CylinderShape)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("initialize", _SE(js_cc_physics_CylinderShape_initialize)); 
    cls->defineFunction("onEnable", _SE(js_cc_physics_CylinderShape_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_cc_physics_CylinderShape_onDisable)); 
    cls->defineFunction("onDestroy", _SE(js_cc_physics_CylinderShape_onDestroy)); 
    cls->defineFunction("setMaterial", _SE(js_cc_physics_CylinderShape_setMaterial)); 
    cls->defineFunction("setAsTrigger", _SE(js_cc_physics_CylinderShape_setAsTrigger)); 
    cls->defineFunction("setCenter", _SE(js_cc_physics_CylinderShape_setCenter)); 
    cls->defineFunction("updateEventListener", _SE(js_cc_physics_CylinderShape_updateEventListener)); 
    cls->defineFunction("getAABB", _SE(js_cc_physics_CylinderShape_getAABB)); 
    cls->defineFunction("getBoundingSphere", _SE(js_cc_physics_CylinderShape_getBoundingSphere)); 
    cls->defineFunction("getGroup", _SE(js_cc_physics_CylinderShape_getGroup)); 
    cls->defineFunction("setGroup", _SE(js_cc_physics_CylinderShape_setGroup)); 
    cls->defineFunction("getMask", _SE(js_cc_physics_CylinderShape_getMask)); 
    cls->defineFunction("setMask", _SE(js_cc_physics_CylinderShape_setMask)); 
    cls->defineFunction("getObjectID", _SE(js_cc_physics_CylinderShape_getObjectID)); 
    cls->defineFunction("setConvex", _SE(js_cc_physics_CylinderShape_setConvex)); 
    cls->defineFunction("setCylinder", _SE(js_cc_physics_CylinderShape_setCylinder)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_physics_CylinderShape));
    
    
    cls->install();
    JSBClassType::registerClass<cc::physics::CylinderShape>(cls);
    
    __jsb_cc_physics_CylinderShape_proto = cls->getProto();
    __jsb_cc_physics_CylinderShape_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_physics_ConeShape_class = nullptr;
se::Object* __jsb_cc_physics_ConeShape_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_physics_ConeShape) 

static bool js_new_cc_physics_ConeShape(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::physics::ConeShape *result;
    result = (cc::physics::ConeShape *)new cc::physics::ConeShape();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_physics_ConeShape, __jsb_cc_physics_ConeShape_class, js_delete_cc_physics_ConeShape)

static bool js_delete_cc_physics_ConeShape(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_physics_ConeShape) 

static bool js_cc_physics_ConeShape_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->initialize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_initialize) 

static bool js_cc_physics_ConeShape_onEnable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    if (nullptr == arg1) return true;
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_onEnable) 

static bool js_cc_physics_ConeShape_onDisable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    if (nullptr == arg1) return true;
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_onDisable) 

static bool js_cc_physics_ConeShape_onDestroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    if (nullptr == arg1) return true;
    (arg1)->onDestroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_onDestroy) 

static bool js_cc_physics_ConeShape_setMaterial(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    uint16_t arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    uint8_t arg6 ;
    uint8_t arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setMaterial(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_setMaterial) 

static bool js_cc_physics_ConeShape_setAsTrigger(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAsTrigger(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_setAsTrigger) 

static bool js_cc_physics_ConeShape_setCenter(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setCenter(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_setCenter) 

static bool js_cc_physics_ConeShape_updateEventListener(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    cc::physics::EShapeFilterFlag arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->updateEventListener(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_updateEventListener) 

static bool js_cc_physics_ConeShape_getAABB(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    if (nullptr == arg1) return true;
    result = (cc::geometry::AABB *) &(arg1)->getAABB();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_getAABB) 

static bool js_cc_physics_ConeShape_getBoundingSphere(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    cc::geometry::Sphere *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    if (nullptr == arg1) return true;
    result = (cc::geometry::Sphere *) &(arg1)->getBoundingSphere();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_getBoundingSphere) 

static bool js_cc_physics_ConeShape_getGroup(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getGroup();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_getGroup) 

static bool js_cc_physics_ConeShape_setGroup(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setGroup(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_setGroup) 

static bool js_cc_physics_ConeShape_getMask(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getMask();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_getMask) 

static bool js_cc_physics_ConeShape_setMask(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setMask(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_setMask) 

static bool js_cc_physics_ConeShape_getObjectID(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    if (nullptr == arg1) return true;
    result = ((cc::physics::ConeShape const *)arg1)->getObjectID();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_getObjectID) 

static bool js_cc_physics_ConeShape_setConvex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setConvex(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_setConvex) 

static bool js_cc_physics_ConeShape_setCone(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::ConeShape *arg1 = (cc::physics::ConeShape *) NULL ;
    float arg2 ;
    float arg3 ;
    cc::physics::EAxisDirection arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::ConeShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->setCone(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_ConeShape_setCone) 

bool js_register_cc_physics_ConeShape(se::Object* obj) {
    auto* cls = se::Class::create("ConeShape", obj, nullptr, _SE(js_new_cc_physics_ConeShape)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("initialize", _SE(js_cc_physics_ConeShape_initialize)); 
    cls->defineFunction("onEnable", _SE(js_cc_physics_ConeShape_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_cc_physics_ConeShape_onDisable)); 
    cls->defineFunction("onDestroy", _SE(js_cc_physics_ConeShape_onDestroy)); 
    cls->defineFunction("setMaterial", _SE(js_cc_physics_ConeShape_setMaterial)); 
    cls->defineFunction("setAsTrigger", _SE(js_cc_physics_ConeShape_setAsTrigger)); 
    cls->defineFunction("setCenter", _SE(js_cc_physics_ConeShape_setCenter)); 
    cls->defineFunction("updateEventListener", _SE(js_cc_physics_ConeShape_updateEventListener)); 
    cls->defineFunction("getAABB", _SE(js_cc_physics_ConeShape_getAABB)); 
    cls->defineFunction("getBoundingSphere", _SE(js_cc_physics_ConeShape_getBoundingSphere)); 
    cls->defineFunction("getGroup", _SE(js_cc_physics_ConeShape_getGroup)); 
    cls->defineFunction("setGroup", _SE(js_cc_physics_ConeShape_setGroup)); 
    cls->defineFunction("getMask", _SE(js_cc_physics_ConeShape_getMask)); 
    cls->defineFunction("setMask", _SE(js_cc_physics_ConeShape_setMask)); 
    cls->defineFunction("getObjectID", _SE(js_cc_physics_ConeShape_getObjectID)); 
    cls->defineFunction("setConvex", _SE(js_cc_physics_ConeShape_setConvex)); 
    cls->defineFunction("setCone", _SE(js_cc_physics_ConeShape_setCone)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_physics_ConeShape));
    
    
    cls->install();
    JSBClassType::registerClass<cc::physics::ConeShape>(cls);
    
    __jsb_cc_physics_ConeShape_proto = cls->getProto();
    __jsb_cc_physics_ConeShape_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_physics_TerrainShape_class = nullptr;
se::Object* __jsb_cc_physics_TerrainShape_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_physics_TerrainShape) 

static bool js_new_cc_physics_TerrainShape(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::physics::TerrainShape *result;
    result = (cc::physics::TerrainShape *)new cc::physics::TerrainShape();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_physics_TerrainShape, __jsb_cc_physics_TerrainShape_class, js_delete_cc_physics_TerrainShape)

static bool js_delete_cc_physics_TerrainShape(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_physics_TerrainShape) 

static bool js_cc_physics_TerrainShape_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->initialize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_initialize) 

static bool js_cc_physics_TerrainShape_onEnable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    if (nullptr == arg1) return true;
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_onEnable) 

static bool js_cc_physics_TerrainShape_onDisable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    if (nullptr == arg1) return true;
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_onDisable) 

static bool js_cc_physics_TerrainShape_onDestroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    if (nullptr == arg1) return true;
    (arg1)->onDestroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_onDestroy) 

static bool js_cc_physics_TerrainShape_setMaterial(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    uint16_t arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    uint8_t arg6 ;
    uint8_t arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setMaterial(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_setMaterial) 

static bool js_cc_physics_TerrainShape_setAsTrigger(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAsTrigger(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_setAsTrigger) 

static bool js_cc_physics_TerrainShape_setCenter(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setCenter(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_setCenter) 

static bool js_cc_physics_TerrainShape_updateEventListener(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    cc::physics::EShapeFilterFlag arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->updateEventListener(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_updateEventListener) 

static bool js_cc_physics_TerrainShape_getAABB(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    if (nullptr == arg1) return true;
    result = (cc::geometry::AABB *) &(arg1)->getAABB();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_getAABB) 

static bool js_cc_physics_TerrainShape_getBoundingSphere(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    cc::geometry::Sphere *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    if (nullptr == arg1) return true;
    result = (cc::geometry::Sphere *) &(arg1)->getBoundingSphere();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_getBoundingSphere) 

static bool js_cc_physics_TerrainShape_getGroup(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getGroup();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_getGroup) 

static bool js_cc_physics_TerrainShape_setGroup(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setGroup(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_setGroup) 

static bool js_cc_physics_TerrainShape_getMask(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getMask();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_getMask) 

static bool js_cc_physics_TerrainShape_setMask(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setMask(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_setMask) 

static bool js_cc_physics_TerrainShape_getObjectID(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    if (nullptr == arg1) return true;
    result = ((cc::physics::TerrainShape const *)arg1)->getObjectID();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_getObjectID) 

static bool js_cc_physics_TerrainShape_setTerrain(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::TerrainShape *arg1 = (cc::physics::TerrainShape *) NULL ;
    uint32_t arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::TerrainShape>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setTerrain(arg2,arg3,arg4,arg5);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_TerrainShape_setTerrain) 

bool js_register_cc_physics_TerrainShape(se::Object* obj) {
    auto* cls = se::Class::create("TerrainShape", obj, nullptr, _SE(js_new_cc_physics_TerrainShape)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("initialize", _SE(js_cc_physics_TerrainShape_initialize)); 
    cls->defineFunction("onEnable", _SE(js_cc_physics_TerrainShape_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_cc_physics_TerrainShape_onDisable)); 
    cls->defineFunction("onDestroy", _SE(js_cc_physics_TerrainShape_onDestroy)); 
    cls->defineFunction("setMaterial", _SE(js_cc_physics_TerrainShape_setMaterial)); 
    cls->defineFunction("setAsTrigger", _SE(js_cc_physics_TerrainShape_setAsTrigger)); 
    cls->defineFunction("setCenter", _SE(js_cc_physics_TerrainShape_setCenter)); 
    cls->defineFunction("updateEventListener", _SE(js_cc_physics_TerrainShape_updateEventListener)); 
    cls->defineFunction("getAABB", _SE(js_cc_physics_TerrainShape_getAABB)); 
    cls->defineFunction("getBoundingSphere", _SE(js_cc_physics_TerrainShape_getBoundingSphere)); 
    cls->defineFunction("getGroup", _SE(js_cc_physics_TerrainShape_getGroup)); 
    cls->defineFunction("setGroup", _SE(js_cc_physics_TerrainShape_setGroup)); 
    cls->defineFunction("getMask", _SE(js_cc_physics_TerrainShape_getMask)); 
    cls->defineFunction("setMask", _SE(js_cc_physics_TerrainShape_setMask)); 
    cls->defineFunction("getObjectID", _SE(js_cc_physics_TerrainShape_getObjectID)); 
    cls->defineFunction("setTerrain", _SE(js_cc_physics_TerrainShape_setTerrain)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_physics_TerrainShape));
    
    
    cls->install();
    JSBClassType::registerClass<cc::physics::TerrainShape>(cls);
    
    __jsb_cc_physics_TerrainShape_proto = cls->getProto();
    __jsb_cc_physics_TerrainShape_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_physics_RevoluteJoint_class = nullptr;
se::Object* __jsb_cc_physics_RevoluteJoint_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_physics_RevoluteJoint) 

static bool js_new_cc_physics_RevoluteJoint(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::physics::RevoluteJoint *result;
    result = (cc::physics::RevoluteJoint *)new cc::physics::RevoluteJoint();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_physics_RevoluteJoint, __jsb_cc_physics_RevoluteJoint_class, js_delete_cc_physics_RevoluteJoint)

static bool js_delete_cc_physics_RevoluteJoint(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_physics_RevoluteJoint) 

static bool js_cc_physics_RevoluteJoint_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RevoluteJoint *arg1 = (cc::physics::RevoluteJoint *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RevoluteJoint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->initialize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RevoluteJoint_initialize) 

static bool js_cc_physics_RevoluteJoint_onEnable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RevoluteJoint *arg1 = (cc::physics::RevoluteJoint *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RevoluteJoint>(s);
    if (nullptr == arg1) return true;
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RevoluteJoint_onEnable) 

static bool js_cc_physics_RevoluteJoint_onDisable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RevoluteJoint *arg1 = (cc::physics::RevoluteJoint *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RevoluteJoint>(s);
    if (nullptr == arg1) return true;
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RevoluteJoint_onDisable) 

static bool js_cc_physics_RevoluteJoint_onDestroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RevoluteJoint *arg1 = (cc::physics::RevoluteJoint *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RevoluteJoint>(s);
    if (nullptr == arg1) return true;
    (arg1)->onDestroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RevoluteJoint_onDestroy) 

static bool js_cc_physics_RevoluteJoint_setEnableCollision(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RevoluteJoint *arg1 = (cc::physics::RevoluteJoint *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RevoluteJoint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setEnableCollision(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RevoluteJoint_setEnableCollision) 

static bool js_cc_physics_RevoluteJoint_setConnectedBody(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RevoluteJoint *arg1 = (cc::physics::RevoluteJoint *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RevoluteJoint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setConnectedBody(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RevoluteJoint_setConnectedBody) 

static bool js_cc_physics_RevoluteJoint_getObjectID(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RevoluteJoint *arg1 = (cc::physics::RevoluteJoint *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RevoluteJoint>(s);
    if (nullptr == arg1) return true;
    result = ((cc::physics::RevoluteJoint const *)arg1)->getObjectID();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RevoluteJoint_getObjectID) 

static bool js_cc_physics_RevoluteJoint_setPivotA(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RevoluteJoint *arg1 = (cc::physics::RevoluteJoint *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RevoluteJoint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPivotA(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RevoluteJoint_setPivotA) 

static bool js_cc_physics_RevoluteJoint_setPivotB(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RevoluteJoint *arg1 = (cc::physics::RevoluteJoint *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RevoluteJoint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPivotB(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RevoluteJoint_setPivotB) 

static bool js_cc_physics_RevoluteJoint_setAxis(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::RevoluteJoint *arg1 = (cc::physics::RevoluteJoint *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::RevoluteJoint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAxis(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_RevoluteJoint_setAxis) 

bool js_register_cc_physics_RevoluteJoint(se::Object* obj) {
    auto* cls = se::Class::create("RevoluteJoint", obj, nullptr, _SE(js_new_cc_physics_RevoluteJoint)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("initialize", _SE(js_cc_physics_RevoluteJoint_initialize)); 
    cls->defineFunction("onEnable", _SE(js_cc_physics_RevoluteJoint_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_cc_physics_RevoluteJoint_onDisable)); 
    cls->defineFunction("onDestroy", _SE(js_cc_physics_RevoluteJoint_onDestroy)); 
    cls->defineFunction("setEnableCollision", _SE(js_cc_physics_RevoluteJoint_setEnableCollision)); 
    cls->defineFunction("setConnectedBody", _SE(js_cc_physics_RevoluteJoint_setConnectedBody)); 
    cls->defineFunction("getObjectID", _SE(js_cc_physics_RevoluteJoint_getObjectID)); 
    cls->defineFunction("setPivotA", _SE(js_cc_physics_RevoluteJoint_setPivotA)); 
    cls->defineFunction("setPivotB", _SE(js_cc_physics_RevoluteJoint_setPivotB)); 
    cls->defineFunction("setAxis", _SE(js_cc_physics_RevoluteJoint_setAxis)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_physics_RevoluteJoint));
    
    
    cls->install();
    JSBClassType::registerClass<cc::physics::RevoluteJoint>(cls);
    
    __jsb_cc_physics_RevoluteJoint_proto = cls->getProto();
    __jsb_cc_physics_RevoluteJoint_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_physics_DistanceJoint_class = nullptr;
se::Object* __jsb_cc_physics_DistanceJoint_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_physics_DistanceJoint) 

static bool js_new_cc_physics_DistanceJoint(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::physics::DistanceJoint *result;
    result = (cc::physics::DistanceJoint *)new cc::physics::DistanceJoint();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_physics_DistanceJoint, __jsb_cc_physics_DistanceJoint_class, js_delete_cc_physics_DistanceJoint)

static bool js_delete_cc_physics_DistanceJoint(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_physics_DistanceJoint) 

static bool js_cc_physics_DistanceJoint_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::DistanceJoint *arg1 = (cc::physics::DistanceJoint *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::DistanceJoint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->initialize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_DistanceJoint_initialize) 

static bool js_cc_physics_DistanceJoint_onEnable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::DistanceJoint *arg1 = (cc::physics::DistanceJoint *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::DistanceJoint>(s);
    if (nullptr == arg1) return true;
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_DistanceJoint_onEnable) 

static bool js_cc_physics_DistanceJoint_onDisable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::DistanceJoint *arg1 = (cc::physics::DistanceJoint *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::DistanceJoint>(s);
    if (nullptr == arg1) return true;
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_DistanceJoint_onDisable) 

static bool js_cc_physics_DistanceJoint_onDestroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::DistanceJoint *arg1 = (cc::physics::DistanceJoint *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::DistanceJoint>(s);
    if (nullptr == arg1) return true;
    (arg1)->onDestroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_DistanceJoint_onDestroy) 

static bool js_cc_physics_DistanceJoint_setEnableCollision(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::DistanceJoint *arg1 = (cc::physics::DistanceJoint *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::DistanceJoint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setEnableCollision(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_DistanceJoint_setEnableCollision) 

static bool js_cc_physics_DistanceJoint_setConnectedBody(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::DistanceJoint *arg1 = (cc::physics::DistanceJoint *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::DistanceJoint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setConnectedBody(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_DistanceJoint_setConnectedBody) 

static bool js_cc_physics_DistanceJoint_getObjectID(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::DistanceJoint *arg1 = (cc::physics::DistanceJoint *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::DistanceJoint>(s);
    if (nullptr == arg1) return true;
    result = ((cc::physics::DistanceJoint const *)arg1)->getObjectID();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_DistanceJoint_getObjectID) 

static bool js_cc_physics_DistanceJoint_setPivotA(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::DistanceJoint *arg1 = (cc::physics::DistanceJoint *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::DistanceJoint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPivotA(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_DistanceJoint_setPivotA) 

static bool js_cc_physics_DistanceJoint_setPivotB(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::DistanceJoint *arg1 = (cc::physics::DistanceJoint *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::DistanceJoint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPivotB(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_DistanceJoint_setPivotB) 

bool js_register_cc_physics_DistanceJoint(se::Object* obj) {
    auto* cls = se::Class::create("DistanceJoint", obj, nullptr, _SE(js_new_cc_physics_DistanceJoint)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("initialize", _SE(js_cc_physics_DistanceJoint_initialize)); 
    cls->defineFunction("onEnable", _SE(js_cc_physics_DistanceJoint_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_cc_physics_DistanceJoint_onDisable)); 
    cls->defineFunction("onDestroy", _SE(js_cc_physics_DistanceJoint_onDestroy)); 
    cls->defineFunction("setEnableCollision", _SE(js_cc_physics_DistanceJoint_setEnableCollision)); 
    cls->defineFunction("setConnectedBody", _SE(js_cc_physics_DistanceJoint_setConnectedBody)); 
    cls->defineFunction("getObjectID", _SE(js_cc_physics_DistanceJoint_getObjectID)); 
    cls->defineFunction("setPivotA", _SE(js_cc_physics_DistanceJoint_setPivotA)); 
    cls->defineFunction("setPivotB", _SE(js_cc_physics_DistanceJoint_setPivotB)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_physics_DistanceJoint));
    
    
    cls->install();
    JSBClassType::registerClass<cc::physics::DistanceJoint>(cls);
    
    __jsb_cc_physics_DistanceJoint_proto = cls->getProto();
    __jsb_cc_physics_DistanceJoint_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_physics_FixedJoint_class = nullptr;
se::Object* __jsb_cc_physics_FixedJoint_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_physics_FixedJoint) 

static bool js_new_cc_physics_FixedJoint(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::physics::FixedJoint *result;
    result = (cc::physics::FixedJoint *)new cc::physics::FixedJoint();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_physics_FixedJoint, __jsb_cc_physics_FixedJoint_class, js_delete_cc_physics_FixedJoint)

static bool js_delete_cc_physics_FixedJoint(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_physics_FixedJoint) 

static bool js_cc_physics_FixedJoint_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::FixedJoint *arg1 = (cc::physics::FixedJoint *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::FixedJoint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->initialize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_FixedJoint_initialize) 

static bool js_cc_physics_FixedJoint_onEnable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::FixedJoint *arg1 = (cc::physics::FixedJoint *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::FixedJoint>(s);
    if (nullptr == arg1) return true;
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_FixedJoint_onEnable) 

static bool js_cc_physics_FixedJoint_onDisable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::FixedJoint *arg1 = (cc::physics::FixedJoint *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::FixedJoint>(s);
    if (nullptr == arg1) return true;
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_FixedJoint_onDisable) 

static bool js_cc_physics_FixedJoint_onDestroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::FixedJoint *arg1 = (cc::physics::FixedJoint *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::FixedJoint>(s);
    if (nullptr == arg1) return true;
    (arg1)->onDestroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_FixedJoint_onDestroy) 

static bool js_cc_physics_FixedJoint_setEnableCollision(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::FixedJoint *arg1 = (cc::physics::FixedJoint *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::FixedJoint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setEnableCollision(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_FixedJoint_setEnableCollision) 

static bool js_cc_physics_FixedJoint_setConnectedBody(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::FixedJoint *arg1 = (cc::physics::FixedJoint *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::FixedJoint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setConnectedBody(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_FixedJoint_setConnectedBody) 

static bool js_cc_physics_FixedJoint_getObjectID(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::FixedJoint *arg1 = (cc::physics::FixedJoint *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::FixedJoint>(s);
    if (nullptr == arg1) return true;
    result = ((cc::physics::FixedJoint const *)arg1)->getObjectID();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_FixedJoint_getObjectID) 

static bool js_cc_physics_FixedJoint_setBreakForce(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::FixedJoint *arg1 = (cc::physics::FixedJoint *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::FixedJoint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setBreakForce(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_FixedJoint_setBreakForce) 

static bool js_cc_physics_FixedJoint_setBreakTorque(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::physics::FixedJoint *arg1 = (cc::physics::FixedJoint *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::physics::FixedJoint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setBreakTorque(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_physics_FixedJoint_setBreakTorque) 

bool js_register_cc_physics_FixedJoint(se::Object* obj) {
    auto* cls = se::Class::create("FixedJoint", obj, nullptr, _SE(js_new_cc_physics_FixedJoint)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("initialize", _SE(js_cc_physics_FixedJoint_initialize)); 
    cls->defineFunction("onEnable", _SE(js_cc_physics_FixedJoint_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_cc_physics_FixedJoint_onDisable)); 
    cls->defineFunction("onDestroy", _SE(js_cc_physics_FixedJoint_onDestroy)); 
    cls->defineFunction("setEnableCollision", _SE(js_cc_physics_FixedJoint_setEnableCollision)); 
    cls->defineFunction("setConnectedBody", _SE(js_cc_physics_FixedJoint_setConnectedBody)); 
    cls->defineFunction("getObjectID", _SE(js_cc_physics_FixedJoint_getObjectID)); 
    cls->defineFunction("setBreakForce", _SE(js_cc_physics_FixedJoint_setBreakForce)); 
    cls->defineFunction("setBreakTorque", _SE(js_cc_physics_FixedJoint_setBreakTorque)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_physics_FixedJoint));
    
    
    cls->install();
    JSBClassType::registerClass<cc::physics::FixedJoint>(cls);
    
    __jsb_cc_physics_FixedJoint_proto = cls->getProto();
    __jsb_cc_physics_FixedJoint_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}




bool register_all_physics(se::Object* obj) {
    // Get the ns
    se::Value nsVal;
    if (!obj->getProperty("jsb.physics", &nsVal, true))
    {
        se::HandleObject jsobj(se::Object::createPlainObject());
        nsVal.setObject(jsobj);
        obj->setProperty("jsb.physics", nsVal);
    }
    se::Object* ns = nsVal.toObject();
    /* Register classes */
    js_register_cc_physics_World(ns); 
    js_register_cc_physics_RigidBody(ns); 
    js_register_cc_physics_SphereShape(ns); 
    js_register_cc_physics_BoxShape(ns); 
    js_register_cc_physics_CapsuleShape(ns); 
    js_register_cc_physics_PlaneShape(ns); 
    js_register_cc_physics_TrimeshShape(ns); 
    js_register_cc_physics_CylinderShape(ns); 
    js_register_cc_physics_ConeShape(ns); 
    js_register_cc_physics_TerrainShape(ns); 
    js_register_cc_physics_RevoluteJoint(ns); 
    js_register_cc_physics_DistanceJoint(ns); 
    js_register_cc_physics_FixedJoint(ns); 
    
    /* Register global variables & global functions */
    
    
    
    return true;
}


#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif
// clang-format on
