// clang-format off

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.1.0
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

/****************************************************************************
 Copyright (c) 2022 Xiamen Yaji Software Co., Ltd.

 http://www.cocos.com

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated engine source code (the "Software"), a limited,
 worldwide, royalty-free, non-assignable, revocable and non-exclusive license
 to use Cocos Creator solely to develop games on your target platforms. You shall
 not use Cocos Creator software for developing other software or tools that's
 used for developing games. You are not granted to publish, distribute,
 sublicense, and/or sell copies of Cocos Creator.

 The software or tools in this License Agreement are licensed, not sold.
 Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
****************************************************************************/

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-variable"
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-variable"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4101)
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static 
#endif



#include <stdio.h>


#include "bindings/jswrapper/SeApi.h"
#include "bindings/manual/jsb_conversions.h"
#include "bindings/manual/jsb_global.h"


#include "bindings/auto/jsb_dragonbones_auto.h"


#include <string.h>



se::Class* __jsb_dragonBones_Rectangle_class = nullptr;
se::Object* __jsb_dragonBones_Rectangle_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_Rectangle) 

static bool js_dragonBones_Rectangle_x_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Rectangle *arg1 = (dragonBones::Rectangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Rectangle>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->x, nullptr);
    SE_PRECONDITION2(ok, false, "Rectangle_x_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Rectangle_x_set) 

static bool js_dragonBones_Rectangle_x_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Rectangle *arg1 = (dragonBones::Rectangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Rectangle>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->x, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Rectangle_x_get) 

static bool js_dragonBones_Rectangle_y_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Rectangle *arg1 = (dragonBones::Rectangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Rectangle>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->y, nullptr);
    SE_PRECONDITION2(ok, false, "Rectangle_y_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Rectangle_y_set) 

static bool js_dragonBones_Rectangle_y_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Rectangle *arg1 = (dragonBones::Rectangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Rectangle>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->y, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Rectangle_y_get) 

static bool js_dragonBones_Rectangle_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Rectangle *arg1 = (dragonBones::Rectangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Rectangle>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->width, nullptr);
    SE_PRECONDITION2(ok, false, "Rectangle_width_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Rectangle_width_set) 

static bool js_dragonBones_Rectangle_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Rectangle *arg1 = (dragonBones::Rectangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Rectangle>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->width, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Rectangle_width_get) 

static bool js_dragonBones_Rectangle_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Rectangle *arg1 = (dragonBones::Rectangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Rectangle>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->height, nullptr);
    SE_PRECONDITION2(ok, false, "Rectangle_height_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Rectangle_height_set) 

static bool js_dragonBones_Rectangle_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Rectangle *arg1 = (dragonBones::Rectangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Rectangle>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->height, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Rectangle_height_get) 

static bool js_new_dragonBones_Rectangle__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    dragonBones::Rectangle *result;
    result = (dragonBones::Rectangle *)new dragonBones::Rectangle();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_dragonBones_Rectangle__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    dragonBones::Rectangle *arg1 = 0 ;
    dragonBones::Rectangle temp1 ;
    dragonBones::Rectangle *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Rectangle,1,SWIGTYPE_p_dragonBones__Rectangle");
    arg1 = &temp1;
    
    result = (dragonBones::Rectangle *)new dragonBones::Rectangle((dragonBones::Rectangle const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_Rectangle(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_ctor_dispatcher
    size_t argc = s.args().size();
    bool ret = false;
    
    // switch all cases by means of series of if-returns.
    
    // js_ctor_dispatch_case
    if(argc == 0) {
        ret = js_new_dragonBones_Rectangle__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_dragonBones_Rectangle__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    
    // default:
    SE_REPORT_ERROR("Illegal arguments for construction of Rectangle");
    return false;
}
SE_BIND_CTOR(js_new_Rectangle, __jsb_dragonBones_Rectangle_class, js_delete_dragonBones_Rectangle)

static bool js_delete_dragonBones_Rectangle(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_Rectangle) 

static bool js_dragonBones_Rectangle_clear(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Rectangle *arg1 = (dragonBones::Rectangle *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Rectangle>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->clear();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Rectangle_clear) 

bool js_register_dragonBones_Rectangle(se::Object* obj) {
    auto* cls = se::Class::create("Rectangle", obj, nullptr, _SE(js_new_Rectangle)); 
    
    cls->defineProperty("x", _SE(js_dragonBones_Rectangle_x_get), _SE(js_dragonBones_Rectangle_x_set)); 
    cls->defineProperty("y", _SE(js_dragonBones_Rectangle_y_get), _SE(js_dragonBones_Rectangle_y_set)); 
    cls->defineProperty("width", _SE(js_dragonBones_Rectangle_width_get), _SE(js_dragonBones_Rectangle_width_set)); 
    cls->defineProperty("height", _SE(js_dragonBones_Rectangle_height_get), _SE(js_dragonBones_Rectangle_height_set)); 
    
    cls->defineFunction("clear", _SE(js_dragonBones_Rectangle_clear)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_Rectangle));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::Rectangle>(cls);
    
    __jsb_dragonBones_Rectangle_proto = cls->getProto();
    __jsb_dragonBones_Rectangle_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_Transform_class = nullptr;
se::Object* __jsb_dragonBones_Transform_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_Transform) 

static bool js_dragonBones_Transform_PI_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    float result;
    
    result = (float)(float)dragonBones::Transform::PI;
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Transform_PI_get) 

static bool js_dragonBones_Transform_PI_D_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    float result;
    
    result = (float)(float)dragonBones::Transform::PI_D;
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Transform_PI_D_get) 

static bool js_dragonBones_Transform_PI_H_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    float result;
    
    result = (float)(float)dragonBones::Transform::PI_H;
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Transform_PI_H_get) 

static bool js_dragonBones_Transform_PI_Q_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    float result;
    
    result = (float)(float)dragonBones::Transform::PI_Q;
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Transform_PI_Q_get) 

static bool js_dragonBones_Transform_DEG_RAD_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    float result;
    
    result = (float)(float)dragonBones::Transform::DEG_RAD;
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Transform_DEG_RAD_get) 

static bool js_dragonBones_Transform_RAD_DEG_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    float result;
    
    result = (float)(float)dragonBones::Transform::RAD_DEG;
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Transform_RAD_DEG_get) 

static bool js_dragonBones_Transform_normalizeRadian_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float arg1 ;
    float result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "Transform_normalizeRadian,1,SWIGTYPE_float"); 
    result = (float)dragonBones::Transform::normalizeRadian(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Transform_normalizeRadian_static) 

static bool js_dragonBones_Transform_x_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Transform *arg1 = (dragonBones::Transform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Transform>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->x, nullptr);
    SE_PRECONDITION2(ok, false, "Transform_x_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Transform_x_set) 

static bool js_dragonBones_Transform_x_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Transform *arg1 = (dragonBones::Transform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Transform>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->x, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Transform_x_get) 

static bool js_dragonBones_Transform_y_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Transform *arg1 = (dragonBones::Transform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Transform>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->y, nullptr);
    SE_PRECONDITION2(ok, false, "Transform_y_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Transform_y_set) 

static bool js_dragonBones_Transform_y_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Transform *arg1 = (dragonBones::Transform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Transform>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->y, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Transform_y_get) 

static bool js_dragonBones_Transform_skew_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Transform *arg1 = (dragonBones::Transform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Transform>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->skew, nullptr);
    SE_PRECONDITION2(ok, false, "Transform_skew_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Transform_skew_set) 

static bool js_dragonBones_Transform_skew_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Transform *arg1 = (dragonBones::Transform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Transform>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->skew, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Transform_skew_get) 

static bool js_dragonBones_Transform_rotation_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Transform *arg1 = (dragonBones::Transform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Transform>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->rotation, nullptr);
    SE_PRECONDITION2(ok, false, "Transform_rotation_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Transform_rotation_set) 

static bool js_dragonBones_Transform_rotation_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Transform *arg1 = (dragonBones::Transform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Transform>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->rotation, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Transform_rotation_get) 

static bool js_dragonBones_Transform_scaleX_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Transform *arg1 = (dragonBones::Transform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Transform>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->scaleX, nullptr);
    SE_PRECONDITION2(ok, false, "Transform_scaleX_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Transform_scaleX_set) 

static bool js_dragonBones_Transform_scaleX_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Transform *arg1 = (dragonBones::Transform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Transform>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->scaleX, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Transform_scaleX_get) 

static bool js_dragonBones_Transform_scaleY_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Transform *arg1 = (dragonBones::Transform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Transform>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->scaleY, nullptr);
    SE_PRECONDITION2(ok, false, "Transform_scaleY_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Transform_scaleY_set) 

static bool js_dragonBones_Transform_scaleY_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Transform *arg1 = (dragonBones::Transform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Transform>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->scaleY, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Transform_scaleY_get) 

static bool js_delete_dragonBones_Transform(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_Transform) 

bool js_register_dragonBones_Transform(se::Object* obj) {
    auto* cls = se::Class::create("Transform", obj, nullptr, nullptr); 
    
    cls->defineProperty("x", _SE(js_dragonBones_Transform_x_get), _SE(js_dragonBones_Transform_x_set)); 
    cls->defineProperty("y", _SE(js_dragonBones_Transform_y_get), _SE(js_dragonBones_Transform_y_set)); 
    cls->defineProperty("skew", _SE(js_dragonBones_Transform_skew_get), _SE(js_dragonBones_Transform_skew_set)); 
    cls->defineProperty("rotation", _SE(js_dragonBones_Transform_rotation_get), _SE(js_dragonBones_Transform_rotation_set)); 
    cls->defineProperty("scaleX", _SE(js_dragonBones_Transform_scaleX_get), _SE(js_dragonBones_Transform_scaleX_set)); 
    cls->defineProperty("scaleY", _SE(js_dragonBones_Transform_scaleY_get), _SE(js_dragonBones_Transform_scaleY_set)); 
    
    
    cls->defineStaticProperty("PI", _SE(js_dragonBones_Transform_PI_get), nullptr); 
    cls->defineStaticProperty("PI_D", _SE(js_dragonBones_Transform_PI_D_get), nullptr); 
    cls->defineStaticProperty("PI_H", _SE(js_dragonBones_Transform_PI_H_get), nullptr); 
    cls->defineStaticProperty("PI_Q", _SE(js_dragonBones_Transform_PI_Q_get), nullptr); 
    cls->defineStaticProperty("DEG_RAD", _SE(js_dragonBones_Transform_DEG_RAD_get), nullptr); 
    cls->defineStaticProperty("RAD_DEG", _SE(js_dragonBones_Transform_RAD_DEG_get), nullptr); 
    
    cls->defineStaticFunction("normalizeRadian", _SE(js_dragonBones_Transform_normalizeRadian_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_Transform));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::Transform>(cls);
    
    __jsb_dragonBones_Transform_proto = cls->getProto();
    __jsb_dragonBones_Transform_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_Matrix_class = nullptr;
se::Object* __jsb_dragonBones_Matrix_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_Matrix) 

static bool js_dragonBones_Matrix_a_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Matrix *arg1 = (dragonBones::Matrix *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Matrix>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->a, nullptr);
    SE_PRECONDITION2(ok, false, "Matrix_a_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Matrix_a_set) 

static bool js_dragonBones_Matrix_a_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Matrix *arg1 = (dragonBones::Matrix *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Matrix>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->a, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Matrix_a_get) 

static bool js_dragonBones_Matrix_b_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Matrix *arg1 = (dragonBones::Matrix *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Matrix>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->b, nullptr);
    SE_PRECONDITION2(ok, false, "Matrix_b_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Matrix_b_set) 

static bool js_dragonBones_Matrix_b_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Matrix *arg1 = (dragonBones::Matrix *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Matrix>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->b, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Matrix_b_get) 

static bool js_dragonBones_Matrix_c_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Matrix *arg1 = (dragonBones::Matrix *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Matrix>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->c, nullptr);
    SE_PRECONDITION2(ok, false, "Matrix_c_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Matrix_c_set) 

static bool js_dragonBones_Matrix_c_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Matrix *arg1 = (dragonBones::Matrix *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Matrix>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->c, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Matrix_c_get) 

static bool js_dragonBones_Matrix_d_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Matrix *arg1 = (dragonBones::Matrix *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Matrix>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->d, nullptr);
    SE_PRECONDITION2(ok, false, "Matrix_d_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Matrix_d_set) 

static bool js_dragonBones_Matrix_d_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Matrix *arg1 = (dragonBones::Matrix *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Matrix>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->d, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Matrix_d_get) 

static bool js_dragonBones_Matrix_tx_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Matrix *arg1 = (dragonBones::Matrix *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Matrix>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->tx, nullptr);
    SE_PRECONDITION2(ok, false, "Matrix_tx_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Matrix_tx_set) 

static bool js_dragonBones_Matrix_tx_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Matrix *arg1 = (dragonBones::Matrix *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Matrix>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->tx, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Matrix_tx_get) 

static bool js_dragonBones_Matrix_ty_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Matrix *arg1 = (dragonBones::Matrix *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Matrix>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->ty, nullptr);
    SE_PRECONDITION2(ok, false, "Matrix_ty_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Matrix_ty_set) 

static bool js_dragonBones_Matrix_ty_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Matrix *arg1 = (dragonBones::Matrix *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Matrix>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->ty, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Matrix_ty_get) 

static bool js_delete_dragonBones_Matrix(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_Matrix) 

bool js_register_dragonBones_Matrix(se::Object* obj) {
    auto* cls = se::Class::create("Matrix", obj, nullptr, nullptr); 
    
    cls->defineProperty("a", _SE(js_dragonBones_Matrix_a_get), _SE(js_dragonBones_Matrix_a_set)); 
    cls->defineProperty("b", _SE(js_dragonBones_Matrix_b_get), _SE(js_dragonBones_Matrix_b_set)); 
    cls->defineProperty("c", _SE(js_dragonBones_Matrix_c_get), _SE(js_dragonBones_Matrix_c_set)); 
    cls->defineProperty("d", _SE(js_dragonBones_Matrix_d_get), _SE(js_dragonBones_Matrix_d_set)); 
    cls->defineProperty("tx", _SE(js_dragonBones_Matrix_tx_get), _SE(js_dragonBones_Matrix_tx_set)); 
    cls->defineProperty("ty", _SE(js_dragonBones_Matrix_ty_get), _SE(js_dragonBones_Matrix_ty_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_Matrix));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::Matrix>(cls);
    
    __jsb_dragonBones_Matrix_proto = cls->getProto();
    __jsb_dragonBones_Matrix_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_BaseObject_class = nullptr;
se::Object* __jsb_dragonBones_BaseObject_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_BaseObject) 

static bool js_dragonBones_BaseObject_setMaxCount_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    std::size_t arg1 ;
    unsigned int arg2 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseObject_setMaxCount,1,SWIGTYPE_std__size_t"); 
    
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "BaseObject_setMaxCount,2,SWIGTYPE_unsigned_int");
    
    dragonBones::BaseObject::setMaxCount(arg1,arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_BaseObject_setMaxCount_static) 

static bool js_dragonBones_BaseObject_clearPool_static__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    std::size_t arg1 ;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseObject_clearPool,1,SWIGTYPE_std__size_t"); 
    
    dragonBones::BaseObject::clearPool(arg1);
    
    
    return true;
}

static bool js_dragonBones_BaseObject_clearPool_static__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    
    dragonBones::BaseObject::clearPool();
    
    
    return true;
}

static bool js_dragonBones_BaseObject_clearPool_static(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_dragonBones_BaseObject_clearPool_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 0) {
        ok = js_dragonBones_BaseObject_clearPool_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_BaseObject_clearPool_static) 

static bool js_dragonBones_BaseObject_hashCode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BaseObject *arg1 = (dragonBones::BaseObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->hashCode, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BaseObject_hashCode_get) 

static bool js_delete_dragonBones_BaseObject(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_BaseObject) 

static bool js_dragonBones_BaseObject_returnToPool(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BaseObject *arg1 = (dragonBones::BaseObject *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::BaseObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->returnToPool();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_BaseObject_returnToPool) 

bool js_register_dragonBones_BaseObject(se::Object* obj) {
    auto* cls = se::Class::create("BaseObject", obj, nullptr, nullptr); 
    
    cls->defineProperty("hashCode", _SE(js_dragonBones_BaseObject_hashCode_get), nullptr); 
    
    cls->defineFunction("returnToPool", _SE(js_dragonBones_BaseObject_returnToPool)); 
    
    
    cls->defineStaticFunction("setMaxCount", _SE(js_dragonBones_BaseObject_setMaxCount_static)); 
    cls->defineStaticFunction("clearPool", _SE(js_dragonBones_BaseObject_clearPool_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_BaseObject));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::BaseObject>(cls);
    
    __jsb_dragonBones_BaseObject_proto = cls->getProto();
    __jsb_dragonBones_BaseObject_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_EventObject_class = nullptr;
se::Object* __jsb_dragonBones_EventObject_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_EventObject) 

static bool js_delete_dragonBones_EventObject(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_EventObject) 

static bool js_dragonBones_EventObject_START_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    char *arg1 = (char *) NULL ;
    ccstd::string temp1 ;
    
    
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "EventObject_START_set,1,SWIGTYPE_p_char");
    arg1 = (char *) temp1.c_str(); 
    {
        if (arg1) {
            dragonBones::EventObject::START = (char const *) (new char[strlen((const char *)arg1)+1]);
            strcpy((char *)dragonBones::EventObject::START, (const char *)arg1);
        } else {
            dragonBones::EventObject::START = 0;
        }
    }
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_EventObject_START_set) 

static bool js_dragonBones_EventObject_START_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    char *result = 0 ;
    
    result = (char *)dragonBones::EventObject::START;
    // out 6
    ok &= nativevalue_to_se(result, s.rval(), nullptr /*ctx*/);
    SE_PRECONDITION2(ok, false, "EventObject_START_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_EventObject_START_get) 

static bool js_dragonBones_EventObject_LOOP_COMPLETE_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    char *arg1 = (char *) NULL ;
    ccstd::string temp1 ;
    
    
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "EventObject_LOOP_COMPLETE_set,1,SWIGTYPE_p_char");
    arg1 = (char *) temp1.c_str(); 
    {
        if (arg1) {
            dragonBones::EventObject::LOOP_COMPLETE = (char const *) (new char[strlen((const char *)arg1)+1]);
            strcpy((char *)dragonBones::EventObject::LOOP_COMPLETE, (const char *)arg1);
        } else {
            dragonBones::EventObject::LOOP_COMPLETE = 0;
        }
    }
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_EventObject_LOOP_COMPLETE_set) 

static bool js_dragonBones_EventObject_LOOP_COMPLETE_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    char *result = 0 ;
    
    result = (char *)dragonBones::EventObject::LOOP_COMPLETE;
    // out 6
    ok &= nativevalue_to_se(result, s.rval(), nullptr /*ctx*/);
    SE_PRECONDITION2(ok, false, "EventObject_LOOP_COMPLETE_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_EventObject_LOOP_COMPLETE_get) 

static bool js_dragonBones_EventObject_COMPLETE_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    char *arg1 = (char *) NULL ;
    ccstd::string temp1 ;
    
    
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "EventObject_COMPLETE_set,1,SWIGTYPE_p_char");
    arg1 = (char *) temp1.c_str(); 
    {
        if (arg1) {
            dragonBones::EventObject::COMPLETE = (char const *) (new char[strlen((const char *)arg1)+1]);
            strcpy((char *)dragonBones::EventObject::COMPLETE, (const char *)arg1);
        } else {
            dragonBones::EventObject::COMPLETE = 0;
        }
    }
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_EventObject_COMPLETE_set) 

static bool js_dragonBones_EventObject_COMPLETE_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    char *result = 0 ;
    
    result = (char *)dragonBones::EventObject::COMPLETE;
    // out 6
    ok &= nativevalue_to_se(result, s.rval(), nullptr /*ctx*/);
    SE_PRECONDITION2(ok, false, "EventObject_COMPLETE_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_EventObject_COMPLETE_get) 

static bool js_dragonBones_EventObject_FADE_IN_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    char *arg1 = (char *) NULL ;
    ccstd::string temp1 ;
    
    
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "EventObject_FADE_IN_set,1,SWIGTYPE_p_char");
    arg1 = (char *) temp1.c_str(); 
    {
        if (arg1) {
            dragonBones::EventObject::FADE_IN = (char const *) (new char[strlen((const char *)arg1)+1]);
            strcpy((char *)dragonBones::EventObject::FADE_IN, (const char *)arg1);
        } else {
            dragonBones::EventObject::FADE_IN = 0;
        }
    }
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_EventObject_FADE_IN_set) 

static bool js_dragonBones_EventObject_FADE_IN_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    char *result = 0 ;
    
    result = (char *)dragonBones::EventObject::FADE_IN;
    // out 6
    ok &= nativevalue_to_se(result, s.rval(), nullptr /*ctx*/);
    SE_PRECONDITION2(ok, false, "EventObject_FADE_IN_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_EventObject_FADE_IN_get) 

static bool js_dragonBones_EventObject_FADE_IN_COMPLETE_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    char *arg1 = (char *) NULL ;
    ccstd::string temp1 ;
    
    
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "EventObject_FADE_IN_COMPLETE_set,1,SWIGTYPE_p_char");
    arg1 = (char *) temp1.c_str(); 
    {
        if (arg1) {
            dragonBones::EventObject::FADE_IN_COMPLETE = (char const *) (new char[strlen((const char *)arg1)+1]);
            strcpy((char *)dragonBones::EventObject::FADE_IN_COMPLETE, (const char *)arg1);
        } else {
            dragonBones::EventObject::FADE_IN_COMPLETE = 0;
        }
    }
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_EventObject_FADE_IN_COMPLETE_set) 

static bool js_dragonBones_EventObject_FADE_IN_COMPLETE_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    char *result = 0 ;
    
    result = (char *)dragonBones::EventObject::FADE_IN_COMPLETE;
    // out 6
    ok &= nativevalue_to_se(result, s.rval(), nullptr /*ctx*/);
    SE_PRECONDITION2(ok, false, "EventObject_FADE_IN_COMPLETE_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_EventObject_FADE_IN_COMPLETE_get) 

static bool js_dragonBones_EventObject_FADE_OUT_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    char *arg1 = (char *) NULL ;
    ccstd::string temp1 ;
    
    
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "EventObject_FADE_OUT_set,1,SWIGTYPE_p_char");
    arg1 = (char *) temp1.c_str(); 
    {
        if (arg1) {
            dragonBones::EventObject::FADE_OUT = (char const *) (new char[strlen((const char *)arg1)+1]);
            strcpy((char *)dragonBones::EventObject::FADE_OUT, (const char *)arg1);
        } else {
            dragonBones::EventObject::FADE_OUT = 0;
        }
    }
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_EventObject_FADE_OUT_set) 

static bool js_dragonBones_EventObject_FADE_OUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    char *result = 0 ;
    
    result = (char *)dragonBones::EventObject::FADE_OUT;
    // out 6
    ok &= nativevalue_to_se(result, s.rval(), nullptr /*ctx*/);
    SE_PRECONDITION2(ok, false, "EventObject_FADE_OUT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_EventObject_FADE_OUT_get) 

static bool js_dragonBones_EventObject_FADE_OUT_COMPLETE_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    char *arg1 = (char *) NULL ;
    ccstd::string temp1 ;
    
    
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "EventObject_FADE_OUT_COMPLETE_set,1,SWIGTYPE_p_char");
    arg1 = (char *) temp1.c_str(); 
    {
        if (arg1) {
            dragonBones::EventObject::FADE_OUT_COMPLETE = (char const *) (new char[strlen((const char *)arg1)+1]);
            strcpy((char *)dragonBones::EventObject::FADE_OUT_COMPLETE, (const char *)arg1);
        } else {
            dragonBones::EventObject::FADE_OUT_COMPLETE = 0;
        }
    }
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_EventObject_FADE_OUT_COMPLETE_set) 

static bool js_dragonBones_EventObject_FADE_OUT_COMPLETE_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    char *result = 0 ;
    
    result = (char *)dragonBones::EventObject::FADE_OUT_COMPLETE;
    // out 6
    ok &= nativevalue_to_se(result, s.rval(), nullptr /*ctx*/);
    SE_PRECONDITION2(ok, false, "EventObject_FADE_OUT_COMPLETE_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_EventObject_FADE_OUT_COMPLETE_get) 

static bool js_dragonBones_EventObject_FRAME_EVENT_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    char *arg1 = (char *) NULL ;
    ccstd::string temp1 ;
    
    
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "EventObject_FRAME_EVENT_set,1,SWIGTYPE_p_char");
    arg1 = (char *) temp1.c_str(); 
    {
        if (arg1) {
            dragonBones::EventObject::FRAME_EVENT = (char const *) (new char[strlen((const char *)arg1)+1]);
            strcpy((char *)dragonBones::EventObject::FRAME_EVENT, (const char *)arg1);
        } else {
            dragonBones::EventObject::FRAME_EVENT = 0;
        }
    }
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_EventObject_FRAME_EVENT_set) 

static bool js_dragonBones_EventObject_FRAME_EVENT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    char *result = 0 ;
    
    result = (char *)dragonBones::EventObject::FRAME_EVENT;
    // out 6
    ok &= nativevalue_to_se(result, s.rval(), nullptr /*ctx*/);
    SE_PRECONDITION2(ok, false, "EventObject_FRAME_EVENT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_EventObject_FRAME_EVENT_get) 

static bool js_dragonBones_EventObject_SOUND_EVENT_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    char *arg1 = (char *) NULL ;
    ccstd::string temp1 ;
    
    
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "EventObject_SOUND_EVENT_set,1,SWIGTYPE_p_char");
    arg1 = (char *) temp1.c_str(); 
    {
        if (arg1) {
            dragonBones::EventObject::SOUND_EVENT = (char const *) (new char[strlen((const char *)arg1)+1]);
            strcpy((char *)dragonBones::EventObject::SOUND_EVENT, (const char *)arg1);
        } else {
            dragonBones::EventObject::SOUND_EVENT = 0;
        }
    }
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_EventObject_SOUND_EVENT_set) 

static bool js_dragonBones_EventObject_SOUND_EVENT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    char *result = 0 ;
    
    result = (char *)dragonBones::EventObject::SOUND_EVENT;
    // out 6
    ok &= nativevalue_to_se(result, s.rval(), nullptr /*ctx*/);
    SE_PRECONDITION2(ok, false, "EventObject_SOUND_EVENT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_EventObject_SOUND_EVENT_get) 

static bool js_dragonBones_EventObject_time_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->time, nullptr);
    SE_PRECONDITION2(ok, false, "EventObject_time_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_EventObject_time_set) 

static bool js_dragonBones_EventObject_time_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->time, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_EventObject_time_get) 

static bool js_dragonBones_EventObject_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->type, s.thisObject());
    SE_PRECONDITION2(ok, false, "EventObject_type_set,2,SWIGTYPE_std__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_EventObject_type_set) 

static bool js_dragonBones_EventObject_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->type, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "EventObject_type_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->type, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_EventObject_type_get) 

static bool js_dragonBones_EventObject_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "EventObject_name_set,2,SWIGTYPE_std__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_EventObject_name_set) 

static bool js_dragonBones_EventObject_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "EventObject_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_EventObject_name_get) 

static bool js_dragonBones_EventObject_armature_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->armature, s.thisObject());
    SE_PRECONDITION2(ok, false, "EventObject_armature_set,2,SWIGTYPE_p_dragonBones__Armature"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_EventObject_armature_set) 

static bool js_dragonBones_EventObject_armature_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->armature, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "EventObject_armature_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->armature, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_EventObject_armature_get) 

static bool js_dragonBones_EventObject_bone_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->bone, s.thisObject());
    SE_PRECONDITION2(ok, false, "EventObject_bone_set,2,SWIGTYPE_p_dragonBones__Bone"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_EventObject_bone_set) 

static bool js_dragonBones_EventObject_bone_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->bone, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "EventObject_bone_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->bone, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_EventObject_bone_get) 

static bool js_dragonBones_EventObject_slot_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->slot, s.thisObject());
    SE_PRECONDITION2(ok, false, "EventObject_slot_set,2,SWIGTYPE_p_dragonBones__Slot"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_EventObject_slot_set) 

static bool js_dragonBones_EventObject_slot_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->slot, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "EventObject_slot_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->slot, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_EventObject_slot_get) 

static bool js_dragonBones_EventObject_animationState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->animationState, s.thisObject());
    SE_PRECONDITION2(ok, false, "EventObject_animationState_set,2,SWIGTYPE_p_dragonBones__AnimationState"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_EventObject_animationState_set) 

static bool js_dragonBones_EventObject_animationState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->animationState, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "EventObject_animationState_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->animationState, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_EventObject_animationState_get) 

static bool js_dragonBones_EventObject_getArmature(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    dragonBones::Armature *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::Armature *)((dragonBones::EventObject const *)arg1)->getArmature();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "EventObject_getArmature, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_EventObject_getArmature) 

static bool js_dragonBones_EventObject_getBone(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    dragonBones::Bone *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::Bone *)((dragonBones::EventObject const *)arg1)->getBone();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "EventObject_getBone, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_EventObject_getBone) 

static bool js_dragonBones_EventObject_getSlot(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    dragonBones::Slot *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::Slot *)((dragonBones::EventObject const *)arg1)->getSlot();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "EventObject_getSlot, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_EventObject_getSlot) 

static bool js_dragonBones_EventObject_getAnimationState(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    dragonBones::AnimationState *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::AnimationState *)((dragonBones::EventObject const *)arg1)->getAnimationState();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "EventObject_getAnimationState, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_EventObject_getAnimationState) 

bool js_register_dragonBones_EventObject(se::Object* obj) {
    auto* cls = se::Class::create("EventObject", obj, __jsb_dragonBones_BaseObject_proto, nullptr); 
    
    cls->defineProperty("time", _SE(js_dragonBones_EventObject_time_get), _SE(js_dragonBones_EventObject_time_set)); 
    cls->defineProperty("type", _SE(js_dragonBones_EventObject_type_get), _SE(js_dragonBones_EventObject_type_set)); 
    cls->defineProperty("name", _SE(js_dragonBones_EventObject_name_get), _SE(js_dragonBones_EventObject_name_set)); 
    cls->defineProperty("armature", _SE(js_dragonBones_EventObject_armature_get), _SE(js_dragonBones_EventObject_armature_set)); 
    cls->defineProperty("bone", _SE(js_dragonBones_EventObject_bone_get), _SE(js_dragonBones_EventObject_bone_set)); 
    cls->defineProperty("slot", _SE(js_dragonBones_EventObject_slot_get), _SE(js_dragonBones_EventObject_slot_set)); 
    cls->defineProperty("animationState", _SE(js_dragonBones_EventObject_animationState_get), _SE(js_dragonBones_EventObject_animationState_set)); 
    
    cls->defineFunction("getArmature", _SE(js_dragonBones_EventObject_getArmature)); 
    cls->defineFunction("getBone", _SE(js_dragonBones_EventObject_getBone)); 
    cls->defineFunction("getSlot", _SE(js_dragonBones_EventObject_getSlot)); 
    cls->defineFunction("getAnimationState", _SE(js_dragonBones_EventObject_getAnimationState)); 
    
    cls->defineStaticProperty("START", _SE(js_dragonBones_EventObject_START_get), _SE(js_dragonBones_EventObject_START_set)); 
    cls->defineStaticProperty("LOOP_COMPLETE", _SE(js_dragonBones_EventObject_LOOP_COMPLETE_get), _SE(js_dragonBones_EventObject_LOOP_COMPLETE_set)); 
    cls->defineStaticProperty("COMPLETE", _SE(js_dragonBones_EventObject_COMPLETE_get), _SE(js_dragonBones_EventObject_COMPLETE_set)); 
    cls->defineStaticProperty("FADE_IN", _SE(js_dragonBones_EventObject_FADE_IN_get), _SE(js_dragonBones_EventObject_FADE_IN_set)); 
    cls->defineStaticProperty("FADE_IN_COMPLETE", _SE(js_dragonBones_EventObject_FADE_IN_COMPLETE_get), _SE(js_dragonBones_EventObject_FADE_IN_COMPLETE_set)); 
    cls->defineStaticProperty("FADE_OUT", _SE(js_dragonBones_EventObject_FADE_OUT_get), _SE(js_dragonBones_EventObject_FADE_OUT_set)); 
    cls->defineStaticProperty("FADE_OUT_COMPLETE", _SE(js_dragonBones_EventObject_FADE_OUT_COMPLETE_get), _SE(js_dragonBones_EventObject_FADE_OUT_COMPLETE_set)); 
    cls->defineStaticProperty("FRAME_EVENT", _SE(js_dragonBones_EventObject_FRAME_EVENT_get), _SE(js_dragonBones_EventObject_FRAME_EVENT_set)); 
    cls->defineStaticProperty("SOUND_EVENT", _SE(js_dragonBones_EventObject_SOUND_EVENT_get), _SE(js_dragonBones_EventObject_SOUND_EVENT_set)); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_EventObject));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::EventObject>(cls);
    
    __jsb_dragonBones_EventObject_proto = cls->getProto();
    __jsb_dragonBones_EventObject_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_BaseFactory_class = nullptr;
se::Object* __jsb_dragonBones_BaseFactory_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_BaseFactory) 

static bool js_dragonBones_BaseFactory_autoSearch_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->autoSearch);
    SE_PRECONDITION2(ok, false, "BaseFactory_autoSearch_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BaseFactory_autoSearch_set) 

static bool js_dragonBones_BaseFactory_autoSearch_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->autoSearch, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BaseFactory_autoSearch_get) 

static bool js_delete_dragonBones_BaseFactory(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_BaseFactory) 

static bool js_dragonBones_BaseFactory_parseDragonBonesData__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    char *arg2 = (char *) NULL ;
    std::string *arg3 = 0 ;
    float arg4 ;
    ccstd::string temp2 ;
    std::string temp3 ;
    dragonBones::DragonBonesData *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "BaseFactory_parseDragonBonesData,2,SWIGTYPE_p_char");
    arg2 = (char *) temp2.c_str(); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_parseDragonBonesData,3,SWIGTYPE_p_std__string");
    arg3 = &temp3;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "BaseFactory_parseDragonBonesData,4,SWIGTYPE_float"); 
    result = (dragonBones::DragonBonesData *)(arg1)->parseDragonBonesData((char const *)arg2,(std::string const &)*arg3,arg4);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BaseFactory_parseDragonBonesData, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_parseDragonBonesData__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    char *arg2 = (char *) NULL ;
    std::string *arg3 = 0 ;
    ccstd::string temp2 ;
    std::string temp3 ;
    dragonBones::DragonBonesData *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "BaseFactory_parseDragonBonesData,2,SWIGTYPE_p_char");
    arg2 = (char *) temp2.c_str(); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_parseDragonBonesData,3,SWIGTYPE_p_std__string");
    arg3 = &temp3;
    
    result = (dragonBones::DragonBonesData *)(arg1)->parseDragonBonesData((char const *)arg2,(std::string const &)*arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BaseFactory_parseDragonBonesData, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_parseDragonBonesData__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    char *arg2 = (char *) NULL ;
    ccstd::string temp2 ;
    dragonBones::DragonBonesData *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "BaseFactory_parseDragonBonesData,2,SWIGTYPE_p_char");
    arg2 = (char *) temp2.c_str(); 
    result = (dragonBones::DragonBonesData *)(arg1)->parseDragonBonesData((char const *)arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BaseFactory_parseDragonBonesData, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_parseDragonBonesData(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_dragonBones_BaseFactory_parseDragonBonesData__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_dragonBones_BaseFactory_parseDragonBonesData__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_dragonBones_BaseFactory_parseDragonBonesData__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_parseDragonBonesData) 

static bool js_dragonBones_BaseFactory_getDragonBonesData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::DragonBonesData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_getDragonBonesData,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (dragonBones::DragonBonesData *)((dragonBones::BaseFactory const *)arg1)->getDragonBonesData((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BaseFactory_getDragonBonesData, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_getDragonBonesData) 

static bool js_dragonBones_BaseFactory_addDragonBonesData__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    dragonBones::DragonBonesData *arg2 = (dragonBones::DragonBonesData *) NULL ;
    std::string *arg3 = 0 ;
    std::string temp3 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_addDragonBonesData,2,SWIGTYPE_p_dragonBones__DragonBonesData"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_addDragonBonesData,3,SWIGTYPE_p_std__string");
    arg3 = &temp3;
    
    (arg1)->addDragonBonesData(arg2,(std::string const &)*arg3);
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_addDragonBonesData__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    dragonBones::DragonBonesData *arg2 = (dragonBones::DragonBonesData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_addDragonBonesData,2,SWIGTYPE_p_dragonBones__DragonBonesData"); 
    (arg1)->addDragonBonesData(arg2);
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_addDragonBonesData(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_dragonBones_BaseFactory_addDragonBonesData__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_dragonBones_BaseFactory_addDragonBonesData__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_addDragonBonesData) 

static bool js_dragonBones_BaseFactory_removeDragonBonesData__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    std::string *arg2 = 0 ;
    bool arg3 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_removeDragonBonesData,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "BaseFactory_removeDragonBonesData,3,SWIGTYPE_bool"); 
    (arg1)->removeDragonBonesData((std::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_removeDragonBonesData__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_removeDragonBonesData,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    (arg1)->removeDragonBonesData((std::string const &)*arg2);
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_removeDragonBonesData(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_dragonBones_BaseFactory_removeDragonBonesData__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_dragonBones_BaseFactory_removeDragonBonesData__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_removeDragonBonesData) 

static bool js_dragonBones_BaseFactory_addTextureAtlasData__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    dragonBones::TextureAtlasData *arg2 = (dragonBones::TextureAtlasData *) NULL ;
    std::string *arg3 = 0 ;
    std::string temp3 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_addTextureAtlasData,2,SWIGTYPE_p_dragonBones__TextureAtlasData"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_addTextureAtlasData,3,SWIGTYPE_p_std__string");
    arg3 = &temp3;
    
    (arg1)->addTextureAtlasData(arg2,(std::string const &)*arg3);
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_addTextureAtlasData__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    dragonBones::TextureAtlasData *arg2 = (dragonBones::TextureAtlasData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_addTextureAtlasData,2,SWIGTYPE_p_dragonBones__TextureAtlasData"); 
    (arg1)->addTextureAtlasData(arg2);
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_addTextureAtlasData(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_dragonBones_BaseFactory_addTextureAtlasData__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_dragonBones_BaseFactory_addTextureAtlasData__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_addTextureAtlasData) 

static bool js_dragonBones_BaseFactory_removeTextureAtlasData__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    std::string *arg2 = 0 ;
    bool arg3 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_removeTextureAtlasData,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "BaseFactory_removeTextureAtlasData,3,SWIGTYPE_bool"); 
    (arg1)->removeTextureAtlasData((std::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_removeTextureAtlasData__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_removeTextureAtlasData,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    (arg1)->removeTextureAtlasData((std::string const &)*arg2);
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_removeTextureAtlasData(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_dragonBones_BaseFactory_removeTextureAtlasData__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_dragonBones_BaseFactory_removeTextureAtlasData__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_removeTextureAtlasData) 

static bool js_dragonBones_BaseFactory_getArmatureData__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    dragonBones::ArmatureData *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_getArmatureData,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_getArmatureData,3,SWIGTYPE_p_std__string");
    arg3 = &temp3;
    
    result = (dragonBones::ArmatureData *)((dragonBones::BaseFactory const *)arg1)->getArmatureData((std::string const &)*arg2,(std::string const &)*arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BaseFactory_getArmatureData, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_getArmatureData__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::ArmatureData *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_getArmatureData,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (dragonBones::ArmatureData *)((dragonBones::BaseFactory const *)arg1)->getArmatureData((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BaseFactory_getArmatureData, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_getArmatureData(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_dragonBones_BaseFactory_getArmatureData__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_dragonBones_BaseFactory_getArmatureData__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_getArmatureData) 

static bool js_dragonBones_BaseFactory_clear__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "BaseFactory_clear,2,SWIGTYPE_bool"); 
    (arg1)->clear(arg2);
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_clear__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->clear();
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_clear(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_dragonBones_BaseFactory_clear__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 0) {
        ok = js_dragonBones_BaseFactory_clear__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_clear) 

static bool js_dragonBones_BaseFactory_buildArmature__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string *arg4 = 0 ;
    std::string *arg5 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    std::string temp4 ;
    std::string temp5 ;
    dragonBones::Armature *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_buildArmature,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_buildArmature,3,SWIGTYPE_p_std__string");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_buildArmature,4,SWIGTYPE_p_std__string");
    arg4 = &temp4;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_buildArmature,5,SWIGTYPE_p_std__string");
    arg5 = &temp5;
    
    result = (dragonBones::Armature *)((dragonBones::BaseFactory const *)arg1)->buildArmature((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BaseFactory_buildArmature, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_buildArmature__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string *arg4 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    std::string temp4 ;
    dragonBones::Armature *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_buildArmature,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_buildArmature,3,SWIGTYPE_p_std__string");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_buildArmature,4,SWIGTYPE_p_std__string");
    arg4 = &temp4;
    
    result = (dragonBones::Armature *)((dragonBones::BaseFactory const *)arg1)->buildArmature((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BaseFactory_buildArmature, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_buildArmature__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    dragonBones::Armature *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_buildArmature,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_buildArmature,3,SWIGTYPE_p_std__string");
    arg3 = &temp3;
    
    result = (dragonBones::Armature *)((dragonBones::BaseFactory const *)arg1)->buildArmature((std::string const &)*arg2,(std::string const &)*arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BaseFactory_buildArmature, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_buildArmature__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::Armature *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_buildArmature,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (dragonBones::Armature *)((dragonBones::BaseFactory const *)arg1)->buildArmature((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BaseFactory_buildArmature, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_buildArmature(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 4) {
        ok = js_dragonBones_BaseFactory_buildArmature__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_dragonBones_BaseFactory_buildArmature__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_dragonBones_BaseFactory_buildArmature__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_dragonBones_BaseFactory_buildArmature__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_buildArmature) 

static bool js_dragonBones_BaseFactory_replaceSlotDisplay__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string *arg4 = 0 ;
    std::string *arg5 = 0 ;
    dragonBones::Slot *arg6 = (dragonBones::Slot *) NULL ;
    int arg7 ;
    std::string temp2 ;
    std::string temp3 ;
    std::string temp4 ;
    std::string temp5 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_replaceSlotDisplay,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_replaceSlotDisplay,3,SWIGTYPE_p_std__string");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_replaceSlotDisplay,4,SWIGTYPE_p_std__string");
    arg4 = &temp4;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_replaceSlotDisplay,5,SWIGTYPE_p_std__string");
    arg5 = &temp5;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_replaceSlotDisplay,6,SWIGTYPE_p_dragonBones__Slot"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg7, nullptr);
    SE_PRECONDITION2(ok, false, "BaseFactory_replaceSlotDisplay,7,SWIGTYPE_int"); 
    result = (bool)((dragonBones::BaseFactory const *)arg1)->replaceSlotDisplay((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5,arg6,arg7);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_replaceSlotDisplay__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string *arg4 = 0 ;
    std::string *arg5 = 0 ;
    dragonBones::Slot *arg6 = (dragonBones::Slot *) NULL ;
    std::string temp2 ;
    std::string temp3 ;
    std::string temp4 ;
    std::string temp5 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_replaceSlotDisplay,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_replaceSlotDisplay,3,SWIGTYPE_p_std__string");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_replaceSlotDisplay,4,SWIGTYPE_p_std__string");
    arg4 = &temp4;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_replaceSlotDisplay,5,SWIGTYPE_p_std__string");
    arg5 = &temp5;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_replaceSlotDisplay,6,SWIGTYPE_p_dragonBones__Slot"); 
    result = (bool)((dragonBones::BaseFactory const *)arg1)->replaceSlotDisplay((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5,arg6);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_replaceSlotDisplay(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 6) {
        ok = js_dragonBones_BaseFactory_replaceSlotDisplay__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_dragonBones_BaseFactory_replaceSlotDisplay__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_replaceSlotDisplay) 

static bool js_dragonBones_BaseFactory_replaceSkin(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    dragonBones::Armature *arg2 = (dragonBones::Armature *) NULL ;
    dragonBones::SkinData *arg3 = (dragonBones::SkinData *) NULL ;
    bool arg4 ;
    std::vector< std::string > *arg5 = 0 ;
    std::vector< std::string > temp5 ;
    bool result;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_replaceSkin,2,SWIGTYPE_p_dragonBones__Armature"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_replaceSkin,3,SWIGTYPE_p_dragonBones__SkinData"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "BaseFactory_replaceSkin,4,SWIGTYPE_bool"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_replaceSkin,5,SWIGTYPE_p_std__vectorT_std__string_t");
    arg5 = &temp5;
    
    result = (bool)((dragonBones::BaseFactory const *)arg1)->replaceSkin(arg2,arg3,arg4,(std::vector< std::string > const &)*arg5);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_replaceSkin) 

static bool js_dragonBones_BaseFactory_replaceAnimation__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    dragonBones::Armature *arg2 = (dragonBones::Armature *) NULL ;
    dragonBones::ArmatureData *arg3 = (dragonBones::ArmatureData *) NULL ;
    bool arg4 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_replaceAnimation,2,SWIGTYPE_p_dragonBones__Armature"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_replaceAnimation,3,SWIGTYPE_p_dragonBones__ArmatureData"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "BaseFactory_replaceAnimation,4,SWIGTYPE_bool"); 
    result = (bool)((dragonBones::BaseFactory const *)arg1)->replaceAnimation(arg2,arg3,arg4);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_replaceAnimation__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    dragonBones::Armature *arg2 = (dragonBones::Armature *) NULL ;
    dragonBones::ArmatureData *arg3 = (dragonBones::ArmatureData *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_replaceAnimation,2,SWIGTYPE_p_dragonBones__Armature"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_replaceAnimation,3,SWIGTYPE_p_dragonBones__ArmatureData"); 
    result = (bool)((dragonBones::BaseFactory const *)arg1)->replaceAnimation(arg2,arg3);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_replaceAnimation(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_dragonBones_BaseFactory_replaceAnimation__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_dragonBones_BaseFactory_replaceAnimation__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_replaceAnimation) 

static bool js_dragonBones_BaseFactory_getClock(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    dragonBones::WorldClock *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::WorldClock *)((dragonBones::BaseFactory const *)arg1)->getClock();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BaseFactory_getClock, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_getClock) 

static bool js_dragonBones_BaseFactory_changeSkin(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    dragonBones::Armature *arg2 = (dragonBones::Armature *) NULL ;
    dragonBones::SkinData *arg3 = (dragonBones::SkinData *) NULL ;
    std::vector< std::string > *arg4 = 0 ;
    std::vector< std::string > temp4 ;
    bool result;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_changeSkin,2,SWIGTYPE_p_dragonBones__Armature"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_changeSkin,3,SWIGTYPE_p_dragonBones__SkinData"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "BaseFactory_changeSkin,4,SWIGTYPE_p_std__vectorT_std__string_t");
    arg4 = &temp4;
    
    result = (bool)((dragonBones::BaseFactory const *)arg1)->changeSkin(arg2,arg3,(std::vector< std::string > const &)*arg4);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_changeSkin) 

bool js_register_dragonBones_BaseFactory(se::Object* obj) {
    auto* cls = se::Class::create("BaseFactory", obj, nullptr, nullptr); 
    
    cls->defineProperty("autoSearch", _SE(js_dragonBones_BaseFactory_autoSearch_get), _SE(js_dragonBones_BaseFactory_autoSearch_set)); 
    
    cls->defineFunction("parseDragonBonesData", _SE(js_dragonBones_BaseFactory_parseDragonBonesData)); 
    cls->defineFunction("getDragonBonesData", _SE(js_dragonBones_BaseFactory_getDragonBonesData)); 
    cls->defineFunction("addDragonBonesData", _SE(js_dragonBones_BaseFactory_addDragonBonesData)); 
    cls->defineFunction("removeDragonBonesData", _SE(js_dragonBones_BaseFactory_removeDragonBonesData)); 
    cls->defineFunction("addTextureAtlasData", _SE(js_dragonBones_BaseFactory_addTextureAtlasData)); 
    cls->defineFunction("removeTextureAtlasData", _SE(js_dragonBones_BaseFactory_removeTextureAtlasData)); 
    cls->defineFunction("getArmatureData", _SE(js_dragonBones_BaseFactory_getArmatureData)); 
    cls->defineFunction("clear", _SE(js_dragonBones_BaseFactory_clear)); 
    cls->defineFunction("buildArmature", _SE(js_dragonBones_BaseFactory_buildArmature)); 
    cls->defineFunction("replaceSlotDisplay", _SE(js_dragonBones_BaseFactory_replaceSlotDisplay)); 
    cls->defineFunction("replaceSkin", _SE(js_dragonBones_BaseFactory_replaceSkin)); 
    cls->defineFunction("replaceAnimation", _SE(js_dragonBones_BaseFactory_replaceAnimation)); 
    cls->defineFunction("getClock", _SE(js_dragonBones_BaseFactory_getClock)); 
    cls->defineFunction("changeSkin", _SE(js_dragonBones_BaseFactory_changeSkin)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_BaseFactory));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::BaseFactory>(cls);
    
    __jsb_dragonBones_BaseFactory_proto = cls->getProto();
    __jsb_dragonBones_BaseFactory_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_BuildArmaturePackage_class = nullptr;
se::Object* __jsb_dragonBones_BuildArmaturePackage_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_BuildArmaturePackage) 

static bool js_dragonBones_BuildArmaturePackage_dataName_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BuildArmaturePackage *arg1 = (dragonBones::BuildArmaturePackage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BuildArmaturePackage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->dataName, s.thisObject());
    SE_PRECONDITION2(ok, false, "BuildArmaturePackage_dataName_set,2,SWIGTYPE_std__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BuildArmaturePackage_dataName_set) 

static bool js_dragonBones_BuildArmaturePackage_dataName_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BuildArmaturePackage *arg1 = (dragonBones::BuildArmaturePackage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BuildArmaturePackage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->dataName, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BuildArmaturePackage_dataName_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->dataName, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BuildArmaturePackage_dataName_get) 

static bool js_dragonBones_BuildArmaturePackage_textureAtlasName_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BuildArmaturePackage *arg1 = (dragonBones::BuildArmaturePackage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BuildArmaturePackage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->textureAtlasName, s.thisObject());
    SE_PRECONDITION2(ok, false, "BuildArmaturePackage_textureAtlasName_set,2,SWIGTYPE_std__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BuildArmaturePackage_textureAtlasName_set) 

static bool js_dragonBones_BuildArmaturePackage_textureAtlasName_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BuildArmaturePackage *arg1 = (dragonBones::BuildArmaturePackage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BuildArmaturePackage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->textureAtlasName, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BuildArmaturePackage_textureAtlasName_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->textureAtlasName, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BuildArmaturePackage_textureAtlasName_get) 

static bool js_dragonBones_BuildArmaturePackage_data_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BuildArmaturePackage *arg1 = (dragonBones::BuildArmaturePackage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BuildArmaturePackage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->data, s.thisObject());
    SE_PRECONDITION2(ok, false, "BuildArmaturePackage_data_set,2,SWIGTYPE_p_dragonBones__DragonBonesData"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BuildArmaturePackage_data_set) 

static bool js_dragonBones_BuildArmaturePackage_data_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BuildArmaturePackage *arg1 = (dragonBones::BuildArmaturePackage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BuildArmaturePackage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->data, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BuildArmaturePackage_data_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->data, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BuildArmaturePackage_data_get) 

static bool js_dragonBones_BuildArmaturePackage_armature_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BuildArmaturePackage *arg1 = (dragonBones::BuildArmaturePackage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BuildArmaturePackage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->armature, s.thisObject());
    SE_PRECONDITION2(ok, false, "BuildArmaturePackage_armature_set,2,SWIGTYPE_p_dragonBones__ArmatureData"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BuildArmaturePackage_armature_set) 

static bool js_dragonBones_BuildArmaturePackage_armature_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BuildArmaturePackage *arg1 = (dragonBones::BuildArmaturePackage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BuildArmaturePackage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->armature, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BuildArmaturePackage_armature_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->armature, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BuildArmaturePackage_armature_get) 

static bool js_dragonBones_BuildArmaturePackage_skin_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BuildArmaturePackage *arg1 = (dragonBones::BuildArmaturePackage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BuildArmaturePackage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->skin, s.thisObject());
    SE_PRECONDITION2(ok, false, "BuildArmaturePackage_skin_set,2,SWIGTYPE_p_dragonBones__SkinData"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BuildArmaturePackage_skin_set) 

static bool js_dragonBones_BuildArmaturePackage_skin_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BuildArmaturePackage *arg1 = (dragonBones::BuildArmaturePackage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BuildArmaturePackage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->skin, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BuildArmaturePackage_skin_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->skin, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BuildArmaturePackage_skin_get) 

// js_ctor
static bool js_new_dragonBones_BuildArmaturePackage(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    dragonBones::BuildArmaturePackage *result;
    result = (dragonBones::BuildArmaturePackage *)new dragonBones::BuildArmaturePackage();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_dragonBones_BuildArmaturePackage, __jsb_dragonBones_BuildArmaturePackage_class, js_delete_dragonBones_BuildArmaturePackage)

static bool js_delete_dragonBones_BuildArmaturePackage(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_BuildArmaturePackage) 

bool js_register_dragonBones_BuildArmaturePackage(se::Object* obj) {
    auto* cls = se::Class::create("BuildArmaturePackage", obj, nullptr, _SE(js_new_dragonBones_BuildArmaturePackage)); 
    
    cls->defineProperty("dataName", _SE(js_dragonBones_BuildArmaturePackage_dataName_get), _SE(js_dragonBones_BuildArmaturePackage_dataName_set)); 
    cls->defineProperty("textureAtlasName", _SE(js_dragonBones_BuildArmaturePackage_textureAtlasName_get), _SE(js_dragonBones_BuildArmaturePackage_textureAtlasName_set)); 
    cls->defineProperty("data", _SE(js_dragonBones_BuildArmaturePackage_data_get), _SE(js_dragonBones_BuildArmaturePackage_data_set)); 
    cls->defineProperty("armature", _SE(js_dragonBones_BuildArmaturePackage_armature_get), _SE(js_dragonBones_BuildArmaturePackage_armature_set)); 
    cls->defineProperty("skin", _SE(js_dragonBones_BuildArmaturePackage_skin_get), _SE(js_dragonBones_BuildArmaturePackage_skin_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_BuildArmaturePackage));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::BuildArmaturePackage>(cls);
    
    __jsb_dragonBones_BuildArmaturePackage_proto = cls->getProto();
    __jsb_dragonBones_BuildArmaturePackage_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_DragonBonesData_class = nullptr;
se::Object* __jsb_dragonBones_DragonBonesData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_DragonBonesData) 

static bool js_dragonBones_DragonBonesData_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::DragonBonesData *arg1 = (dragonBones::DragonBonesData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::DragonBonesData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "DragonBonesData_name_set,2,SWIGTYPE_std__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_DragonBonesData_name_set) 

static bool js_dragonBones_DragonBonesData_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::DragonBonesData *arg1 = (dragonBones::DragonBonesData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::DragonBonesData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DragonBonesData_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_DragonBonesData_name_get) 

static bool js_delete_dragonBones_DragonBonesData(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_DragonBonesData) 

static bool js_dragonBones_DragonBonesData_addArmature(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::DragonBonesData *arg1 = (dragonBones::DragonBonesData *) NULL ;
    dragonBones::ArmatureData *arg2 = (dragonBones::ArmatureData *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::DragonBonesData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DragonBonesData_addArmature,2,SWIGTYPE_p_dragonBones__ArmatureData"); 
    (arg1)->addArmature(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_DragonBonesData_addArmature) 

static bool js_dragonBones_DragonBonesData_getArmature(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::DragonBonesData *arg1 = (dragonBones::DragonBonesData *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::ArmatureData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::DragonBonesData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DragonBonesData_getArmature,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (dragonBones::ArmatureData *)((dragonBones::DragonBonesData const *)arg1)->getArmature((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DragonBonesData_getArmature, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_DragonBonesData_getArmature) 

static bool js_dragonBones_DragonBonesData_getFrameIndices(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::DragonBonesData *arg1 = (dragonBones::DragonBonesData *) NULL ;
    std::vector< unsigned int > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::DragonBonesData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (std::vector< unsigned int > *)(arg1)->getFrameIndices();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DragonBonesData_getFrameIndices, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_DragonBonesData_getFrameIndices) 

static bool js_dragonBones_DragonBonesData_getArmatureNames(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::DragonBonesData *arg1 = (dragonBones::DragonBonesData *) NULL ;
    std::vector< std::string > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::DragonBonesData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (std::vector< std::string > *) &((dragonBones::DragonBonesData const *)arg1)->getArmatureNames();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DragonBonesData_getArmatureNames, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_DragonBonesData_getArmatureNames) 

bool js_register_dragonBones_DragonBonesData(se::Object* obj) {
    auto* cls = se::Class::create("DragonBonesData", obj, __jsb_dragonBones_BaseObject_proto, nullptr); 
    
    cls->defineProperty("name", _SE(js_dragonBones_DragonBonesData_name_get), _SE(js_dragonBones_DragonBonesData_name_set)); 
    
    cls->defineFunction("addArmature", _SE(js_dragonBones_DragonBonesData_addArmature)); 
    cls->defineFunction("getArmature", _SE(js_dragonBones_DragonBonesData_getArmature)); 
    cls->defineFunction("getFrameIndices", _SE(js_dragonBones_DragonBonesData_getFrameIndices)); 
    cls->defineFunction("getArmatureNames", _SE(js_dragonBones_DragonBonesData_getArmatureNames)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_DragonBonesData));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::DragonBonesData>(cls);
    
    __jsb_dragonBones_DragonBonesData_proto = cls->getProto();
    __jsb_dragonBones_DragonBonesData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_TextureAtlasData_class = nullptr;
se::Object* __jsb_dragonBones_TextureAtlasData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_TextureAtlasData) 

static bool js_delete_dragonBones_TextureAtlasData(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_TextureAtlasData) 

static bool js_dragonBones_TextureAtlasData_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TextureAtlasData *arg1 = (dragonBones::TextureAtlasData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TextureAtlasData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureAtlasData_name_set,2,SWIGTYPE_std__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_TextureAtlasData_name_set) 

static bool js_dragonBones_TextureAtlasData_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::TextureAtlasData *arg1 = (dragonBones::TextureAtlasData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TextureAtlasData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureAtlasData_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_TextureAtlasData_name_get) 

static bool js_dragonBones_TextureAtlasData_createTexture(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TextureAtlasData *arg1 = (dragonBones::TextureAtlasData *) NULL ;
    dragonBones::TextureData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TextureAtlasData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::TextureData *)((dragonBones::TextureAtlasData const *)arg1)->createTexture();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureAtlasData_createTexture, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TextureAtlasData_createTexture) 

static bool js_dragonBones_TextureAtlasData_addTexture(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TextureAtlasData *arg1 = (dragonBones::TextureAtlasData *) NULL ;
    dragonBones::TextureData *arg2 = (dragonBones::TextureData *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TextureAtlasData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureAtlasData_addTexture,2,SWIGTYPE_p_dragonBones__TextureData"); 
    (arg1)->addTexture(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TextureAtlasData_addTexture) 

static bool js_dragonBones_TextureAtlasData_getTexture(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TextureAtlasData *arg1 = (dragonBones::TextureAtlasData *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::TextureData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TextureAtlasData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureAtlasData_getTexture,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (dragonBones::TextureData *)((dragonBones::TextureAtlasData const *)arg1)->getTexture((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureAtlasData_getTexture, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TextureAtlasData_getTexture) 

bool js_register_dragonBones_TextureAtlasData(se::Object* obj) {
    auto* cls = se::Class::create("TextureAtlasData", obj, __jsb_dragonBones_BaseObject_proto, nullptr); 
    
    cls->defineProperty("name", _SE(js_dragonBones_TextureAtlasData_name_get), _SE(js_dragonBones_TextureAtlasData_name_set)); 
    
    cls->defineFunction("createTexture", _SE(js_dragonBones_TextureAtlasData_createTexture)); 
    cls->defineFunction("addTexture", _SE(js_dragonBones_TextureAtlasData_addTexture)); 
    cls->defineFunction("getTexture", _SE(js_dragonBones_TextureAtlasData_getTexture)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_TextureAtlasData));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::TextureAtlasData>(cls);
    
    __jsb_dragonBones_TextureAtlasData_proto = cls->getProto();
    __jsb_dragonBones_TextureAtlasData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_TextureData_class = nullptr;
se::Object* __jsb_dragonBones_TextureData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_TextureData) 

static bool js_dragonBones_TextureData_createRectangle_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Rectangle *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (dragonBones::Rectangle *)dragonBones::TextureData::createRectangle();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureData_createRectangle, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TextureData_createRectangle_static) 

static bool js_delete_dragonBones_TextureData(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_TextureData) 

static bool js_dragonBones_TextureData_getRegion(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TextureData *arg1 = (dragonBones::TextureData *) NULL ;
    dragonBones::Rectangle *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TextureData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::Rectangle *)(arg1)->getRegion();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureData_getRegion, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TextureData_getRegion) 

static bool js_dragonBones_TextureData_getFrame(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TextureData *arg1 = (dragonBones::TextureData *) NULL ;
    dragonBones::Rectangle *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TextureData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::Rectangle *)((dragonBones::TextureData const *)arg1)->getFrame();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureData_getFrame, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TextureData_getFrame) 

static bool js_dragonBones_TextureData_setFrame(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TextureData *arg1 = (dragonBones::TextureData *) NULL ;
    dragonBones::Rectangle *arg2 = (dragonBones::Rectangle *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TextureData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureData_setFrame,2,SWIGTYPE_p_dragonBones__Rectangle"); 
    (arg1)->setFrame(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TextureData_setFrame) 

static bool js_dragonBones_TextureData_getParent(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TextureData *arg1 = (dragonBones::TextureData *) NULL ;
    dragonBones::TextureAtlasData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TextureData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::TextureAtlasData *)((dragonBones::TextureData const *)arg1)->getParent();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureData_getParent, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TextureData_getParent) 

static bool js_dragonBones_TextureData_setParent(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TextureData *arg1 = (dragonBones::TextureData *) NULL ;
    dragonBones::TextureAtlasData *arg2 = (dragonBones::TextureAtlasData *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TextureData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureData_setParent,2,SWIGTYPE_p_dragonBones__TextureAtlasData"); 
    (arg1)->setParent(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TextureData_setParent) 

bool js_register_dragonBones_TextureData(se::Object* obj) {
    auto* cls = se::Class::create("TextureData", obj, __jsb_dragonBones_BaseObject_proto, nullptr); 
    
    
    cls->defineFunction("getRegion", _SE(js_dragonBones_TextureData_getRegion)); 
    cls->defineFunction("getFrame", _SE(js_dragonBones_TextureData_getFrame)); 
    cls->defineFunction("setFrame", _SE(js_dragonBones_TextureData_setFrame)); 
    cls->defineFunction("getParent", _SE(js_dragonBones_TextureData_getParent)); 
    cls->defineFunction("setParent", _SE(js_dragonBones_TextureData_setParent)); 
    
    
    cls->defineStaticFunction("createRectangle", _SE(js_dragonBones_TextureData_createRectangle_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_TextureData));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::TextureData>(cls);
    
    __jsb_dragonBones_TextureData_proto = cls->getProto();
    __jsb_dragonBones_TextureData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_ArmatureData_class = nullptr;
se::Object* __jsb_dragonBones_ArmatureData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_ArmatureData) 

static bool js_dragonBones_ArmatureData_frameRate_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg1->frameRate, nullptr);
    SE_PRECONDITION2(ok, false, "ArmatureData_frameRate_set,2,SWIGTYPE_unsigned_int");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_ArmatureData_frameRate_set) 

static bool js_dragonBones_ArmatureData_frameRate_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->frameRate, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_ArmatureData_frameRate_get) 

static bool js_dragonBones_ArmatureData_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "ArmatureData_name_set,2,SWIGTYPE_std__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_ArmatureData_name_set) 

static bool js_dragonBones_ArmatureData_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ArmatureData_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_ArmatureData_name_get) 

static bool js_delete_dragonBones_ArmatureData(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_ArmatureData) 

static bool js_dragonBones_ArmatureData_sortBones(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->sortBones();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_sortBones) 

static bool js_dragonBones_ArmatureData_getBone(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::BoneData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ArmatureData_getBone,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (dragonBones::BoneData *)((dragonBones::ArmatureData const *)arg1)->getBone((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ArmatureData_getBone, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_getBone) 

static bool js_dragonBones_ArmatureData_getSlot(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::SlotData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ArmatureData_getSlot,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (dragonBones::SlotData *)((dragonBones::ArmatureData const *)arg1)->getSlot((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ArmatureData_getSlot, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_getSlot) 

static bool js_dragonBones_ArmatureData_getSkin(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::SkinData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ArmatureData_getSkin,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (dragonBones::SkinData *)((dragonBones::ArmatureData const *)arg1)->getSkin((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ArmatureData_getSkin, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_getSkin) 

static bool js_dragonBones_ArmatureData_getMesh(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string *arg4 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    std::string temp4 ;
    dragonBones::MeshDisplayData *result = 0 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ArmatureData_getMesh,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "ArmatureData_getMesh,3,SWIGTYPE_p_std__string");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "ArmatureData_getMesh,4,SWIGTYPE_p_std__string");
    arg4 = &temp4;
    
    result = (dragonBones::MeshDisplayData *)((dragonBones::ArmatureData const *)arg1)->getMesh((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ArmatureData_getMesh, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_getMesh) 

static bool js_dragonBones_ArmatureData_getAnimation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::AnimationData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ArmatureData_getAnimation,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (dragonBones::AnimationData *)((dragonBones::ArmatureData const *)arg1)->getAnimation((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ArmatureData_getAnimation, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_getAnimation) 

static bool js_dragonBones_ArmatureData_getType(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)((dragonBones::ArmatureData const *)arg1)->getType();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_getType) 

static bool js_dragonBones_ArmatureData_setType(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ArmatureData_setType,2,SWIGTYPE_int"); 
    (arg1)->setType(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_setType) 

static bool js_dragonBones_ArmatureData_getAABB(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    dragonBones::Rectangle *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::Rectangle *)(arg1)->getAABB();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ArmatureData_getAABB, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_getAABB) 

static bool js_dragonBones_ArmatureData_getAnimationNames(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    std::vector< std::string > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (std::vector< std::string > *) &((dragonBones::ArmatureData const *)arg1)->getAnimationNames();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ArmatureData_getAnimationNames, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_getAnimationNames) 

static bool js_dragonBones_ArmatureData_getDefaultSkin(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    dragonBones::SkinData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::SkinData *)((dragonBones::ArmatureData const *)arg1)->getDefaultSkin();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ArmatureData_getDefaultSkin, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_getDefaultSkin) 

static bool js_dragonBones_ArmatureData_setDefaultSkin(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    dragonBones::SkinData *arg2 = (dragonBones::SkinData *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ArmatureData_setDefaultSkin,2,SWIGTYPE_p_dragonBones__SkinData"); 
    (arg1)->setDefaultSkin(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_setDefaultSkin) 

static bool js_dragonBones_ArmatureData_getDefaultAnimation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    dragonBones::AnimationData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::AnimationData *)((dragonBones::ArmatureData const *)arg1)->getDefaultAnimation();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ArmatureData_getDefaultAnimation, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_getDefaultAnimation) 

static bool js_dragonBones_ArmatureData_setDefaultAnimation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    dragonBones::AnimationData *arg2 = (dragonBones::AnimationData *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ArmatureData_setDefaultAnimation,2,SWIGTYPE_p_dragonBones__AnimationData"); 
    (arg1)->setDefaultAnimation(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_setDefaultAnimation) 

static bool js_dragonBones_ArmatureData_getParent(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    dragonBones::DragonBonesData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::DragonBonesData *)((dragonBones::ArmatureData const *)arg1)->getParent();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ArmatureData_getParent, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_getParent) 

static bool js_dragonBones_ArmatureData_setParent(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    dragonBones::DragonBonesData *arg2 = (dragonBones::DragonBonesData *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ArmatureData_setParent,2,SWIGTYPE_p_dragonBones__DragonBonesData"); 
    (arg1)->setParent(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_setParent) 

bool js_register_dragonBones_ArmatureData(se::Object* obj) {
    auto* cls = se::Class::create("ArmatureData", obj, __jsb_dragonBones_BaseObject_proto, nullptr); 
    
    cls->defineProperty("frameRate", _SE(js_dragonBones_ArmatureData_frameRate_get), _SE(js_dragonBones_ArmatureData_frameRate_set)); 
    cls->defineProperty("name", _SE(js_dragonBones_ArmatureData_name_get), _SE(js_dragonBones_ArmatureData_name_set)); 
    
    cls->defineFunction("sortBones", _SE(js_dragonBones_ArmatureData_sortBones)); 
    cls->defineFunction("getBone", _SE(js_dragonBones_ArmatureData_getBone)); 
    cls->defineFunction("getSlot", _SE(js_dragonBones_ArmatureData_getSlot)); 
    cls->defineFunction("getSkin", _SE(js_dragonBones_ArmatureData_getSkin)); 
    cls->defineFunction("getMesh", _SE(js_dragonBones_ArmatureData_getMesh)); 
    cls->defineFunction("getAnimation", _SE(js_dragonBones_ArmatureData_getAnimation)); 
    cls->defineFunction("getType", _SE(js_dragonBones_ArmatureData_getType)); 
    cls->defineFunction("setType", _SE(js_dragonBones_ArmatureData_setType)); 
    cls->defineFunction("getAABB", _SE(js_dragonBones_ArmatureData_getAABB)); 
    cls->defineFunction("getAnimationNames", _SE(js_dragonBones_ArmatureData_getAnimationNames)); 
    cls->defineFunction("getDefaultSkin", _SE(js_dragonBones_ArmatureData_getDefaultSkin)); 
    cls->defineFunction("setDefaultSkin", _SE(js_dragonBones_ArmatureData_setDefaultSkin)); 
    cls->defineFunction("getDefaultAnimation", _SE(js_dragonBones_ArmatureData_getDefaultAnimation)); 
    cls->defineFunction("setDefaultAnimation", _SE(js_dragonBones_ArmatureData_setDefaultAnimation)); 
    cls->defineFunction("getParent", _SE(js_dragonBones_ArmatureData_getParent)); 
    cls->defineFunction("setParent", _SE(js_dragonBones_ArmatureData_setParent)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_ArmatureData));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::ArmatureData>(cls);
    
    __jsb_dragonBones_ArmatureData_proto = cls->getProto();
    __jsb_dragonBones_ArmatureData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_BoneData_class = nullptr;
se::Object* __jsb_dragonBones_BoneData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_BoneData) 

static bool js_dragonBones_BoneData_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BoneData *arg1 = (dragonBones::BoneData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "BoneData_name_set,2,SWIGTYPE_std__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BoneData_name_set) 

static bool js_dragonBones_BoneData_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BoneData *arg1 = (dragonBones::BoneData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BoneData_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BoneData_name_get) 

static bool js_dragonBones_BoneData_parent_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BoneData *arg1 = (dragonBones::BoneData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->parent, s.thisObject());
    SE_PRECONDITION2(ok, false, "BoneData_parent_set,2,SWIGTYPE_p_dragonBones__BoneData"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BoneData_parent_set) 

static bool js_dragonBones_BoneData_parent_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BoneData *arg1 = (dragonBones::BoneData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->parent, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BoneData_parent_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->parent, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BoneData_parent_get) 

static bool js_delete_dragonBones_BoneData(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_BoneData) 

static bool js_dragonBones_BoneData_getTransfrom(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BoneData *arg1 = (dragonBones::BoneData *) NULL ;
    dragonBones::Transform *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::Transform *)(arg1)->getTransfrom();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BoneData_getTransfrom, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_BoneData_getTransfrom) 

static bool js_dragonBones_BoneData_getParent(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BoneData *arg1 = (dragonBones::BoneData *) NULL ;
    dragonBones::BoneData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::BoneData *)((dragonBones::BoneData const *)arg1)->getParent();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BoneData_getParent, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_BoneData_getParent) 

static bool js_dragonBones_BoneData_setParent(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BoneData *arg1 = (dragonBones::BoneData *) NULL ;
    dragonBones::BoneData *arg2 = (dragonBones::BoneData *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BoneData_setParent,2,SWIGTYPE_p_dragonBones__BoneData"); 
    (arg1)->setParent(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_BoneData_setParent) 

bool js_register_dragonBones_BoneData(se::Object* obj) {
    auto* cls = se::Class::create("BoneData", obj, __jsb_dragonBones_BaseObject_proto, nullptr); 
    
    cls->defineProperty("name", _SE(js_dragonBones_BoneData_name_get), _SE(js_dragonBones_BoneData_name_set)); 
    cls->defineProperty("parent", _SE(js_dragonBones_BoneData_parent_get), _SE(js_dragonBones_BoneData_parent_set)); 
    
    cls->defineFunction("getTransfrom", _SE(js_dragonBones_BoneData_getTransfrom)); 
    cls->defineFunction("getParent", _SE(js_dragonBones_BoneData_getParent)); 
    cls->defineFunction("setParent", _SE(js_dragonBones_BoneData_setParent)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_BoneData));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::BoneData>(cls);
    
    __jsb_dragonBones_BoneData_proto = cls->getProto();
    __jsb_dragonBones_BoneData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_SlotData_class = nullptr;
se::Object* __jsb_dragonBones_SlotData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_SlotData) 

static bool js_dragonBones_SlotData_blendMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "SlotData_blendMode_set,2,SWIGTYPE_dragonBones__BlendMode");
    arg1->blendMode = (dragonBones::BlendMode)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_SlotData_blendMode_set) 

static bool js_dragonBones_SlotData_blendMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->blendMode));
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_SlotData_blendMode_get) 

static bool js_dragonBones_SlotData_displayIndex_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->displayIndex, nullptr);
    SE_PRECONDITION2(ok, false, "SlotData_displayIndex_set,2,SWIGTYPE_int"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_SlotData_displayIndex_set) 

static bool js_dragonBones_SlotData_displayIndex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->displayIndex, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_SlotData_displayIndex_get) 

static bool js_dragonBones_SlotData_zOrder_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->zOrder, nullptr);
    SE_PRECONDITION2(ok, false, "SlotData_zOrder_set,2,SWIGTYPE_int"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_SlotData_zOrder_set) 

static bool js_dragonBones_SlotData_zOrder_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->zOrder, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_SlotData_zOrder_get) 

static bool js_dragonBones_SlotData_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "SlotData_name_set,2,SWIGTYPE_std__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_SlotData_name_set) 

static bool js_dragonBones_SlotData_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SlotData_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_SlotData_name_get) 

static bool js_dragonBones_SlotData_parent_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->parent, s.thisObject());
    SE_PRECONDITION2(ok, false, "SlotData_parent_set,2,SWIGTYPE_p_dragonBones__BoneData"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_SlotData_parent_set) 

static bool js_dragonBones_SlotData_parent_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->parent, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SlotData_parent_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->parent, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_SlotData_parent_get) 

static bool js_delete_dragonBones_SlotData(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_SlotData) 

static bool js_dragonBones_SlotData_getBlendMode(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)((dragonBones::SlotData const *)arg1)->getBlendMode();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_SlotData_getBlendMode) 

static bool js_dragonBones_SlotData_setBlendMode(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SlotData_setBlendMode,2,SWIGTYPE_int"); 
    (arg1)->setBlendMode(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_SlotData_setBlendMode) 

static bool js_dragonBones_SlotData_getParent(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    dragonBones::BoneData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::BoneData *)((dragonBones::SlotData const *)arg1)->getParent();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SlotData_getParent, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_SlotData_getParent) 

static bool js_dragonBones_SlotData_setParent(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    dragonBones::BoneData *arg2 = (dragonBones::BoneData *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SlotData_setParent,2,SWIGTYPE_p_dragonBones__BoneData"); 
    (arg1)->setParent(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_SlotData_setParent) 

bool js_register_dragonBones_SlotData(se::Object* obj) {
    auto* cls = se::Class::create("SlotData", obj, __jsb_dragonBones_BaseObject_proto, nullptr); 
    
    cls->defineProperty("blendMode", _SE(js_dragonBones_SlotData_blendMode_get), _SE(js_dragonBones_SlotData_blendMode_set)); 
    cls->defineProperty("displayIndex", _SE(js_dragonBones_SlotData_displayIndex_get), _SE(js_dragonBones_SlotData_displayIndex_set)); 
    cls->defineProperty("zOrder", _SE(js_dragonBones_SlotData_zOrder_get), _SE(js_dragonBones_SlotData_zOrder_set)); 
    cls->defineProperty("name", _SE(js_dragonBones_SlotData_name_get), _SE(js_dragonBones_SlotData_name_set)); 
    cls->defineProperty("parent", _SE(js_dragonBones_SlotData_parent_get), _SE(js_dragonBones_SlotData_parent_set)); 
    
    cls->defineFunction("getBlendMode", _SE(js_dragonBones_SlotData_getBlendMode)); 
    cls->defineFunction("setBlendMode", _SE(js_dragonBones_SlotData_setBlendMode)); 
    cls->defineFunction("getParent", _SE(js_dragonBones_SlotData_getParent)); 
    cls->defineFunction("setParent", _SE(js_dragonBones_SlotData_setParent)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_SlotData));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::SlotData>(cls);
    
    __jsb_dragonBones_SlotData_proto = cls->getProto();
    __jsb_dragonBones_SlotData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_SkinData_class = nullptr;
se::Object* __jsb_dragonBones_SkinData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_SkinData) 

static bool js_delete_dragonBones_SkinData(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_SkinData) 

static bool js_dragonBones_SkinData_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::SkinData *arg1 = (dragonBones::SkinData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::SkinData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkinData_name_set,2,SWIGTYPE_std__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_SkinData_name_set) 

static bool js_dragonBones_SkinData_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::SkinData *arg1 = (dragonBones::SkinData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::SkinData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkinData_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_SkinData_name_get) 

bool js_register_dragonBones_SkinData(se::Object* obj) {
    auto* cls = se::Class::create("SkinData", obj, __jsb_dragonBones_BaseObject_proto, nullptr); 
    
    cls->defineProperty("name", _SE(js_dragonBones_SkinData_name_get), _SE(js_dragonBones_SkinData_name_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_SkinData));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::SkinData>(cls);
    
    __jsb_dragonBones_SkinData_proto = cls->getProto();
    __jsb_dragonBones_SkinData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_AnimationData_class = nullptr;
se::Object* __jsb_dragonBones_AnimationData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_AnimationData) 

static bool js_dragonBones_AnimationData_frameCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg1->frameCount, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationData_frameCount_set,2,SWIGTYPE_unsigned_int");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationData_frameCount_set) 

static bool js_dragonBones_AnimationData_frameCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->frameCount, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationData_frameCount_get) 

static bool js_dragonBones_AnimationData_playTimes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg1->playTimes, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationData_playTimes_set,2,SWIGTYPE_unsigned_int");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationData_playTimes_set) 

static bool js_dragonBones_AnimationData_playTimes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->playTimes, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationData_playTimes_get) 

static bool js_dragonBones_AnimationData_duration_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->duration, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationData_duration_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationData_duration_set) 

static bool js_dragonBones_AnimationData_duration_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->duration, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationData_duration_get) 

static bool js_dragonBones_AnimationData_fadeInTime_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->fadeInTime, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationData_fadeInTime_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationData_fadeInTime_set) 

static bool js_dragonBones_AnimationData_fadeInTime_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->fadeInTime, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationData_fadeInTime_get) 

static bool js_dragonBones_AnimationData_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "AnimationData_name_set,2,SWIGTYPE_std__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationData_name_set) 

static bool js_dragonBones_AnimationData_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AnimationData_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationData_name_get) 

static bool js_delete_dragonBones_AnimationData(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_AnimationData) 

static bool js_dragonBones_AnimationData_getBoneCachedFrameIndices(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    std::vector< int > *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "AnimationData_getBoneCachedFrameIndices,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (std::vector< int > *)(arg1)->getBoneCachedFrameIndices((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AnimationData_getBoneCachedFrameIndices, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationData_getBoneCachedFrameIndices) 

static bool js_dragonBones_AnimationData_getSlotCachedFrameIndices(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    std::vector< int > *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "AnimationData_getSlotCachedFrameIndices,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (std::vector< int > *)(arg1)->getSlotCachedFrameIndices((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AnimationData_getSlotCachedFrameIndices, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationData_getSlotCachedFrameIndices) 

static bool js_dragonBones_AnimationData_getZOrderTimeline(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    dragonBones::TimelineData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::TimelineData *)((dragonBones::AnimationData const *)arg1)->getZOrderTimeline();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AnimationData_getZOrderTimeline, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationData_getZOrderTimeline) 

static bool js_dragonBones_AnimationData_getParent(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    dragonBones::ArmatureData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::ArmatureData *)((dragonBones::AnimationData const *)arg1)->getParent();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AnimationData_getParent, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationData_getParent) 

static bool js_dragonBones_AnimationData_setParent(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    dragonBones::ArmatureData *arg2 = (dragonBones::ArmatureData *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "AnimationData_setParent,2,SWIGTYPE_p_dragonBones__ArmatureData"); 
    (arg1)->setParent(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationData_setParent) 

bool js_register_dragonBones_AnimationData(se::Object* obj) {
    auto* cls = se::Class::create("AnimationData", obj, __jsb_dragonBones_BaseObject_proto, nullptr); 
    
    cls->defineProperty("frameCount", _SE(js_dragonBones_AnimationData_frameCount_get), _SE(js_dragonBones_AnimationData_frameCount_set)); 
    cls->defineProperty("playTimes", _SE(js_dragonBones_AnimationData_playTimes_get), _SE(js_dragonBones_AnimationData_playTimes_set)); 
    cls->defineProperty("duration", _SE(js_dragonBones_AnimationData_duration_get), _SE(js_dragonBones_AnimationData_duration_set)); 
    cls->defineProperty("fadeInTime", _SE(js_dragonBones_AnimationData_fadeInTime_get), _SE(js_dragonBones_AnimationData_fadeInTime_set)); 
    cls->defineProperty("name", _SE(js_dragonBones_AnimationData_name_get), _SE(js_dragonBones_AnimationData_name_set)); 
    
    cls->defineFunction("getBoneCachedFrameIndices", _SE(js_dragonBones_AnimationData_getBoneCachedFrameIndices)); 
    cls->defineFunction("getSlotCachedFrameIndices", _SE(js_dragonBones_AnimationData_getSlotCachedFrameIndices)); 
    cls->defineFunction("getZOrderTimeline", _SE(js_dragonBones_AnimationData_getZOrderTimeline)); 
    cls->defineFunction("getParent", _SE(js_dragonBones_AnimationData_getParent)); 
    cls->defineFunction("setParent", _SE(js_dragonBones_AnimationData_setParent)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_AnimationData));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::AnimationData>(cls);
    
    __jsb_dragonBones_AnimationData_proto = cls->getProto();
    __jsb_dragonBones_AnimationData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_TimelineData_class = nullptr;
se::Object* __jsb_dragonBones_TimelineData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_TimelineData) 

static bool js_dragonBones_TimelineData_getTypeIndex_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    std::size_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = dragonBones::TimelineData::getTypeIndex();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TimelineData_getTypeIndex, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TimelineData_getTypeIndex_static) 

// js_ctor
static bool js_new_dragonBones_TimelineData(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    dragonBones::TimelineData *result;
    result = (dragonBones::TimelineData *)new dragonBones::TimelineData();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_dragonBones_TimelineData, __jsb_dragonBones_TimelineData_class, js_delete_dragonBones_TimelineData)

static bool js_delete_dragonBones_TimelineData(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_TimelineData) 

static bool js_dragonBones_TimelineData_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TimelineData *arg1 = (dragonBones::TimelineData *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TimelineData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TimelineData_type_set,2,SWIGTYPE_dragonBones__TimelineType");
    arg1->type = (dragonBones::TimelineType)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_TimelineData_type_set) 

static bool js_dragonBones_TimelineData_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::TimelineData *arg1 = (dragonBones::TimelineData *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TimelineData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->type));
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_TimelineData_type_get) 

static bool js_dragonBones_TimelineData_offset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TimelineData *arg1 = (dragonBones::TimelineData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TimelineData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg1->offset, nullptr);
    SE_PRECONDITION2(ok, false, "TimelineData_offset_set,2,SWIGTYPE_unsigned_int");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_TimelineData_offset_set) 

static bool js_dragonBones_TimelineData_offset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::TimelineData *arg1 = (dragonBones::TimelineData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TimelineData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->offset, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_TimelineData_offset_get) 

static bool js_dragonBones_TimelineData_frameIndicesOffset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TimelineData *arg1 = (dragonBones::TimelineData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TimelineData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->frameIndicesOffset, nullptr);
    SE_PRECONDITION2(ok, false, "TimelineData_frameIndicesOffset_set,2,SWIGTYPE_int"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_TimelineData_frameIndicesOffset_set) 

static bool js_dragonBones_TimelineData_frameIndicesOffset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::TimelineData *arg1 = (dragonBones::TimelineData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TimelineData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->frameIndicesOffset, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_TimelineData_frameIndicesOffset_get) 

static bool js_dragonBones_TimelineData_getType(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TimelineData *arg1 = (dragonBones::TimelineData *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TimelineData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)((dragonBones::TimelineData const *)arg1)->getType();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TimelineData_getType) 

static bool js_dragonBones_TimelineData_setType(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TimelineData *arg1 = (dragonBones::TimelineData *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TimelineData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "TimelineData_setType,2,SWIGTYPE_int"); 
    (arg1)->setType(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TimelineData_setType) 

bool js_register_dragonBones_TimelineData(se::Object* obj) {
    auto* cls = se::Class::create("TimelineData", obj, __jsb_dragonBones_BaseObject_proto, _SE(js_new_dragonBones_TimelineData)); 
    
    cls->defineProperty("type", _SE(js_dragonBones_TimelineData_type_get), _SE(js_dragonBones_TimelineData_type_set)); 
    cls->defineProperty("offset", _SE(js_dragonBones_TimelineData_offset_get), _SE(js_dragonBones_TimelineData_offset_set)); 
    cls->defineProperty("frameIndicesOffset", _SE(js_dragonBones_TimelineData_frameIndicesOffset_get), _SE(js_dragonBones_TimelineData_frameIndicesOffset_set)); 
    
    cls->defineFunction("getType", _SE(js_dragonBones_TimelineData_getType)); 
    cls->defineFunction("setType", _SE(js_dragonBones_TimelineData_setType)); 
    
    
    cls->defineStaticFunction("getTypeIndex", _SE(js_dragonBones_TimelineData_getTypeIndex_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_TimelineData));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::TimelineData>(cls);
    
    __jsb_dragonBones_TimelineData_proto = cls->getProto();
    __jsb_dragonBones_TimelineData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_WorldClock_class = nullptr;
se::Object* __jsb_dragonBones_WorldClock_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_WorldClock) 

static bool js_dragonBones_WorldClock_time_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::WorldClock *arg1 = (dragonBones::WorldClock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::WorldClock>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->time, nullptr);
    SE_PRECONDITION2(ok, false, "WorldClock_time_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_WorldClock_time_set) 

static bool js_dragonBones_WorldClock_time_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::WorldClock *arg1 = (dragonBones::WorldClock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::WorldClock>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->time, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_WorldClock_time_get) 

static bool js_dragonBones_WorldClock_timeScale_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::WorldClock *arg1 = (dragonBones::WorldClock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::WorldClock>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->timeScale, nullptr);
    SE_PRECONDITION2(ok, false, "WorldClock_timeScale_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_WorldClock_timeScale_set) 

static bool js_dragonBones_WorldClock_timeScale_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::WorldClock *arg1 = (dragonBones::WorldClock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::WorldClock>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->timeScale, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_WorldClock_timeScale_get) 

static bool js_delete_dragonBones_WorldClock(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_WorldClock) 

static bool js_dragonBones_WorldClock_advanceTime(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::WorldClock *arg1 = (dragonBones::WorldClock *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::WorldClock>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "WorldClock_advanceTime,2,SWIGTYPE_float"); 
    (arg1)->advanceTime(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_WorldClock_advanceTime) 

static bool js_dragonBones_WorldClock_render(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::WorldClock *arg1 = (dragonBones::WorldClock *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::WorldClock>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->render();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_WorldClock_render) 

static bool js_dragonBones_WorldClock_clear(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::WorldClock *arg1 = (dragonBones::WorldClock *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::WorldClock>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->clear();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_WorldClock_clear) 

static bool js_dragonBones_WorldClock_getClock(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::WorldClock *arg1 = (dragonBones::WorldClock *) NULL ;
    dragonBones::WorldClock *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::WorldClock>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::WorldClock *)((dragonBones::WorldClock const *)arg1)->getClock();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "WorldClock_getClock, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_WorldClock_getClock) 

static bool js_dragonBones_WorldClock_setClock(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::WorldClock *arg1 = (dragonBones::WorldClock *) NULL ;
    dragonBones::WorldClock *arg2 = (dragonBones::WorldClock *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::WorldClock>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "WorldClock_setClock,2,SWIGTYPE_p_dragonBones__WorldClock"); 
    (arg1)->setClock(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_WorldClock_setClock) 

static bool js_dragonBones_WorldClock_getStaticClock_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::WorldClock *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (dragonBones::WorldClock *)dragonBones::WorldClock::getStaticClock();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "WorldClock_getStaticClock, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_WorldClock_getStaticClock_static) 

bool js_register_dragonBones_WorldClock(se::Object* obj) {
    auto* cls = se::Class::create("WorldClock", obj, nullptr, nullptr); 
    
    cls->defineProperty("time", _SE(js_dragonBones_WorldClock_time_get), _SE(js_dragonBones_WorldClock_time_set)); 
    cls->defineProperty("timeScale", _SE(js_dragonBones_WorldClock_timeScale_get), _SE(js_dragonBones_WorldClock_timeScale_set)); 
    
    cls->defineFunction("advanceTime", _SE(js_dragonBones_WorldClock_advanceTime)); 
    cls->defineFunction("render", _SE(js_dragonBones_WorldClock_render)); 
    cls->defineFunction("clear", _SE(js_dragonBones_WorldClock_clear)); 
    cls->defineFunction("getClock", _SE(js_dragonBones_WorldClock_getClock)); 
    cls->defineFunction("setClock", _SE(js_dragonBones_WorldClock_setClock)); 
    
    
    cls->defineStaticFunction("getStaticClock", _SE(js_dragonBones_WorldClock_getStaticClock_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_WorldClock));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::WorldClock>(cls);
    
    __jsb_dragonBones_WorldClock_proto = cls->getProto();
    __jsb_dragonBones_WorldClock_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_Animation_class = nullptr;
se::Object* __jsb_dragonBones_Animation_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_Animation) 

static bool js_dragonBones_Animation_timeScale_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->timeScale, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_timeScale_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Animation_timeScale_set) 

static bool js_dragonBones_Animation_timeScale_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->timeScale, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Animation_timeScale_get) 

static bool js_delete_dragonBones_Animation(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_Animation) 

static bool js_dragonBones_Animation_init(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    dragonBones::Armature *arg2 = (dragonBones::Armature *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_init,2,SWIGTYPE_p_dragonBones__Armature"); 
    (arg1)->init(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Animation_init) 

static bool js_dragonBones_Animation_advanceTime(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_advanceTime,2,SWIGTYPE_float"); 
    (arg1)->advanceTime(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Animation_advanceTime) 

static bool js_dragonBones_Animation_reset(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->reset();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Animation_reset) 

static bool js_dragonBones_Animation_stop__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_stop,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    (arg1)->stop((std::string const &)*arg2);
    
    
    return true;
}

static bool js_dragonBones_Animation_stop__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->stop();
    
    
    return true;
}

static bool js_dragonBones_Animation_stop(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_dragonBones_Animation_stop__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 0) {
        ok = js_dragonBones_Animation_stop__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_Animation_stop) 

static bool js_dragonBones_Animation_play__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    int arg3 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_play,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_play,3,SWIGTYPE_int"); 
    result = (dragonBones::AnimationState *)(arg1)->play((std::string const &)*arg2,arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_play, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_play__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_play,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (dragonBones::AnimationState *)(arg1)->play((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_play, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_play__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::AnimationState *)(arg1)->play();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_play, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_play(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_dragonBones_Animation_play__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_dragonBones_Animation_play__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 0) {
        ok = js_dragonBones_Animation_play__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_Animation_play) 

static bool js_dragonBones_Animation_fadeIn__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    float arg3 ;
    int arg4 ;
    int arg5 ;
    std::string *arg6 = 0 ;
    dragonBones::AnimationFadeOutMode arg7 ;
    std::string temp2 ;
    std::string temp6 ;
    int32_t temp7 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_fadeIn,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_fadeIn,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_fadeIn,4,SWIGTYPE_int"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_fadeIn,5,SWIGTYPE_int"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[4], &temp6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_fadeIn,6,SWIGTYPE_p_std__string");
    arg6 = &temp6;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp7)
    ok &= sevalue_to_native(args[5], &temp7);
    SE_PRECONDITION2(ok, false, "Animation_fadeIn,7,SWIGTYPE_dragonBones__AnimationFadeOutMode");
    arg7 = (dragonBones::AnimationFadeOutMode)temp7;
    result = (dragonBones::AnimationState *)(arg1)->fadeIn((std::string const &)*arg2,arg3,arg4,arg5,(std::string const &)*arg6,arg7);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_fadeIn, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_fadeIn__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    float arg3 ;
    int arg4 ;
    int arg5 ;
    std::string *arg6 = 0 ;
    std::string temp2 ;
    std::string temp6 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_fadeIn,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_fadeIn,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_fadeIn,4,SWIGTYPE_int"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_fadeIn,5,SWIGTYPE_int"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[4], &temp6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_fadeIn,6,SWIGTYPE_p_std__string");
    arg6 = &temp6;
    
    result = (dragonBones::AnimationState *)(arg1)->fadeIn((std::string const &)*arg2,arg3,arg4,arg5,(std::string const &)*arg6);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_fadeIn, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_fadeIn__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    float arg3 ;
    int arg4 ;
    int arg5 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_fadeIn,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_fadeIn,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_fadeIn,4,SWIGTYPE_int"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_fadeIn,5,SWIGTYPE_int"); 
    result = (dragonBones::AnimationState *)(arg1)->fadeIn((std::string const &)*arg2,arg3,arg4,arg5);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_fadeIn, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_fadeIn__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    float arg3 ;
    int arg4 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_fadeIn,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_fadeIn,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_fadeIn,4,SWIGTYPE_int"); 
    result = (dragonBones::AnimationState *)(arg1)->fadeIn((std::string const &)*arg2,arg3,arg4);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_fadeIn, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_fadeIn__SWIG_4(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_fadeIn,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_fadeIn,3,SWIGTYPE_float"); 
    result = (dragonBones::AnimationState *)(arg1)->fadeIn((std::string const &)*arg2,arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_fadeIn, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_fadeIn__SWIG_5(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_fadeIn,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (dragonBones::AnimationState *)(arg1)->fadeIn((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_fadeIn, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_fadeIn(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 6) {
        ok = js_dragonBones_Animation_fadeIn__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_dragonBones_Animation_fadeIn__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_dragonBones_Animation_fadeIn__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_dragonBones_Animation_fadeIn__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_dragonBones_Animation_fadeIn__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_dragonBones_Animation_fadeIn__SWIG_5(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_Animation_fadeIn) 

static bool js_dragonBones_Animation_gotoAndPlayByTime__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    float arg3 ;
    int arg4 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_gotoAndPlayByTime,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_gotoAndPlayByTime,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_gotoAndPlayByTime,4,SWIGTYPE_int"); 
    result = (dragonBones::AnimationState *)(arg1)->gotoAndPlayByTime((std::string const &)*arg2,arg3,arg4);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_gotoAndPlayByTime, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndPlayByTime__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_gotoAndPlayByTime,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_gotoAndPlayByTime,3,SWIGTYPE_float"); 
    result = (dragonBones::AnimationState *)(arg1)->gotoAndPlayByTime((std::string const &)*arg2,arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_gotoAndPlayByTime, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndPlayByTime__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_gotoAndPlayByTime,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (dragonBones::AnimationState *)(arg1)->gotoAndPlayByTime((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_gotoAndPlayByTime, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndPlayByTime(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_dragonBones_Animation_gotoAndPlayByTime__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_dragonBones_Animation_gotoAndPlayByTime__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_dragonBones_Animation_gotoAndPlayByTime__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_Animation_gotoAndPlayByTime) 

static bool js_dragonBones_Animation_gotoAndPlayByFrame__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    unsigned int arg3 ;
    int arg4 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_gotoAndPlayByFrame,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_gotoAndPlayByFrame,3,SWIGTYPE_unsigned_int");
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_gotoAndPlayByFrame,4,SWIGTYPE_int"); 
    result = (dragonBones::AnimationState *)(arg1)->gotoAndPlayByFrame((std::string const &)*arg2,arg3,arg4);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_gotoAndPlayByFrame, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndPlayByFrame__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    unsigned int arg3 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_gotoAndPlayByFrame,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_gotoAndPlayByFrame,3,SWIGTYPE_unsigned_int");
    
    result = (dragonBones::AnimationState *)(arg1)->gotoAndPlayByFrame((std::string const &)*arg2,arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_gotoAndPlayByFrame, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndPlayByFrame__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_gotoAndPlayByFrame,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (dragonBones::AnimationState *)(arg1)->gotoAndPlayByFrame((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_gotoAndPlayByFrame, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndPlayByFrame(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_dragonBones_Animation_gotoAndPlayByFrame__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_dragonBones_Animation_gotoAndPlayByFrame__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_dragonBones_Animation_gotoAndPlayByFrame__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_Animation_gotoAndPlayByFrame) 

static bool js_dragonBones_Animation_gotoAndPlayByProgress__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    float arg3 ;
    int arg4 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_gotoAndPlayByProgress,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_gotoAndPlayByProgress,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_gotoAndPlayByProgress,4,SWIGTYPE_int"); 
    result = (dragonBones::AnimationState *)(arg1)->gotoAndPlayByProgress((std::string const &)*arg2,arg3,arg4);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_gotoAndPlayByProgress, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndPlayByProgress__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_gotoAndPlayByProgress,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_gotoAndPlayByProgress,3,SWIGTYPE_float"); 
    result = (dragonBones::AnimationState *)(arg1)->gotoAndPlayByProgress((std::string const &)*arg2,arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_gotoAndPlayByProgress, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndPlayByProgress__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_gotoAndPlayByProgress,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (dragonBones::AnimationState *)(arg1)->gotoAndPlayByProgress((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_gotoAndPlayByProgress, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndPlayByProgress(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_dragonBones_Animation_gotoAndPlayByProgress__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_dragonBones_Animation_gotoAndPlayByProgress__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_dragonBones_Animation_gotoAndPlayByProgress__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_Animation_gotoAndPlayByProgress) 

static bool js_dragonBones_Animation_gotoAndStopByTime__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_gotoAndStopByTime,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_gotoAndStopByTime,3,SWIGTYPE_float"); 
    result = (dragonBones::AnimationState *)(arg1)->gotoAndStopByTime((std::string const &)*arg2,arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_gotoAndStopByTime, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndStopByTime__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_gotoAndStopByTime,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (dragonBones::AnimationState *)(arg1)->gotoAndStopByTime((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_gotoAndStopByTime, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndStopByTime(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_dragonBones_Animation_gotoAndStopByTime__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_dragonBones_Animation_gotoAndStopByTime__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_Animation_gotoAndStopByTime) 

static bool js_dragonBones_Animation_gotoAndStopByFrame__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    unsigned int arg3 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_gotoAndStopByFrame,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_gotoAndStopByFrame,3,SWIGTYPE_unsigned_int");
    
    result = (dragonBones::AnimationState *)(arg1)->gotoAndStopByFrame((std::string const &)*arg2,arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_gotoAndStopByFrame, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndStopByFrame__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_gotoAndStopByFrame,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (dragonBones::AnimationState *)(arg1)->gotoAndStopByFrame((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_gotoAndStopByFrame, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndStopByFrame(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_dragonBones_Animation_gotoAndStopByFrame__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_dragonBones_Animation_gotoAndStopByFrame__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_Animation_gotoAndStopByFrame) 

static bool js_dragonBones_Animation_gotoAndStopByProgress__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_gotoAndStopByProgress,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_gotoAndStopByProgress,3,SWIGTYPE_float"); 
    result = (dragonBones::AnimationState *)(arg1)->gotoAndStopByProgress((std::string const &)*arg2,arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_gotoAndStopByProgress, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndStopByProgress__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_gotoAndStopByProgress,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (dragonBones::AnimationState *)(arg1)->gotoAndStopByProgress((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_gotoAndStopByProgress, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndStopByProgress(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_dragonBones_Animation_gotoAndStopByProgress__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_dragonBones_Animation_gotoAndStopByProgress__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_Animation_gotoAndStopByProgress) 

static bool js_dragonBones_Animation_getState(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_getState,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (dragonBones::AnimationState *)((dragonBones::Animation const *)arg1)->getState((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_getState, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Animation_getState) 

static bool js_dragonBones_Animation_hasAnimation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Animation_hasAnimation,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (bool)((dragonBones::Animation const *)arg1)->hasAnimation((std::string const &)*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Animation_hasAnimation) 

static bool js_dragonBones_Animation_isPlaying(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((dragonBones::Animation const *)arg1)->isPlaying();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Animation_isPlaying) 

static bool js_dragonBones_Animation_isCompleted(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((dragonBones::Animation const *)arg1)->isCompleted();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Animation_isCompleted) 

static bool js_dragonBones_Animation_getLastAnimationName(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (std::string *) &((dragonBones::Animation const *)arg1)->getLastAnimationName();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_getLastAnimationName, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Animation_getLastAnimationName) 

static bool js_dragonBones_Animation_getAnimationNames(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::vector< std::string > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (std::vector< std::string > *) &((dragonBones::Animation const *)arg1)->getAnimationNames();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_getAnimationNames, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Animation_getAnimationNames) 

static bool js_dragonBones_Animation_getLastAnimationState(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    dragonBones::AnimationState *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::AnimationState *)((dragonBones::Animation const *)arg1)->getLastAnimationState();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_getLastAnimationState, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Animation_getLastAnimationState) 

bool js_register_dragonBones_Animation(se::Object* obj) {
    auto* cls = se::Class::create("Animation", obj, __jsb_dragonBones_BaseObject_proto, nullptr); 
    
    cls->defineProperty("timeScale", _SE(js_dragonBones_Animation_timeScale_get), _SE(js_dragonBones_Animation_timeScale_set)); 
    
    cls->defineFunction("init", _SE(js_dragonBones_Animation_init)); 
    cls->defineFunction("advanceTime", _SE(js_dragonBones_Animation_advanceTime)); 
    cls->defineFunction("reset", _SE(js_dragonBones_Animation_reset)); 
    cls->defineFunction("stop", _SE(js_dragonBones_Animation_stop)); 
    cls->defineFunction("play", _SE(js_dragonBones_Animation_play)); 
    cls->defineFunction("fadeIn", _SE(js_dragonBones_Animation_fadeIn)); 
    cls->defineFunction("gotoAndPlayByTime", _SE(js_dragonBones_Animation_gotoAndPlayByTime)); 
    cls->defineFunction("gotoAndPlayByFrame", _SE(js_dragonBones_Animation_gotoAndPlayByFrame)); 
    cls->defineFunction("gotoAndPlayByProgress", _SE(js_dragonBones_Animation_gotoAndPlayByProgress)); 
    cls->defineFunction("gotoAndStopByTime", _SE(js_dragonBones_Animation_gotoAndStopByTime)); 
    cls->defineFunction("gotoAndStopByFrame", _SE(js_dragonBones_Animation_gotoAndStopByFrame)); 
    cls->defineFunction("gotoAndStopByProgress", _SE(js_dragonBones_Animation_gotoAndStopByProgress)); 
    cls->defineFunction("getState", _SE(js_dragonBones_Animation_getState)); 
    cls->defineFunction("hasAnimation", _SE(js_dragonBones_Animation_hasAnimation)); 
    cls->defineFunction("isPlaying", _SE(js_dragonBones_Animation_isPlaying)); 
    cls->defineFunction("isCompleted", _SE(js_dragonBones_Animation_isCompleted)); 
    cls->defineFunction("getLastAnimationName", _SE(js_dragonBones_Animation_getLastAnimationName)); 
    cls->defineFunction("getAnimationNames", _SE(js_dragonBones_Animation_getAnimationNames)); 
    cls->defineFunction("getLastAnimationState", _SE(js_dragonBones_Animation_getLastAnimationState)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_Animation));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::Animation>(cls);
    
    __jsb_dragonBones_Animation_proto = cls->getProto();
    __jsb_dragonBones_Animation_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_AnimationState_class = nullptr;
se::Object* __jsb_dragonBones_AnimationState_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_AnimationState) 

static bool js_dragonBones_AnimationState_actionEnabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->actionEnabled);
    SE_PRECONDITION2(ok, false, "AnimationState_actionEnabled_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState_actionEnabled_set) 

static bool js_dragonBones_AnimationState_actionEnabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->actionEnabled, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState_actionEnabled_get) 

static bool js_dragonBones_AnimationState_additiveBlending_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->additiveBlending);
    SE_PRECONDITION2(ok, false, "AnimationState_additiveBlending_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState_additiveBlending_set) 

static bool js_dragonBones_AnimationState_additiveBlending_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->additiveBlending, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState_additiveBlending_get) 

static bool js_dragonBones_AnimationState_displayControl_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->displayControl);
    SE_PRECONDITION2(ok, false, "AnimationState_displayControl_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState_displayControl_set) 

static bool js_dragonBones_AnimationState_displayControl_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->displayControl, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState_displayControl_get) 

static bool js_dragonBones_AnimationState_resetToPose_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->resetToPose);
    SE_PRECONDITION2(ok, false, "AnimationState_resetToPose_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState_resetToPose_set) 

static bool js_dragonBones_AnimationState_resetToPose_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->resetToPose, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState_resetToPose_get) 

static bool js_dragonBones_AnimationState_playTimes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg1->playTimes, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState_playTimes_set,2,SWIGTYPE_unsigned_int");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState_playTimes_set) 

static bool js_dragonBones_AnimationState_playTimes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->playTimes, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState_playTimes_get) 

static bool js_dragonBones_AnimationState_layer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg1->layer, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState_layer_set,2,SWIGTYPE_unsigned_int");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState_layer_set) 

static bool js_dragonBones_AnimationState_layer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->layer, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState_layer_get) 

static bool js_dragonBones_AnimationState_timeScale_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->timeScale, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState_timeScale_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState_timeScale_set) 

static bool js_dragonBones_AnimationState_timeScale_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->timeScale, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState_timeScale_get) 

static bool js_dragonBones_AnimationState_weight_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->weight, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState_weight_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState_weight_set) 

static bool js_dragonBones_AnimationState_weight_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->weight, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState_weight_get) 

static bool js_dragonBones_AnimationState_autoFadeOutTime_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->autoFadeOutTime, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState_autoFadeOutTime_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState_autoFadeOutTime_set) 

static bool js_dragonBones_AnimationState_autoFadeOutTime_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->autoFadeOutTime, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState_autoFadeOutTime_get) 

static bool js_dragonBones_AnimationState_fadeTotalTime_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->fadeTotalTime, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState_fadeTotalTime_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState_fadeTotalTime_set) 

static bool js_dragonBones_AnimationState_fadeTotalTime_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->fadeTotalTime, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState_fadeTotalTime_get) 

static bool js_dragonBones_AnimationState_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "AnimationState_name_set,2,SWIGTYPE_std__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState_name_set) 

static bool js_dragonBones_AnimationState_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AnimationState_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState_name_get) 

static bool js_dragonBones_AnimationState_group_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->group, s.thisObject());
    SE_PRECONDITION2(ok, false, "AnimationState_group_set,2,SWIGTYPE_std__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState_group_set) 

static bool js_dragonBones_AnimationState_group_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->group, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AnimationState_group_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->group, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState_group_get) 

static bool js_dragonBones_AnimationState__playheadState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->_playheadState, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState__playheadState_set,2,SWIGTYPE_int"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState__playheadState_set) 

static bool js_dragonBones_AnimationState__playheadState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->_playheadState, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState__playheadState_get) 

static bool js_dragonBones_AnimationState__fadeState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->_fadeState, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState__fadeState_set,2,SWIGTYPE_int"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState__fadeState_set) 

static bool js_dragonBones_AnimationState__fadeState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->_fadeState, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState__fadeState_get) 

static bool js_dragonBones_AnimationState__subFadeState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->_subFadeState, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState__subFadeState_set,2,SWIGTYPE_int"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState__subFadeState_set) 

static bool js_dragonBones_AnimationState__subFadeState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->_subFadeState, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState__subFadeState_get) 

static bool js_dragonBones_AnimationState__position_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->_position, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState__position_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState__position_set) 

static bool js_dragonBones_AnimationState__position_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->_position, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState__position_get) 

static bool js_dragonBones_AnimationState__duration_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->_duration, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState__duration_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState__duration_set) 

static bool js_dragonBones_AnimationState__duration_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->_duration, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState__duration_get) 

static bool js_dragonBones_AnimationState__fadeProgress_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->_fadeProgress, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState__fadeProgress_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState__fadeProgress_set) 

static bool js_dragonBones_AnimationState__fadeProgress_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->_fadeProgress, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState__fadeProgress_get) 

static bool js_dragonBones_AnimationState__weightResult_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->_weightResult, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState__weightResult_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState__weightResult_set) 

static bool js_dragonBones_AnimationState__weightResult_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->_weightResult, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState__weightResult_get) 

static bool js_dragonBones_AnimationState__animationData_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->_animationData, s.thisObject());
    SE_PRECONDITION2(ok, false, "AnimationState__animationData_set,2,SWIGTYPE_p_dragonBones__AnimationData"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState__animationData_set) 

static bool js_dragonBones_AnimationState__animationData_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->_animationData, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AnimationState__animationData_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_animationData, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState__animationData_get) 

static bool js_delete_dragonBones_AnimationState(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_AnimationState) 

static bool js_dragonBones_AnimationState_advanceTime(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    float arg2 ;
    float arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState_advanceTime,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState_advanceTime,3,SWIGTYPE_float"); 
    (arg1)->advanceTime(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_advanceTime) 

static bool js_dragonBones_AnimationState_play(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->play();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_play) 

static bool js_dragonBones_AnimationState_stop(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->stop();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_stop) 

static bool js_dragonBones_AnimationState_fadeOut__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    float arg2 ;
    bool arg3 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState_fadeOut,2,SWIGTYPE_float"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "AnimationState_fadeOut,3,SWIGTYPE_bool"); 
    (arg1)->fadeOut(arg2,arg3);
    
    
    return true;
}

static bool js_dragonBones_AnimationState_fadeOut__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState_fadeOut,2,SWIGTYPE_float"); 
    (arg1)->fadeOut(arg2);
    
    
    return true;
}

static bool js_dragonBones_AnimationState_fadeOut(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_dragonBones_AnimationState_fadeOut__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_dragonBones_AnimationState_fadeOut__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_fadeOut) 

static bool js_dragonBones_AnimationState_containsBoneMask(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "AnimationState_containsBoneMask,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (bool)((dragonBones::AnimationState const *)arg1)->containsBoneMask((std::string const &)*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_containsBoneMask) 

static bool js_dragonBones_AnimationState_addBoneMask__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    std::string *arg2 = 0 ;
    bool arg3 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "AnimationState_addBoneMask,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "AnimationState_addBoneMask,3,SWIGTYPE_bool"); 
    (arg1)->addBoneMask((std::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_dragonBones_AnimationState_addBoneMask__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "AnimationState_addBoneMask,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    (arg1)->addBoneMask((std::string const &)*arg2);
    
    
    return true;
}

static bool js_dragonBones_AnimationState_addBoneMask(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_dragonBones_AnimationState_addBoneMask__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_dragonBones_AnimationState_addBoneMask__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_addBoneMask) 

static bool js_dragonBones_AnimationState_removeBoneMask__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    std::string *arg2 = 0 ;
    bool arg3 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "AnimationState_removeBoneMask,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "AnimationState_removeBoneMask,3,SWIGTYPE_bool"); 
    (arg1)->removeBoneMask((std::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_dragonBones_AnimationState_removeBoneMask__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "AnimationState_removeBoneMask,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    (arg1)->removeBoneMask((std::string const &)*arg2);
    
    
    return true;
}

static bool js_dragonBones_AnimationState_removeBoneMask(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_dragonBones_AnimationState_removeBoneMask__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_dragonBones_AnimationState_removeBoneMask__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_removeBoneMask) 

static bool js_dragonBones_AnimationState_removeAllBoneMask(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->removeAllBoneMask();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_removeAllBoneMask) 

static bool js_dragonBones_AnimationState_isFadeIn(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((dragonBones::AnimationState const *)arg1)->isFadeIn();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_isFadeIn) 

static bool js_dragonBones_AnimationState_isFadeOut(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((dragonBones::AnimationState const *)arg1)->isFadeOut();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_isFadeOut) 

static bool js_dragonBones_AnimationState_isFadeComplete(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((dragonBones::AnimationState const *)arg1)->isFadeComplete();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_isFadeComplete) 

static bool js_dragonBones_AnimationState_isPlaying(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((dragonBones::AnimationState const *)arg1)->isPlaying();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_isPlaying) 

static bool js_dragonBones_AnimationState_isCompleted(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((dragonBones::AnimationState const *)arg1)->isCompleted();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_isCompleted) 

static bool js_dragonBones_AnimationState_getCurrentPlayTimes(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    unsigned int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (unsigned int)((dragonBones::AnimationState const *)arg1)->getCurrentPlayTimes();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_getCurrentPlayTimes) 

static bool js_dragonBones_AnimationState_getTotalTime(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)((dragonBones::AnimationState const *)arg1)->getTotalTime();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_getTotalTime) 

static bool js_dragonBones_AnimationState_getCurrentTime(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)((dragonBones::AnimationState const *)arg1)->getCurrentTime();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_getCurrentTime) 

static bool js_dragonBones_AnimationState_setCurrentTime(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState_setCurrentTime,2,SWIGTYPE_float"); 
    (arg1)->setCurrentTime(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_setCurrentTime) 

static bool js_dragonBones_AnimationState_getName(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    std::string *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (std::string *) &((dragonBones::AnimationState const *)arg1)->getName();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AnimationState_getName, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_getName) 

static bool js_dragonBones_AnimationState_getAnimationData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    dragonBones::AnimationData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::AnimationData *)((dragonBones::AnimationState const *)arg1)->getAnimationData();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AnimationState_getAnimationData, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_getAnimationData) 

bool js_register_dragonBones_AnimationState(se::Object* obj) {
    auto* cls = se::Class::create("AnimationState", obj, __jsb_dragonBones_BaseObject_proto, nullptr); 
    
    cls->defineProperty("actionEnabled", _SE(js_dragonBones_AnimationState_actionEnabled_get), _SE(js_dragonBones_AnimationState_actionEnabled_set)); 
    cls->defineProperty("additiveBlending", _SE(js_dragonBones_AnimationState_additiveBlending_get), _SE(js_dragonBones_AnimationState_additiveBlending_set)); 
    cls->defineProperty("displayControl", _SE(js_dragonBones_AnimationState_displayControl_get), _SE(js_dragonBones_AnimationState_displayControl_set)); 
    cls->defineProperty("resetToPose", _SE(js_dragonBones_AnimationState_resetToPose_get), _SE(js_dragonBones_AnimationState_resetToPose_set)); 
    cls->defineProperty("playTimes", _SE(js_dragonBones_AnimationState_playTimes_get), _SE(js_dragonBones_AnimationState_playTimes_set)); 
    cls->defineProperty("layer", _SE(js_dragonBones_AnimationState_layer_get), _SE(js_dragonBones_AnimationState_layer_set)); 
    cls->defineProperty("timeScale", _SE(js_dragonBones_AnimationState_timeScale_get), _SE(js_dragonBones_AnimationState_timeScale_set)); 
    cls->defineProperty("weight", _SE(js_dragonBones_AnimationState_weight_get), _SE(js_dragonBones_AnimationState_weight_set)); 
    cls->defineProperty("autoFadeOutTime", _SE(js_dragonBones_AnimationState_autoFadeOutTime_get), _SE(js_dragonBones_AnimationState_autoFadeOutTime_set)); 
    cls->defineProperty("fadeTotalTime", _SE(js_dragonBones_AnimationState_fadeTotalTime_get), _SE(js_dragonBones_AnimationState_fadeTotalTime_set)); 
    cls->defineProperty("name", _SE(js_dragonBones_AnimationState_name_get), _SE(js_dragonBones_AnimationState_name_set)); 
    cls->defineProperty("group", _SE(js_dragonBones_AnimationState_group_get), _SE(js_dragonBones_AnimationState_group_set)); 
    cls->defineProperty("_playheadState", _SE(js_dragonBones_AnimationState__playheadState_get), _SE(js_dragonBones_AnimationState__playheadState_set)); 
    cls->defineProperty("_fadeState", _SE(js_dragonBones_AnimationState__fadeState_get), _SE(js_dragonBones_AnimationState__fadeState_set)); 
    cls->defineProperty("_subFadeState", _SE(js_dragonBones_AnimationState__subFadeState_get), _SE(js_dragonBones_AnimationState__subFadeState_set)); 
    cls->defineProperty("_position", _SE(js_dragonBones_AnimationState__position_get), _SE(js_dragonBones_AnimationState__position_set)); 
    cls->defineProperty("_duration", _SE(js_dragonBones_AnimationState__duration_get), _SE(js_dragonBones_AnimationState__duration_set)); 
    cls->defineProperty("_fadeProgress", _SE(js_dragonBones_AnimationState__fadeProgress_get), _SE(js_dragonBones_AnimationState__fadeProgress_set)); 
    cls->defineProperty("_weightResult", _SE(js_dragonBones_AnimationState__weightResult_get), _SE(js_dragonBones_AnimationState__weightResult_set)); 
    cls->defineProperty("_animationData", _SE(js_dragonBones_AnimationState__animationData_get), _SE(js_dragonBones_AnimationState__animationData_set)); 
    
    cls->defineFunction("advanceTime", _SE(js_dragonBones_AnimationState_advanceTime)); 
    cls->defineFunction("play", _SE(js_dragonBones_AnimationState_play)); 
    cls->defineFunction("stop", _SE(js_dragonBones_AnimationState_stop)); 
    cls->defineFunction("fadeOut", _SE(js_dragonBones_AnimationState_fadeOut)); 
    cls->defineFunction("containsBoneMask", _SE(js_dragonBones_AnimationState_containsBoneMask)); 
    cls->defineFunction("addBoneMask", _SE(js_dragonBones_AnimationState_addBoneMask)); 
    cls->defineFunction("removeBoneMask", _SE(js_dragonBones_AnimationState_removeBoneMask)); 
    cls->defineFunction("removeAllBoneMask", _SE(js_dragonBones_AnimationState_removeAllBoneMask)); 
    cls->defineFunction("isFadeIn", _SE(js_dragonBones_AnimationState_isFadeIn)); 
    cls->defineFunction("isFadeOut", _SE(js_dragonBones_AnimationState_isFadeOut)); 
    cls->defineFunction("isFadeComplete", _SE(js_dragonBones_AnimationState_isFadeComplete)); 
    cls->defineFunction("isPlaying", _SE(js_dragonBones_AnimationState_isPlaying)); 
    cls->defineFunction("isCompleted", _SE(js_dragonBones_AnimationState_isCompleted)); 
    cls->defineFunction("getCurrentPlayTimes", _SE(js_dragonBones_AnimationState_getCurrentPlayTimes)); 
    cls->defineFunction("getTotalTime", _SE(js_dragonBones_AnimationState_getTotalTime)); 
    cls->defineFunction("getCurrentTime", _SE(js_dragonBones_AnimationState_getCurrentTime)); 
    cls->defineFunction("setCurrentTime", _SE(js_dragonBones_AnimationState_setCurrentTime)); 
    cls->defineFunction("getName", _SE(js_dragonBones_AnimationState_getName)); 
    cls->defineFunction("getAnimationData", _SE(js_dragonBones_AnimationState_getAnimationData)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_AnimationState));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::AnimationState>(cls);
    
    __jsb_dragonBones_AnimationState_proto = cls->getProto();
    __jsb_dragonBones_AnimationState_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_BonePose_class = nullptr;
se::Object* __jsb_dragonBones_BonePose_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_BonePose) 

static bool js_dragonBones_BonePose_getTypeIndex_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    std::size_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = dragonBones::BonePose::getTypeIndex();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BonePose_getTypeIndex, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_BonePose_getTypeIndex_static) 

// js_ctor
static bool js_new_dragonBones_BonePose(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    dragonBones::BonePose *result;
    result = (dragonBones::BonePose *)new dragonBones::BonePose();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_dragonBones_BonePose, __jsb_dragonBones_BonePose_class, js_delete_dragonBones_BonePose)

static bool js_delete_dragonBones_BonePose(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_BonePose) 

static bool js_dragonBones_BonePose_current_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BonePose *arg1 = (dragonBones::BonePose *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BonePose>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->current, s.thisObject());
    SE_PRECONDITION2(ok, false, "BonePose_current_set,2,SWIGTYPE_dragonBones__Transform"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BonePose_current_set) 

static bool js_dragonBones_BonePose_current_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BonePose *arg1 = (dragonBones::BonePose *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BonePose>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->current, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BonePose_current_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->current, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BonePose_current_get) 

static bool js_dragonBones_BonePose_delta_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BonePose *arg1 = (dragonBones::BonePose *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BonePose>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->delta, s.thisObject());
    SE_PRECONDITION2(ok, false, "BonePose_delta_set,2,SWIGTYPE_dragonBones__Transform"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BonePose_delta_set) 

static bool js_dragonBones_BonePose_delta_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BonePose *arg1 = (dragonBones::BonePose *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BonePose>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->delta, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BonePose_delta_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->delta, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BonePose_delta_get) 

static bool js_dragonBones_BonePose_result_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BonePose *arg1 = (dragonBones::BonePose *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BonePose>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->result, s.thisObject());
    SE_PRECONDITION2(ok, false, "BonePose_result_set,2,SWIGTYPE_dragonBones__Transform"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BonePose_result_set) 

static bool js_dragonBones_BonePose_result_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BonePose *arg1 = (dragonBones::BonePose *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BonePose>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BonePose_result_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BonePose_result_get) 

bool js_register_dragonBones_BonePose(se::Object* obj) {
    auto* cls = se::Class::create("BonePose", obj, __jsb_dragonBones_BaseObject_proto, _SE(js_new_dragonBones_BonePose)); 
    
    cls->defineProperty("current", _SE(js_dragonBones_BonePose_current_get), _SE(js_dragonBones_BonePose_current_set)); 
    cls->defineProperty("delta", _SE(js_dragonBones_BonePose_delta_get), _SE(js_dragonBones_BonePose_delta_set)); 
    cls->defineProperty("result", _SE(js_dragonBones_BonePose_result_get), _SE(js_dragonBones_BonePose_result_set)); 
    
    
    
    cls->defineStaticFunction("getTypeIndex", _SE(js_dragonBones_BonePose_getTypeIndex_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_BonePose));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::BonePose>(cls);
    
    __jsb_dragonBones_BonePose_proto = cls->getProto();
    __jsb_dragonBones_BonePose_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_BlendState_class = nullptr;
se::Object* __jsb_dragonBones_BlendState_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_BlendState) 

static bool js_dragonBones_BlendState_dirty_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BlendState *arg1 = (dragonBones::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BlendState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->dirty);
    SE_PRECONDITION2(ok, false, "BlendState_dirty_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BlendState_dirty_set) 

static bool js_dragonBones_BlendState_dirty_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BlendState *arg1 = (dragonBones::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BlendState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->dirty, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BlendState_dirty_get) 

static bool js_dragonBones_BlendState_layer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BlendState *arg1 = (dragonBones::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BlendState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->layer, nullptr);
    SE_PRECONDITION2(ok, false, "BlendState_layer_set,2,SWIGTYPE_int"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BlendState_layer_set) 

static bool js_dragonBones_BlendState_layer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BlendState *arg1 = (dragonBones::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BlendState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->layer, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BlendState_layer_get) 

static bool js_dragonBones_BlendState_leftWeight_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BlendState *arg1 = (dragonBones::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BlendState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->leftWeight, nullptr);
    SE_PRECONDITION2(ok, false, "BlendState_leftWeight_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BlendState_leftWeight_set) 

static bool js_dragonBones_BlendState_leftWeight_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BlendState *arg1 = (dragonBones::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BlendState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->leftWeight, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BlendState_leftWeight_get) 

static bool js_dragonBones_BlendState_layerWeight_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BlendState *arg1 = (dragonBones::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BlendState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->layerWeight, nullptr);
    SE_PRECONDITION2(ok, false, "BlendState_layerWeight_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BlendState_layerWeight_set) 

static bool js_dragonBones_BlendState_layerWeight_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BlendState *arg1 = (dragonBones::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BlendState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->layerWeight, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BlendState_layerWeight_get) 

static bool js_dragonBones_BlendState_blendWeight_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BlendState *arg1 = (dragonBones::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BlendState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->blendWeight, nullptr);
    SE_PRECONDITION2(ok, false, "BlendState_blendWeight_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BlendState_blendWeight_set) 

static bool js_dragonBones_BlendState_blendWeight_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BlendState *arg1 = (dragonBones::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BlendState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->blendWeight, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BlendState_blendWeight_get) 

static bool js_dragonBones_BlendState_update(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BlendState *arg1 = (dragonBones::BlendState *) NULL ;
    float arg2 ;
    int arg3 ;
    int result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::BlendState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "BlendState_update,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "BlendState_update,3,SWIGTYPE_int"); 
    result = (int)(arg1)->update(arg2,arg3);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_BlendState_update) 

static bool js_dragonBones_BlendState_clear(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BlendState *arg1 = (dragonBones::BlendState *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::BlendState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->clear();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_BlendState_clear) 

// js_ctor
static bool js_new_dragonBones_BlendState(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    dragonBones::BlendState *result;
    result = (dragonBones::BlendState *)new dragonBones::BlendState();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_dragonBones_BlendState, __jsb_dragonBones_BlendState_class, js_delete_dragonBones_BlendState)

static bool js_delete_dragonBones_BlendState(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_BlendState) 

bool js_register_dragonBones_BlendState(se::Object* obj) {
    auto* cls = se::Class::create("BlendState", obj, nullptr, _SE(js_new_dragonBones_BlendState)); 
    
    cls->defineProperty("dirty", _SE(js_dragonBones_BlendState_dirty_get), _SE(js_dragonBones_BlendState_dirty_set)); 
    cls->defineProperty("layer", _SE(js_dragonBones_BlendState_layer_get), _SE(js_dragonBones_BlendState_layer_set)); 
    cls->defineProperty("leftWeight", _SE(js_dragonBones_BlendState_leftWeight_get), _SE(js_dragonBones_BlendState_leftWeight_set)); 
    cls->defineProperty("layerWeight", _SE(js_dragonBones_BlendState_layerWeight_get), _SE(js_dragonBones_BlendState_layerWeight_set)); 
    cls->defineProperty("blendWeight", _SE(js_dragonBones_BlendState_blendWeight_get), _SE(js_dragonBones_BlendState_blendWeight_set)); 
    
    cls->defineFunction("update", _SE(js_dragonBones_BlendState_update)); 
    cls->defineFunction("clear", _SE(js_dragonBones_BlendState_clear)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_BlendState));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::BlendState>(cls);
    
    __jsb_dragonBones_BlendState_proto = cls->getProto();
    __jsb_dragonBones_BlendState_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_TransformObject_class = nullptr;
se::Object* __jsb_dragonBones_TransformObject_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_TransformObject) 

static bool js_delete_dragonBones_TransformObject(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_TransformObject) 

static bool js_dragonBones_TransformObject_globalTransformMatrix_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->globalTransformMatrix, s.thisObject());
    SE_PRECONDITION2(ok, false, "TransformObject_globalTransformMatrix_set,2,SWIGTYPE_dragonBones__Matrix"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_TransformObject_globalTransformMatrix_set) 

static bool js_dragonBones_TransformObject_globalTransformMatrix_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->globalTransformMatrix, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TransformObject_globalTransformMatrix_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->globalTransformMatrix, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_TransformObject_globalTransformMatrix_get) 

static bool js_dragonBones_TransformObject_global_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->global, s.thisObject());
    SE_PRECONDITION2(ok, false, "TransformObject_global_set,2,SWIGTYPE_dragonBones__Transform"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_TransformObject_global_set) 

static bool js_dragonBones_TransformObject_global_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->global, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TransformObject_global_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->global, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_TransformObject_global_get) 

static bool js_dragonBones_TransformObject_offset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->offset, s.thisObject());
    SE_PRECONDITION2(ok, false, "TransformObject_offset_set,2,SWIGTYPE_dragonBones__Transform"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_TransformObject_offset_set) 

static bool js_dragonBones_TransformObject_offset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->offset, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TransformObject_offset_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->offset, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_TransformObject_offset_get) 

static bool js_dragonBones_TransformObject_origin_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->origin, s.thisObject());
    SE_PRECONDITION2(ok, false, "TransformObject_origin_set,2,SWIGTYPE_p_dragonBones__Transform"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_TransformObject_origin_set) 

static bool js_dragonBones_TransformObject_origin_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->origin, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TransformObject_origin_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->origin, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_TransformObject_origin_get) 

static bool js_dragonBones_TransformObject_userData_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    ok &= sevalue_to_native(args[0], &arg1->userData);
    SE_PRECONDITION2(ok, false, "TransformObject_userData_set,2,SWIGTYPE_p_void");
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_TransformObject_userData_set) 

static bool js_dragonBones_TransformObject_userData_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->userData, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TransformObject_userData_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->userData, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_TransformObject_userData_get) 

static bool js_dragonBones_TransformObject__armature_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->_armature, s.thisObject());
    SE_PRECONDITION2(ok, false, "TransformObject__armature_set,2,SWIGTYPE_p_dragonBones__Armature"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_TransformObject__armature_set) 

static bool js_dragonBones_TransformObject__armature_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->_armature, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TransformObject__armature_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_armature, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_TransformObject__armature_get) 

static bool js_dragonBones_TransformObject_updateGlobalTransform(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->updateGlobalTransform();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TransformObject_updateGlobalTransform) 

static bool js_dragonBones_TransformObject_getArmature(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    dragonBones::Armature *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::Armature *)((dragonBones::TransformObject const *)arg1)->getArmature();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TransformObject_getArmature, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TransformObject_getArmature) 

static bool js_dragonBones_TransformObject_getGlobalTransformMatrix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    dragonBones::Matrix *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::Matrix *)(arg1)->getGlobalTransformMatrix();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TransformObject_getGlobalTransformMatrix, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TransformObject_getGlobalTransformMatrix) 

static bool js_dragonBones_TransformObject_getGlobal(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    dragonBones::Transform *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::Transform *)(arg1)->getGlobal();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TransformObject_getGlobal, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TransformObject_getGlobal) 

static bool js_dragonBones_TransformObject_getOffset(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    dragonBones::Transform *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::Transform *)(arg1)->getOffset();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TransformObject_getOffset, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TransformObject_getOffset) 

static bool js_dragonBones_TransformObject_getOrigin(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    dragonBones::Transform *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::Transform *)((dragonBones::TransformObject const *)arg1)->getOrigin();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TransformObject_getOrigin, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TransformObject_getOrigin) 

bool js_register_dragonBones_TransformObject(se::Object* obj) {
    auto* cls = se::Class::create("TransformObject", obj, __jsb_dragonBones_BaseObject_proto, nullptr); 
    
    cls->defineProperty("globalTransformMatrix", _SE(js_dragonBones_TransformObject_globalTransformMatrix_get), _SE(js_dragonBones_TransformObject_globalTransformMatrix_set)); 
    cls->defineProperty("global", _SE(js_dragonBones_TransformObject_global_get), _SE(js_dragonBones_TransformObject_global_set)); 
    cls->defineProperty("offset", _SE(js_dragonBones_TransformObject_offset_get), _SE(js_dragonBones_TransformObject_offset_set)); 
    cls->defineProperty("origin", _SE(js_dragonBones_TransformObject_origin_get), _SE(js_dragonBones_TransformObject_origin_set)); 
    cls->defineProperty("userData", _SE(js_dragonBones_TransformObject_userData_get), _SE(js_dragonBones_TransformObject_userData_set)); 
    cls->defineProperty("_armature", _SE(js_dragonBones_TransformObject__armature_get), _SE(js_dragonBones_TransformObject__armature_set)); 
    
    cls->defineFunction("updateGlobalTransform", _SE(js_dragonBones_TransformObject_updateGlobalTransform)); 
    cls->defineFunction("getArmature", _SE(js_dragonBones_TransformObject_getArmature)); 
    cls->defineFunction("getGlobalTransformMatrix", _SE(js_dragonBones_TransformObject_getGlobalTransformMatrix)); 
    cls->defineFunction("getGlobal", _SE(js_dragonBones_TransformObject_getGlobal)); 
    cls->defineFunction("getOffset", _SE(js_dragonBones_TransformObject_getOffset)); 
    cls->defineFunction("getOrigin", _SE(js_dragonBones_TransformObject_getOrigin)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_TransformObject));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::TransformObject>(cls);
    
    __jsb_dragonBones_TransformObject_proto = cls->getProto();
    __jsb_dragonBones_TransformObject_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_Slot_class = nullptr;
se::Object* __jsb_dragonBones_Slot_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_Slot) 

static bool js_dragonBones_Slot_displayController_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->displayController, s.thisObject());
    SE_PRECONDITION2(ok, false, "Slot_displayController_set,2,SWIGTYPE_std__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Slot_displayController_set) 

static bool js_dragonBones_Slot_displayController_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->displayController, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Slot_displayController_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->displayController, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Slot_displayController_get) 

static bool js_dragonBones_Slot__zOrder_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->_zOrder, nullptr);
    SE_PRECONDITION2(ok, false, "Slot__zOrder_set,2,SWIGTYPE_int"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Slot__zOrder_set) 

static bool js_dragonBones_Slot__zOrder_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->_zOrder, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Slot__zOrder_get) 

static bool js_delete_dragonBones_Slot(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_Slot) 

static bool js_dragonBones_Slot__updateColor(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->_updateColor();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot__updateColor) 

static bool js_dragonBones_Slot__setZorder(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    int arg2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Slot__setZorder,2,SWIGTYPE_int"); 
    result = (bool)(arg1)->_setZorder(arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot__setZorder) 

static bool js_dragonBones_Slot_update(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Slot_update,2,SWIGTYPE_int"); 
    (arg1)->update(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_update) 

static bool js_dragonBones_Slot_updateTransformAndMatrix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->updateTransformAndMatrix();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_updateTransformAndMatrix) 

static bool js_dragonBones_Slot_containsPoint(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    float arg2 ;
    float arg3 ;
    bool result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Slot_containsPoint,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Slot_containsPoint,3,SWIGTYPE_float"); 
    result = (bool)(arg1)->containsPoint(arg2,arg3);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_containsPoint) 

static bool js_dragonBones_Slot_invalidUpdate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->invalidUpdate();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_invalidUpdate) 

static bool js_dragonBones_Slot_getVisible(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((dragonBones::Slot const *)arg1)->getVisible();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_getVisible) 

static bool js_dragonBones_Slot_setVisible(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Slot_setVisible,2,SWIGTYPE_bool"); 
    (arg1)->setVisible(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_setVisible) 

static bool js_dragonBones_Slot_getDisplayIndex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)((dragonBones::Slot const *)arg1)->getDisplayIndex();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_getDisplayIndex) 

static bool js_dragonBones_Slot_setDisplayIndex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Slot_setDisplayIndex,2,SWIGTYPE_int"); 
    (arg1)->setDisplayIndex(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_setDisplayIndex) 

static bool js_dragonBones_Slot_getName(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    std::string *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (std::string *) &((dragonBones::Slot const *)arg1)->getName();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Slot_getName, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_getName) 

static bool js_dragonBones_Slot_getRawDisplayDatas(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    std::vector< dragonBones::DisplayData * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (std::vector< dragonBones::DisplayData * > *)((dragonBones::Slot const *)arg1)->getRawDisplayDatas();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Slot_getRawDisplayDatas, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_getRawDisplayDatas) 

static bool js_dragonBones_Slot_getSlotData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    dragonBones::SlotData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::SlotData *)((dragonBones::Slot const *)arg1)->getSlotData();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Slot_getSlotData, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_getSlotData) 

static bool js_dragonBones_Slot_getBoundingBoxData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    dragonBones::BoundingBoxData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::BoundingBoxData *)((dragonBones::Slot const *)arg1)->getBoundingBoxData();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Slot_getBoundingBoxData, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_getBoundingBoxData) 

static bool js_dragonBones_Slot_getChildArmature(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    dragonBones::Armature *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::Armature *)((dragonBones::Slot const *)arg1)->getChildArmature();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Slot_getChildArmature, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_getChildArmature) 

static bool js_dragonBones_Slot_setChildArmature(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    dragonBones::Armature *arg2 = (dragonBones::Armature *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Slot_setChildArmature,2,SWIGTYPE_p_dragonBones__Armature"); 
    (arg1)->setChildArmature(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_setChildArmature) 

static bool js_dragonBones_Slot_getParent(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    dragonBones::Bone *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::Bone *)((dragonBones::Slot const *)arg1)->getParent();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Slot_getParent, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_getParent) 

bool js_register_dragonBones_Slot(se::Object* obj) {
    auto* cls = se::Class::create("Slot", obj, __jsb_dragonBones_TransformObject_proto, nullptr); 
    
    cls->defineProperty("displayController", _SE(js_dragonBones_Slot_displayController_get), _SE(js_dragonBones_Slot_displayController_set)); 
    cls->defineProperty("_zOrder", _SE(js_dragonBones_Slot__zOrder_get), _SE(js_dragonBones_Slot__zOrder_set)); 
    
    cls->defineFunction("_updateColor", _SE(js_dragonBones_Slot__updateColor)); 
    cls->defineFunction("_setZorder", _SE(js_dragonBones_Slot__setZorder)); 
    cls->defineFunction("update", _SE(js_dragonBones_Slot_update)); 
    cls->defineFunction("updateTransformAndMatrix", _SE(js_dragonBones_Slot_updateTransformAndMatrix)); 
    cls->defineFunction("containsPoint", _SE(js_dragonBones_Slot_containsPoint)); 
    cls->defineFunction("invalidUpdate", _SE(js_dragonBones_Slot_invalidUpdate)); 
    cls->defineFunction("getVisible", _SE(js_dragonBones_Slot_getVisible)); 
    cls->defineFunction("setVisible", _SE(js_dragonBones_Slot_setVisible)); 
    cls->defineFunction("getDisplayIndex", _SE(js_dragonBones_Slot_getDisplayIndex)); 
    cls->defineFunction("setDisplayIndex", _SE(js_dragonBones_Slot_setDisplayIndex)); 
    cls->defineFunction("getName", _SE(js_dragonBones_Slot_getName)); 
    cls->defineFunction("getRawDisplayDatas", _SE(js_dragonBones_Slot_getRawDisplayDatas)); 
    cls->defineFunction("getSlotData", _SE(js_dragonBones_Slot_getSlotData)); 
    cls->defineFunction("getBoundingBoxData", _SE(js_dragonBones_Slot_getBoundingBoxData)); 
    cls->defineFunction("getChildArmature", _SE(js_dragonBones_Slot_getChildArmature)); 
    cls->defineFunction("setChildArmature", _SE(js_dragonBones_Slot_setChildArmature)); 
    cls->defineFunction("getParent", _SE(js_dragonBones_Slot_getParent)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_Slot));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::Slot>(cls);
    
    __jsb_dragonBones_Slot_proto = cls->getProto();
    __jsb_dragonBones_Slot_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_Bone_class = nullptr;
se::Object* __jsb_dragonBones_Bone_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_Bone) 

static bool js_delete_dragonBones_Bone(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_Bone) 

static bool js_dragonBones_Bone_offsetMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "Bone_offsetMode_set,2,SWIGTYPE_dragonBones__OffsetMode");
    arg1->offsetMode = (dragonBones::OffsetMode)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Bone_offsetMode_set) 

static bool js_dragonBones_Bone_offsetMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->offsetMode));
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Bone_offsetMode_get) 

static bool js_dragonBones_Bone_animationPose_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->animationPose, s.thisObject());
    SE_PRECONDITION2(ok, false, "Bone_animationPose_set,2,SWIGTYPE_dragonBones__Transform"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Bone_animationPose_set) 

static bool js_dragonBones_Bone_animationPose_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->animationPose, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Bone_animationPose_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->animationPose, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Bone_animationPose_get) 

static bool js_dragonBones_Bone__transformDirty_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->_transformDirty);
    SE_PRECONDITION2(ok, false, "Bone__transformDirty_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Bone__transformDirty_set) 

static bool js_dragonBones_Bone__transformDirty_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->_transformDirty, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Bone__transformDirty_get) 

static bool js_dragonBones_Bone__childrenTransformDirty_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->_childrenTransformDirty);
    SE_PRECONDITION2(ok, false, "Bone__childrenTransformDirty_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Bone__childrenTransformDirty_set) 

static bool js_dragonBones_Bone__childrenTransformDirty_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->_childrenTransformDirty, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Bone__childrenTransformDirty_get) 

static bool js_dragonBones_Bone__hasConstraint_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->_hasConstraint);
    SE_PRECONDITION2(ok, false, "Bone__hasConstraint_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Bone__hasConstraint_set) 

static bool js_dragonBones_Bone__hasConstraint_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->_hasConstraint, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Bone__hasConstraint_get) 

static bool js_dragonBones_Bone__blendState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_blendState, s.thisObject());
    SE_PRECONDITION2(ok, false, "Bone__blendState_set,2,SWIGTYPE_dragonBones__BlendState"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Bone__blendState_set) 

static bool js_dragonBones_Bone__blendState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_blendState, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Bone__blendState_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_blendState, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Bone__blendState_get) 

static bool js_dragonBones_Bone__boneData_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->_boneData, s.thisObject());
    SE_PRECONDITION2(ok, false, "Bone__boneData_set,2,SWIGTYPE_p_dragonBones__BoneData"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Bone__boneData_set) 

static bool js_dragonBones_Bone__boneData_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->_boneData, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Bone__boneData_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_boneData, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Bone__boneData_get) 

static bool js_dragonBones_Bone_init(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    dragonBones::BoneData *arg2 = (dragonBones::BoneData *) NULL ;
    dragonBones::Armature *arg3 = (dragonBones::Armature *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Bone_init,2,SWIGTYPE_p_dragonBones__BoneData"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Bone_init,3,SWIGTYPE_p_dragonBones__Armature"); 
    (arg1)->init((dragonBones::BoneData const *)arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Bone_init) 

static bool js_dragonBones_Bone_update(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_update,2,SWIGTYPE_int"); 
    (arg1)->update(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Bone_update) 

static bool js_dragonBones_Bone_updateByConstraint(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->updateByConstraint();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Bone_updateByConstraint) 

static bool js_dragonBones_Bone_invalidUpdate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->invalidUpdate();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Bone_invalidUpdate) 

static bool js_dragonBones_Bone_contains(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    dragonBones::Bone *arg2 = (dragonBones::Bone *) NULL ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Bone_contains,2,SWIGTYPE_p_dragonBones__Bone"); 
    result = (bool)((dragonBones::Bone const *)arg1)->contains((dragonBones::Bone const *)arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Bone_contains) 

static bool js_dragonBones_Bone_getBoneData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    dragonBones::BoneData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::BoneData *)((dragonBones::Bone const *)arg1)->getBoneData();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Bone_getBoneData, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Bone_getBoneData) 

static bool js_dragonBones_Bone_getVisible(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((dragonBones::Bone const *)arg1)->getVisible();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Bone_getVisible) 

static bool js_dragonBones_Bone_setVisible(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Bone_setVisible,2,SWIGTYPE_bool"); 
    (arg1)->setVisible(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Bone_setVisible) 

static bool js_dragonBones_Bone_getName(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    std::string *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (std::string *) &((dragonBones::Bone const *)arg1)->getName();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Bone_getName, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Bone_getName) 

static bool js_dragonBones_Bone_getParent(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    dragonBones::Bone *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::Bone *)((dragonBones::Bone const *)arg1)->getParent();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Bone_getParent, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Bone_getParent) 

static bool js_dragonBones_Bone_getOffsetMode(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)((dragonBones::Bone const *)arg1)->getOffsetMode();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Bone_getOffsetMode) 

static bool js_dragonBones_Bone_setOffsetMode(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_setOffsetMode,2,SWIGTYPE_int"); 
    (arg1)->setOffsetMode(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Bone_setOffsetMode) 

bool js_register_dragonBones_Bone(se::Object* obj) {
    auto* cls = se::Class::create("Bone", obj, __jsb_dragonBones_TransformObject_proto, nullptr); 
    
    cls->defineProperty("offsetMode", _SE(js_dragonBones_Bone_offsetMode_get), _SE(js_dragonBones_Bone_offsetMode_set)); 
    cls->defineProperty("animationPose", _SE(js_dragonBones_Bone_animationPose_get), _SE(js_dragonBones_Bone_animationPose_set)); 
    cls->defineProperty("_transformDirty", _SE(js_dragonBones_Bone__transformDirty_get), _SE(js_dragonBones_Bone__transformDirty_set)); 
    cls->defineProperty("_childrenTransformDirty", _SE(js_dragonBones_Bone__childrenTransformDirty_get), _SE(js_dragonBones_Bone__childrenTransformDirty_set)); 
    cls->defineProperty("_hasConstraint", _SE(js_dragonBones_Bone__hasConstraint_get), _SE(js_dragonBones_Bone__hasConstraint_set)); 
    cls->defineProperty("_blendState", _SE(js_dragonBones_Bone__blendState_get), _SE(js_dragonBones_Bone__blendState_set)); 
    cls->defineProperty("_boneData", _SE(js_dragonBones_Bone__boneData_get), _SE(js_dragonBones_Bone__boneData_set)); 
    
    cls->defineFunction("init", _SE(js_dragonBones_Bone_init)); 
    cls->defineFunction("update", _SE(js_dragonBones_Bone_update)); 
    cls->defineFunction("updateByConstraint", _SE(js_dragonBones_Bone_updateByConstraint)); 
    cls->defineFunction("invalidUpdate", _SE(js_dragonBones_Bone_invalidUpdate)); 
    cls->defineFunction("contains", _SE(js_dragonBones_Bone_contains)); 
    cls->defineFunction("getBoneData", _SE(js_dragonBones_Bone_getBoneData)); 
    cls->defineFunction("getVisible", _SE(js_dragonBones_Bone_getVisible)); 
    cls->defineFunction("setVisible", _SE(js_dragonBones_Bone_setVisible)); 
    cls->defineFunction("getName", _SE(js_dragonBones_Bone_getName)); 
    cls->defineFunction("getParent", _SE(js_dragonBones_Bone_getParent)); 
    cls->defineFunction("getOffsetMode", _SE(js_dragonBones_Bone_getOffsetMode)); 
    cls->defineFunction("setOffsetMode", _SE(js_dragonBones_Bone_setOffsetMode)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_Bone));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::Bone>(cls);
    
    __jsb_dragonBones_Bone_proto = cls->getProto();
    __jsb_dragonBones_Bone_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_Armature_class = nullptr;
se::Object* __jsb_dragonBones_Armature_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_Armature) 

static bool js_dragonBones_Armature_inheritAnimation_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->inheritAnimation);
    SE_PRECONDITION2(ok, false, "Armature_inheritAnimation_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Armature_inheritAnimation_set) 

static bool js_dragonBones_Armature_inheritAnimation_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->inheritAnimation, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Armature_inheritAnimation_get) 

static bool js_dragonBones_Armature_userData_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    ok &= sevalue_to_native(args[0], &arg1->userData);
    SE_PRECONDITION2(ok, false, "Armature_userData_set,2,SWIGTYPE_p_void");
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Armature_userData_set) 

static bool js_dragonBones_Armature_userData_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->userData, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Armature_userData_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->userData, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Armature_userData_get) 

static bool js_dragonBones_Armature__cacheFrameIndex_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->_cacheFrameIndex, nullptr);
    SE_PRECONDITION2(ok, false, "Armature__cacheFrameIndex_set,2,SWIGTYPE_int"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Armature__cacheFrameIndex_set) 

static bool js_dragonBones_Armature__cacheFrameIndex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->_cacheFrameIndex, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Armature__cacheFrameIndex_get) 

static bool js_dragonBones_Armature__armatureData_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->_armatureData, s.thisObject());
    SE_PRECONDITION2(ok, false, "Armature__armatureData_set,2,SWIGTYPE_p_dragonBones__ArmatureData"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Armature__armatureData_set) 

static bool js_dragonBones_Armature__armatureData_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->_armatureData, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Armature__armatureData_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_armatureData, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Armature__armatureData_get) 

static bool js_dragonBones_Armature__parent_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->_parent, s.thisObject());
    SE_PRECONDITION2(ok, false, "Armature__parent_set,2,SWIGTYPE_p_dragonBones__Slot"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Armature__parent_set) 

static bool js_dragonBones_Armature__parent_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->_parent, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Armature__parent_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_parent, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Armature__parent_get) 

static bool js_dragonBones_Armature__replaceTextureAtlasData_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->_replaceTextureAtlasData, s.thisObject());
    SE_PRECONDITION2(ok, false, "Armature__replaceTextureAtlasData_set,2,SWIGTYPE_p_dragonBones__TextureAtlasData"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Armature__replaceTextureAtlasData_set) 

static bool js_dragonBones_Armature__replaceTextureAtlasData_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->_replaceTextureAtlasData, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Armature__replaceTextureAtlasData_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_replaceTextureAtlasData, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Armature__replaceTextureAtlasData_get) 

static bool js_delete_dragonBones_Armature(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_Armature) 

static bool js_dragonBones_Armature__addBone(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    dragonBones::Bone *arg2 = (dragonBones::Bone *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Armature__addBone,2,SWIGTYPE_p_dragonBones__Bone"); 
    (arg1)->_addBone(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature__addBone) 

static bool js_dragonBones_Armature__addSlot(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    dragonBones::Slot *arg2 = (dragonBones::Slot *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Armature__addSlot,2,SWIGTYPE_p_dragonBones__Slot"); 
    (arg1)->_addSlot(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature__addSlot) 

static bool js_dragonBones_Armature__bufferAction(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    dragonBones::EventObject *arg2 = (dragonBones::EventObject *) NULL ;
    bool arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Armature__bufferAction,2,SWIGTYPE_p_dragonBones__EventObject"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "Armature__bufferAction,3,SWIGTYPE_bool"); 
    (arg1)->_bufferAction(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature__bufferAction) 

static bool js_dragonBones_Armature_dispose(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->dispose();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_dispose) 

static bool js_dragonBones_Armature_advanceTime(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Armature_advanceTime,2,SWIGTYPE_float"); 
    (arg1)->advanceTime(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_advanceTime) 

static bool js_dragonBones_Armature_render(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->render();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_render) 

static bool js_dragonBones_Armature_invalidUpdate__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    std::string *arg2 = 0 ;
    bool arg3 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Armature_invalidUpdate,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "Armature_invalidUpdate,3,SWIGTYPE_bool"); 
    (arg1)->invalidUpdate((std::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_dragonBones_Armature_invalidUpdate__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Armature_invalidUpdate,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    (arg1)->invalidUpdate((std::string const &)*arg2);
    
    
    return true;
}

static bool js_dragonBones_Armature_invalidUpdate__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->invalidUpdate();
    
    
    return true;
}

static bool js_dragonBones_Armature_invalidUpdate(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_dragonBones_Armature_invalidUpdate__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_dragonBones_Armature_invalidUpdate__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 0) {
        ok = js_dragonBones_Armature_invalidUpdate__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_Armature_invalidUpdate) 

static bool js_dragonBones_Armature_containsPoint(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    float arg2 ;
    float arg3 ;
    dragonBones::Slot *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Armature_containsPoint,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Armature_containsPoint,3,SWIGTYPE_float"); 
    result = (dragonBones::Slot *)((dragonBones::Armature const *)arg1)->containsPoint(arg2,arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Armature_containsPoint, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_containsPoint) 

static bool js_dragonBones_Armature_getBone(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::Bone *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Armature_getBone,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (dragonBones::Bone *)((dragonBones::Armature const *)arg1)->getBone((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Armature_getBone, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_getBone) 

static bool js_dragonBones_Armature_getSlot(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::Slot *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Armature_getSlot,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (dragonBones::Slot *)((dragonBones::Armature const *)arg1)->getSlot((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Armature_getSlot, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_getSlot) 

static bool js_dragonBones_Armature_getFlipX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((dragonBones::Armature const *)arg1)->getFlipX();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_getFlipX) 

static bool js_dragonBones_Armature_setFlipX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Armature_setFlipX,2,SWIGTYPE_bool"); 
    (arg1)->setFlipX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_setFlipX) 

static bool js_dragonBones_Armature_getFlipY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((dragonBones::Armature const *)arg1)->getFlipY();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_getFlipY) 

static bool js_dragonBones_Armature_setFlipY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Armature_setFlipY,2,SWIGTYPE_bool"); 
    (arg1)->setFlipY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_setFlipY) 

static bool js_dragonBones_Armature_getCacheFrameRate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    unsigned int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (unsigned int)((dragonBones::Armature const *)arg1)->getCacheFrameRate();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_getCacheFrameRate) 

static bool js_dragonBones_Armature_setCacheFrameRate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    unsigned int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Armature_setCacheFrameRate,2,SWIGTYPE_unsigned_int");
    
    (arg1)->setCacheFrameRate(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_setCacheFrameRate) 

static bool js_dragonBones_Armature_getName(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    std::string *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (std::string *) &((dragonBones::Armature const *)arg1)->getName();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Armature_getName, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_getName) 

static bool js_dragonBones_Armature_getArmatureData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    dragonBones::ArmatureData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::ArmatureData *)((dragonBones::Armature const *)arg1)->getArmatureData();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Armature_getArmatureData, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_getArmatureData) 

static bool js_dragonBones_Armature_getAnimation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    dragonBones::Animation *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::Animation *)((dragonBones::Armature const *)arg1)->getAnimation();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Armature_getAnimation, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_getAnimation) 

static bool js_dragonBones_Armature_getProxy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    dragonBones::IArmatureProxy *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::IArmatureProxy *)((dragonBones::Armature const *)arg1)->getProxy();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Armature_getProxy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_getProxy) 

static bool js_dragonBones_Armature_getEventDispatcher(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    dragonBones::IEventDispatcher *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::IEventDispatcher *)((dragonBones::Armature const *)arg1)->getEventDispatcher();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Armature_getEventDispatcher, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_getEventDispatcher) 

static bool js_dragonBones_Armature_getClock(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    dragonBones::WorldClock *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::WorldClock *)((dragonBones::Armature const *)arg1)->getClock();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Armature_getClock, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_getClock) 

static bool js_dragonBones_Armature_setClock(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    dragonBones::WorldClock *arg2 = (dragonBones::WorldClock *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Armature_setClock,2,SWIGTYPE_p_dragonBones__WorldClock"); 
    (arg1)->setClock(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_setClock) 

static bool js_dragonBones_Armature_getParent(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    dragonBones::Slot *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::Slot *)((dragonBones::Armature const *)arg1)->getParent();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Armature_getParent, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_getParent) 

bool js_register_dragonBones_Armature(se::Object* obj) {
    auto* cls = se::Class::create("Armature", obj, __jsb_dragonBones_BaseObject_proto, nullptr); 
    
    cls->defineProperty("inheritAnimation", _SE(js_dragonBones_Armature_inheritAnimation_get), _SE(js_dragonBones_Armature_inheritAnimation_set)); 
    cls->defineProperty("userData", _SE(js_dragonBones_Armature_userData_get), _SE(js_dragonBones_Armature_userData_set)); 
    cls->defineProperty("_cacheFrameIndex", _SE(js_dragonBones_Armature__cacheFrameIndex_get), _SE(js_dragonBones_Armature__cacheFrameIndex_set)); 
    cls->defineProperty("_armatureData", _SE(js_dragonBones_Armature__armatureData_get), _SE(js_dragonBones_Armature__armatureData_set)); 
    cls->defineProperty("_parent", _SE(js_dragonBones_Armature__parent_get), _SE(js_dragonBones_Armature__parent_set)); 
    cls->defineProperty("_replaceTextureAtlasData", _SE(js_dragonBones_Armature__replaceTextureAtlasData_get), _SE(js_dragonBones_Armature__replaceTextureAtlasData_set)); 
    
    cls->defineFunction("_addBone", _SE(js_dragonBones_Armature__addBone)); 
    cls->defineFunction("_addSlot", _SE(js_dragonBones_Armature__addSlot)); 
    cls->defineFunction("_bufferAction", _SE(js_dragonBones_Armature__bufferAction)); 
    cls->defineFunction("dispose", _SE(js_dragonBones_Armature_dispose)); 
    cls->defineFunction("advanceTime", _SE(js_dragonBones_Armature_advanceTime)); 
    cls->defineFunction("render", _SE(js_dragonBones_Armature_render)); 
    cls->defineFunction("invalidUpdate", _SE(js_dragonBones_Armature_invalidUpdate)); 
    cls->defineFunction("containsPoint", _SE(js_dragonBones_Armature_containsPoint)); 
    cls->defineFunction("getBone", _SE(js_dragonBones_Armature_getBone)); 
    cls->defineFunction("getSlot", _SE(js_dragonBones_Armature_getSlot)); 
    cls->defineFunction("getFlipX", _SE(js_dragonBones_Armature_getFlipX)); 
    cls->defineFunction("setFlipX", _SE(js_dragonBones_Armature_setFlipX)); 
    cls->defineFunction("getFlipY", _SE(js_dragonBones_Armature_getFlipY)); 
    cls->defineFunction("setFlipY", _SE(js_dragonBones_Armature_setFlipY)); 
    cls->defineFunction("getCacheFrameRate", _SE(js_dragonBones_Armature_getCacheFrameRate)); 
    cls->defineFunction("setCacheFrameRate", _SE(js_dragonBones_Armature_setCacheFrameRate)); 
    cls->defineFunction("getName", _SE(js_dragonBones_Armature_getName)); 
    cls->defineFunction("getArmatureData", _SE(js_dragonBones_Armature_getArmatureData)); 
    cls->defineFunction("getAnimation", _SE(js_dragonBones_Armature_getAnimation)); 
    cls->defineFunction("getProxy", _SE(js_dragonBones_Armature_getProxy)); 
    cls->defineFunction("getEventDispatcher", _SE(js_dragonBones_Armature_getEventDispatcher)); 
    cls->defineFunction("getClock", _SE(js_dragonBones_Armature_getClock)); 
    cls->defineFunction("setClock", _SE(js_dragonBones_Armature_setClock)); 
    cls->defineFunction("getParent", _SE(js_dragonBones_Armature_getParent)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_Armature));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::Armature>(cls);
    
    __jsb_dragonBones_Armature_proto = cls->getProto();
    __jsb_dragonBones_Armature_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_CCArmatureDisplay_class = nullptr;
se::Object* __jsb_dragonBones_CCArmatureDisplay_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_CCArmatureDisplay) 

static bool js_dragonBones_CCArmatureDisplay_create_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (dragonBones::CCArmatureDisplay *)dragonBones::CCArmatureDisplay::create();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CCArmatureDisplay_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_create_static) 

// js_ctor
static bool js_new_dragonBones_CCArmatureDisplay(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    dragonBones::CCArmatureDisplay *result;
    result = (dragonBones::CCArmatureDisplay *)new dragonBones::CCArmatureDisplay();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_dragonBones_CCArmatureDisplay, __jsb_dragonBones_CCArmatureDisplay_class, js_delete_dragonBones_CCArmatureDisplay)

static bool js_delete_dragonBones_CCArmatureDisplay(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_CCArmatureDisplay) 

static bool js_dragonBones_CCArmatureDisplay_dbInit(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    dragonBones::Armature *arg2 = (dragonBones::Armature *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCArmatureDisplay_dbInit,2,SWIGTYPE_p_dragonBones__Armature"); 
    (arg1)->dbInit(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_dbInit) 

static bool js_dragonBones_CCArmatureDisplay_dbClear(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->dbClear();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_dbClear) 

static bool js_dragonBones_CCArmatureDisplay_dbUpdate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->dbUpdate();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_dbUpdate) 

static bool js_dragonBones_CCArmatureDisplay_dbRender(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->dbRender();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_dbRender) 

static bool js_dragonBones_CCArmatureDisplay_dispose(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->dispose();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_dispose) 

static bool js_dragonBones_CCArmatureDisplay_hasDBEventListener(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCArmatureDisplay_hasDBEventListener,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (bool)((dragonBones::CCArmatureDisplay const *)arg1)->hasDBEventListener((std::string const &)*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_hasDBEventListener) 

static bool js_dragonBones_CCArmatureDisplay_dispatchDBEvent(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    std::string *arg2 = 0 ;
    dragonBones::EventObject *arg3 = (dragonBones::EventObject *) NULL ;
    std::string temp2 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCArmatureDisplay_dispatchDBEvent,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCArmatureDisplay_dispatchDBEvent,3,SWIGTYPE_p_dragonBones__EventObject"); 
    (arg1)->dispatchDBEvent((std::string const &)*arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_dispatchDBEvent) 

static bool js_dragonBones_CCArmatureDisplay_addDBEventListener(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    std::string *arg2 = 0 ;
    std::function< void (dragonBones::EventObject *) > *arg3 = 0 ;
    std::string temp2 ;
    std::function< void (dragonBones::EventObject *) > temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCArmatureDisplay_addDBEventListener,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCArmatureDisplay_addDBEventListener,3,SWIGTYPE_p_std__functionT_void_fdragonBones__EventObject_pF_t");
    arg3 = &temp3;
    
    (arg1)->addDBEventListener((std::string const &)*arg2,(std::function< void (dragonBones::EventObject *) > const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_addDBEventListener) 

static bool js_dragonBones_CCArmatureDisplay_removeDBEventListener(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    std::string *arg2 = 0 ;
    std::function< void (dragonBones::EventObject *) > *arg3 = 0 ;
    std::string temp2 ;
    std::function< void (dragonBones::EventObject *) > temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCArmatureDisplay_removeDBEventListener,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCArmatureDisplay_removeDBEventListener,3,SWIGTYPE_p_std__functionT_void_fdragonBones__EventObject_pF_t");
    arg3 = &temp3;
    
    (arg1)->removeDBEventListener((std::string const &)*arg2,(std::function< void (dragonBones::EventObject *) > const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_removeDBEventListener) 

static bool js_dragonBones_CCArmatureDisplay_setDBEventCallback(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    dragonBones::CCArmatureDisplay::dbEventCallback arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCArmatureDisplay_setDBEventCallback,2,SWIGTYPE_std__functionT_void_fdragonBones__EventObject_pF_t"); 
    
    (arg1)->setDBEventCallback(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_setDBEventCallback) 

static bool js_dragonBones_CCArmatureDisplay_armature(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    dragonBones::Armature *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::Armature *)((dragonBones::CCArmatureDisplay const *)arg1)->getArmature();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CCArmatureDisplay_armature, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_armature) 

static bool js_dragonBones_CCArmatureDisplay_getAnimation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    dragonBones::Animation *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::Animation *)((dragonBones::CCArmatureDisplay const *)arg1)->getAnimation();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CCArmatureDisplay_getAnimation, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_getAnimation) 

static bool js_dragonBones_CCArmatureDisplay_getDebugData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    se_object_ptr result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((dragonBones::CCArmatureDisplay const *)arg1)->getDebugData();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CCArmatureDisplay_getDebugData, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_getDebugData) 

static bool js_dragonBones_CCArmatureDisplay_getSharedBufferOffset(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    se_object_ptr result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((dragonBones::CCArmatureDisplay const *)arg1)->getSharedBufferOffset();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CCArmatureDisplay_getSharedBufferOffset, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_getSharedBufferOffset) 

static bool js_dragonBones_CCArmatureDisplay_getParamsBuffer(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    se_object_ptr result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((dragonBones::CCArmatureDisplay const *)arg1)->getParamsBuffer();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CCArmatureDisplay_getParamsBuffer, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_getParamsBuffer) 

static bool js_dragonBones_CCArmatureDisplay_setColor(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "CCArmatureDisplay_setColor,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "CCArmatureDisplay_setColor,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "CCArmatureDisplay_setColor,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "CCArmatureDisplay_setColor,5,SWIGTYPE_float"); 
    (arg1)->setColor(arg2,arg3,arg4,arg5);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_setColor) 

static bool js_dragonBones_CCArmatureDisplay_setDebugBonesEnabled(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "CCArmatureDisplay_setDebugBonesEnabled,2,SWIGTYPE_bool"); 
    (arg1)->setDebugBonesEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_setDebugBonesEnabled) 

static bool js_dragonBones_CCArmatureDisplay_setBatchEnabled(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "CCArmatureDisplay_setBatchEnabled,2,SWIGTYPE_bool"); 
    (arg1)->setBatchEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_setBatchEnabled) 

static bool js_dragonBones_CCArmatureDisplay_setAttachEnabled(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "CCArmatureDisplay_setAttachEnabled,2,SWIGTYPE_bool"); 
    (arg1)->setAttachEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_setAttachEnabled) 

static bool js_dragonBones_CCArmatureDisplay_setOpacityModifyRGB(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "CCArmatureDisplay_setOpacityModifyRGB,2,SWIGTYPE_bool"); 
    (arg1)->setOpacityModifyRGB(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_setOpacityModifyRGB) 

static bool js_dragonBones_CCArmatureDisplay_convertToRootSpace(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    float arg2 ;
    float arg3 ;
    cc::Vec2 *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "CCArmatureDisplay_convertToRootSpace,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "CCArmatureDisplay_convertToRootSpace,3,SWIGTYPE_float"); 
    result = (cc::Vec2 *) &((dragonBones::CCArmatureDisplay const *)arg1)->convertToRootSpace(arg2,arg3);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CCArmatureDisplay_convertToRootSpace, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_convertToRootSpace) 

static bool js_dragonBones_CCArmatureDisplay_getRootDisplay(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    dragonBones::CCArmatureDisplay *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::CCArmatureDisplay *)(arg1)->getRootDisplay();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CCArmatureDisplay_getRootDisplay, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_getRootDisplay) 

bool js_register_dragonBones_CCArmatureDisplay(se::Object* obj) {
    auto* cls = se::Class::create("CCArmatureDisplay", obj, nullptr, _SE(js_new_dragonBones_CCArmatureDisplay)); 
    
    
    cls->defineFunction("dbInit", _SE(js_dragonBones_CCArmatureDisplay_dbInit)); 
    cls->defineFunction("dbClear", _SE(js_dragonBones_CCArmatureDisplay_dbClear)); 
    cls->defineFunction("dbUpdate", _SE(js_dragonBones_CCArmatureDisplay_dbUpdate)); 
    cls->defineFunction("dbRender", _SE(js_dragonBones_CCArmatureDisplay_dbRender)); 
    cls->defineFunction("dispose", _SE(js_dragonBones_CCArmatureDisplay_dispose)); 
    cls->defineFunction("hasDBEventListener", _SE(js_dragonBones_CCArmatureDisplay_hasDBEventListener)); 
    cls->defineFunction("dispatchDBEvent", _SE(js_dragonBones_CCArmatureDisplay_dispatchDBEvent)); 
    cls->defineFunction("addDBEventListener", _SE(js_dragonBones_CCArmatureDisplay_addDBEventListener)); 
    cls->defineFunction("removeDBEventListener", _SE(js_dragonBones_CCArmatureDisplay_removeDBEventListener)); 
    cls->defineFunction("setDBEventCallback", _SE(js_dragonBones_CCArmatureDisplay_setDBEventCallback)); 
    cls->defineFunction("armature", _SE(js_dragonBones_CCArmatureDisplay_armature)); 
    cls->defineFunction("getAnimation", _SE(js_dragonBones_CCArmatureDisplay_getAnimation)); 
    cls->defineFunction("getDebugData", _SE(js_dragonBones_CCArmatureDisplay_getDebugData)); 
    cls->defineFunction("getSharedBufferOffset", _SE(js_dragonBones_CCArmatureDisplay_getSharedBufferOffset)); 
    cls->defineFunction("getParamsBuffer", _SE(js_dragonBones_CCArmatureDisplay_getParamsBuffer)); 
    cls->defineFunction("setColor", _SE(js_dragonBones_CCArmatureDisplay_setColor)); 
    cls->defineFunction("setDebugBonesEnabled", _SE(js_dragonBones_CCArmatureDisplay_setDebugBonesEnabled)); 
    cls->defineFunction("setBatchEnabled", _SE(js_dragonBones_CCArmatureDisplay_setBatchEnabled)); 
    cls->defineFunction("setAttachEnabled", _SE(js_dragonBones_CCArmatureDisplay_setAttachEnabled)); 
    cls->defineFunction("setOpacityModifyRGB", _SE(js_dragonBones_CCArmatureDisplay_setOpacityModifyRGB)); 
    cls->defineFunction("convertToRootSpace", _SE(js_dragonBones_CCArmatureDisplay_convertToRootSpace)); 
    cls->defineFunction("getRootDisplay", _SE(js_dragonBones_CCArmatureDisplay_getRootDisplay)); 
    
    
    cls->defineStaticFunction("create", _SE(js_dragonBones_CCArmatureDisplay_create_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_CCArmatureDisplay));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::CCArmatureDisplay>(cls);
    
    __jsb_dragonBones_CCArmatureDisplay_proto = cls->getProto();
    __jsb_dragonBones_CCArmatureDisplay_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_CCFactory_class = nullptr;
se::Object* __jsb_dragonBones_CCFactory_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_CCFactory) 

static bool js_dragonBones_CCFactory_isInit_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (bool)dragonBones::CCFactory::isInit();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_isInit_static) 

static bool js_dragonBones_CCFactory_getFactory_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCFactory *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (dragonBones::CCFactory *)dragonBones::CCFactory::getFactory();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CCFactory_getFactory, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_getFactory_static) 

static bool js_dragonBones_CCFactory_destroyFactory_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    dragonBones::CCFactory::destroyFactory();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_destroyFactory_static) 

// js_ctor
static bool js_new_dragonBones_CCFactory(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    dragonBones::CCFactory *result;
    result = (dragonBones::CCFactory *)new dragonBones::CCFactory();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_dragonBones_CCFactory, __jsb_dragonBones_CCFactory_class, js_delete_dragonBones_CCFactory)

static bool js_dragonBones_CCFactory_update(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "CCFactory_update,2,SWIGTYPE_float"); 
    (arg1)->update(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_update) 

static bool js_dragonBones_CCFactory_render(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "CCFactory_render,2,SWIGTYPE_float"); 
    (arg1)->render(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_render) 

static bool js_dragonBones_CCFactory_stopSchedule(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->stopSchedule();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_stopSchedule) 

static bool js_delete_dragonBones_CCFactory(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_CCFactory) 

static bool js_dragonBones_CCFactory_buildArmatureDisplay__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string *arg4 = 0 ;
    std::string *arg5 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    std::string temp4 ;
    std::string temp5 ;
    dragonBones::CCArmatureDisplay *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCFactory_buildArmatureDisplay,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCFactory_buildArmatureDisplay,3,SWIGTYPE_p_std__string");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCFactory_buildArmatureDisplay,4,SWIGTYPE_p_std__string");
    arg4 = &temp4;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCFactory_buildArmatureDisplay,5,SWIGTYPE_p_std__string");
    arg5 = &temp5;
    
    result = (dragonBones::CCArmatureDisplay *)((dragonBones::CCFactory const *)arg1)->buildArmatureDisplay((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CCFactory_buildArmatureDisplay, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_CCFactory_buildArmatureDisplay__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string *arg4 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    std::string temp4 ;
    dragonBones::CCArmatureDisplay *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCFactory_buildArmatureDisplay,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCFactory_buildArmatureDisplay,3,SWIGTYPE_p_std__string");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCFactory_buildArmatureDisplay,4,SWIGTYPE_p_std__string");
    arg4 = &temp4;
    
    result = (dragonBones::CCArmatureDisplay *)((dragonBones::CCFactory const *)arg1)->buildArmatureDisplay((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CCFactory_buildArmatureDisplay, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_CCFactory_buildArmatureDisplay__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    dragonBones::CCArmatureDisplay *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCFactory_buildArmatureDisplay,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCFactory_buildArmatureDisplay,3,SWIGTYPE_p_std__string");
    arg3 = &temp3;
    
    result = (dragonBones::CCArmatureDisplay *)((dragonBones::CCFactory const *)arg1)->buildArmatureDisplay((std::string const &)*arg2,(std::string const &)*arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CCFactory_buildArmatureDisplay, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_CCFactory_buildArmatureDisplay__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::CCArmatureDisplay *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCFactory_buildArmatureDisplay,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (dragonBones::CCArmatureDisplay *)((dragonBones::CCFactory const *)arg1)->buildArmatureDisplay((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CCFactory_buildArmatureDisplay, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_CCFactory_buildArmatureDisplay(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 4) {
        ok = js_dragonBones_CCFactory_buildArmatureDisplay__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_dragonBones_CCFactory_buildArmatureDisplay__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_dragonBones_CCFactory_buildArmatureDisplay__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_dragonBones_CCFactory_buildArmatureDisplay__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_buildArmatureDisplay) 

static bool js_dragonBones_CCFactory_getSoundEventManager(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    dragonBones::CCArmatureDisplay *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::CCArmatureDisplay *)((dragonBones::CCFactory const *)arg1)->getSoundEventManager();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CCFactory_getSoundEventManager, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_getSoundEventManager) 

static bool js_dragonBones_CCFactory_getClock_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::WorldClock *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (dragonBones::WorldClock *)dragonBones::CCFactory::getClock();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CCFactory_getClock, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_getClock_static) 

static bool js_dragonBones_CCFactory_add(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    dragonBones::Armature *arg2 = (dragonBones::Armature *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCFactory_add,2,SWIGTYPE_p_dragonBones__Armature"); 
    (arg1)->add(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_add) 

static bool js_dragonBones_CCFactory_remove(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    dragonBones::Armature *arg2 = (dragonBones::Armature *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCFactory_remove,2,SWIGTYPE_p_dragonBones__Armature"); 
    (arg1)->remove(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_remove) 

static bool js_dragonBones_CCFactory_setTimeScale(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "CCFactory_setTimeScale,2,SWIGTYPE_float"); 
    (arg1)->setTimeScale(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_setTimeScale) 

static bool js_dragonBones_CCFactory_getTimeScale(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getTimeScale();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_getTimeScale) 

static bool js_dragonBones_CCFactory_getDragonBones(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    dragonBones::DragonBones *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::DragonBones *)(arg1)->getDragonBones();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CCFactory_getDragonBones, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_getDragonBones) 

static bool js_dragonBones_CCFactory_removeTextureAtlasDataByIndex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    std::string *arg2 = 0 ;
    int arg3 ;
    std::string temp2 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCFactory_removeTextureAtlasDataByIndex,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "CCFactory_removeTextureAtlasDataByIndex,3,SWIGTYPE_int"); 
    (arg1)->removeTextureAtlasDataByIndex((std::string const &)*arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_removeTextureAtlasDataByIndex) 

static bool js_dragonBones_CCFactory_removeDragonBonesDataByUUID__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    std::string *arg2 = 0 ;
    bool arg3 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCFactory_removeDragonBonesDataByUUID,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "CCFactory_removeDragonBonesDataByUUID,3,SWIGTYPE_bool"); 
    (arg1)->removeDragonBonesDataByUUID((std::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_dragonBones_CCFactory_removeDragonBonesDataByUUID__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCFactory_removeDragonBonesDataByUUID,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    (arg1)->removeDragonBonesDataByUUID((std::string const &)*arg2);
    
    
    return true;
}

static bool js_dragonBones_CCFactory_removeDragonBonesDataByUUID(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_dragonBones_CCFactory_removeDragonBonesDataByUUID__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_dragonBones_CCFactory_removeDragonBonesDataByUUID__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_removeDragonBonesDataByUUID) 

static bool js_dragonBones_CCFactory_getTextureAtlasDataByIndex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    std::string *arg2 = 0 ;
    int arg3 ;
    std::string temp2 ;
    dragonBones::CCTextureAtlasData *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCFactory_getTextureAtlasDataByIndex,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "CCFactory_getTextureAtlasDataByIndex,3,SWIGTYPE_int"); 
    result = (dragonBones::CCTextureAtlasData *)((dragonBones::CCFactory const *)arg1)->getTextureAtlasDataByIndex((std::string const &)*arg2,arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CCFactory_getTextureAtlasDataByIndex, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_getTextureAtlasDataByIndex) 

static bool js_dragonBones_CCFactory_parseDragonBonesDataByPath__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    float arg4 ;
    std::string temp2 ;
    std::string temp3 ;
    dragonBones::DragonBonesData *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCFactory_parseDragonBonesDataByPath,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCFactory_parseDragonBonesDataByPath,3,SWIGTYPE_p_std__string");
    arg3 = &temp3;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "CCFactory_parseDragonBonesDataByPath,4,SWIGTYPE_float"); 
    result = (dragonBones::DragonBonesData *)(arg1)->parseDragonBonesDataByPath((std::string const &)*arg2,(std::string const &)*arg3,arg4);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CCFactory_parseDragonBonesDataByPath, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_CCFactory_parseDragonBonesDataByPath__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    dragonBones::DragonBonesData *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCFactory_parseDragonBonesDataByPath,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCFactory_parseDragonBonesDataByPath,3,SWIGTYPE_p_std__string");
    arg3 = &temp3;
    
    result = (dragonBones::DragonBonesData *)(arg1)->parseDragonBonesDataByPath((std::string const &)*arg2,(std::string const &)*arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CCFactory_parseDragonBonesDataByPath, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_CCFactory_parseDragonBonesDataByPath__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::DragonBonesData *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCFactory_parseDragonBonesDataByPath,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (dragonBones::DragonBonesData *)(arg1)->parseDragonBonesDataByPath((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CCFactory_parseDragonBonesDataByPath, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_CCFactory_parseDragonBonesDataByPath(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_dragonBones_CCFactory_parseDragonBonesDataByPath__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_dragonBones_CCFactory_parseDragonBonesDataByPath__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_dragonBones_CCFactory_parseDragonBonesDataByPath__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_parseDragonBonesDataByPath) 

bool js_register_dragonBones_CCFactory(se::Object* obj) {
    auto* cls = se::Class::create("CCFactory", obj, __jsb_dragonBones_BaseFactory_proto, _SE(js_new_dragonBones_CCFactory)); 
    
    
    cls->defineFunction("update", _SE(js_dragonBones_CCFactory_update)); 
    cls->defineFunction("render", _SE(js_dragonBones_CCFactory_render)); 
    cls->defineFunction("stopSchedule", _SE(js_dragonBones_CCFactory_stopSchedule)); 
    cls->defineFunction("buildArmatureDisplay", _SE(js_dragonBones_CCFactory_buildArmatureDisplay)); 
    cls->defineFunction("getSoundEventManager", _SE(js_dragonBones_CCFactory_getSoundEventManager)); 
    cls->defineFunction("add", _SE(js_dragonBones_CCFactory_add)); 
    cls->defineFunction("remove", _SE(js_dragonBones_CCFactory_remove)); 
    cls->defineFunction("setTimeScale", _SE(js_dragonBones_CCFactory_setTimeScale)); 
    cls->defineFunction("getTimeScale", _SE(js_dragonBones_CCFactory_getTimeScale)); 
    cls->defineFunction("getDragonBones", _SE(js_dragonBones_CCFactory_getDragonBones)); 
    cls->defineFunction("removeTextureAtlasDataByIndex", _SE(js_dragonBones_CCFactory_removeTextureAtlasDataByIndex)); 
    cls->defineFunction("removeDragonBonesDataByUUID", _SE(js_dragonBones_CCFactory_removeDragonBonesDataByUUID)); 
    cls->defineFunction("getTextureAtlasDataByIndex", _SE(js_dragonBones_CCFactory_getTextureAtlasDataByIndex)); 
    cls->defineFunction("parseDragonBonesDataByPath", _SE(js_dragonBones_CCFactory_parseDragonBonesDataByPath)); 
    
    
    cls->defineStaticFunction("isInit", _SE(js_dragonBones_CCFactory_isInit_static)); 
    cls->defineStaticFunction("getFactory", _SE(js_dragonBones_CCFactory_getFactory_static)); 
    cls->defineStaticFunction("destroyFactory", _SE(js_dragonBones_CCFactory_destroyFactory_static)); 
    cls->defineStaticFunction("getClock", _SE(js_dragonBones_CCFactory_getClock_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_CCFactory));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::CCFactory>(cls);
    
    __jsb_dragonBones_CCFactory_proto = cls->getProto();
    __jsb_dragonBones_CCFactory_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_CCSlot_class = nullptr;
se::Object* __jsb_dragonBones_CCSlot_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_CCSlot) 

static bool js_delete_dragonBones_CCSlot(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_CCSlot) 

static bool js_dragonBones_CCSlot_updateWorldMatrix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCSlot *arg1 = (dragonBones::CCSlot *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCSlot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->updateWorldMatrix();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCSlot_updateWorldMatrix) 

bool js_register_dragonBones_CCSlot(se::Object* obj) {
    auto* cls = se::Class::create("CCSlot", obj, __jsb_dragonBones_Slot_proto, nullptr); 
    
    
    cls->defineFunction("updateWorldMatrix", _SE(js_dragonBones_CCSlot_updateWorldMatrix)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_CCSlot));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::CCSlot>(cls);
    
    __jsb_dragonBones_CCSlot_proto = cls->getProto();
    __jsb_dragonBones_CCSlot_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_CCArmatureCacheDisplay_class = nullptr;
se::Object* __jsb_dragonBones_CCArmatureCacheDisplay_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_CCArmatureCacheDisplay) 

// js_ctor
static bool js_new_dragonBones_CCArmatureCacheDisplay(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 4) {
        SE_REPORT_ERROR("js_new_dragonBones_CCArmatureCacheDisplay: wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    
    std::string *arg1 = 0 ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    bool arg4 ;
    std::string temp1 ;
    std::string temp2 ;
    std::string temp3 ;
    dragonBones::CCArmatureCacheDisplay *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_CCArmatureCacheDisplay,1,SWIGTYPE_p_std__string");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_CCArmatureCacheDisplay,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_CCArmatureCacheDisplay,3,SWIGTYPE_p_std__string");
    arg3 = &temp3;
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[3], &arg4);
    SE_PRECONDITION2(ok, false, "new_CCArmatureCacheDisplay,4,SWIGTYPE_bool"); 
    result = (dragonBones::CCArmatureCacheDisplay *)new dragonBones::CCArmatureCacheDisplay((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,arg4);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_dragonBones_CCArmatureCacheDisplay, __jsb_dragonBones_CCArmatureCacheDisplay_class, js_delete_dragonBones_CCArmatureCacheDisplay)

static bool js_delete_dragonBones_CCArmatureCacheDisplay(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_CCArmatureCacheDisplay) 

static bool js_dragonBones_CCArmatureCacheDisplay_dispose(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->dispose();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_dispose) 

static bool js_dragonBones_CCArmatureCacheDisplay_update(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "CCArmatureCacheDisplay_update,2,SWIGTYPE_float"); 
    (arg1)->update(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_update) 

static bool js_dragonBones_CCArmatureCacheDisplay_render(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "CCArmatureCacheDisplay_render,2,SWIGTYPE_float"); 
    (arg1)->render(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_render) 

static bool js_dragonBones_CCArmatureCacheDisplay_setTimeScale(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "CCArmatureCacheDisplay_setTimeScale,2,SWIGTYPE_float"); 
    (arg1)->setTimeScale(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_setTimeScale) 

static bool js_dragonBones_CCArmatureCacheDisplay_getTimeScale(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)((dragonBones::CCArmatureCacheDisplay const *)arg1)->getTimeScale();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_getTimeScale) 

static bool js_dragonBones_CCArmatureCacheDisplay_beginSchedule(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->beginSchedule();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_beginSchedule) 

static bool js_dragonBones_CCArmatureCacheDisplay_stopSchedule(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->stopSchedule();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_stopSchedule) 

static bool js_dragonBones_CCArmatureCacheDisplay_onEnable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_onEnable) 

static bool js_dragonBones_CCArmatureCacheDisplay_onDisable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_onDisable) 

static bool js_dragonBones_CCArmatureCacheDisplay_armature(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    dragonBones::Armature *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::Armature *)((dragonBones::CCArmatureCacheDisplay const *)arg1)->getArmature();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CCArmatureCacheDisplay_armature, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_armature) 

static bool js_dragonBones_CCArmatureCacheDisplay_getAnimation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    dragonBones::Animation *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::Animation *)((dragonBones::CCArmatureCacheDisplay const *)arg1)->getAnimation();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CCArmatureCacheDisplay_getAnimation, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_getAnimation) 

static bool js_dragonBones_CCArmatureCacheDisplay_setColor(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "CCArmatureCacheDisplay_setColor,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "CCArmatureCacheDisplay_setColor,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "CCArmatureCacheDisplay_setColor,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "CCArmatureCacheDisplay_setColor,5,SWIGTYPE_float"); 
    (arg1)->setColor(arg2,arg3,arg4,arg5);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_setColor) 

static bool js_dragonBones_CCArmatureCacheDisplay_setBatchEnabled(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "CCArmatureCacheDisplay_setBatchEnabled,2,SWIGTYPE_bool"); 
    (arg1)->setBatchEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_setBatchEnabled) 

static bool js_dragonBones_CCArmatureCacheDisplay_setAttachEnabled(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "CCArmatureCacheDisplay_setAttachEnabled,2,SWIGTYPE_bool"); 
    (arg1)->setAttachEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_setAttachEnabled) 

static bool js_dragonBones_CCArmatureCacheDisplay_setOpacityModifyRGB(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "CCArmatureCacheDisplay_setOpacityModifyRGB,2,SWIGTYPE_bool"); 
    (arg1)->setOpacityModifyRGB(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_setOpacityModifyRGB) 

static bool js_dragonBones_CCArmatureCacheDisplay_setDBEventCallback(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    dragonBones::CCArmatureCacheDisplay::dbEventCallback arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCArmatureCacheDisplay_setDBEventCallback,2,SWIGTYPE_std__functionT_void_fdragonBones__EventObject_pF_t"); 
    
    (arg1)->setDBEventCallback(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_setDBEventCallback) 

static bool js_dragonBones_CCArmatureCacheDisplay_addDBEventListener(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCArmatureCacheDisplay_addDBEventListener,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    (arg1)->addDBEventListener((std::string const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_addDBEventListener) 

static bool js_dragonBones_CCArmatureCacheDisplay_removeDBEventListener(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCArmatureCacheDisplay_removeDBEventListener,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    (arg1)->removeDBEventListener((std::string const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_removeDBEventListener) 

static bool js_dragonBones_CCArmatureCacheDisplay_dispatchDBEvent(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    std::string *arg2 = 0 ;
    dragonBones::EventObject *arg3 = (dragonBones::EventObject *) NULL ;
    std::string temp2 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCArmatureCacheDisplay_dispatchDBEvent,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCArmatureCacheDisplay_dispatchDBEvent,3,SWIGTYPE_p_dragonBones__EventObject"); 
    (arg1)->dispatchDBEvent((std::string const &)*arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_dispatchDBEvent) 

static bool js_dragonBones_CCArmatureCacheDisplay_playAnimation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    std::string *arg2 = 0 ;
    int arg3 ;
    std::string temp2 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCArmatureCacheDisplay_playAnimation,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "CCArmatureCacheDisplay_playAnimation,3,SWIGTYPE_int"); 
    (arg1)->playAnimation((std::string const &)*arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_playAnimation) 

static bool js_dragonBones_CCArmatureCacheDisplay_updateAnimationCache(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCArmatureCacheDisplay_updateAnimationCache,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    (arg1)->updateAnimationCache((std::string const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_updateAnimationCache) 

static bool js_dragonBones_CCArmatureCacheDisplay_updateAllAnimationCache(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->updateAllAnimationCache();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_updateAllAnimationCache) 

static bool js_dragonBones_CCArmatureCacheDisplay_getSharedBufferOffset(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    se_object_ptr result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((dragonBones::CCArmatureCacheDisplay const *)arg1)->getSharedBufferOffset();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CCArmatureCacheDisplay_getSharedBufferOffset, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_getSharedBufferOffset) 

static bool js_dragonBones_CCArmatureCacheDisplay_getParamsBuffer(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    se_object_ptr result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((dragonBones::CCArmatureCacheDisplay const *)arg1)->getParamsBuffer();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CCArmatureCacheDisplay_getParamsBuffer, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_getParamsBuffer) 

bool js_register_dragonBones_CCArmatureCacheDisplay(se::Object* obj) {
    auto* cls = se::Class::create("CCArmatureCacheDisplay", obj, nullptr, _SE(js_new_dragonBones_CCArmatureCacheDisplay)); 
    
    
    cls->defineFunction("dispose", _SE(js_dragonBones_CCArmatureCacheDisplay_dispose)); 
    cls->defineFunction("update", _SE(js_dragonBones_CCArmatureCacheDisplay_update)); 
    cls->defineFunction("render", _SE(js_dragonBones_CCArmatureCacheDisplay_render)); 
    cls->defineFunction("setTimeScale", _SE(js_dragonBones_CCArmatureCacheDisplay_setTimeScale)); 
    cls->defineFunction("getTimeScale", _SE(js_dragonBones_CCArmatureCacheDisplay_getTimeScale)); 
    cls->defineFunction("beginSchedule", _SE(js_dragonBones_CCArmatureCacheDisplay_beginSchedule)); 
    cls->defineFunction("stopSchedule", _SE(js_dragonBones_CCArmatureCacheDisplay_stopSchedule)); 
    cls->defineFunction("onEnable", _SE(js_dragonBones_CCArmatureCacheDisplay_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_dragonBones_CCArmatureCacheDisplay_onDisable)); 
    cls->defineFunction("armature", _SE(js_dragonBones_CCArmatureCacheDisplay_armature)); 
    cls->defineFunction("getAnimation", _SE(js_dragonBones_CCArmatureCacheDisplay_getAnimation)); 
    cls->defineFunction("setColor", _SE(js_dragonBones_CCArmatureCacheDisplay_setColor)); 
    cls->defineFunction("setBatchEnabled", _SE(js_dragonBones_CCArmatureCacheDisplay_setBatchEnabled)); 
    cls->defineFunction("setAttachEnabled", _SE(js_dragonBones_CCArmatureCacheDisplay_setAttachEnabled)); 
    cls->defineFunction("setOpacityModifyRGB", _SE(js_dragonBones_CCArmatureCacheDisplay_setOpacityModifyRGB)); 
    cls->defineFunction("setDBEventCallback", _SE(js_dragonBones_CCArmatureCacheDisplay_setDBEventCallback)); 
    cls->defineFunction("addDBEventListener", _SE(js_dragonBones_CCArmatureCacheDisplay_addDBEventListener)); 
    cls->defineFunction("removeDBEventListener", _SE(js_dragonBones_CCArmatureCacheDisplay_removeDBEventListener)); 
    cls->defineFunction("dispatchDBEvent", _SE(js_dragonBones_CCArmatureCacheDisplay_dispatchDBEvent)); 
    cls->defineFunction("playAnimation", _SE(js_dragonBones_CCArmatureCacheDisplay_playAnimation)); 
    cls->defineFunction("updateAnimationCache", _SE(js_dragonBones_CCArmatureCacheDisplay_updateAnimationCache)); 
    cls->defineFunction("updateAllAnimationCache", _SE(js_dragonBones_CCArmatureCacheDisplay_updateAllAnimationCache)); 
    cls->defineFunction("getSharedBufferOffset", _SE(js_dragonBones_CCArmatureCacheDisplay_getSharedBufferOffset)); 
    cls->defineFunction("getParamsBuffer", _SE(js_dragonBones_CCArmatureCacheDisplay_getParamsBuffer)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_CCArmatureCacheDisplay));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::CCArmatureCacheDisplay>(cls);
    
    __jsb_dragonBones_CCArmatureCacheDisplay_proto = cls->getProto();
    __jsb_dragonBones_CCArmatureCacheDisplay_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_ArmatureCache_class = nullptr;
se::Object* __jsb_dragonBones_ArmatureCache_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_ArmatureCache) 

// js_ctor
static bool js_new_dragonBones_ArmatureCache(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 3) {
        SE_REPORT_ERROR("js_new_dragonBones_ArmatureCache: wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    
    std::string *arg1 = 0 ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string temp1 ;
    std::string temp2 ;
    std::string temp3 ;
    dragonBones::ArmatureCache *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_ArmatureCache,1,SWIGTYPE_p_std__string");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_ArmatureCache,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_ArmatureCache,3,SWIGTYPE_p_std__string");
    arg3 = &temp3;
    
    result = (dragonBones::ArmatureCache *)new dragonBones::ArmatureCache((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_dragonBones_ArmatureCache, __jsb_dragonBones_ArmatureCache_class, js_delete_dragonBones_ArmatureCache)

static bool js_delete_dragonBones_ArmatureCache(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_ArmatureCache) 

static bool js_dragonBones_ArmatureCache_updateToFrame__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::ArmatureCache *arg1 = (dragonBones::ArmatureCache *) NULL ;
    std::string *arg2 = 0 ;
    int arg3 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureCache>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ArmatureCache_updateToFrame,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "ArmatureCache_updateToFrame,3,SWIGTYPE_int"); 
    (arg1)->updateToFrame((std::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_dragonBones_ArmatureCache_updateToFrame__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::ArmatureCache *arg1 = (dragonBones::ArmatureCache *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureCache>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ArmatureCache_updateToFrame,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    (arg1)->updateToFrame((std::string const &)*arg2);
    
    
    return true;
}

static bool js_dragonBones_ArmatureCache_updateToFrame(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_dragonBones_ArmatureCache_updateToFrame__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_dragonBones_ArmatureCache_updateToFrame__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_ArmatureCache_updateToFrame) 

static bool js_dragonBones_ArmatureCache_buildAnimationData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureCache *arg1 = (dragonBones::ArmatureCache *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::ArmatureCache::AnimationData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureCache>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ArmatureCache_buildAnimationData,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (dragonBones::ArmatureCache::AnimationData *)(arg1)->buildAnimationData((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ArmatureCache_buildAnimationData, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureCache_buildAnimationData) 

static bool js_dragonBones_ArmatureCache_getAnimationData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureCache *arg1 = (dragonBones::ArmatureCache *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::ArmatureCache::AnimationData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureCache>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ArmatureCache_getAnimationData,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (dragonBones::ArmatureCache::AnimationData *)(arg1)->getAnimationData((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ArmatureCache_getAnimationData, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureCache_getAnimationData) 

static bool js_dragonBones_ArmatureCache_getArmatureDisplay(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureCache *arg1 = (dragonBones::ArmatureCache *) NULL ;
    dragonBones::CCArmatureDisplay *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureCache>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (dragonBones::CCArmatureDisplay *)(arg1)->getArmatureDisplay();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ArmatureCache_getArmatureDisplay, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureCache_getArmatureDisplay) 

static bool js_dragonBones_ArmatureCache_resetAllAnimationData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureCache *arg1 = (dragonBones::ArmatureCache *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureCache>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->resetAllAnimationData();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureCache_resetAllAnimationData) 

static bool js_dragonBones_ArmatureCache_resetAnimationData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureCache *arg1 = (dragonBones::ArmatureCache *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureCache>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ArmatureCache_resetAnimationData,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    (arg1)->resetAnimationData((std::string const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureCache_resetAnimationData) 

static bool js_dragonBones_ArmatureCache_FrameTime_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float arg1 ;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "ArmatureCache_FrameTime_set,1,SWIGTYPE_float"); 
    dragonBones::ArmatureCache::FrameTime = arg1;
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_ArmatureCache_FrameTime_set) 

static bool js_dragonBones_ArmatureCache_FrameTime_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    float result;
    
    result = (float)dragonBones::ArmatureCache::FrameTime;
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_ArmatureCache_FrameTime_get) 

static bool js_dragonBones_ArmatureCache_MaxCacheTime_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float arg1 ;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "ArmatureCache_MaxCacheTime_set,1,SWIGTYPE_float"); 
    dragonBones::ArmatureCache::MaxCacheTime = arg1;
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_ArmatureCache_MaxCacheTime_set) 

static bool js_dragonBones_ArmatureCache_MaxCacheTime_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    float result;
    
    result = (float)dragonBones::ArmatureCache::MaxCacheTime;
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_ArmatureCache_MaxCacheTime_get) 

bool js_register_dragonBones_ArmatureCache(se::Object* obj) {
    auto* cls = se::Class::create("ArmatureCache", obj, nullptr, _SE(js_new_dragonBones_ArmatureCache)); 
    
    
    cls->defineFunction("updateToFrame", _SE(js_dragonBones_ArmatureCache_updateToFrame)); 
    cls->defineFunction("buildAnimationData", _SE(js_dragonBones_ArmatureCache_buildAnimationData)); 
    cls->defineFunction("getAnimationData", _SE(js_dragonBones_ArmatureCache_getAnimationData)); 
    cls->defineFunction("getArmatureDisplay", _SE(js_dragonBones_ArmatureCache_getArmatureDisplay)); 
    cls->defineFunction("resetAllAnimationData", _SE(js_dragonBones_ArmatureCache_resetAllAnimationData)); 
    cls->defineFunction("resetAnimationData", _SE(js_dragonBones_ArmatureCache_resetAnimationData)); 
    
    cls->defineStaticProperty("FrameTime", _SE(js_dragonBones_ArmatureCache_FrameTime_get), _SE(js_dragonBones_ArmatureCache_FrameTime_set)); 
    cls->defineStaticProperty("MaxCacheTime", _SE(js_dragonBones_ArmatureCache_MaxCacheTime_get), _SE(js_dragonBones_ArmatureCache_MaxCacheTime_set)); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_ArmatureCache));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::ArmatureCache>(cls);
    
    __jsb_dragonBones_ArmatureCache_proto = cls->getProto();
    __jsb_dragonBones_ArmatureCache_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_ArmatureCacheMgr_class = nullptr;
se::Object* __jsb_dragonBones_ArmatureCacheMgr_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_ArmatureCacheMgr) 

static bool js_dragonBones_ArmatureCacheMgr_getInstance_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureCacheMgr *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (dragonBones::ArmatureCacheMgr *)dragonBones::ArmatureCacheMgr::getInstance();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ArmatureCacheMgr_getInstance, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureCacheMgr_getInstance_static) 

static bool js_dragonBones_ArmatureCacheMgr_destroyInstance_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    dragonBones::ArmatureCacheMgr::destroyInstance();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureCacheMgr_destroyInstance_static) 

static bool js_dragonBones_ArmatureCacheMgr_removeArmatureCache(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureCacheMgr *arg1 = (dragonBones::ArmatureCacheMgr *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureCacheMgr>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ArmatureCacheMgr_removeArmatureCache,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    (arg1)->removeArmatureCache((std::string const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureCacheMgr_removeArmatureCache) 

static bool js_dragonBones_ArmatureCacheMgr_buildArmatureCache(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureCacheMgr *arg1 = (dragonBones::ArmatureCacheMgr *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string *arg4 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    std::string temp4 ;
    dragonBones::ArmatureCache *result = 0 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureCacheMgr>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ArmatureCacheMgr_buildArmatureCache,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "ArmatureCacheMgr_buildArmatureCache,3,SWIGTYPE_p_std__string");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "ArmatureCacheMgr_buildArmatureCache,4,SWIGTYPE_p_std__string");
    arg4 = &temp4;
    
    result = (dragonBones::ArmatureCache *)(arg1)->buildArmatureCache((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ArmatureCacheMgr_buildArmatureCache, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureCacheMgr_buildArmatureCache) 

// js_ctor
static bool js_new_dragonBones_ArmatureCacheMgr(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    dragonBones::ArmatureCacheMgr *result;
    result = (dragonBones::ArmatureCacheMgr *)new dragonBones::ArmatureCacheMgr();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_dragonBones_ArmatureCacheMgr, __jsb_dragonBones_ArmatureCacheMgr_class, js_delete_dragonBones_ArmatureCacheMgr)

static bool js_delete_dragonBones_ArmatureCacheMgr(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_ArmatureCacheMgr) 

bool js_register_dragonBones_ArmatureCacheMgr(se::Object* obj) {
    auto* cls = se::Class::create("ArmatureCacheMgr", obj, nullptr, _SE(js_new_dragonBones_ArmatureCacheMgr)); 
    
    
    cls->defineFunction("removeArmatureCache", _SE(js_dragonBones_ArmatureCacheMgr_removeArmatureCache)); 
    cls->defineFunction("buildArmatureCache", _SE(js_dragonBones_ArmatureCacheMgr_buildArmatureCache)); 
    
    
    cls->defineStaticFunction("getInstance", _SE(js_dragonBones_ArmatureCacheMgr_getInstance_static)); 
    cls->defineStaticFunction("destroyInstance", _SE(js_dragonBones_ArmatureCacheMgr_destroyInstance_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_ArmatureCacheMgr));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::ArmatureCacheMgr>(cls);
    
    __jsb_dragonBones_ArmatureCacheMgr_proto = cls->getProto();
    __jsb_dragonBones_ArmatureCacheMgr_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}




bool register_all_dragonbones(se::Object* obj) {
    // Get the ns
    se::Value nsVal;
    if (!obj->getProperty("dragonBones", &nsVal, true))
    {
        se::HandleObject jsobj(se::Object::createPlainObject());
        nsVal.setObject(jsobj);
        obj->setProperty("dragonBones", nsVal);
    }
    se::Object* ns = nsVal.toObject();
    /* Register classes */
    js_register_dragonBones_Rectangle(ns); 
    js_register_dragonBones_Transform(ns); 
    js_register_dragonBones_Matrix(ns); 
    js_register_dragonBones_BaseObject(ns); 
    js_register_dragonBones_EventObject(ns); 
    js_register_dragonBones_BaseFactory(ns); 
    js_register_dragonBones_BuildArmaturePackage(ns); 
    js_register_dragonBones_DragonBonesData(ns); 
    js_register_dragonBones_TextureAtlasData(ns); 
    js_register_dragonBones_TextureData(ns); 
    js_register_dragonBones_ArmatureData(ns); 
    js_register_dragonBones_BoneData(ns); 
    js_register_dragonBones_SlotData(ns); 
    js_register_dragonBones_SkinData(ns); 
    js_register_dragonBones_AnimationData(ns); 
    js_register_dragonBones_TimelineData(ns); 
    js_register_dragonBones_WorldClock(ns); 
    js_register_dragonBones_Animation(ns); 
    js_register_dragonBones_AnimationState(ns); 
    js_register_dragonBones_BonePose(ns); 
    js_register_dragonBones_BlendState(ns); 
    js_register_dragonBones_TransformObject(ns); 
    js_register_dragonBones_Slot(ns); 
    js_register_dragonBones_Bone(ns); 
    js_register_dragonBones_Armature(ns); 
    js_register_dragonBones_CCArmatureDisplay(ns); 
    js_register_dragonBones_CCFactory(ns); 
    js_register_dragonBones_CCSlot(ns); 
    js_register_dragonBones_CCArmatureCacheDisplay(ns); 
    js_register_dragonBones_ArmatureCache(ns); 
    js_register_dragonBones_ArmatureCacheMgr(ns); 
    
    /* Register global variables & global functions */
    
    
    
    return true;
}


#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif
// clang-format on
