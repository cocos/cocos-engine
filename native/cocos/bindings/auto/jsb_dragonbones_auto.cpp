// clang-format off

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

/****************************************************************************
 Copyright (c) 2022-2023 Xiamen Yaji Software Co., Ltd.

 http://www.cocos.com

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights to
 use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 of the Software, and to permit persons to whom the Software is furnished to do so,
 subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
****************************************************************************/

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-variable"
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-variable"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4101)
#endif


#define SWIG_STD_MOVE(OBJ) std::move(OBJ)


#include <stdio.h>


#include "bindings/jswrapper/SeApi.h"
#include "bindings/manual/jsb_conversions.h"
#include "bindings/manual/jsb_global.h"


#include "bindings/auto/jsb_2d_auto.h"
#include "bindings/auto/jsb_assets_auto.h"
#include "bindings/auto/jsb_cocos_auto.h"
#include "bindings/auto/jsb_dragonbones_auto.h"



se::Class* __jsb_dragonBones_Rectangle_class = nullptr;
se::Object* __jsb_dragonBones_Rectangle_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_Rectangle) 

static bool js_dragonBones_Rectangle_x_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Rectangle *arg1 = (dragonBones::Rectangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Rectangle>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->x, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Rectangle_x_set) 

static bool js_dragonBones_Rectangle_x_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Rectangle *arg1 = (dragonBones::Rectangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Rectangle>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->x, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Rectangle_x_get) 

static bool js_dragonBones_Rectangle_y_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Rectangle *arg1 = (dragonBones::Rectangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Rectangle>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->y, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Rectangle_y_set) 

static bool js_dragonBones_Rectangle_y_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Rectangle *arg1 = (dragonBones::Rectangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Rectangle>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->y, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Rectangle_y_get) 

static bool js_dragonBones_Rectangle_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Rectangle *arg1 = (dragonBones::Rectangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Rectangle>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->width, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Rectangle_width_set) 

static bool js_dragonBones_Rectangle_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Rectangle *arg1 = (dragonBones::Rectangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Rectangle>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->width, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Rectangle_width_get) 

static bool js_dragonBones_Rectangle_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Rectangle *arg1 = (dragonBones::Rectangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Rectangle>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->height, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Rectangle_height_set) 

static bool js_dragonBones_Rectangle_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Rectangle *arg1 = (dragonBones::Rectangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Rectangle>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->height, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Rectangle_height_get) 

static bool js_new_dragonBones_Rectangle__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    dragonBones::Rectangle *result;
    result = (dragonBones::Rectangle *)new dragonBones::Rectangle();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_dragonBones_Rectangle__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    dragonBones::Rectangle *arg1 = 0 ;
    dragonBones::Rectangle temp1 ;
    dragonBones::Rectangle *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = (dragonBones::Rectangle *)new dragonBones::Rectangle((dragonBones::Rectangle const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_Rectangle(se::State& s) // NOLINT(readability-identifier-naming)
{
    size_t argc = s.args().size();
    bool ret = false;
    
    if(argc == 0) {
        ret = js_new_dragonBones_Rectangle__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 1) {
        ret = js_new_dragonBones_Rectangle__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    SE_REPORT_ERROR("Illegal arguments for construction of Rectangle");
    return false;
}
SE_BIND_CTOR(js_new_Rectangle, __jsb_dragonBones_Rectangle_class, js_delete_dragonBones_Rectangle)

static bool js_delete_dragonBones_Rectangle(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_Rectangle) 

static bool js_dragonBones_Rectangle_clear(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Rectangle *arg1 = (dragonBones::Rectangle *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Rectangle>(s);
    if (nullptr == arg1) return true;
    (arg1)->clear();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Rectangle_clear) 

bool js_register_dragonBones_Rectangle(se::Object* obj) {
    auto* cls = se::Class::create("Rectangle", obj, nullptr, _SE(js_new_Rectangle)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("x", _SE(js_dragonBones_Rectangle_x_get), _SE(js_dragonBones_Rectangle_x_set)); 
    cls->defineProperty("y", _SE(js_dragonBones_Rectangle_y_get), _SE(js_dragonBones_Rectangle_y_set)); 
    cls->defineProperty("width", _SE(js_dragonBones_Rectangle_width_get), _SE(js_dragonBones_Rectangle_width_set)); 
    cls->defineProperty("height", _SE(js_dragonBones_Rectangle_height_get), _SE(js_dragonBones_Rectangle_height_set)); 
    
    cls->defineFunction("clear", _SE(js_dragonBones_Rectangle_clear)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_Rectangle));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::Rectangle>(cls);
    
    __jsb_dragonBones_Rectangle_proto = cls->getProto();
    __jsb_dragonBones_Rectangle_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_Transform_class = nullptr;
se::Object* __jsb_dragonBones_Transform_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_Transform) 

static bool js_dragonBones_Transform_PI_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    float result;
    
    result = (float)(float)dragonBones::Transform::PI;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Transform_PI_get) 

static bool js_dragonBones_Transform_PI_D_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    float result;
    
    result = (float)(float)dragonBones::Transform::PI_D;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Transform_PI_D_get) 

static bool js_dragonBones_Transform_PI_H_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    float result;
    
    result = (float)(float)dragonBones::Transform::PI_H;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Transform_PI_H_get) 

static bool js_dragonBones_Transform_PI_Q_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    float result;
    
    result = (float)(float)dragonBones::Transform::PI_Q;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Transform_PI_Q_get) 

static bool js_dragonBones_Transform_DEG_RAD_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    float result;
    
    result = (float)(float)dragonBones::Transform::DEG_RAD;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Transform_DEG_RAD_get) 

static bool js_dragonBones_Transform_RAD_DEG_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    float result;
    
    result = (float)(float)dragonBones::Transform::RAD_DEG;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Transform_RAD_DEG_get) 

static bool js_dragonBones_Transform_normalizeRadian_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float arg1 ;
    float result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (float)dragonBones::Transform::normalizeRadian(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Transform_normalizeRadian_static) 

static bool js_dragonBones_Transform_x_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Transform *arg1 = (dragonBones::Transform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Transform>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->x, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Transform_x_set) 

static bool js_dragonBones_Transform_x_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Transform *arg1 = (dragonBones::Transform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Transform>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->x, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Transform_x_get) 

static bool js_dragonBones_Transform_y_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Transform *arg1 = (dragonBones::Transform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Transform>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->y, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Transform_y_set) 

static bool js_dragonBones_Transform_y_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Transform *arg1 = (dragonBones::Transform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Transform>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->y, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Transform_y_get) 

static bool js_dragonBones_Transform_skew_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Transform *arg1 = (dragonBones::Transform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Transform>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->skew, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Transform_skew_set) 

static bool js_dragonBones_Transform_skew_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Transform *arg1 = (dragonBones::Transform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Transform>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->skew, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Transform_skew_get) 

static bool js_dragonBones_Transform_rotation_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Transform *arg1 = (dragonBones::Transform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Transform>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->rotation, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Transform_rotation_set) 

static bool js_dragonBones_Transform_rotation_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Transform *arg1 = (dragonBones::Transform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Transform>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->rotation, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Transform_rotation_get) 

static bool js_dragonBones_Transform_scaleX_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Transform *arg1 = (dragonBones::Transform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Transform>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->scaleX, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Transform_scaleX_set) 

static bool js_dragonBones_Transform_scaleX_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Transform *arg1 = (dragonBones::Transform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Transform>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->scaleX, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Transform_scaleX_get) 

static bool js_dragonBones_Transform_scaleY_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Transform *arg1 = (dragonBones::Transform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Transform>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->scaleY, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Transform_scaleY_set) 

static bool js_dragonBones_Transform_scaleY_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Transform *arg1 = (dragonBones::Transform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Transform>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->scaleY, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Transform_scaleY_get) 

static bool js_delete_dragonBones_Transform(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_Transform) 

bool js_register_dragonBones_Transform(se::Object* obj) {
    auto* cls = se::Class::create("Transform", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("x", _SE(js_dragonBones_Transform_x_get), _SE(js_dragonBones_Transform_x_set)); 
    cls->defineProperty("y", _SE(js_dragonBones_Transform_y_get), _SE(js_dragonBones_Transform_y_set)); 
    cls->defineProperty("skew", _SE(js_dragonBones_Transform_skew_get), _SE(js_dragonBones_Transform_skew_set)); 
    cls->defineProperty("rotation", _SE(js_dragonBones_Transform_rotation_get), _SE(js_dragonBones_Transform_rotation_set)); 
    cls->defineProperty("scaleX", _SE(js_dragonBones_Transform_scaleX_get), _SE(js_dragonBones_Transform_scaleX_set)); 
    cls->defineProperty("scaleY", _SE(js_dragonBones_Transform_scaleY_get), _SE(js_dragonBones_Transform_scaleY_set)); 
    
    
    cls->defineStaticProperty("PI", _SE(js_dragonBones_Transform_PI_get), nullptr); 
    cls->defineStaticProperty("PI_D", _SE(js_dragonBones_Transform_PI_D_get), nullptr); 
    cls->defineStaticProperty("PI_H", _SE(js_dragonBones_Transform_PI_H_get), nullptr); 
    cls->defineStaticProperty("PI_Q", _SE(js_dragonBones_Transform_PI_Q_get), nullptr); 
    cls->defineStaticProperty("DEG_RAD", _SE(js_dragonBones_Transform_DEG_RAD_get), nullptr); 
    cls->defineStaticProperty("RAD_DEG", _SE(js_dragonBones_Transform_RAD_DEG_get), nullptr); 
    
    cls->defineStaticFunction("normalizeRadian", _SE(js_dragonBones_Transform_normalizeRadian_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_Transform));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::Transform>(cls);
    
    __jsb_dragonBones_Transform_proto = cls->getProto();
    __jsb_dragonBones_Transform_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_Matrix_class = nullptr;
se::Object* __jsb_dragonBones_Matrix_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_Matrix) 

static bool js_dragonBones_Matrix_a_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Matrix *arg1 = (dragonBones::Matrix *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Matrix>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->a, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Matrix_a_set) 

static bool js_dragonBones_Matrix_a_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Matrix *arg1 = (dragonBones::Matrix *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Matrix>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->a, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Matrix_a_get) 

static bool js_dragonBones_Matrix_b_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Matrix *arg1 = (dragonBones::Matrix *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Matrix>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->b, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Matrix_b_set) 

static bool js_dragonBones_Matrix_b_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Matrix *arg1 = (dragonBones::Matrix *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Matrix>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->b, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Matrix_b_get) 

static bool js_dragonBones_Matrix_c_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Matrix *arg1 = (dragonBones::Matrix *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Matrix>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->c, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Matrix_c_set) 

static bool js_dragonBones_Matrix_c_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Matrix *arg1 = (dragonBones::Matrix *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Matrix>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->c, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Matrix_c_get) 

static bool js_dragonBones_Matrix_d_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Matrix *arg1 = (dragonBones::Matrix *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Matrix>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->d, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Matrix_d_set) 

static bool js_dragonBones_Matrix_d_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Matrix *arg1 = (dragonBones::Matrix *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Matrix>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->d, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Matrix_d_get) 

static bool js_dragonBones_Matrix_tx_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Matrix *arg1 = (dragonBones::Matrix *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Matrix>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->tx, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Matrix_tx_set) 

static bool js_dragonBones_Matrix_tx_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Matrix *arg1 = (dragonBones::Matrix *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Matrix>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->tx, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Matrix_tx_get) 

static bool js_dragonBones_Matrix_ty_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Matrix *arg1 = (dragonBones::Matrix *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Matrix>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->ty, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Matrix_ty_set) 

static bool js_dragonBones_Matrix_ty_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Matrix *arg1 = (dragonBones::Matrix *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Matrix>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->ty, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Matrix_ty_get) 

static bool js_delete_dragonBones_Matrix(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_Matrix) 

bool js_register_dragonBones_Matrix(se::Object* obj) {
    auto* cls = se::Class::create("Matrix", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("a", _SE(js_dragonBones_Matrix_a_get), _SE(js_dragonBones_Matrix_a_set)); 
    cls->defineProperty("b", _SE(js_dragonBones_Matrix_b_get), _SE(js_dragonBones_Matrix_b_set)); 
    cls->defineProperty("c", _SE(js_dragonBones_Matrix_c_get), _SE(js_dragonBones_Matrix_c_set)); 
    cls->defineProperty("d", _SE(js_dragonBones_Matrix_d_get), _SE(js_dragonBones_Matrix_d_set)); 
    cls->defineProperty("tx", _SE(js_dragonBones_Matrix_tx_get), _SE(js_dragonBones_Matrix_tx_set)); 
    cls->defineProperty("ty", _SE(js_dragonBones_Matrix_ty_get), _SE(js_dragonBones_Matrix_ty_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_Matrix));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::Matrix>(cls);
    
    __jsb_dragonBones_Matrix_proto = cls->getProto();
    __jsb_dragonBones_Matrix_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_BaseObject_class = nullptr;
se::Object* __jsb_dragonBones_BaseObject_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_BaseObject) 

static bool js_dragonBones_BaseObject_setMaxCount_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    std::size_t arg1 ;
    unsigned int arg2 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    dragonBones::BaseObject::setMaxCount(SWIG_STD_MOVE(arg1),arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_BaseObject_setMaxCount_static) 

static bool js_dragonBones_BaseObject_clearPool_static__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    std::size_t arg1 ;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    dragonBones::BaseObject::clearPool(SWIG_STD_MOVE(arg1));
    
    
    return true;
}

static bool js_dragonBones_BaseObject_clearPool_static__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    
    dragonBones::BaseObject::clearPool();
    
    
    return true;
}

static bool js_dragonBones_BaseObject_clearPool_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_dragonBones_BaseObject_clearPool_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 0) {
        ok = js_dragonBones_BaseObject_clearPool_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_BaseObject_clearPool_static) 

static bool js_dragonBones_BaseObject_hashCode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BaseObject *arg1 = (dragonBones::BaseObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->hashCode, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BaseObject_hashCode_get) 

static bool js_delete_dragonBones_BaseObject(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_BaseObject) 

static bool js_dragonBones_BaseObject_returnToPool(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BaseObject *arg1 = (dragonBones::BaseObject *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::BaseObject>(s);
    if (nullptr == arg1) return true;
    (arg1)->returnToPool();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_BaseObject_returnToPool) 

bool js_register_dragonBones_BaseObject(se::Object* obj) {
    auto* cls = se::Class::create("BaseObject", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("hashCode", _SE(js_dragonBones_BaseObject_hashCode_get), nullptr); 
    
    cls->defineFunction("returnToPool", _SE(js_dragonBones_BaseObject_returnToPool)); 
    
    
    cls->defineStaticFunction("setMaxCount", _SE(js_dragonBones_BaseObject_setMaxCount_static)); 
    cls->defineStaticFunction("clearPool", _SE(js_dragonBones_BaseObject_clearPool_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_BaseObject));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::BaseObject>(cls);
    
    __jsb_dragonBones_BaseObject_proto = cls->getProto();
    __jsb_dragonBones_BaseObject_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_EventObject_class = nullptr;
se::Object* __jsb_dragonBones_EventObject_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_EventObject) 

static bool js_delete_dragonBones_EventObject(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_EventObject) 

static bool js_dragonBones_EventObject_time_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->time, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_EventObject_time_set) 

static bool js_dragonBones_EventObject_time_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->time, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_EventObject_time_get) 

static bool js_dragonBones_EventObject_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->type, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_EventObject_type_set) 

static bool js_dragonBones_EventObject_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->type, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->type, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_EventObject_type_get) 

static bool js_dragonBones_EventObject_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_EventObject_name_set) 

static bool js_dragonBones_EventObject_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_EventObject_name_get) 

static bool js_dragonBones_EventObject_armature_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->armature, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_EventObject_armature_set) 

static bool js_dragonBones_EventObject_armature_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->armature, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->armature, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_EventObject_armature_get) 

static bool js_dragonBones_EventObject_bone_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->bone, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_EventObject_bone_set) 

static bool js_dragonBones_EventObject_bone_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->bone, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->bone, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_EventObject_bone_get) 

static bool js_dragonBones_EventObject_slot_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->slot, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_EventObject_slot_set) 

static bool js_dragonBones_EventObject_slot_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->slot, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->slot, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_EventObject_slot_get) 

static bool js_dragonBones_EventObject_animationState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->animationState, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_EventObject_animationState_set) 

static bool js_dragonBones_EventObject_animationState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->animationState, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->animationState, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_EventObject_animationState_get) 

static bool js_dragonBones_EventObject_getArmature(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    dragonBones::Armature *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::Armature *)((dragonBones::EventObject const *)arg1)->getArmature();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_EventObject_getArmature) 

static bool js_dragonBones_EventObject_getBone(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    dragonBones::Bone *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::Bone *)((dragonBones::EventObject const *)arg1)->getBone();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_EventObject_getBone) 

static bool js_dragonBones_EventObject_getSlot(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    dragonBones::Slot *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::Slot *)((dragonBones::EventObject const *)arg1)->getSlot();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_EventObject_getSlot) 

static bool js_dragonBones_EventObject_getAnimationState(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::EventObject *arg1 = (dragonBones::EventObject *) NULL ;
    dragonBones::AnimationState *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::EventObject>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::AnimationState *)((dragonBones::EventObject const *)arg1)->getAnimationState();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_EventObject_getAnimationState) 

bool js_register_dragonBones_EventObject(se::Object* obj) {
    auto* cls = se::Class::create("EventObject", obj, __jsb_dragonBones_BaseObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("time", _SE(js_dragonBones_EventObject_time_get), _SE(js_dragonBones_EventObject_time_set)); 
    cls->defineProperty("type", _SE(js_dragonBones_EventObject_type_get), _SE(js_dragonBones_EventObject_type_set)); 
    cls->defineProperty("name", _SE(js_dragonBones_EventObject_name_get), _SE(js_dragonBones_EventObject_name_set)); 
    cls->defineProperty("armature", _SE(js_dragonBones_EventObject_armature_get), _SE(js_dragonBones_EventObject_armature_set)); 
    cls->defineProperty("bone", _SE(js_dragonBones_EventObject_bone_get), _SE(js_dragonBones_EventObject_bone_set)); 
    cls->defineProperty("slot", _SE(js_dragonBones_EventObject_slot_get), _SE(js_dragonBones_EventObject_slot_set)); 
    cls->defineProperty("animationState", _SE(js_dragonBones_EventObject_animationState_get), _SE(js_dragonBones_EventObject_animationState_set)); 
    
    cls->defineFunction("getArmature", _SE(js_dragonBones_EventObject_getArmature)); 
    cls->defineFunction("getBone", _SE(js_dragonBones_EventObject_getBone)); 
    cls->defineFunction("getSlot", _SE(js_dragonBones_EventObject_getSlot)); 
    cls->defineFunction("getAnimationState", _SE(js_dragonBones_EventObject_getAnimationState)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_EventObject));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::EventObject>(cls);
    
    __jsb_dragonBones_EventObject_proto = cls->getProto();
    __jsb_dragonBones_EventObject_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_BaseFactory_class = nullptr;
se::Object* __jsb_dragonBones_BaseFactory_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_BaseFactory) 

static bool js_dragonBones_BaseFactory_autoSearch_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->autoSearch);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BaseFactory_autoSearch_set) 

static bool js_dragonBones_BaseFactory_autoSearch_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->autoSearch, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BaseFactory_autoSearch_get) 

static bool js_delete_dragonBones_BaseFactory(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_BaseFactory) 

static bool js_dragonBones_BaseFactory_parseDragonBonesData__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    char *arg2 = (char *) NULL ;
    std::string *arg3 = 0 ;
    float arg4 ;
    ccstd::string temp2 ;
    std::string temp3 ;
    dragonBones::DragonBonesData *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = (char *) temp2.c_str(); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (dragonBones::DragonBonesData *)(arg1)->parseDragonBonesData((char const *)arg2,(std::string const &)*arg3,arg4);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_parseDragonBonesData__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    char *arg2 = (char *) NULL ;
    std::string *arg3 = 0 ;
    ccstd::string temp2 ;
    std::string temp3 ;
    dragonBones::DragonBonesData *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = (char *) temp2.c_str(); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    result = (dragonBones::DragonBonesData *)(arg1)->parseDragonBonesData((char const *)arg2,(std::string const &)*arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_parseDragonBonesData__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    char *arg2 = (char *) NULL ;
    ccstd::string temp2 ;
    dragonBones::DragonBonesData *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = (char *) temp2.c_str(); 
    result = (dragonBones::DragonBonesData *)(arg1)->parseDragonBonesData((char const *)arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_parseDragonBonesData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_dragonBones_BaseFactory_parseDragonBonesData__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_dragonBones_BaseFactory_parseDragonBonesData__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_dragonBones_BaseFactory_parseDragonBonesData__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_parseDragonBonesData) 

static bool js_dragonBones_BaseFactory_getDragonBonesData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::DragonBonesData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (dragonBones::DragonBonesData *)((dragonBones::BaseFactory const *)arg1)->getDragonBonesData((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_getDragonBonesData) 

static bool js_dragonBones_BaseFactory_addDragonBonesData__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    dragonBones::DragonBonesData *arg2 = (dragonBones::DragonBonesData *) NULL ;
    std::string *arg3 = 0 ;
    std::string temp3 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->addDragonBonesData(arg2,(std::string const &)*arg3);
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_addDragonBonesData__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    dragonBones::DragonBonesData *arg2 = (dragonBones::DragonBonesData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addDragonBonesData(arg2);
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_addDragonBonesData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_dragonBones_BaseFactory_addDragonBonesData__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_dragonBones_BaseFactory_addDragonBonesData__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_addDragonBonesData) 

static bool js_dragonBones_BaseFactory_removeDragonBonesData__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    std::string *arg2 = 0 ;
    bool arg3 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->removeDragonBonesData((std::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_removeDragonBonesData__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->removeDragonBonesData((std::string const &)*arg2);
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_removeDragonBonesData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_dragonBones_BaseFactory_removeDragonBonesData__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_dragonBones_BaseFactory_removeDragonBonesData__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_removeDragonBonesData) 

static bool js_dragonBones_BaseFactory_addTextureAtlasData__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    dragonBones::TextureAtlasData *arg2 = (dragonBones::TextureAtlasData *) NULL ;
    std::string *arg3 = 0 ;
    std::string temp3 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->addTextureAtlasData(arg2,(std::string const &)*arg3);
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_addTextureAtlasData__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    dragonBones::TextureAtlasData *arg2 = (dragonBones::TextureAtlasData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addTextureAtlasData(arg2);
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_addTextureAtlasData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_dragonBones_BaseFactory_addTextureAtlasData__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_dragonBones_BaseFactory_addTextureAtlasData__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_addTextureAtlasData) 

static bool js_dragonBones_BaseFactory_removeTextureAtlasData__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    std::string *arg2 = 0 ;
    bool arg3 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->removeTextureAtlasData((std::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_removeTextureAtlasData__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->removeTextureAtlasData((std::string const &)*arg2);
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_removeTextureAtlasData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_dragonBones_BaseFactory_removeTextureAtlasData__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_dragonBones_BaseFactory_removeTextureAtlasData__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_removeTextureAtlasData) 

static bool js_dragonBones_BaseFactory_getArmatureData__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    dragonBones::ArmatureData *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    result = (dragonBones::ArmatureData *)((dragonBones::BaseFactory const *)arg1)->getArmatureData((std::string const &)*arg2,(std::string const &)*arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_getArmatureData__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::ArmatureData *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (dragonBones::ArmatureData *)((dragonBones::BaseFactory const *)arg1)->getArmatureData((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_getArmatureData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_dragonBones_BaseFactory_getArmatureData__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_dragonBones_BaseFactory_getArmatureData__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_getArmatureData) 

static bool js_dragonBones_BaseFactory_clear__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->clear(arg2);
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_clear__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    (arg1)->clear();
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_clear(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_dragonBones_BaseFactory_clear__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 0) {
        ok = js_dragonBones_BaseFactory_clear__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_clear) 

static bool js_dragonBones_BaseFactory_buildArmature__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string *arg4 = 0 ;
    std::string *arg5 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    std::string temp4 ;
    std::string temp5 ;
    dragonBones::Armature *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg5 = &temp5;
    
    result = (dragonBones::Armature *)((dragonBones::BaseFactory const *)arg1)->buildArmature((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_buildArmature__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string *arg4 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    std::string temp4 ;
    dragonBones::Armature *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    result = (dragonBones::Armature *)((dragonBones::BaseFactory const *)arg1)->buildArmature((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_buildArmature__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    dragonBones::Armature *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    result = (dragonBones::Armature *)((dragonBones::BaseFactory const *)arg1)->buildArmature((std::string const &)*arg2,(std::string const &)*arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_buildArmature__SWIG_3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::Armature *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (dragonBones::Armature *)((dragonBones::BaseFactory const *)arg1)->buildArmature((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_buildArmature(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 4) {
        ok = js_dragonBones_BaseFactory_buildArmature__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 3) {
        ok = js_dragonBones_BaseFactory_buildArmature__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_dragonBones_BaseFactory_buildArmature__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_dragonBones_BaseFactory_buildArmature__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_buildArmature) 

static bool js_dragonBones_BaseFactory_replaceSlotDisplay__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string *arg4 = 0 ;
    std::string *arg5 = 0 ;
    dragonBones::Slot *arg6 = (dragonBones::Slot *) NULL ;
    int arg7 ;
    std::string temp2 ;
    std::string temp3 ;
    std::string temp4 ;
    std::string temp5 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg5 = &temp5;
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (bool)((dragonBones::BaseFactory const *)arg1)->replaceSlotDisplay((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5,arg6,arg7);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_replaceSlotDisplay__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string *arg4 = 0 ;
    std::string *arg5 = 0 ;
    dragonBones::Slot *arg6 = (dragonBones::Slot *) NULL ;
    std::string temp2 ;
    std::string temp3 ;
    std::string temp4 ;
    std::string temp5 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg5 = &temp5;
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (bool)((dragonBones::BaseFactory const *)arg1)->replaceSlotDisplay((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5,arg6);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_replaceSlotDisplay(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 6) {
        ok = js_dragonBones_BaseFactory_replaceSlotDisplay__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 5) {
        ok = js_dragonBones_BaseFactory_replaceSlotDisplay__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_replaceSlotDisplay) 

static bool js_dragonBones_BaseFactory_replaceSkin(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    dragonBones::Armature *arg2 = (dragonBones::Armature *) NULL ;
    dragonBones::SkinData *arg3 = (dragonBones::SkinData *) NULL ;
    bool arg4 ;
    std::vector< std::string > *arg5 = 0 ;
    std::vector< std::string > temp5 ;
    bool result;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg5 = &temp5;
    
    result = (bool)((dragonBones::BaseFactory const *)arg1)->replaceSkin(arg2,arg3,arg4,(std::vector< std::string > const &)*arg5);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_replaceSkin) 

static bool js_dragonBones_BaseFactory_replaceAnimation__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    dragonBones::Armature *arg2 = (dragonBones::Armature *) NULL ;
    dragonBones::ArmatureData *arg3 = (dragonBones::ArmatureData *) NULL ;
    bool arg4 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (bool)((dragonBones::BaseFactory const *)arg1)->replaceAnimation(arg2,arg3,arg4);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_replaceAnimation__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    dragonBones::Armature *arg2 = (dragonBones::Armature *) NULL ;
    dragonBones::ArmatureData *arg3 = (dragonBones::ArmatureData *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (bool)((dragonBones::BaseFactory const *)arg1)->replaceAnimation(arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}

static bool js_dragonBones_BaseFactory_replaceAnimation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_dragonBones_BaseFactory_replaceAnimation__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_dragonBones_BaseFactory_replaceAnimation__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_replaceAnimation) 

static bool js_dragonBones_BaseFactory_getClock(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    dragonBones::WorldClock *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::WorldClock *)((dragonBones::BaseFactory const *)arg1)->getClock();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_getClock) 

static bool js_dragonBones_BaseFactory_changeSkin(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BaseFactory *arg1 = (dragonBones::BaseFactory *) NULL ;
    dragonBones::Armature *arg2 = (dragonBones::Armature *) NULL ;
    dragonBones::SkinData *arg3 = (dragonBones::SkinData *) NULL ;
    std::vector< std::string > *arg4 = 0 ;
    std::vector< std::string > temp4 ;
    bool result;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::BaseFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    result = (bool)((dragonBones::BaseFactory const *)arg1)->changeSkin(arg2,arg3,(std::vector< std::string > const &)*arg4);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_BaseFactory_changeSkin) 

bool js_register_dragonBones_BaseFactory(se::Object* obj) {
    auto* cls = se::Class::create("BaseFactory", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("autoSearch", _SE(js_dragonBones_BaseFactory_autoSearch_get), _SE(js_dragonBones_BaseFactory_autoSearch_set)); 
    
    cls->defineFunction("parseDragonBonesData", _SE(js_dragonBones_BaseFactory_parseDragonBonesData)); 
    cls->defineFunction("getDragonBonesData", _SE(js_dragonBones_BaseFactory_getDragonBonesData)); 
    cls->defineFunction("addDragonBonesData", _SE(js_dragonBones_BaseFactory_addDragonBonesData)); 
    cls->defineFunction("removeDragonBonesData", _SE(js_dragonBones_BaseFactory_removeDragonBonesData)); 
    cls->defineFunction("addTextureAtlasData", _SE(js_dragonBones_BaseFactory_addTextureAtlasData)); 
    cls->defineFunction("removeTextureAtlasData", _SE(js_dragonBones_BaseFactory_removeTextureAtlasData)); 
    cls->defineFunction("getArmatureData", _SE(js_dragonBones_BaseFactory_getArmatureData)); 
    cls->defineFunction("clear", _SE(js_dragonBones_BaseFactory_clear)); 
    cls->defineFunction("buildArmature", _SE(js_dragonBones_BaseFactory_buildArmature)); 
    cls->defineFunction("replaceSlotDisplay", _SE(js_dragonBones_BaseFactory_replaceSlotDisplay)); 
    cls->defineFunction("replaceSkin", _SE(js_dragonBones_BaseFactory_replaceSkin)); 
    cls->defineFunction("replaceAnimation", _SE(js_dragonBones_BaseFactory_replaceAnimation)); 
    cls->defineFunction("getClock", _SE(js_dragonBones_BaseFactory_getClock)); 
    cls->defineFunction("changeSkin", _SE(js_dragonBones_BaseFactory_changeSkin)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_BaseFactory));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::BaseFactory>(cls);
    
    __jsb_dragonBones_BaseFactory_proto = cls->getProto();
    __jsb_dragonBones_BaseFactory_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_BuildArmaturePackage_class = nullptr;
se::Object* __jsb_dragonBones_BuildArmaturePackage_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_BuildArmaturePackage) 

static bool js_dragonBones_BuildArmaturePackage_dataName_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BuildArmaturePackage *arg1 = (dragonBones::BuildArmaturePackage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BuildArmaturePackage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->dataName, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BuildArmaturePackage_dataName_set) 

static bool js_dragonBones_BuildArmaturePackage_dataName_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BuildArmaturePackage *arg1 = (dragonBones::BuildArmaturePackage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BuildArmaturePackage>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->dataName, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->dataName, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BuildArmaturePackage_dataName_get) 

static bool js_dragonBones_BuildArmaturePackage_textureAtlasName_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BuildArmaturePackage *arg1 = (dragonBones::BuildArmaturePackage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BuildArmaturePackage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->textureAtlasName, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BuildArmaturePackage_textureAtlasName_set) 

static bool js_dragonBones_BuildArmaturePackage_textureAtlasName_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BuildArmaturePackage *arg1 = (dragonBones::BuildArmaturePackage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BuildArmaturePackage>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->textureAtlasName, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->textureAtlasName, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BuildArmaturePackage_textureAtlasName_get) 

static bool js_dragonBones_BuildArmaturePackage_data_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BuildArmaturePackage *arg1 = (dragonBones::BuildArmaturePackage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BuildArmaturePackage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->data, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BuildArmaturePackage_data_set) 

static bool js_dragonBones_BuildArmaturePackage_data_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BuildArmaturePackage *arg1 = (dragonBones::BuildArmaturePackage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BuildArmaturePackage>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->data, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->data, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BuildArmaturePackage_data_get) 

static bool js_dragonBones_BuildArmaturePackage_armature_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BuildArmaturePackage *arg1 = (dragonBones::BuildArmaturePackage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BuildArmaturePackage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->armature, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BuildArmaturePackage_armature_set) 

static bool js_dragonBones_BuildArmaturePackage_armature_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BuildArmaturePackage *arg1 = (dragonBones::BuildArmaturePackage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BuildArmaturePackage>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->armature, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->armature, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BuildArmaturePackage_armature_get) 

static bool js_dragonBones_BuildArmaturePackage_skin_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BuildArmaturePackage *arg1 = (dragonBones::BuildArmaturePackage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BuildArmaturePackage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->skin, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BuildArmaturePackage_skin_set) 

static bool js_dragonBones_BuildArmaturePackage_skin_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BuildArmaturePackage *arg1 = (dragonBones::BuildArmaturePackage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BuildArmaturePackage>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->skin, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->skin, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BuildArmaturePackage_skin_get) 

static bool js_new_dragonBones_BuildArmaturePackage(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    dragonBones::BuildArmaturePackage *result;
    result = (dragonBones::BuildArmaturePackage *)new dragonBones::BuildArmaturePackage();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_dragonBones_BuildArmaturePackage, __jsb_dragonBones_BuildArmaturePackage_class, js_delete_dragonBones_BuildArmaturePackage)

static bool js_delete_dragonBones_BuildArmaturePackage(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_BuildArmaturePackage) 

bool js_register_dragonBones_BuildArmaturePackage(se::Object* obj) {
    auto* cls = se::Class::create("BuildArmaturePackage", obj, nullptr, _SE(js_new_dragonBones_BuildArmaturePackage)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("dataName", _SE(js_dragonBones_BuildArmaturePackage_dataName_get), _SE(js_dragonBones_BuildArmaturePackage_dataName_set)); 
    cls->defineProperty("textureAtlasName", _SE(js_dragonBones_BuildArmaturePackage_textureAtlasName_get), _SE(js_dragonBones_BuildArmaturePackage_textureAtlasName_set)); 
    cls->defineProperty("data", _SE(js_dragonBones_BuildArmaturePackage_data_get), _SE(js_dragonBones_BuildArmaturePackage_data_set)); 
    cls->defineProperty("armature", _SE(js_dragonBones_BuildArmaturePackage_armature_get), _SE(js_dragonBones_BuildArmaturePackage_armature_set)); 
    cls->defineProperty("skin", _SE(js_dragonBones_BuildArmaturePackage_skin_get), _SE(js_dragonBones_BuildArmaturePackage_skin_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_BuildArmaturePackage));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::BuildArmaturePackage>(cls);
    
    __jsb_dragonBones_BuildArmaturePackage_proto = cls->getProto();
    __jsb_dragonBones_BuildArmaturePackage_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_DragonBonesData_class = nullptr;
se::Object* __jsb_dragonBones_DragonBonesData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_DragonBonesData) 

static bool js_dragonBones_DragonBonesData_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::DragonBonesData *arg1 = (dragonBones::DragonBonesData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::DragonBonesData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_DragonBonesData_name_set) 

static bool js_dragonBones_DragonBonesData_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::DragonBonesData *arg1 = (dragonBones::DragonBonesData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::DragonBonesData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_DragonBonesData_name_get) 

static bool js_delete_dragonBones_DragonBonesData(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_DragonBonesData) 

static bool js_dragonBones_DragonBonesData_addArmature(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::DragonBonesData *arg1 = (dragonBones::DragonBonesData *) NULL ;
    dragonBones::ArmatureData *arg2 = (dragonBones::ArmatureData *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::DragonBonesData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addArmature(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_DragonBonesData_addArmature) 

static bool js_dragonBones_DragonBonesData_getArmature(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::DragonBonesData *arg1 = (dragonBones::DragonBonesData *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::ArmatureData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::DragonBonesData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (dragonBones::ArmatureData *)((dragonBones::DragonBonesData const *)arg1)->getArmature((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_DragonBonesData_getArmature) 

static bool js_dragonBones_DragonBonesData_getFrameIndices(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::DragonBonesData *arg1 = (dragonBones::DragonBonesData *) NULL ;
    std::vector< unsigned int > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::DragonBonesData>(s);
    if (nullptr == arg1) return true;
    result = (std::vector< unsigned int > *)(arg1)->getFrameIndices();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_DragonBonesData_getFrameIndices) 

static bool js_dragonBones_DragonBonesData_getArmatureNames(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::DragonBonesData *arg1 = (dragonBones::DragonBonesData *) NULL ;
    std::vector< std::string > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::DragonBonesData>(s);
    if (nullptr == arg1) return true;
    result = (std::vector< std::string > *) &((dragonBones::DragonBonesData const *)arg1)->getArmatureNames();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_DragonBonesData_getArmatureNames) 

bool js_register_dragonBones_DragonBonesData(se::Object* obj) {
    auto* cls = se::Class::create("DragonBonesData", obj, __jsb_dragonBones_BaseObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("name", _SE(js_dragonBones_DragonBonesData_name_get), _SE(js_dragonBones_DragonBonesData_name_set)); 
    
    cls->defineFunction("addArmature", _SE(js_dragonBones_DragonBonesData_addArmature)); 
    cls->defineFunction("getArmature", _SE(js_dragonBones_DragonBonesData_getArmature)); 
    cls->defineFunction("getFrameIndices", _SE(js_dragonBones_DragonBonesData_getFrameIndices)); 
    cls->defineFunction("getArmatureNames", _SE(js_dragonBones_DragonBonesData_getArmatureNames)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_DragonBonesData));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::DragonBonesData>(cls);
    
    __jsb_dragonBones_DragonBonesData_proto = cls->getProto();
    __jsb_dragonBones_DragonBonesData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_TextureAtlasData_class = nullptr;
se::Object* __jsb_dragonBones_TextureAtlasData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_TextureAtlasData) 

static bool js_delete_dragonBones_TextureAtlasData(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_TextureAtlasData) 

static bool js_dragonBones_TextureAtlasData_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TextureAtlasData *arg1 = (dragonBones::TextureAtlasData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TextureAtlasData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_TextureAtlasData_name_set) 

static bool js_dragonBones_TextureAtlasData_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::TextureAtlasData *arg1 = (dragonBones::TextureAtlasData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TextureAtlasData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_TextureAtlasData_name_get) 

static bool js_dragonBones_TextureAtlasData_createTexture(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TextureAtlasData *arg1 = (dragonBones::TextureAtlasData *) NULL ;
    dragonBones::TextureData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TextureAtlasData>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::TextureData *)((dragonBones::TextureAtlasData const *)arg1)->createTexture();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TextureAtlasData_createTexture) 

static bool js_dragonBones_TextureAtlasData_addTexture(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TextureAtlasData *arg1 = (dragonBones::TextureAtlasData *) NULL ;
    dragonBones::TextureData *arg2 = (dragonBones::TextureData *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TextureAtlasData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addTexture(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TextureAtlasData_addTexture) 

static bool js_dragonBones_TextureAtlasData_getTexture(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TextureAtlasData *arg1 = (dragonBones::TextureAtlasData *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::TextureData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TextureAtlasData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (dragonBones::TextureData *)((dragonBones::TextureAtlasData const *)arg1)->getTexture((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TextureAtlasData_getTexture) 

bool js_register_dragonBones_TextureAtlasData(se::Object* obj) {
    auto* cls = se::Class::create("TextureAtlasData", obj, __jsb_dragonBones_BaseObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("name", _SE(js_dragonBones_TextureAtlasData_name_get), _SE(js_dragonBones_TextureAtlasData_name_set)); 
    
    cls->defineFunction("createTexture", _SE(js_dragonBones_TextureAtlasData_createTexture)); 
    cls->defineFunction("addTexture", _SE(js_dragonBones_TextureAtlasData_addTexture)); 
    cls->defineFunction("getTexture", _SE(js_dragonBones_TextureAtlasData_getTexture)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_TextureAtlasData));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::TextureAtlasData>(cls);
    
    __jsb_dragonBones_TextureAtlasData_proto = cls->getProto();
    __jsb_dragonBones_TextureAtlasData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_TextureData_class = nullptr;
se::Object* __jsb_dragonBones_TextureData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_TextureData) 

static bool js_dragonBones_TextureData_createRectangle_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Rectangle *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (dragonBones::Rectangle *)dragonBones::TextureData::createRectangle();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TextureData_createRectangle_static) 

static bool js_delete_dragonBones_TextureData(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_TextureData) 

static bool js_dragonBones_TextureData_getRegion(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TextureData *arg1 = (dragonBones::TextureData *) NULL ;
    dragonBones::Rectangle *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TextureData>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::Rectangle *)(arg1)->getRegion();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TextureData_getRegion) 

static bool js_dragonBones_TextureData_getFrame(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TextureData *arg1 = (dragonBones::TextureData *) NULL ;
    dragonBones::Rectangle *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TextureData>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::Rectangle *)((dragonBones::TextureData const *)arg1)->getFrame();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TextureData_getFrame) 

static bool js_dragonBones_TextureData_setFrame(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TextureData *arg1 = (dragonBones::TextureData *) NULL ;
    dragonBones::Rectangle *arg2 = (dragonBones::Rectangle *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TextureData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setFrame(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TextureData_setFrame) 

static bool js_dragonBones_TextureData_getParent(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TextureData *arg1 = (dragonBones::TextureData *) NULL ;
    dragonBones::TextureAtlasData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TextureData>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::TextureAtlasData *)((dragonBones::TextureData const *)arg1)->getParent();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TextureData_getParent) 

static bool js_dragonBones_TextureData_setParent(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TextureData *arg1 = (dragonBones::TextureData *) NULL ;
    dragonBones::TextureAtlasData *arg2 = (dragonBones::TextureAtlasData *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TextureData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setParent(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TextureData_setParent) 

bool js_register_dragonBones_TextureData(se::Object* obj) {
    auto* cls = se::Class::create("TextureData", obj, __jsb_dragonBones_BaseObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getRegion", _SE(js_dragonBones_TextureData_getRegion)); 
    cls->defineFunction("getFrame", _SE(js_dragonBones_TextureData_getFrame)); 
    cls->defineFunction("setFrame", _SE(js_dragonBones_TextureData_setFrame)); 
    cls->defineFunction("getParent", _SE(js_dragonBones_TextureData_getParent)); 
    cls->defineFunction("setParent", _SE(js_dragonBones_TextureData_setParent)); 
    
    
    cls->defineStaticFunction("createRectangle", _SE(js_dragonBones_TextureData_createRectangle_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_TextureData));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::TextureData>(cls);
    
    __jsb_dragonBones_TextureData_proto = cls->getProto();
    __jsb_dragonBones_TextureData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_ArmatureData_class = nullptr;
se::Object* __jsb_dragonBones_ArmatureData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_ArmatureData) 

static bool js_dragonBones_ArmatureData_frameRate_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->frameRate, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_ArmatureData_frameRate_set) 

static bool js_dragonBones_ArmatureData_frameRate_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->frameRate, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_ArmatureData_frameRate_get) 

static bool js_dragonBones_ArmatureData_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_ArmatureData_name_set) 

static bool js_dragonBones_ArmatureData_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_ArmatureData_name_get) 

static bool js_delete_dragonBones_ArmatureData(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_ArmatureData) 

static bool js_dragonBones_ArmatureData_sortBones(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    if (nullptr == arg1) return true;
    (arg1)->sortBones();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_sortBones) 

static bool js_dragonBones_ArmatureData_getBone(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::BoneData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (dragonBones::BoneData *)((dragonBones::ArmatureData const *)arg1)->getBone((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_getBone) 

static bool js_dragonBones_ArmatureData_getSlot(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::SlotData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (dragonBones::SlotData *)((dragonBones::ArmatureData const *)arg1)->getSlot((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_getSlot) 

static bool js_dragonBones_ArmatureData_getSkin(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::SkinData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (dragonBones::SkinData *)((dragonBones::ArmatureData const *)arg1)->getSkin((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_getSkin) 

static bool js_dragonBones_ArmatureData_getMesh(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string *arg4 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    std::string temp4 ;
    dragonBones::MeshDisplayData *result = 0 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    result = (dragonBones::MeshDisplayData *)((dragonBones::ArmatureData const *)arg1)->getMesh((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_getMesh) 

static bool js_dragonBones_ArmatureData_getAnimation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::AnimationData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (dragonBones::AnimationData *)((dragonBones::ArmatureData const *)arg1)->getAnimation((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_getAnimation) 

static bool js_dragonBones_ArmatureData_getType(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    if (nullptr == arg1) return true;
    result = (int)((dragonBones::ArmatureData const *)arg1)->getType();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_getType) 

static bool js_dragonBones_ArmatureData_setType(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setType(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_setType) 

static bool js_dragonBones_ArmatureData_getAABB(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    dragonBones::Rectangle *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::Rectangle *)(arg1)->getAABB();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_getAABB) 

static bool js_dragonBones_ArmatureData_getAnimationNames(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    std::vector< std::string > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    if (nullptr == arg1) return true;
    result = (std::vector< std::string > *) &((dragonBones::ArmatureData const *)arg1)->getAnimationNames();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_getAnimationNames) 

static bool js_dragonBones_ArmatureData_getDefaultSkin(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    dragonBones::SkinData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::SkinData *)((dragonBones::ArmatureData const *)arg1)->getDefaultSkin();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_getDefaultSkin) 

static bool js_dragonBones_ArmatureData_setDefaultSkin(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    dragonBones::SkinData *arg2 = (dragonBones::SkinData *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setDefaultSkin(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_setDefaultSkin) 

static bool js_dragonBones_ArmatureData_getDefaultAnimation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    dragonBones::AnimationData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::AnimationData *)((dragonBones::ArmatureData const *)arg1)->getDefaultAnimation();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_getDefaultAnimation) 

static bool js_dragonBones_ArmatureData_setDefaultAnimation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    dragonBones::AnimationData *arg2 = (dragonBones::AnimationData *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setDefaultAnimation(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_setDefaultAnimation) 

static bool js_dragonBones_ArmatureData_getParent(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    dragonBones::DragonBonesData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::DragonBonesData *)((dragonBones::ArmatureData const *)arg1)->getParent();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_getParent) 

static bool js_dragonBones_ArmatureData_setParent(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureData *arg1 = (dragonBones::ArmatureData *) NULL ;
    dragonBones::DragonBonesData *arg2 = (dragonBones::DragonBonesData *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setParent(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureData_setParent) 

bool js_register_dragonBones_ArmatureData(se::Object* obj) {
    auto* cls = se::Class::create("ArmatureData", obj, __jsb_dragonBones_BaseObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("frameRate", _SE(js_dragonBones_ArmatureData_frameRate_get), _SE(js_dragonBones_ArmatureData_frameRate_set)); 
    cls->defineProperty("name", _SE(js_dragonBones_ArmatureData_name_get), _SE(js_dragonBones_ArmatureData_name_set)); 
    
    cls->defineFunction("sortBones", _SE(js_dragonBones_ArmatureData_sortBones)); 
    cls->defineFunction("getBone", _SE(js_dragonBones_ArmatureData_getBone)); 
    cls->defineFunction("getSlot", _SE(js_dragonBones_ArmatureData_getSlot)); 
    cls->defineFunction("getSkin", _SE(js_dragonBones_ArmatureData_getSkin)); 
    cls->defineFunction("getMesh", _SE(js_dragonBones_ArmatureData_getMesh)); 
    cls->defineFunction("getAnimation", _SE(js_dragonBones_ArmatureData_getAnimation)); 
    cls->defineFunction("getType", _SE(js_dragonBones_ArmatureData_getType)); 
    cls->defineFunction("setType", _SE(js_dragonBones_ArmatureData_setType)); 
    cls->defineFunction("getAABB", _SE(js_dragonBones_ArmatureData_getAABB)); 
    cls->defineFunction("getAnimationNames", _SE(js_dragonBones_ArmatureData_getAnimationNames)); 
    cls->defineFunction("getDefaultSkin", _SE(js_dragonBones_ArmatureData_getDefaultSkin)); 
    cls->defineFunction("setDefaultSkin", _SE(js_dragonBones_ArmatureData_setDefaultSkin)); 
    cls->defineFunction("getDefaultAnimation", _SE(js_dragonBones_ArmatureData_getDefaultAnimation)); 
    cls->defineFunction("setDefaultAnimation", _SE(js_dragonBones_ArmatureData_setDefaultAnimation)); 
    cls->defineFunction("getParent", _SE(js_dragonBones_ArmatureData_getParent)); 
    cls->defineFunction("setParent", _SE(js_dragonBones_ArmatureData_setParent)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_ArmatureData));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::ArmatureData>(cls);
    
    __jsb_dragonBones_ArmatureData_proto = cls->getProto();
    __jsb_dragonBones_ArmatureData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_BoneData_class = nullptr;
se::Object* __jsb_dragonBones_BoneData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_BoneData) 

static bool js_dragonBones_BoneData_length_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BoneData *arg1 = (dragonBones::BoneData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BoneData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->length, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BoneData_length_set) 

static bool js_dragonBones_BoneData_length_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BoneData *arg1 = (dragonBones::BoneData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BoneData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->length, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BoneData_length_get) 

static bool js_dragonBones_BoneData_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BoneData *arg1 = (dragonBones::BoneData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BoneData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BoneData_name_set) 

static bool js_dragonBones_BoneData_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BoneData *arg1 = (dragonBones::BoneData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BoneData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BoneData_name_get) 

static bool js_dragonBones_BoneData_parent_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BoneData *arg1 = (dragonBones::BoneData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BoneData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->parent, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BoneData_parent_set) 

static bool js_dragonBones_BoneData_parent_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BoneData *arg1 = (dragonBones::BoneData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BoneData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->parent, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->parent, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BoneData_parent_get) 

static bool js_delete_dragonBones_BoneData(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_BoneData) 

static bool js_dragonBones_BoneData_getTransfrom(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BoneData *arg1 = (dragonBones::BoneData *) NULL ;
    dragonBones::Transform *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::BoneData>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::Transform *)(arg1)->getTransfrom();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_BoneData_getTransfrom) 

static bool js_dragonBones_BoneData_getParent(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BoneData *arg1 = (dragonBones::BoneData *) NULL ;
    dragonBones::BoneData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::BoneData>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::BoneData *)((dragonBones::BoneData const *)arg1)->getParent();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_BoneData_getParent) 

static bool js_dragonBones_BoneData_setParent(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BoneData *arg1 = (dragonBones::BoneData *) NULL ;
    dragonBones::BoneData *arg2 = (dragonBones::BoneData *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::BoneData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setParent(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_BoneData_setParent) 

bool js_register_dragonBones_BoneData(se::Object* obj) {
    auto* cls = se::Class::create("BoneData", obj, __jsb_dragonBones_BaseObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("length", _SE(js_dragonBones_BoneData_length_get), _SE(js_dragonBones_BoneData_length_set)); 
    cls->defineProperty("name", _SE(js_dragonBones_BoneData_name_get), _SE(js_dragonBones_BoneData_name_set)); 
    cls->defineProperty("parent", _SE(js_dragonBones_BoneData_parent_get), _SE(js_dragonBones_BoneData_parent_set)); 
    
    cls->defineFunction("getTransfrom", _SE(js_dragonBones_BoneData_getTransfrom)); 
    cls->defineFunction("getParent", _SE(js_dragonBones_BoneData_getParent)); 
    cls->defineFunction("setParent", _SE(js_dragonBones_BoneData_setParent)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_BoneData));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::BoneData>(cls);
    
    __jsb_dragonBones_BoneData_proto = cls->getProto();
    __jsb_dragonBones_BoneData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_SlotData_class = nullptr;
se::Object* __jsb_dragonBones_SlotData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_SlotData) 

static bool js_dragonBones_SlotData_blendMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blendMode, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_SlotData_blendMode_set) 

static bool js_dragonBones_SlotData_blendMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blendMode, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendMode, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_SlotData_blendMode_get) 

static bool js_dragonBones_SlotData_displayIndex_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->displayIndex, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_SlotData_displayIndex_set) 

static bool js_dragonBones_SlotData_displayIndex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->displayIndex, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_SlotData_displayIndex_get) 

static bool js_dragonBones_SlotData_zOrder_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->zOrder, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_SlotData_zOrder_set) 

static bool js_dragonBones_SlotData_zOrder_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->zOrder, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_SlotData_zOrder_get) 

static bool js_dragonBones_SlotData_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_SlotData_name_set) 

static bool js_dragonBones_SlotData_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_SlotData_name_get) 

static bool js_dragonBones_SlotData_parent_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->parent, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_SlotData_parent_set) 

static bool js_dragonBones_SlotData_parent_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->parent, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->parent, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_SlotData_parent_get) 

static bool js_delete_dragonBones_SlotData(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_SlotData) 

static bool js_dragonBones_SlotData_getBlendMode(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    if (nullptr == arg1) return true;
    result = (int)((dragonBones::SlotData const *)arg1)->getBlendMode();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_SlotData_getBlendMode) 

static bool js_dragonBones_SlotData_setBlendMode(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setBlendMode(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_SlotData_setBlendMode) 

static bool js_dragonBones_SlotData_getParent(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    dragonBones::BoneData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::BoneData *)((dragonBones::SlotData const *)arg1)->getParent();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_SlotData_getParent) 

static bool js_dragonBones_SlotData_setParent(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::SlotData *arg1 = (dragonBones::SlotData *) NULL ;
    dragonBones::BoneData *arg2 = (dragonBones::BoneData *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::SlotData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setParent(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_SlotData_setParent) 

bool js_register_dragonBones_SlotData(se::Object* obj) {
    auto* cls = se::Class::create("SlotData", obj, __jsb_dragonBones_BaseObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("blendMode", _SE(js_dragonBones_SlotData_blendMode_get), _SE(js_dragonBones_SlotData_blendMode_set)); 
    cls->defineProperty("displayIndex", _SE(js_dragonBones_SlotData_displayIndex_get), _SE(js_dragonBones_SlotData_displayIndex_set)); 
    cls->defineProperty("zOrder", _SE(js_dragonBones_SlotData_zOrder_get), _SE(js_dragonBones_SlotData_zOrder_set)); 
    cls->defineProperty("name", _SE(js_dragonBones_SlotData_name_get), _SE(js_dragonBones_SlotData_name_set)); 
    cls->defineProperty("parent", _SE(js_dragonBones_SlotData_parent_get), _SE(js_dragonBones_SlotData_parent_set)); 
    
    cls->defineFunction("getBlendMode", _SE(js_dragonBones_SlotData_getBlendMode)); 
    cls->defineFunction("setBlendMode", _SE(js_dragonBones_SlotData_setBlendMode)); 
    cls->defineFunction("getParent", _SE(js_dragonBones_SlotData_getParent)); 
    cls->defineFunction("setParent", _SE(js_dragonBones_SlotData_setParent)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_SlotData));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::SlotData>(cls);
    
    __jsb_dragonBones_SlotData_proto = cls->getProto();
    __jsb_dragonBones_SlotData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_SkinData_class = nullptr;
se::Object* __jsb_dragonBones_SkinData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_SkinData) 

static bool js_delete_dragonBones_SkinData(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_SkinData) 

static bool js_dragonBones_SkinData_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::SkinData *arg1 = (dragonBones::SkinData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::SkinData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_SkinData_name_set) 

static bool js_dragonBones_SkinData_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::SkinData *arg1 = (dragonBones::SkinData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::SkinData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_SkinData_name_get) 

bool js_register_dragonBones_SkinData(se::Object* obj) {
    auto* cls = se::Class::create("SkinData", obj, __jsb_dragonBones_BaseObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("name", _SE(js_dragonBones_SkinData_name_get), _SE(js_dragonBones_SkinData_name_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_SkinData));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::SkinData>(cls);
    
    __jsb_dragonBones_SkinData_proto = cls->getProto();
    __jsb_dragonBones_SkinData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_AnimationData_class = nullptr;
se::Object* __jsb_dragonBones_AnimationData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_AnimationData) 

static bool js_dragonBones_AnimationData_frameCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->frameCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationData_frameCount_set) 

static bool js_dragonBones_AnimationData_frameCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->frameCount, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationData_frameCount_get) 

static bool js_dragonBones_AnimationData_playTimes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->playTimes, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationData_playTimes_set) 

static bool js_dragonBones_AnimationData_playTimes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->playTimes, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationData_playTimes_get) 

static bool js_dragonBones_AnimationData_duration_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->duration, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationData_duration_set) 

static bool js_dragonBones_AnimationData_duration_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->duration, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationData_duration_get) 

static bool js_dragonBones_AnimationData_fadeInTime_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->fadeInTime, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationData_fadeInTime_set) 

static bool js_dragonBones_AnimationData_fadeInTime_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->fadeInTime, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationData_fadeInTime_get) 

static bool js_dragonBones_AnimationData_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationData_name_set) 

static bool js_dragonBones_AnimationData_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationData_name_get) 

static bool js_delete_dragonBones_AnimationData(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_AnimationData) 

static bool js_dragonBones_AnimationData_getBoneCachedFrameIndices(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    std::vector< int > *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (std::vector< int > *)(arg1)->getBoneCachedFrameIndices((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationData_getBoneCachedFrameIndices) 

static bool js_dragonBones_AnimationData_getSlotCachedFrameIndices(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    std::vector< int > *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (std::vector< int > *)(arg1)->getSlotCachedFrameIndices((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationData_getSlotCachedFrameIndices) 

static bool js_dragonBones_AnimationData_getZOrderTimeline(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    dragonBones::TimelineData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::TimelineData *)((dragonBones::AnimationData const *)arg1)->getZOrderTimeline();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationData_getZOrderTimeline) 

static bool js_dragonBones_AnimationData_getParent(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    dragonBones::ArmatureData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::ArmatureData *)((dragonBones::AnimationData const *)arg1)->getParent();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationData_getParent) 

static bool js_dragonBones_AnimationData_setParent(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationData *arg1 = (dragonBones::AnimationData *) NULL ;
    dragonBones::ArmatureData *arg2 = (dragonBones::ArmatureData *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setParent(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationData_setParent) 

bool js_register_dragonBones_AnimationData(se::Object* obj) {
    auto* cls = se::Class::create("AnimationData", obj, __jsb_dragonBones_BaseObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("frameCount", _SE(js_dragonBones_AnimationData_frameCount_get), _SE(js_dragonBones_AnimationData_frameCount_set)); 
    cls->defineProperty("playTimes", _SE(js_dragonBones_AnimationData_playTimes_get), _SE(js_dragonBones_AnimationData_playTimes_set)); 
    cls->defineProperty("duration", _SE(js_dragonBones_AnimationData_duration_get), _SE(js_dragonBones_AnimationData_duration_set)); 
    cls->defineProperty("fadeInTime", _SE(js_dragonBones_AnimationData_fadeInTime_get), _SE(js_dragonBones_AnimationData_fadeInTime_set)); 
    cls->defineProperty("name", _SE(js_dragonBones_AnimationData_name_get), _SE(js_dragonBones_AnimationData_name_set)); 
    
    cls->defineFunction("getBoneCachedFrameIndices", _SE(js_dragonBones_AnimationData_getBoneCachedFrameIndices)); 
    cls->defineFunction("getSlotCachedFrameIndices", _SE(js_dragonBones_AnimationData_getSlotCachedFrameIndices)); 
    cls->defineFunction("getZOrderTimeline", _SE(js_dragonBones_AnimationData_getZOrderTimeline)); 
    cls->defineFunction("getParent", _SE(js_dragonBones_AnimationData_getParent)); 
    cls->defineFunction("setParent", _SE(js_dragonBones_AnimationData_setParent)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_AnimationData));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::AnimationData>(cls);
    
    __jsb_dragonBones_AnimationData_proto = cls->getProto();
    __jsb_dragonBones_AnimationData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_TimelineData_class = nullptr;
se::Object* __jsb_dragonBones_TimelineData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_TimelineData) 

static bool js_dragonBones_TimelineData_getTypeIndex_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    std::size_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = dragonBones::TimelineData::getTypeIndex();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TimelineData_getTypeIndex_static) 

static bool js_new_dragonBones_TimelineData(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    dragonBones::TimelineData *result;
    result = (dragonBones::TimelineData *)new dragonBones::TimelineData();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_dragonBones_TimelineData, __jsb_dragonBones_TimelineData_class, js_delete_dragonBones_TimelineData)

static bool js_delete_dragonBones_TimelineData(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_TimelineData) 

static bool js_dragonBones_TimelineData_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TimelineData *arg1 = (dragonBones::TimelineData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TimelineData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->type, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_TimelineData_type_set) 

static bool js_dragonBones_TimelineData_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::TimelineData *arg1 = (dragonBones::TimelineData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TimelineData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->type, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->type, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_TimelineData_type_get) 

static bool js_dragonBones_TimelineData_offset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TimelineData *arg1 = (dragonBones::TimelineData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TimelineData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->offset, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_TimelineData_offset_set) 

static bool js_dragonBones_TimelineData_offset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::TimelineData *arg1 = (dragonBones::TimelineData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TimelineData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->offset, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_TimelineData_offset_get) 

static bool js_dragonBones_TimelineData_frameIndicesOffset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TimelineData *arg1 = (dragonBones::TimelineData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TimelineData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->frameIndicesOffset, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_TimelineData_frameIndicesOffset_set) 

static bool js_dragonBones_TimelineData_frameIndicesOffset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::TimelineData *arg1 = (dragonBones::TimelineData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TimelineData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->frameIndicesOffset, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_TimelineData_frameIndicesOffset_get) 

static bool js_dragonBones_TimelineData_getType(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TimelineData *arg1 = (dragonBones::TimelineData *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TimelineData>(s);
    if (nullptr == arg1) return true;
    result = (int)((dragonBones::TimelineData const *)arg1)->getType();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TimelineData_getType) 

static bool js_dragonBones_TimelineData_setType(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TimelineData *arg1 = (dragonBones::TimelineData *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TimelineData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setType(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TimelineData_setType) 

bool js_register_dragonBones_TimelineData(se::Object* obj) {
    auto* cls = se::Class::create("TimelineData", obj, __jsb_dragonBones_BaseObject_proto, _SE(js_new_dragonBones_TimelineData)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("type", _SE(js_dragonBones_TimelineData_type_get), _SE(js_dragonBones_TimelineData_type_set)); 
    cls->defineProperty("offset", _SE(js_dragonBones_TimelineData_offset_get), _SE(js_dragonBones_TimelineData_offset_set)); 
    cls->defineProperty("frameIndicesOffset", _SE(js_dragonBones_TimelineData_frameIndicesOffset_get), _SE(js_dragonBones_TimelineData_frameIndicesOffset_set)); 
    
    cls->defineFunction("getType", _SE(js_dragonBones_TimelineData_getType)); 
    cls->defineFunction("setType", _SE(js_dragonBones_TimelineData_setType)); 
    
    
    cls->defineStaticFunction("getTypeIndex", _SE(js_dragonBones_TimelineData_getTypeIndex_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_TimelineData));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::TimelineData>(cls);
    
    __jsb_dragonBones_TimelineData_proto = cls->getProto();
    __jsb_dragonBones_TimelineData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_WorldClock_class = nullptr;
se::Object* __jsb_dragonBones_WorldClock_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_WorldClock) 

static bool js_dragonBones_WorldClock_time_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::WorldClock *arg1 = (dragonBones::WorldClock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::WorldClock>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->time, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_WorldClock_time_set) 

static bool js_dragonBones_WorldClock_time_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::WorldClock *arg1 = (dragonBones::WorldClock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::WorldClock>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->time, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_WorldClock_time_get) 

static bool js_dragonBones_WorldClock_timeScale_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::WorldClock *arg1 = (dragonBones::WorldClock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::WorldClock>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->timeScale, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_WorldClock_timeScale_set) 

static bool js_dragonBones_WorldClock_timeScale_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::WorldClock *arg1 = (dragonBones::WorldClock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::WorldClock>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->timeScale, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_WorldClock_timeScale_get) 

static bool js_delete_dragonBones_WorldClock(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_WorldClock) 

static bool js_dragonBones_WorldClock_advanceTime(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::WorldClock *arg1 = (dragonBones::WorldClock *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::WorldClock>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->advanceTime(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_WorldClock_advanceTime) 

static bool js_dragonBones_WorldClock_render(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::WorldClock *arg1 = (dragonBones::WorldClock *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::WorldClock>(s);
    if (nullptr == arg1) return true;
    (arg1)->render();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_WorldClock_render) 

static bool js_dragonBones_WorldClock_clear(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::WorldClock *arg1 = (dragonBones::WorldClock *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::WorldClock>(s);
    if (nullptr == arg1) return true;
    (arg1)->clear();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_WorldClock_clear) 

static bool js_dragonBones_WorldClock_getClock(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::WorldClock *arg1 = (dragonBones::WorldClock *) NULL ;
    dragonBones::WorldClock *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::WorldClock>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::WorldClock *)((dragonBones::WorldClock const *)arg1)->getClock();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_WorldClock_getClock) 

static bool js_dragonBones_WorldClock_setClock(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::WorldClock *arg1 = (dragonBones::WorldClock *) NULL ;
    dragonBones::WorldClock *arg2 = (dragonBones::WorldClock *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::WorldClock>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setClock(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_WorldClock_setClock) 

static bool js_dragonBones_WorldClock_getStaticClock_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::WorldClock *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (dragonBones::WorldClock *)dragonBones::WorldClock::getStaticClock();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_WorldClock_getStaticClock_static) 

bool js_register_dragonBones_WorldClock(se::Object* obj) {
    auto* cls = se::Class::create("WorldClock", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("time", _SE(js_dragonBones_WorldClock_time_get), _SE(js_dragonBones_WorldClock_time_set)); 
    cls->defineProperty("timeScale", _SE(js_dragonBones_WorldClock_timeScale_get), _SE(js_dragonBones_WorldClock_timeScale_set)); 
    
    cls->defineFunction("advanceTime", _SE(js_dragonBones_WorldClock_advanceTime)); 
    cls->defineFunction("render", _SE(js_dragonBones_WorldClock_render)); 
    cls->defineFunction("clear", _SE(js_dragonBones_WorldClock_clear)); 
    cls->defineFunction("getClock", _SE(js_dragonBones_WorldClock_getClock)); 
    cls->defineFunction("setClock", _SE(js_dragonBones_WorldClock_setClock)); 
    
    
    cls->defineStaticFunction("getStaticClock", _SE(js_dragonBones_WorldClock_getStaticClock_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_WorldClock));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::WorldClock>(cls);
    
    __jsb_dragonBones_WorldClock_proto = cls->getProto();
    __jsb_dragonBones_WorldClock_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_Animation_class = nullptr;
se::Object* __jsb_dragonBones_Animation_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_Animation) 

static bool js_dragonBones_Animation_timeScale_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->timeScale, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Animation_timeScale_set) 

static bool js_dragonBones_Animation_timeScale_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->timeScale, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Animation_timeScale_get) 

static bool js_delete_dragonBones_Animation(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_Animation) 

static bool js_dragonBones_Animation_init(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    dragonBones::Armature *arg2 = (dragonBones::Armature *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->init(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Animation_init) 

static bool js_dragonBones_Animation_advanceTime(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->advanceTime(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Animation_advanceTime) 

static bool js_dragonBones_Animation_reset(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    (arg1)->reset();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Animation_reset) 

static bool js_dragonBones_Animation_stop__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->stop((std::string const &)*arg2);
    
    
    return true;
}

static bool js_dragonBones_Animation_stop__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    (arg1)->stop();
    
    
    return true;
}

static bool js_dragonBones_Animation_stop(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_dragonBones_Animation_stop__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 0) {
        ok = js_dragonBones_Animation_stop__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_Animation_stop) 

static bool js_dragonBones_Animation_play__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    int arg3 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (dragonBones::AnimationState *)(arg1)->play((std::string const &)*arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_play__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (dragonBones::AnimationState *)(arg1)->play((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_play__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::AnimationState *)(arg1)->play();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_play(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_dragonBones_Animation_play__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_dragonBones_Animation_play__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 0) {
        ok = js_dragonBones_Animation_play__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_Animation_play) 

static bool js_dragonBones_Animation_fadeIn__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    float arg3 ;
    int arg4 ;
    int arg5 ;
    std::string *arg6 = 0 ;
    dragonBones::AnimationFadeOutMode arg7 ;
    std::string temp2 ;
    std::string temp6 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &temp6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg6 = &temp6;
    
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = (dragonBones::AnimationState *)(arg1)->fadeIn((std::string const &)*arg2,arg3,arg4,arg5,(std::string const &)*arg6,arg7);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_fadeIn__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    float arg3 ;
    int arg4 ;
    int arg5 ;
    std::string *arg6 = 0 ;
    std::string temp2 ;
    std::string temp6 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &temp6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg6 = &temp6;
    
    result = (dragonBones::AnimationState *)(arg1)->fadeIn((std::string const &)*arg2,arg3,arg4,arg5,(std::string const &)*arg6);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_fadeIn__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    float arg3 ;
    int arg4 ;
    int arg5 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (dragonBones::AnimationState *)(arg1)->fadeIn((std::string const &)*arg2,arg3,arg4,arg5);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_fadeIn__SWIG_3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    float arg3 ;
    int arg4 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (dragonBones::AnimationState *)(arg1)->fadeIn((std::string const &)*arg2,arg3,arg4);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_fadeIn__SWIG_4(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (dragonBones::AnimationState *)(arg1)->fadeIn((std::string const &)*arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_fadeIn__SWIG_5(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (dragonBones::AnimationState *)(arg1)->fadeIn((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_fadeIn(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 6) {
        ok = js_dragonBones_Animation_fadeIn__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 5) {
        ok = js_dragonBones_Animation_fadeIn__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 4) {
        ok = js_dragonBones_Animation_fadeIn__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 3) {
        ok = js_dragonBones_Animation_fadeIn__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_dragonBones_Animation_fadeIn__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_dragonBones_Animation_fadeIn__SWIG_5(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_Animation_fadeIn) 

static bool js_dragonBones_Animation_gotoAndPlayByTime__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    float arg3 ;
    int arg4 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (dragonBones::AnimationState *)(arg1)->gotoAndPlayByTime((std::string const &)*arg2,arg3,arg4);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndPlayByTime__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (dragonBones::AnimationState *)(arg1)->gotoAndPlayByTime((std::string const &)*arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndPlayByTime__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (dragonBones::AnimationState *)(arg1)->gotoAndPlayByTime((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndPlayByTime(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_dragonBones_Animation_gotoAndPlayByTime__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_dragonBones_Animation_gotoAndPlayByTime__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_dragonBones_Animation_gotoAndPlayByTime__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_Animation_gotoAndPlayByTime) 

static bool js_dragonBones_Animation_gotoAndPlayByFrame__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    unsigned int arg3 ;
    int arg4 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (dragonBones::AnimationState *)(arg1)->gotoAndPlayByFrame((std::string const &)*arg2,arg3,arg4);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndPlayByFrame__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    unsigned int arg3 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (dragonBones::AnimationState *)(arg1)->gotoAndPlayByFrame((std::string const &)*arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndPlayByFrame__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (dragonBones::AnimationState *)(arg1)->gotoAndPlayByFrame((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndPlayByFrame(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_dragonBones_Animation_gotoAndPlayByFrame__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_dragonBones_Animation_gotoAndPlayByFrame__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_dragonBones_Animation_gotoAndPlayByFrame__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_Animation_gotoAndPlayByFrame) 

static bool js_dragonBones_Animation_gotoAndPlayByProgress__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    float arg3 ;
    int arg4 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (dragonBones::AnimationState *)(arg1)->gotoAndPlayByProgress((std::string const &)*arg2,arg3,arg4);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndPlayByProgress__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (dragonBones::AnimationState *)(arg1)->gotoAndPlayByProgress((std::string const &)*arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndPlayByProgress__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (dragonBones::AnimationState *)(arg1)->gotoAndPlayByProgress((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndPlayByProgress(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_dragonBones_Animation_gotoAndPlayByProgress__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_dragonBones_Animation_gotoAndPlayByProgress__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_dragonBones_Animation_gotoAndPlayByProgress__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_Animation_gotoAndPlayByProgress) 

static bool js_dragonBones_Animation_gotoAndStopByTime__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (dragonBones::AnimationState *)(arg1)->gotoAndStopByTime((std::string const &)*arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndStopByTime__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (dragonBones::AnimationState *)(arg1)->gotoAndStopByTime((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndStopByTime(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_dragonBones_Animation_gotoAndStopByTime__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_dragonBones_Animation_gotoAndStopByTime__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_Animation_gotoAndStopByTime) 

static bool js_dragonBones_Animation_gotoAndStopByFrame__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    unsigned int arg3 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (dragonBones::AnimationState *)(arg1)->gotoAndStopByFrame((std::string const &)*arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndStopByFrame__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (dragonBones::AnimationState *)(arg1)->gotoAndStopByFrame((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndStopByFrame(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_dragonBones_Animation_gotoAndStopByFrame__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_dragonBones_Animation_gotoAndStopByFrame__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_Animation_gotoAndStopByFrame) 

static bool js_dragonBones_Animation_gotoAndStopByProgress__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (dragonBones::AnimationState *)(arg1)->gotoAndStopByProgress((std::string const &)*arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndStopByProgress__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (dragonBones::AnimationState *)(arg1)->gotoAndStopByProgress((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_Animation_gotoAndStopByProgress(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_dragonBones_Animation_gotoAndStopByProgress__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_dragonBones_Animation_gotoAndStopByProgress__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_Animation_gotoAndStopByProgress) 

static bool js_dragonBones_Animation_getState(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::AnimationState *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (dragonBones::AnimationState *)((dragonBones::Animation const *)arg1)->getState((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Animation_getState) 

static bool js_dragonBones_Animation_hasAnimation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (bool)((dragonBones::Animation const *)arg1)->hasAnimation((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Animation_hasAnimation) 

static bool js_dragonBones_Animation_isPlaying(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    result = (bool)((dragonBones::Animation const *)arg1)->isPlaying();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Animation_isPlaying) 

static bool js_dragonBones_Animation_isCompleted(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    result = (bool)((dragonBones::Animation const *)arg1)->isCompleted();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Animation_isCompleted) 

static bool js_dragonBones_Animation_getLastAnimationName(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::string *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    result = (std::string *) &((dragonBones::Animation const *)arg1)->getLastAnimationName();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Animation_getLastAnimationName) 

static bool js_dragonBones_Animation_getAnimationNames(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    std::vector< std::string > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    result = (std::vector< std::string > *) &((dragonBones::Animation const *)arg1)->getAnimationNames();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Animation_getAnimationNames) 

static bool js_dragonBones_Animation_getLastAnimationState(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Animation *arg1 = (dragonBones::Animation *) NULL ;
    dragonBones::AnimationState *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Animation>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::AnimationState *)((dragonBones::Animation const *)arg1)->getLastAnimationState();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Animation_getLastAnimationState) 

bool js_register_dragonBones_Animation(se::Object* obj) {
    auto* cls = se::Class::create("Animation", obj, __jsb_dragonBones_BaseObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("timeScale", _SE(js_dragonBones_Animation_timeScale_get), _SE(js_dragonBones_Animation_timeScale_set)); 
    
    cls->defineFunction("init", _SE(js_dragonBones_Animation_init)); 
    cls->defineFunction("advanceTime", _SE(js_dragonBones_Animation_advanceTime)); 
    cls->defineFunction("reset", _SE(js_dragonBones_Animation_reset)); 
    cls->defineFunction("stop", _SE(js_dragonBones_Animation_stop)); 
    cls->defineFunction("play", _SE(js_dragonBones_Animation_play)); 
    cls->defineFunction("fadeIn", _SE(js_dragonBones_Animation_fadeIn)); 
    cls->defineFunction("gotoAndPlayByTime", _SE(js_dragonBones_Animation_gotoAndPlayByTime)); 
    cls->defineFunction("gotoAndPlayByFrame", _SE(js_dragonBones_Animation_gotoAndPlayByFrame)); 
    cls->defineFunction("gotoAndPlayByProgress", _SE(js_dragonBones_Animation_gotoAndPlayByProgress)); 
    cls->defineFunction("gotoAndStopByTime", _SE(js_dragonBones_Animation_gotoAndStopByTime)); 
    cls->defineFunction("gotoAndStopByFrame", _SE(js_dragonBones_Animation_gotoAndStopByFrame)); 
    cls->defineFunction("gotoAndStopByProgress", _SE(js_dragonBones_Animation_gotoAndStopByProgress)); 
    cls->defineFunction("getState", _SE(js_dragonBones_Animation_getState)); 
    cls->defineFunction("hasAnimation", _SE(js_dragonBones_Animation_hasAnimation)); 
    cls->defineFunction("isPlaying", _SE(js_dragonBones_Animation_isPlaying)); 
    cls->defineFunction("isCompleted", _SE(js_dragonBones_Animation_isCompleted)); 
    cls->defineFunction("getLastAnimationName", _SE(js_dragonBones_Animation_getLastAnimationName)); 
    cls->defineFunction("getAnimationNames", _SE(js_dragonBones_Animation_getAnimationNames)); 
    cls->defineFunction("getLastAnimationState", _SE(js_dragonBones_Animation_getLastAnimationState)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_Animation));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::Animation>(cls);
    
    __jsb_dragonBones_Animation_proto = cls->getProto();
    __jsb_dragonBones_Animation_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_AnimationState_class = nullptr;
se::Object* __jsb_dragonBones_AnimationState_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_AnimationState) 

static bool js_dragonBones_AnimationState_actionEnabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->actionEnabled);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState_actionEnabled_set) 

static bool js_dragonBones_AnimationState_actionEnabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->actionEnabled, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState_actionEnabled_get) 

static bool js_dragonBones_AnimationState_additiveBlending_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->additiveBlending);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState_additiveBlending_set) 

static bool js_dragonBones_AnimationState_additiveBlending_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->additiveBlending, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState_additiveBlending_get) 

static bool js_dragonBones_AnimationState_displayControl_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->displayControl);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState_displayControl_set) 

static bool js_dragonBones_AnimationState_displayControl_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->displayControl, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState_displayControl_get) 

static bool js_dragonBones_AnimationState_resetToPose_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->resetToPose);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState_resetToPose_set) 

static bool js_dragonBones_AnimationState_resetToPose_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->resetToPose, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState_resetToPose_get) 

static bool js_dragonBones_AnimationState_playTimes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->playTimes, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState_playTimes_set) 

static bool js_dragonBones_AnimationState_playTimes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->playTimes, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState_playTimes_get) 

static bool js_dragonBones_AnimationState_layer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->layer, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState_layer_set) 

static bool js_dragonBones_AnimationState_layer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->layer, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState_layer_get) 

static bool js_dragonBones_AnimationState_timeScale_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->timeScale, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState_timeScale_set) 

static bool js_dragonBones_AnimationState_timeScale_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->timeScale, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState_timeScale_get) 

static bool js_dragonBones_AnimationState_weight_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->weight, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState_weight_set) 

static bool js_dragonBones_AnimationState_weight_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->weight, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState_weight_get) 

static bool js_dragonBones_AnimationState_autoFadeOutTime_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->autoFadeOutTime, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState_autoFadeOutTime_set) 

static bool js_dragonBones_AnimationState_autoFadeOutTime_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->autoFadeOutTime, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState_autoFadeOutTime_get) 

static bool js_dragonBones_AnimationState_fadeTotalTime_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->fadeTotalTime, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState_fadeTotalTime_set) 

static bool js_dragonBones_AnimationState_fadeTotalTime_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->fadeTotalTime, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState_fadeTotalTime_get) 

static bool js_dragonBones_AnimationState_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState_name_set) 

static bool js_dragonBones_AnimationState_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState_name_get) 

static bool js_dragonBones_AnimationState_group_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->group, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState_group_set) 

static bool js_dragonBones_AnimationState_group_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->group, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->group, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState_group_get) 

static bool js_dragonBones_AnimationState__playheadState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_playheadState, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState__playheadState_set) 

static bool js_dragonBones_AnimationState__playheadState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_playheadState, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState__playheadState_get) 

static bool js_dragonBones_AnimationState__fadeState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_fadeState, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState__fadeState_set) 

static bool js_dragonBones_AnimationState__fadeState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_fadeState, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState__fadeState_get) 

static bool js_dragonBones_AnimationState__subFadeState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_subFadeState, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState__subFadeState_set) 

static bool js_dragonBones_AnimationState__subFadeState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_subFadeState, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState__subFadeState_get) 

static bool js_dragonBones_AnimationState__position_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_position, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState__position_set) 

static bool js_dragonBones_AnimationState__position_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_position, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState__position_get) 

static bool js_dragonBones_AnimationState__duration_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_duration, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState__duration_set) 

static bool js_dragonBones_AnimationState__duration_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_duration, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState__duration_get) 

static bool js_dragonBones_AnimationState__fadeProgress_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_fadeProgress, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState__fadeProgress_set) 

static bool js_dragonBones_AnimationState__fadeProgress_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_fadeProgress, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState__fadeProgress_get) 

static bool js_dragonBones_AnimationState__weightResult_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_weightResult, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState__weightResult_set) 

static bool js_dragonBones_AnimationState__weightResult_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_weightResult, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState__weightResult_get) 

static bool js_dragonBones_AnimationState__animationData_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_animationData, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_AnimationState__animationData_set) 

static bool js_dragonBones_AnimationState__animationData_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_animationData, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_animationData, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_AnimationState__animationData_get) 

static bool js_delete_dragonBones_AnimationState(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_AnimationState) 

static bool js_dragonBones_AnimationState_advanceTime(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    float arg2 ;
    float arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->advanceTime(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_advanceTime) 

static bool js_dragonBones_AnimationState_play(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    (arg1)->play();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_play) 

static bool js_dragonBones_AnimationState_stop(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    (arg1)->stop();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_stop) 

static bool js_dragonBones_AnimationState_fadeOut__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    float arg2 ;
    bool arg3 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->fadeOut(arg2,arg3);
    
    
    return true;
}

static bool js_dragonBones_AnimationState_fadeOut__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->fadeOut(arg2);
    
    
    return true;
}

static bool js_dragonBones_AnimationState_fadeOut(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_dragonBones_AnimationState_fadeOut__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_dragonBones_AnimationState_fadeOut__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_fadeOut) 

static bool js_dragonBones_AnimationState_containsBoneMask(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (bool)((dragonBones::AnimationState const *)arg1)->containsBoneMask((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_containsBoneMask) 

static bool js_dragonBones_AnimationState_addBoneMask__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    std::string *arg2 = 0 ;
    bool arg3 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addBoneMask((std::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_dragonBones_AnimationState_addBoneMask__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->addBoneMask((std::string const &)*arg2);
    
    
    return true;
}

static bool js_dragonBones_AnimationState_addBoneMask(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_dragonBones_AnimationState_addBoneMask__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_dragonBones_AnimationState_addBoneMask__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_addBoneMask) 

static bool js_dragonBones_AnimationState_removeBoneMask__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    std::string *arg2 = 0 ;
    bool arg3 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->removeBoneMask((std::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_dragonBones_AnimationState_removeBoneMask__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->removeBoneMask((std::string const &)*arg2);
    
    
    return true;
}

static bool js_dragonBones_AnimationState_removeBoneMask(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_dragonBones_AnimationState_removeBoneMask__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_dragonBones_AnimationState_removeBoneMask__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_removeBoneMask) 

static bool js_dragonBones_AnimationState_removeAllBoneMask(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    (arg1)->removeAllBoneMask();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_removeAllBoneMask) 

static bool js_dragonBones_AnimationState_isFadeIn(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    result = (bool)((dragonBones::AnimationState const *)arg1)->isFadeIn();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_isFadeIn) 

static bool js_dragonBones_AnimationState_isFadeOut(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    result = (bool)((dragonBones::AnimationState const *)arg1)->isFadeOut();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_isFadeOut) 

static bool js_dragonBones_AnimationState_isFadeComplete(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    result = (bool)((dragonBones::AnimationState const *)arg1)->isFadeComplete();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_isFadeComplete) 

static bool js_dragonBones_AnimationState_isPlaying(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    result = (bool)((dragonBones::AnimationState const *)arg1)->isPlaying();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_isPlaying) 

static bool js_dragonBones_AnimationState_isCompleted(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    result = (bool)((dragonBones::AnimationState const *)arg1)->isCompleted();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_isCompleted) 

static bool js_dragonBones_AnimationState_getCurrentPlayTimes(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    unsigned int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    result = (unsigned int)((dragonBones::AnimationState const *)arg1)->getCurrentPlayTimes();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_getCurrentPlayTimes) 

static bool js_dragonBones_AnimationState_getTotalTime(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    result = (float)((dragonBones::AnimationState const *)arg1)->getTotalTime();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_getTotalTime) 

static bool js_dragonBones_AnimationState_getCurrentTime(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    result = (float)((dragonBones::AnimationState const *)arg1)->getCurrentTime();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_getCurrentTime) 

static bool js_dragonBones_AnimationState_setCurrentTime(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setCurrentTime(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_setCurrentTime) 

static bool js_dragonBones_AnimationState_getName(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    std::string *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    result = (std::string *) &((dragonBones::AnimationState const *)arg1)->getName();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_getName) 

static bool js_dragonBones_AnimationState_getAnimationData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::AnimationState *arg1 = (dragonBones::AnimationState *) NULL ;
    dragonBones::AnimationData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::AnimationState>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::AnimationData *)((dragonBones::AnimationState const *)arg1)->getAnimationData();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_AnimationState_getAnimationData) 

bool js_register_dragonBones_AnimationState(se::Object* obj) {
    auto* cls = se::Class::create("AnimationState", obj, __jsb_dragonBones_BaseObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("actionEnabled", _SE(js_dragonBones_AnimationState_actionEnabled_get), _SE(js_dragonBones_AnimationState_actionEnabled_set)); 
    cls->defineProperty("additiveBlending", _SE(js_dragonBones_AnimationState_additiveBlending_get), _SE(js_dragonBones_AnimationState_additiveBlending_set)); 
    cls->defineProperty("displayControl", _SE(js_dragonBones_AnimationState_displayControl_get), _SE(js_dragonBones_AnimationState_displayControl_set)); 
    cls->defineProperty("resetToPose", _SE(js_dragonBones_AnimationState_resetToPose_get), _SE(js_dragonBones_AnimationState_resetToPose_set)); 
    cls->defineProperty("playTimes", _SE(js_dragonBones_AnimationState_playTimes_get), _SE(js_dragonBones_AnimationState_playTimes_set)); 
    cls->defineProperty("layer", _SE(js_dragonBones_AnimationState_layer_get), _SE(js_dragonBones_AnimationState_layer_set)); 
    cls->defineProperty("timeScale", _SE(js_dragonBones_AnimationState_timeScale_get), _SE(js_dragonBones_AnimationState_timeScale_set)); 
    cls->defineProperty("weight", _SE(js_dragonBones_AnimationState_weight_get), _SE(js_dragonBones_AnimationState_weight_set)); 
    cls->defineProperty("autoFadeOutTime", _SE(js_dragonBones_AnimationState_autoFadeOutTime_get), _SE(js_dragonBones_AnimationState_autoFadeOutTime_set)); 
    cls->defineProperty("fadeTotalTime", _SE(js_dragonBones_AnimationState_fadeTotalTime_get), _SE(js_dragonBones_AnimationState_fadeTotalTime_set)); 
    cls->defineProperty("name", _SE(js_dragonBones_AnimationState_name_get), _SE(js_dragonBones_AnimationState_name_set)); 
    cls->defineProperty("group", _SE(js_dragonBones_AnimationState_group_get), _SE(js_dragonBones_AnimationState_group_set)); 
    cls->defineProperty("_playheadState", _SE(js_dragonBones_AnimationState__playheadState_get), _SE(js_dragonBones_AnimationState__playheadState_set)); 
    cls->defineProperty("_fadeState", _SE(js_dragonBones_AnimationState__fadeState_get), _SE(js_dragonBones_AnimationState__fadeState_set)); 
    cls->defineProperty("_subFadeState", _SE(js_dragonBones_AnimationState__subFadeState_get), _SE(js_dragonBones_AnimationState__subFadeState_set)); 
    cls->defineProperty("_position", _SE(js_dragonBones_AnimationState__position_get), _SE(js_dragonBones_AnimationState__position_set)); 
    cls->defineProperty("_duration", _SE(js_dragonBones_AnimationState__duration_get), _SE(js_dragonBones_AnimationState__duration_set)); 
    cls->defineProperty("_fadeProgress", _SE(js_dragonBones_AnimationState__fadeProgress_get), _SE(js_dragonBones_AnimationState__fadeProgress_set)); 
    cls->defineProperty("_weightResult", _SE(js_dragonBones_AnimationState__weightResult_get), _SE(js_dragonBones_AnimationState__weightResult_set)); 
    cls->defineProperty("_animationData", _SE(js_dragonBones_AnimationState__animationData_get), _SE(js_dragonBones_AnimationState__animationData_set)); 
    
    cls->defineFunction("advanceTime", _SE(js_dragonBones_AnimationState_advanceTime)); 
    cls->defineFunction("play", _SE(js_dragonBones_AnimationState_play)); 
    cls->defineFunction("stop", _SE(js_dragonBones_AnimationState_stop)); 
    cls->defineFunction("fadeOut", _SE(js_dragonBones_AnimationState_fadeOut)); 
    cls->defineFunction("containsBoneMask", _SE(js_dragonBones_AnimationState_containsBoneMask)); 
    cls->defineFunction("addBoneMask", _SE(js_dragonBones_AnimationState_addBoneMask)); 
    cls->defineFunction("removeBoneMask", _SE(js_dragonBones_AnimationState_removeBoneMask)); 
    cls->defineFunction("removeAllBoneMask", _SE(js_dragonBones_AnimationState_removeAllBoneMask)); 
    cls->defineFunction("isFadeIn", _SE(js_dragonBones_AnimationState_isFadeIn)); 
    cls->defineFunction("isFadeOut", _SE(js_dragonBones_AnimationState_isFadeOut)); 
    cls->defineFunction("isFadeComplete", _SE(js_dragonBones_AnimationState_isFadeComplete)); 
    cls->defineFunction("isPlaying", _SE(js_dragonBones_AnimationState_isPlaying)); 
    cls->defineFunction("isCompleted", _SE(js_dragonBones_AnimationState_isCompleted)); 
    cls->defineFunction("getCurrentPlayTimes", _SE(js_dragonBones_AnimationState_getCurrentPlayTimes)); 
    cls->defineFunction("getTotalTime", _SE(js_dragonBones_AnimationState_getTotalTime)); 
    cls->defineFunction("getCurrentTime", _SE(js_dragonBones_AnimationState_getCurrentTime)); 
    cls->defineFunction("setCurrentTime", _SE(js_dragonBones_AnimationState_setCurrentTime)); 
    cls->defineFunction("getName", _SE(js_dragonBones_AnimationState_getName)); 
    cls->defineFunction("getAnimationData", _SE(js_dragonBones_AnimationState_getAnimationData)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_AnimationState));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::AnimationState>(cls);
    
    __jsb_dragonBones_AnimationState_proto = cls->getProto();
    __jsb_dragonBones_AnimationState_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_BonePose_class = nullptr;
se::Object* __jsb_dragonBones_BonePose_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_BonePose) 

static bool js_dragonBones_BonePose_getTypeIndex_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    std::size_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = dragonBones::BonePose::getTypeIndex();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_BonePose_getTypeIndex_static) 

static bool js_new_dragonBones_BonePose(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    dragonBones::BonePose *result;
    result = (dragonBones::BonePose *)new dragonBones::BonePose();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_dragonBones_BonePose, __jsb_dragonBones_BonePose_class, js_delete_dragonBones_BonePose)

static bool js_delete_dragonBones_BonePose(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_BonePose) 

static bool js_dragonBones_BonePose_current_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BonePose *arg1 = (dragonBones::BonePose *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BonePose>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->current, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BonePose_current_set) 

static bool js_dragonBones_BonePose_current_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BonePose *arg1 = (dragonBones::BonePose *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BonePose>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->current, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->current, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BonePose_current_get) 

static bool js_dragonBones_BonePose_delta_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BonePose *arg1 = (dragonBones::BonePose *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BonePose>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->delta, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BonePose_delta_set) 

static bool js_dragonBones_BonePose_delta_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BonePose *arg1 = (dragonBones::BonePose *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BonePose>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->delta, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->delta, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BonePose_delta_get) 

static bool js_dragonBones_BonePose_result_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BonePose *arg1 = (dragonBones::BonePose *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BonePose>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->result, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BonePose_result_set) 

static bool js_dragonBones_BonePose_result_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BonePose *arg1 = (dragonBones::BonePose *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BonePose>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BonePose_result_get) 

bool js_register_dragonBones_BonePose(se::Object* obj) {
    auto* cls = se::Class::create("BonePose", obj, __jsb_dragonBones_BaseObject_proto, _SE(js_new_dragonBones_BonePose)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("current", _SE(js_dragonBones_BonePose_current_get), _SE(js_dragonBones_BonePose_current_set)); 
    cls->defineProperty("delta", _SE(js_dragonBones_BonePose_delta_get), _SE(js_dragonBones_BonePose_delta_set)); 
    cls->defineProperty("result", _SE(js_dragonBones_BonePose_result_get), _SE(js_dragonBones_BonePose_result_set)); 
    
    
    
    cls->defineStaticFunction("getTypeIndex", _SE(js_dragonBones_BonePose_getTypeIndex_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_BonePose));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::BonePose>(cls);
    
    __jsb_dragonBones_BonePose_proto = cls->getProto();
    __jsb_dragonBones_BonePose_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_BlendState_class = nullptr;
se::Object* __jsb_dragonBones_BlendState_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_BlendState) 

static bool js_dragonBones_BlendState_dirty_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BlendState *arg1 = (dragonBones::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BlendState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->dirty);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BlendState_dirty_set) 

static bool js_dragonBones_BlendState_dirty_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BlendState *arg1 = (dragonBones::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BlendState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->dirty, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BlendState_dirty_get) 

static bool js_dragonBones_BlendState_layer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BlendState *arg1 = (dragonBones::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BlendState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->layer, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BlendState_layer_set) 

static bool js_dragonBones_BlendState_layer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BlendState *arg1 = (dragonBones::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BlendState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->layer, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BlendState_layer_get) 

static bool js_dragonBones_BlendState_leftWeight_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BlendState *arg1 = (dragonBones::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BlendState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->leftWeight, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BlendState_leftWeight_set) 

static bool js_dragonBones_BlendState_leftWeight_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BlendState *arg1 = (dragonBones::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BlendState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->leftWeight, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BlendState_leftWeight_get) 

static bool js_dragonBones_BlendState_layerWeight_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BlendState *arg1 = (dragonBones::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BlendState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->layerWeight, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BlendState_layerWeight_set) 

static bool js_dragonBones_BlendState_layerWeight_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BlendState *arg1 = (dragonBones::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BlendState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->layerWeight, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BlendState_layerWeight_get) 

static bool js_dragonBones_BlendState_blendWeight_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BlendState *arg1 = (dragonBones::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BlendState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blendWeight, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_BlendState_blendWeight_set) 

static bool js_dragonBones_BlendState_blendWeight_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::BlendState *arg1 = (dragonBones::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::BlendState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blendWeight, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_BlendState_blendWeight_get) 

static bool js_dragonBones_BlendState_update(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BlendState *arg1 = (dragonBones::BlendState *) NULL ;
    float arg2 ;
    int arg3 ;
    int result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::BlendState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (int)(arg1)->update(arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_BlendState_update) 

static bool js_dragonBones_BlendState_clear(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::BlendState *arg1 = (dragonBones::BlendState *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::BlendState>(s);
    if (nullptr == arg1) return true;
    (arg1)->clear();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_BlendState_clear) 

static bool js_new_dragonBones_BlendState(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    dragonBones::BlendState *result;
    result = (dragonBones::BlendState *)new dragonBones::BlendState();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_dragonBones_BlendState, __jsb_dragonBones_BlendState_class, js_delete_dragonBones_BlendState)

static bool js_delete_dragonBones_BlendState(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_BlendState) 

bool js_register_dragonBones_BlendState(se::Object* obj) {
    auto* cls = se::Class::create("BlendState", obj, nullptr, _SE(js_new_dragonBones_BlendState)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("dirty", _SE(js_dragonBones_BlendState_dirty_get), _SE(js_dragonBones_BlendState_dirty_set)); 
    cls->defineProperty("layer", _SE(js_dragonBones_BlendState_layer_get), _SE(js_dragonBones_BlendState_layer_set)); 
    cls->defineProperty("leftWeight", _SE(js_dragonBones_BlendState_leftWeight_get), _SE(js_dragonBones_BlendState_leftWeight_set)); 
    cls->defineProperty("layerWeight", _SE(js_dragonBones_BlendState_layerWeight_get), _SE(js_dragonBones_BlendState_layerWeight_set)); 
    cls->defineProperty("blendWeight", _SE(js_dragonBones_BlendState_blendWeight_get), _SE(js_dragonBones_BlendState_blendWeight_set)); 
    
    cls->defineFunction("update", _SE(js_dragonBones_BlendState_update)); 
    cls->defineFunction("clear", _SE(js_dragonBones_BlendState_clear)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_BlendState));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::BlendState>(cls);
    
    __jsb_dragonBones_BlendState_proto = cls->getProto();
    __jsb_dragonBones_BlendState_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_TransformObject_class = nullptr;
se::Object* __jsb_dragonBones_TransformObject_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_TransformObject) 

static bool js_delete_dragonBones_TransformObject(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_TransformObject) 

static bool js_dragonBones_TransformObject_globalTransformMatrix_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->globalTransformMatrix, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_TransformObject_globalTransformMatrix_set) 

static bool js_dragonBones_TransformObject_globalTransformMatrix_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->globalTransformMatrix, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->globalTransformMatrix, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_TransformObject_globalTransformMatrix_get) 

static bool js_dragonBones_TransformObject_global_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->global, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_TransformObject_global_set) 

static bool js_dragonBones_TransformObject_global_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->global, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->global, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_TransformObject_global_get) 

static bool js_dragonBones_TransformObject_offset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->offset, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_TransformObject_offset_set) 

static bool js_dragonBones_TransformObject_offset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->offset, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->offset, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_TransformObject_offset_get) 

static bool js_dragonBones_TransformObject_origin_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->origin, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_TransformObject_origin_set) 

static bool js_dragonBones_TransformObject_origin_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->origin, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->origin, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_TransformObject_origin_get) 

static bool js_dragonBones_TransformObject_userData_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    if (nullptr == arg1) return true;
    ok &= sevalue_to_native(args[0], &arg1->userData);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_TransformObject_userData_set) 

static bool js_dragonBones_TransformObject_userData_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->userData, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->userData, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_TransformObject_userData_get) 

static bool js_dragonBones_TransformObject__armature_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_armature, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_TransformObject__armature_set) 

static bool js_dragonBones_TransformObject__armature_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_armature, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_armature, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_TransformObject__armature_get) 

static bool js_dragonBones_TransformObject_updateGlobalTransform(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    if (nullptr == arg1) return true;
    (arg1)->updateGlobalTransform();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TransformObject_updateGlobalTransform) 

static bool js_dragonBones_TransformObject_getArmature(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    dragonBones::Armature *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::Armature *)((dragonBones::TransformObject const *)arg1)->getArmature();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TransformObject_getArmature) 

static bool js_dragonBones_TransformObject_getGlobalTransformMatrix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    dragonBones::Matrix *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::Matrix *)(arg1)->getGlobalTransformMatrix();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TransformObject_getGlobalTransformMatrix) 

static bool js_dragonBones_TransformObject_getGlobal(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    dragonBones::Transform *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::Transform *)(arg1)->getGlobal();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TransformObject_getGlobal) 

static bool js_dragonBones_TransformObject_getOffset(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    dragonBones::Transform *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::Transform *)(arg1)->getOffset();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TransformObject_getOffset) 

static bool js_dragonBones_TransformObject_getOrigin(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::TransformObject *arg1 = (dragonBones::TransformObject *) NULL ;
    dragonBones::Transform *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::TransformObject>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::Transform *)((dragonBones::TransformObject const *)arg1)->getOrigin();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_TransformObject_getOrigin) 

bool js_register_dragonBones_TransformObject(se::Object* obj) {
    auto* cls = se::Class::create("TransformObject", obj, __jsb_dragonBones_BaseObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("globalTransformMatrix", _SE(js_dragonBones_TransformObject_globalTransformMatrix_get), _SE(js_dragonBones_TransformObject_globalTransformMatrix_set)); 
    cls->defineProperty("global", _SE(js_dragonBones_TransformObject_global_get), _SE(js_dragonBones_TransformObject_global_set)); 
    cls->defineProperty("offset", _SE(js_dragonBones_TransformObject_offset_get), _SE(js_dragonBones_TransformObject_offset_set)); 
    cls->defineProperty("origin", _SE(js_dragonBones_TransformObject_origin_get), _SE(js_dragonBones_TransformObject_origin_set)); 
    cls->defineProperty("userData", _SE(js_dragonBones_TransformObject_userData_get), _SE(js_dragonBones_TransformObject_userData_set)); 
    cls->defineProperty("_armature", _SE(js_dragonBones_TransformObject__armature_get), _SE(js_dragonBones_TransformObject__armature_set)); 
    
    cls->defineFunction("updateGlobalTransform", _SE(js_dragonBones_TransformObject_updateGlobalTransform)); 
    cls->defineFunction("getArmature", _SE(js_dragonBones_TransformObject_getArmature)); 
    cls->defineFunction("getGlobalTransformMatrix", _SE(js_dragonBones_TransformObject_getGlobalTransformMatrix)); 
    cls->defineFunction("getGlobal", _SE(js_dragonBones_TransformObject_getGlobal)); 
    cls->defineFunction("getOffset", _SE(js_dragonBones_TransformObject_getOffset)); 
    cls->defineFunction("getOrigin", _SE(js_dragonBones_TransformObject_getOrigin)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_TransformObject));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::TransformObject>(cls);
    
    __jsb_dragonBones_TransformObject_proto = cls->getProto();
    __jsb_dragonBones_TransformObject_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_Slot_class = nullptr;
se::Object* __jsb_dragonBones_Slot_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_Slot) 

static bool js_dragonBones_Slot_displayController_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->displayController, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Slot_displayController_set) 

static bool js_dragonBones_Slot_displayController_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->displayController, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->displayController, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Slot_displayController_get) 

static bool js_dragonBones_Slot__zOrder_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_zOrder, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Slot__zOrder_set) 

static bool js_dragonBones_Slot__zOrder_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_zOrder, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Slot__zOrder_get) 

static bool js_delete_dragonBones_Slot(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_Slot) 

static bool js_dragonBones_Slot__updateColor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    if (nullptr == arg1) return true;
    (arg1)->_updateColor();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot__updateColor) 

static bool js_dragonBones_Slot__setZorder(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    int arg2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (bool)(arg1)->_setZorder(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot__setZorder) 

static bool js_dragonBones_Slot_update(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->update(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_update) 

static bool js_dragonBones_Slot_updateTransformAndMatrix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    if (nullptr == arg1) return true;
    (arg1)->updateTransformAndMatrix();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_updateTransformAndMatrix) 

static bool js_dragonBones_Slot_containsPoint(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    float arg2 ;
    float arg3 ;
    bool result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (bool)(arg1)->containsPoint(arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_containsPoint) 

static bool js_dragonBones_Slot_invalidUpdate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    if (nullptr == arg1) return true;
    (arg1)->invalidUpdate();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_invalidUpdate) 

static bool js_dragonBones_Slot_getVisible(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    if (nullptr == arg1) return true;
    result = (bool)((dragonBones::Slot const *)arg1)->getVisible();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_getVisible) 

static bool js_dragonBones_Slot_setVisible(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setVisible(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_setVisible) 

static bool js_dragonBones_Slot_getDisplayIndex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    if (nullptr == arg1) return true;
    result = (int)((dragonBones::Slot const *)arg1)->getDisplayIndex();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_getDisplayIndex) 

static bool js_dragonBones_Slot_setDisplayIndex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setDisplayIndex(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_setDisplayIndex) 

static bool js_dragonBones_Slot_getName(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    std::string *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    if (nullptr == arg1) return true;
    result = (std::string *) &((dragonBones::Slot const *)arg1)->getName();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_getName) 

static bool js_dragonBones_Slot_getRawDisplayDatas(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    std::vector< dragonBones::DisplayData * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    if (nullptr == arg1) return true;
    result = (std::vector< dragonBones::DisplayData * > *)((dragonBones::Slot const *)arg1)->getRawDisplayDatas();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_getRawDisplayDatas) 

static bool js_dragonBones_Slot_getSlotData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    dragonBones::SlotData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::SlotData *)((dragonBones::Slot const *)arg1)->getSlotData();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_getSlotData) 

static bool js_dragonBones_Slot_getBoundingBoxData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    dragonBones::BoundingBoxData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::BoundingBoxData *)((dragonBones::Slot const *)arg1)->getBoundingBoxData();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_getBoundingBoxData) 

static bool js_dragonBones_Slot_getChildArmature(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    dragonBones::Armature *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::Armature *)((dragonBones::Slot const *)arg1)->getChildArmature();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_getChildArmature) 

static bool js_dragonBones_Slot_setChildArmature(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    dragonBones::Armature *arg2 = (dragonBones::Armature *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setChildArmature(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_setChildArmature) 

static bool js_dragonBones_Slot_getParent(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Slot *arg1 = (dragonBones::Slot *) NULL ;
    dragonBones::Bone *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Slot>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::Bone *)((dragonBones::Slot const *)arg1)->getParent();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Slot_getParent) 

bool js_register_dragonBones_Slot(se::Object* obj) {
    auto* cls = se::Class::create("Slot", obj, __jsb_dragonBones_TransformObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("displayController", _SE(js_dragonBones_Slot_displayController_get), _SE(js_dragonBones_Slot_displayController_set)); 
    cls->defineProperty("_zOrder", _SE(js_dragonBones_Slot__zOrder_get), _SE(js_dragonBones_Slot__zOrder_set)); 
    
    cls->defineFunction("_updateColor", _SE(js_dragonBones_Slot__updateColor)); 
    cls->defineFunction("_setZorder", _SE(js_dragonBones_Slot__setZorder)); 
    cls->defineFunction("update", _SE(js_dragonBones_Slot_update)); 
    cls->defineFunction("updateTransformAndMatrix", _SE(js_dragonBones_Slot_updateTransformAndMatrix)); 
    cls->defineFunction("containsPoint", _SE(js_dragonBones_Slot_containsPoint)); 
    cls->defineFunction("invalidUpdate", _SE(js_dragonBones_Slot_invalidUpdate)); 
    cls->defineFunction("getVisible", _SE(js_dragonBones_Slot_getVisible)); 
    cls->defineFunction("setVisible", _SE(js_dragonBones_Slot_setVisible)); 
    cls->defineFunction("getDisplayIndex", _SE(js_dragonBones_Slot_getDisplayIndex)); 
    cls->defineFunction("setDisplayIndex", _SE(js_dragonBones_Slot_setDisplayIndex)); 
    cls->defineFunction("getName", _SE(js_dragonBones_Slot_getName)); 
    cls->defineFunction("getRawDisplayDatas", _SE(js_dragonBones_Slot_getRawDisplayDatas)); 
    cls->defineFunction("getSlotData", _SE(js_dragonBones_Slot_getSlotData)); 
    cls->defineFunction("getBoundingBoxData", _SE(js_dragonBones_Slot_getBoundingBoxData)); 
    cls->defineFunction("getChildArmature", _SE(js_dragonBones_Slot_getChildArmature)); 
    cls->defineFunction("setChildArmature", _SE(js_dragonBones_Slot_setChildArmature)); 
    cls->defineFunction("getParent", _SE(js_dragonBones_Slot_getParent)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_Slot));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::Slot>(cls);
    
    __jsb_dragonBones_Slot_proto = cls->getProto();
    __jsb_dragonBones_Slot_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_Bone_class = nullptr;
se::Object* __jsb_dragonBones_Bone_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_Bone) 

static bool js_delete_dragonBones_Bone(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_Bone) 

static bool js_dragonBones_Bone_offsetMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->offsetMode, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Bone_offsetMode_set) 

static bool js_dragonBones_Bone_offsetMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->offsetMode, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->offsetMode, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Bone_offsetMode_get) 

static bool js_dragonBones_Bone_animationPose_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->animationPose, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Bone_animationPose_set) 

static bool js_dragonBones_Bone_animationPose_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->animationPose, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->animationPose, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Bone_animationPose_get) 

static bool js_dragonBones_Bone__transformDirty_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_transformDirty);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Bone__transformDirty_set) 

static bool js_dragonBones_Bone__transformDirty_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_transformDirty, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Bone__transformDirty_get) 

static bool js_dragonBones_Bone__childrenTransformDirty_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_childrenTransformDirty);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Bone__childrenTransformDirty_set) 

static bool js_dragonBones_Bone__childrenTransformDirty_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_childrenTransformDirty, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Bone__childrenTransformDirty_get) 

static bool js_dragonBones_Bone__hasConstraint_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_hasConstraint);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Bone__hasConstraint_set) 

static bool js_dragonBones_Bone__hasConstraint_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_hasConstraint, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Bone__hasConstraint_get) 

static bool js_dragonBones_Bone__blendState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_blendState, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Bone__blendState_set) 

static bool js_dragonBones_Bone__blendState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_blendState, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_blendState, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Bone__blendState_get) 

static bool js_dragonBones_Bone__boneData_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_boneData, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Bone__boneData_set) 

static bool js_dragonBones_Bone__boneData_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_boneData, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_boneData, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Bone__boneData_get) 

static bool js_dragonBones_Bone_init(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    dragonBones::BoneData *arg2 = (dragonBones::BoneData *) NULL ;
    dragonBones::Armature *arg3 = (dragonBones::Armature *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->init((dragonBones::BoneData const *)arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Bone_init) 

static bool js_dragonBones_Bone_update(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->update(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Bone_update) 

static bool js_dragonBones_Bone_updateByConstraint(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    if (nullptr == arg1) return true;
    (arg1)->updateByConstraint();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Bone_updateByConstraint) 

static bool js_dragonBones_Bone_invalidUpdate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    if (nullptr == arg1) return true;
    (arg1)->invalidUpdate();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Bone_invalidUpdate) 

static bool js_dragonBones_Bone_contains(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    dragonBones::Bone *arg2 = (dragonBones::Bone *) NULL ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (bool)((dragonBones::Bone const *)arg1)->contains((dragonBones::Bone const *)arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Bone_contains) 

static bool js_dragonBones_Bone_getBoneData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    dragonBones::BoneData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::BoneData *)((dragonBones::Bone const *)arg1)->getBoneData();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Bone_getBoneData) 

static bool js_dragonBones_Bone_getVisible(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    if (nullptr == arg1) return true;
    result = (bool)((dragonBones::Bone const *)arg1)->getVisible();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Bone_getVisible) 

static bool js_dragonBones_Bone_setVisible(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setVisible(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Bone_setVisible) 

static bool js_dragonBones_Bone_getName(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    std::string *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    if (nullptr == arg1) return true;
    result = (std::string *) &((dragonBones::Bone const *)arg1)->getName();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Bone_getName) 

static bool js_dragonBones_Bone_getParent(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    dragonBones::Bone *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::Bone *)((dragonBones::Bone const *)arg1)->getParent();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Bone_getParent) 

static bool js_dragonBones_Bone_getOffsetMode(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    if (nullptr == arg1) return true;
    result = (int)((dragonBones::Bone const *)arg1)->getOffsetMode();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Bone_getOffsetMode) 

static bool js_dragonBones_Bone_setOffsetMode(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Bone *arg1 = (dragonBones::Bone *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setOffsetMode(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Bone_setOffsetMode) 

bool js_register_dragonBones_Bone(se::Object* obj) {
    auto* cls = se::Class::create("Bone", obj, __jsb_dragonBones_TransformObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("offsetMode", _SE(js_dragonBones_Bone_offsetMode_get), _SE(js_dragonBones_Bone_offsetMode_set)); 
    cls->defineProperty("animationPose", _SE(js_dragonBones_Bone_animationPose_get), _SE(js_dragonBones_Bone_animationPose_set)); 
    cls->defineProperty("_transformDirty", _SE(js_dragonBones_Bone__transformDirty_get), _SE(js_dragonBones_Bone__transformDirty_set)); 
    cls->defineProperty("_childrenTransformDirty", _SE(js_dragonBones_Bone__childrenTransformDirty_get), _SE(js_dragonBones_Bone__childrenTransformDirty_set)); 
    cls->defineProperty("_hasConstraint", _SE(js_dragonBones_Bone__hasConstraint_get), _SE(js_dragonBones_Bone__hasConstraint_set)); 
    cls->defineProperty("_blendState", _SE(js_dragonBones_Bone__blendState_get), _SE(js_dragonBones_Bone__blendState_set)); 
    cls->defineProperty("_boneData", _SE(js_dragonBones_Bone__boneData_get), _SE(js_dragonBones_Bone__boneData_set)); 
    
    cls->defineFunction("init", _SE(js_dragonBones_Bone_init)); 
    cls->defineFunction("update", _SE(js_dragonBones_Bone_update)); 
    cls->defineFunction("updateByConstraint", _SE(js_dragonBones_Bone_updateByConstraint)); 
    cls->defineFunction("invalidUpdate", _SE(js_dragonBones_Bone_invalidUpdate)); 
    cls->defineFunction("contains", _SE(js_dragonBones_Bone_contains)); 
    cls->defineFunction("getBoneData", _SE(js_dragonBones_Bone_getBoneData)); 
    cls->defineFunction("getVisible", _SE(js_dragonBones_Bone_getVisible)); 
    cls->defineFunction("setVisible", _SE(js_dragonBones_Bone_setVisible)); 
    cls->defineFunction("getName", _SE(js_dragonBones_Bone_getName)); 
    cls->defineFunction("getParent", _SE(js_dragonBones_Bone_getParent)); 
    cls->defineFunction("getOffsetMode", _SE(js_dragonBones_Bone_getOffsetMode)); 
    cls->defineFunction("setOffsetMode", _SE(js_dragonBones_Bone_setOffsetMode)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_Bone));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::Bone>(cls);
    
    __jsb_dragonBones_Bone_proto = cls->getProto();
    __jsb_dragonBones_Bone_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_Armature_class = nullptr;
se::Object* __jsb_dragonBones_Armature_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_Armature) 

static bool js_dragonBones_Armature_inheritAnimation_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->inheritAnimation);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Armature_inheritAnimation_set) 

static bool js_dragonBones_Armature_inheritAnimation_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->inheritAnimation, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Armature_inheritAnimation_get) 

static bool js_dragonBones_Armature_userData_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    ok &= sevalue_to_native(args[0], &arg1->userData);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Armature_userData_set) 

static bool js_dragonBones_Armature_userData_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->userData, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->userData, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Armature_userData_get) 

static bool js_dragonBones_Armature__cacheFrameIndex_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_cacheFrameIndex, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Armature__cacheFrameIndex_set) 

static bool js_dragonBones_Armature__cacheFrameIndex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_cacheFrameIndex, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Armature__cacheFrameIndex_get) 

static bool js_dragonBones_Armature__armatureData_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_armatureData, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Armature__armatureData_set) 

static bool js_dragonBones_Armature__armatureData_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_armatureData, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_armatureData, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Armature__armatureData_get) 

static bool js_dragonBones_Armature__parent_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_parent, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Armature__parent_set) 

static bool js_dragonBones_Armature__parent_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_parent, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_parent, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Armature__parent_get) 

static bool js_dragonBones_Armature__replaceTextureAtlasData_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_replaceTextureAtlasData, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_Armature__replaceTextureAtlasData_set) 

static bool js_dragonBones_Armature__replaceTextureAtlasData_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_replaceTextureAtlasData, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_replaceTextureAtlasData, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_Armature__replaceTextureAtlasData_get) 

static bool js_delete_dragonBones_Armature(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_Armature) 

static bool js_dragonBones_Armature__addBone(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    dragonBones::Bone *arg2 = (dragonBones::Bone *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->_addBone(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature__addBone) 

static bool js_dragonBones_Armature__addSlot(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    dragonBones::Slot *arg2 = (dragonBones::Slot *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->_addSlot(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature__addSlot) 

static bool js_dragonBones_Armature__bufferAction(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    dragonBones::EventObject *arg2 = (dragonBones::EventObject *) NULL ;
    bool arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->_bufferAction(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature__bufferAction) 

static bool js_dragonBones_Armature_dispose(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    (arg1)->dispose();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_dispose) 

static bool js_dragonBones_Armature_advanceTime(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->advanceTime(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_advanceTime) 

static bool js_dragonBones_Armature_render(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    (arg1)->render();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_render) 

static bool js_dragonBones_Armature_invalidUpdate__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    std::string *arg2 = 0 ;
    bool arg3 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->invalidUpdate((std::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_dragonBones_Armature_invalidUpdate__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->invalidUpdate((std::string const &)*arg2);
    
    
    return true;
}

static bool js_dragonBones_Armature_invalidUpdate__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    (arg1)->invalidUpdate();
    
    
    return true;
}

static bool js_dragonBones_Armature_invalidUpdate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_dragonBones_Armature_invalidUpdate__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_dragonBones_Armature_invalidUpdate__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 0) {
        ok = js_dragonBones_Armature_invalidUpdate__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_Armature_invalidUpdate) 

static bool js_dragonBones_Armature_containsPoint(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    float arg2 ;
    float arg3 ;
    dragonBones::Slot *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (dragonBones::Slot *)((dragonBones::Armature const *)arg1)->containsPoint(arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_containsPoint) 

static bool js_dragonBones_Armature_getBone(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::Bone *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (dragonBones::Bone *)((dragonBones::Armature const *)arg1)->getBone((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_getBone) 

static bool js_dragonBones_Armature_getSlot(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::Slot *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (dragonBones::Slot *)((dragonBones::Armature const *)arg1)->getSlot((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_getSlot) 

static bool js_dragonBones_Armature_getFlipX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    result = (bool)((dragonBones::Armature const *)arg1)->getFlipX();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_getFlipX) 

static bool js_dragonBones_Armature_setFlipX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setFlipX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_setFlipX) 

static bool js_dragonBones_Armature_getFlipY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    result = (bool)((dragonBones::Armature const *)arg1)->getFlipY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_getFlipY) 

static bool js_dragonBones_Armature_setFlipY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setFlipY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_setFlipY) 

static bool js_dragonBones_Armature_getCacheFrameRate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    unsigned int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    result = (unsigned int)((dragonBones::Armature const *)arg1)->getCacheFrameRate();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_getCacheFrameRate) 

static bool js_dragonBones_Armature_setCacheFrameRate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    unsigned int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setCacheFrameRate(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_setCacheFrameRate) 

static bool js_dragonBones_Armature_getName(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    std::string *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    result = (std::string *) &((dragonBones::Armature const *)arg1)->getName();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_getName) 

static bool js_dragonBones_Armature_getArmatureData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    dragonBones::ArmatureData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::ArmatureData *)((dragonBones::Armature const *)arg1)->getArmatureData();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_getArmatureData) 

static bool js_dragonBones_Armature_getAnimation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    dragonBones::Animation *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::Animation *)((dragonBones::Armature const *)arg1)->getAnimation();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_getAnimation) 

static bool js_dragonBones_Armature_getProxy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    dragonBones::IArmatureProxy *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::IArmatureProxy *)((dragonBones::Armature const *)arg1)->getProxy();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_getProxy) 

static bool js_dragonBones_Armature_getEventDispatcher(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    dragonBones::IEventDispatcher *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::IEventDispatcher *)((dragonBones::Armature const *)arg1)->getEventDispatcher();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_getEventDispatcher) 

static bool js_dragonBones_Armature_getClock(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    dragonBones::WorldClock *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::WorldClock *)((dragonBones::Armature const *)arg1)->getClock();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_getClock) 

static bool js_dragonBones_Armature_setClock(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    dragonBones::WorldClock *arg2 = (dragonBones::WorldClock *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setClock(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_setClock) 

static bool js_dragonBones_Armature_getParent(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::Armature *arg1 = (dragonBones::Armature *) NULL ;
    dragonBones::Slot *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::Armature>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::Slot *)((dragonBones::Armature const *)arg1)->getParent();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_Armature_getParent) 

bool js_register_dragonBones_Armature(se::Object* obj) {
    auto* cls = se::Class::create("Armature", obj, __jsb_dragonBones_BaseObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("inheritAnimation", _SE(js_dragonBones_Armature_inheritAnimation_get), _SE(js_dragonBones_Armature_inheritAnimation_set)); 
    cls->defineProperty("userData", _SE(js_dragonBones_Armature_userData_get), _SE(js_dragonBones_Armature_userData_set)); 
    cls->defineProperty("_cacheFrameIndex", _SE(js_dragonBones_Armature__cacheFrameIndex_get), _SE(js_dragonBones_Armature__cacheFrameIndex_set)); 
    cls->defineProperty("_armatureData", _SE(js_dragonBones_Armature__armatureData_get), _SE(js_dragonBones_Armature__armatureData_set)); 
    cls->defineProperty("_parent", _SE(js_dragonBones_Armature__parent_get), _SE(js_dragonBones_Armature__parent_set)); 
    cls->defineProperty("_replaceTextureAtlasData", _SE(js_dragonBones_Armature__replaceTextureAtlasData_get), _SE(js_dragonBones_Armature__replaceTextureAtlasData_set)); 
    
    cls->defineFunction("_addBone", _SE(js_dragonBones_Armature__addBone)); 
    cls->defineFunction("_addSlot", _SE(js_dragonBones_Armature__addSlot)); 
    cls->defineFunction("_bufferAction", _SE(js_dragonBones_Armature__bufferAction)); 
    cls->defineFunction("dispose", _SE(js_dragonBones_Armature_dispose)); 
    cls->defineFunction("advanceTime", _SE(js_dragonBones_Armature_advanceTime)); 
    cls->defineFunction("render", _SE(js_dragonBones_Armature_render)); 
    cls->defineFunction("invalidUpdate", _SE(js_dragonBones_Armature_invalidUpdate)); 
    cls->defineFunction("containsPoint", _SE(js_dragonBones_Armature_containsPoint)); 
    cls->defineFunction("getBone", _SE(js_dragonBones_Armature_getBone)); 
    cls->defineFunction("getSlot", _SE(js_dragonBones_Armature_getSlot)); 
    cls->defineFunction("getFlipX", _SE(js_dragonBones_Armature_getFlipX)); 
    cls->defineFunction("setFlipX", _SE(js_dragonBones_Armature_setFlipX)); 
    cls->defineFunction("getFlipY", _SE(js_dragonBones_Armature_getFlipY)); 
    cls->defineFunction("setFlipY", _SE(js_dragonBones_Armature_setFlipY)); 
    cls->defineFunction("getCacheFrameRate", _SE(js_dragonBones_Armature_getCacheFrameRate)); 
    cls->defineFunction("setCacheFrameRate", _SE(js_dragonBones_Armature_setCacheFrameRate)); 
    cls->defineFunction("getName", _SE(js_dragonBones_Armature_getName)); 
    cls->defineFunction("getArmatureData", _SE(js_dragonBones_Armature_getArmatureData)); 
    cls->defineFunction("getAnimation", _SE(js_dragonBones_Armature_getAnimation)); 
    cls->defineFunction("getProxy", _SE(js_dragonBones_Armature_getProxy)); 
    cls->defineFunction("getEventDispatcher", _SE(js_dragonBones_Armature_getEventDispatcher)); 
    cls->defineFunction("getClock", _SE(js_dragonBones_Armature_getClock)); 
    cls->defineFunction("setClock", _SE(js_dragonBones_Armature_setClock)); 
    cls->defineFunction("getParent", _SE(js_dragonBones_Armature_getParent)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_Armature));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::Armature>(cls);
    
    __jsb_dragonBones_Armature_proto = cls->getProto();
    __jsb_dragonBones_Armature_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_CCArmatureDisplay_class = nullptr;
se::Object* __jsb_dragonBones_CCArmatureDisplay_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_CCArmatureDisplay) 

static bool js_dragonBones_CCArmatureDisplay_create_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (dragonBones::CCArmatureDisplay *)dragonBones::CCArmatureDisplay::create();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_create_static) 

static bool js_new_dragonBones_CCArmatureDisplay(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    dragonBones::CCArmatureDisplay *result;
    result = (dragonBones::CCArmatureDisplay *)new dragonBones::CCArmatureDisplay();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_dragonBones_CCArmatureDisplay, __jsb_dragonBones_CCArmatureDisplay_class, js_delete_dragonBones_CCArmatureDisplay)

static bool js_delete_dragonBones_CCArmatureDisplay(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_CCArmatureDisplay) 

static bool js_dragonBones_CCArmatureDisplay_dbInit(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    dragonBones::Armature *arg2 = (dragonBones::Armature *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->dbInit(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_dbInit) 

static bool js_dragonBones_CCArmatureDisplay_dbClear(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    if (nullptr == arg1) return true;
    (arg1)->dbClear();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_dbClear) 

static bool js_dragonBones_CCArmatureDisplay_dbUpdate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    if (nullptr == arg1) return true;
    (arg1)->dbUpdate();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_dbUpdate) 

static bool js_dragonBones_CCArmatureDisplay_dbRender(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    if (nullptr == arg1) return true;
    (arg1)->dbRender();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_dbRender) 

static bool js_dragonBones_CCArmatureDisplay_dispose(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    if (nullptr == arg1) return true;
    (arg1)->dispose();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_dispose) 

static bool js_dragonBones_CCArmatureDisplay_hasDBEventListener(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (bool)((dragonBones::CCArmatureDisplay const *)arg1)->hasDBEventListener((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_hasDBEventListener) 

static bool js_dragonBones_CCArmatureDisplay_dispatchDBEvent(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    std::string *arg2 = 0 ;
    dragonBones::EventObject *arg3 = (dragonBones::EventObject *) NULL ;
    std::string temp2 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->dispatchDBEvent((std::string const &)*arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_dispatchDBEvent) 

static bool js_dragonBones_CCArmatureDisplay_addDBEventListener(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    std::string *arg2 = 0 ;
    std::function< void (dragonBones::EventObject *) > *arg3 = 0 ;
    std::string temp2 ;
    std::function< void (dragonBones::EventObject *) > temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->addDBEventListener((std::string const &)*arg2,(std::function< void (dragonBones::EventObject *) > const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_addDBEventListener) 

static bool js_dragonBones_CCArmatureDisplay_removeDBEventListener(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    std::string *arg2 = 0 ;
    std::function< void (dragonBones::EventObject *) > *arg3 = 0 ;
    std::string temp2 ;
    std::function< void (dragonBones::EventObject *) > temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->removeDBEventListener((std::string const &)*arg2,(std::function< void (dragonBones::EventObject *) > const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_removeDBEventListener) 

static bool js_dragonBones_CCArmatureDisplay_setDBEventCallback(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    dragonBones::CCArmatureDisplay::dbEventCallback arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->setDBEventCallback(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_setDBEventCallback) 

static bool js_dragonBones_CCArmatureDisplay_armature(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    dragonBones::Armature *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::Armature *)((dragonBones::CCArmatureDisplay const *)arg1)->getArmature();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_armature) 

static bool js_dragonBones_CCArmatureDisplay_getAnimation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    dragonBones::Animation *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::Animation *)((dragonBones::CCArmatureDisplay const *)arg1)->getAnimation();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_getAnimation) 

static bool js_dragonBones_CCArmatureDisplay_getDebugData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    se_object_ptr result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    if (nullptr == arg1) return true;
    result = ((dragonBones::CCArmatureDisplay const *)arg1)->getDebugData();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_getDebugData) 

static bool js_dragonBones_CCArmatureDisplay_getSharedBufferOffset(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    se_object_ptr result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    if (nullptr == arg1) return true;
    result = ((dragonBones::CCArmatureDisplay const *)arg1)->getSharedBufferOffset();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_getSharedBufferOffset) 

static bool js_dragonBones_CCArmatureDisplay_setColor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setColor(arg2,arg3,arg4,arg5);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_setColor) 

static bool js_dragonBones_CCArmatureDisplay_setDebugBonesEnabled(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setDebugBonesEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_setDebugBonesEnabled) 

static bool js_dragonBones_CCArmatureDisplay_setBatchEnabled(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setBatchEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_setBatchEnabled) 

static bool js_dragonBones_CCArmatureDisplay_setAttachEnabled(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAttachEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_setAttachEnabled) 

static bool js_dragonBones_CCArmatureDisplay_setOpacityModifyRGB(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setOpacityModifyRGB(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_setOpacityModifyRGB) 

static bool js_dragonBones_CCArmatureDisplay_convertToRootSpace(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    float arg2 ;
    float arg3 ;
    cc::Vec2 *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::Vec2 *) &((dragonBones::CCArmatureDisplay const *)arg1)->convertToRootSpace(arg2,arg3);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_convertToRootSpace) 

static bool js_dragonBones_CCArmatureDisplay_getRootDisplay(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    dragonBones::CCArmatureDisplay *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::CCArmatureDisplay *)(arg1)->getRootDisplay();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_getRootDisplay) 

static bool js_dragonBones_CCArmatureDisplay_setMaterial(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    cc::Material *arg2 = (cc::Material *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setMaterial(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_setMaterial) 

static bool js_dragonBones_CCArmatureDisplay_setRenderEntity(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureDisplay *arg1 = (dragonBones::CCArmatureDisplay *) NULL ;
    cc::RenderEntity *arg2 = (cc::RenderEntity *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRenderEntity(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureDisplay_setRenderEntity) 

bool js_register_dragonBones_CCArmatureDisplay(se::Object* obj) {
    auto* cls = se::Class::create("CCArmatureDisplay", obj, nullptr, _SE(js_new_dragonBones_CCArmatureDisplay)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("dbInit", _SE(js_dragonBones_CCArmatureDisplay_dbInit)); 
    cls->defineFunction("dbClear", _SE(js_dragonBones_CCArmatureDisplay_dbClear)); 
    cls->defineFunction("dbUpdate", _SE(js_dragonBones_CCArmatureDisplay_dbUpdate)); 
    cls->defineFunction("dbRender", _SE(js_dragonBones_CCArmatureDisplay_dbRender)); 
    cls->defineFunction("dispose", _SE(js_dragonBones_CCArmatureDisplay_dispose)); 
    cls->defineFunction("hasDBEventListener", _SE(js_dragonBones_CCArmatureDisplay_hasDBEventListener)); 
    cls->defineFunction("dispatchDBEvent", _SE(js_dragonBones_CCArmatureDisplay_dispatchDBEvent)); 
    cls->defineFunction("addDBEventListener", _SE(js_dragonBones_CCArmatureDisplay_addDBEventListener)); 
    cls->defineFunction("removeDBEventListener", _SE(js_dragonBones_CCArmatureDisplay_removeDBEventListener)); 
    cls->defineFunction("setDBEventCallback", _SE(js_dragonBones_CCArmatureDisplay_setDBEventCallback)); 
    cls->defineFunction("armature", _SE(js_dragonBones_CCArmatureDisplay_armature)); 
    cls->defineFunction("getAnimation", _SE(js_dragonBones_CCArmatureDisplay_getAnimation)); 
    cls->defineFunction("getDebugData", _SE(js_dragonBones_CCArmatureDisplay_getDebugData)); 
    cls->defineFunction("getSharedBufferOffset", _SE(js_dragonBones_CCArmatureDisplay_getSharedBufferOffset)); 
    cls->defineFunction("setColor", _SE(js_dragonBones_CCArmatureDisplay_setColor)); 
    cls->defineFunction("setDebugBonesEnabled", _SE(js_dragonBones_CCArmatureDisplay_setDebugBonesEnabled)); 
    cls->defineFunction("setBatchEnabled", _SE(js_dragonBones_CCArmatureDisplay_setBatchEnabled)); 
    cls->defineFunction("setAttachEnabled", _SE(js_dragonBones_CCArmatureDisplay_setAttachEnabled)); 
    cls->defineFunction("setOpacityModifyRGB", _SE(js_dragonBones_CCArmatureDisplay_setOpacityModifyRGB)); 
    cls->defineFunction("convertToRootSpace", _SE(js_dragonBones_CCArmatureDisplay_convertToRootSpace)); 
    cls->defineFunction("getRootDisplay", _SE(js_dragonBones_CCArmatureDisplay_getRootDisplay)); 
    cls->defineFunction("setMaterial", _SE(js_dragonBones_CCArmatureDisplay_setMaterial)); 
    cls->defineFunction("setRenderEntity", _SE(js_dragonBones_CCArmatureDisplay_setRenderEntity)); 
    
    
    cls->defineStaticFunction("create", _SE(js_dragonBones_CCArmatureDisplay_create_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_CCArmatureDisplay));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::CCArmatureDisplay>(cls);
    
    __jsb_dragonBones_CCArmatureDisplay_proto = cls->getProto();
    __jsb_dragonBones_CCArmatureDisplay_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_CCFactory_class = nullptr;
se::Object* __jsb_dragonBones_CCFactory_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_CCFactory) 

static bool js_dragonBones_CCFactory_isInit_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (bool)dragonBones::CCFactory::isInit();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_isInit_static) 

static bool js_dragonBones_CCFactory_getFactory_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCFactory *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (dragonBones::CCFactory *)dragonBones::CCFactory::getFactory();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_getFactory_static) 

static bool js_dragonBones_CCFactory_destroyFactory_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    dragonBones::CCFactory::destroyFactory();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_destroyFactory_static) 

static bool js_new_dragonBones_CCFactory(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    dragonBones::CCFactory *result;
    result = (dragonBones::CCFactory *)new dragonBones::CCFactory();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_dragonBones_CCFactory, __jsb_dragonBones_CCFactory_class, js_delete_dragonBones_CCFactory)

static bool js_dragonBones_CCFactory_update(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->update(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_update) 

static bool js_dragonBones_CCFactory_render(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->render(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_render) 

static bool js_dragonBones_CCFactory_stopSchedule(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    if (nullptr == arg1) return true;
    (arg1)->stopSchedule();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_stopSchedule) 

static bool js_delete_dragonBones_CCFactory(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_CCFactory) 

static bool js_dragonBones_CCFactory_buildArmatureDisplay__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string *arg4 = 0 ;
    std::string *arg5 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    std::string temp4 ;
    std::string temp5 ;
    dragonBones::CCArmatureDisplay *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg5 = &temp5;
    
    result = (dragonBones::CCArmatureDisplay *)((dragonBones::CCFactory const *)arg1)->buildArmatureDisplay((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_CCFactory_buildArmatureDisplay__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string *arg4 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    std::string temp4 ;
    dragonBones::CCArmatureDisplay *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    result = (dragonBones::CCArmatureDisplay *)((dragonBones::CCFactory const *)arg1)->buildArmatureDisplay((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_CCFactory_buildArmatureDisplay__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    dragonBones::CCArmatureDisplay *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    result = (dragonBones::CCArmatureDisplay *)((dragonBones::CCFactory const *)arg1)->buildArmatureDisplay((std::string const &)*arg2,(std::string const &)*arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_CCFactory_buildArmatureDisplay__SWIG_3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::CCArmatureDisplay *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (dragonBones::CCArmatureDisplay *)((dragonBones::CCFactory const *)arg1)->buildArmatureDisplay((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_CCFactory_buildArmatureDisplay(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 4) {
        ok = js_dragonBones_CCFactory_buildArmatureDisplay__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 3) {
        ok = js_dragonBones_CCFactory_buildArmatureDisplay__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_dragonBones_CCFactory_buildArmatureDisplay__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_dragonBones_CCFactory_buildArmatureDisplay__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_buildArmatureDisplay) 

static bool js_dragonBones_CCFactory_getSoundEventManager(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    dragonBones::CCArmatureDisplay *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::CCArmatureDisplay *)((dragonBones::CCFactory const *)arg1)->getSoundEventManager();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_getSoundEventManager) 

static bool js_dragonBones_CCFactory_getClock_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::WorldClock *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (dragonBones::WorldClock *)dragonBones::CCFactory::getClock();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_getClock_static) 

static bool js_dragonBones_CCFactory_add(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    dragonBones::Armature *arg2 = (dragonBones::Armature *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->add(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_add) 

static bool js_dragonBones_CCFactory_remove(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    dragonBones::Armature *arg2 = (dragonBones::Armature *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->remove(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_remove) 

static bool js_dragonBones_CCFactory_setTimeScale(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setTimeScale(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_setTimeScale) 

static bool js_dragonBones_CCFactory_getTimeScale(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getTimeScale();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_getTimeScale) 

static bool js_dragonBones_CCFactory_getDragonBones(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    dragonBones::DragonBones *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::DragonBones *)(arg1)->getDragonBones();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_getDragonBones) 

static bool js_dragonBones_CCFactory_getDragonBonesDataByUUID(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::DragonBonesData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (dragonBones::DragonBonesData *)(arg1)->getDragonBonesDataByUUID((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_getDragonBonesDataByUUID) 

static bool js_dragonBones_CCFactory_removeTextureAtlasDataByIndex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    std::string *arg2 = 0 ;
    int arg3 ;
    std::string temp2 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->removeTextureAtlasDataByIndex((std::string const &)*arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_removeTextureAtlasDataByIndex) 

static bool js_dragonBones_CCFactory_removeDragonBonesDataByUUID__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    std::string *arg2 = 0 ;
    bool arg3 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->removeDragonBonesDataByUUID((std::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_dragonBones_CCFactory_removeDragonBonesDataByUUID__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->removeDragonBonesDataByUUID((std::string const &)*arg2);
    
    
    return true;
}

static bool js_dragonBones_CCFactory_removeDragonBonesDataByUUID(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_dragonBones_CCFactory_removeDragonBonesDataByUUID__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_dragonBones_CCFactory_removeDragonBonesDataByUUID__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_removeDragonBonesDataByUUID) 

static bool js_dragonBones_CCFactory_getTextureAtlasDataByIndex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    std::string *arg2 = 0 ;
    int arg3 ;
    std::string temp2 ;
    dragonBones::CCTextureAtlasData *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (dragonBones::CCTextureAtlasData *)((dragonBones::CCFactory const *)arg1)->getTextureAtlasDataByIndex((std::string const &)*arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_getTextureAtlasDataByIndex) 

static bool js_dragonBones_CCFactory_parseDragonBonesDataByPath__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    float arg4 ;
    std::string temp2 ;
    std::string temp3 ;
    dragonBones::DragonBonesData *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (dragonBones::DragonBonesData *)(arg1)->parseDragonBonesDataByPath((std::string const &)*arg2,(std::string const &)*arg3,arg4);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_CCFactory_parseDragonBonesDataByPath__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    dragonBones::DragonBonesData *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    result = (dragonBones::DragonBonesData *)(arg1)->parseDragonBonesDataByPath((std::string const &)*arg2,(std::string const &)*arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_CCFactory_parseDragonBonesDataByPath__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::CCFactory *arg1 = (dragonBones::CCFactory *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::DragonBonesData *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::CCFactory>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (dragonBones::DragonBonesData *)(arg1)->parseDragonBonesDataByPath((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_dragonBones_CCFactory_parseDragonBonesDataByPath(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_dragonBones_CCFactory_parseDragonBonesDataByPath__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_dragonBones_CCFactory_parseDragonBonesDataByPath__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_dragonBones_CCFactory_parseDragonBonesDataByPath__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_CCFactory_parseDragonBonesDataByPath) 

bool js_register_dragonBones_CCFactory(se::Object* obj) {
    auto* cls = se::Class::create("CCFactory", obj, __jsb_dragonBones_BaseFactory_proto, _SE(js_new_dragonBones_CCFactory)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("update", _SE(js_dragonBones_CCFactory_update)); 
    cls->defineFunction("render", _SE(js_dragonBones_CCFactory_render)); 
    cls->defineFunction("stopSchedule", _SE(js_dragonBones_CCFactory_stopSchedule)); 
    cls->defineFunction("buildArmatureDisplay", _SE(js_dragonBones_CCFactory_buildArmatureDisplay)); 
    cls->defineFunction("getSoundEventManager", _SE(js_dragonBones_CCFactory_getSoundEventManager)); 
    cls->defineFunction("add", _SE(js_dragonBones_CCFactory_add)); 
    cls->defineFunction("remove", _SE(js_dragonBones_CCFactory_remove)); 
    cls->defineFunction("setTimeScale", _SE(js_dragonBones_CCFactory_setTimeScale)); 
    cls->defineFunction("getTimeScale", _SE(js_dragonBones_CCFactory_getTimeScale)); 
    cls->defineFunction("getDragonBones", _SE(js_dragonBones_CCFactory_getDragonBones)); 
    cls->defineFunction("getDragonBonesDataByUUID", _SE(js_dragonBones_CCFactory_getDragonBonesDataByUUID)); 
    cls->defineFunction("removeTextureAtlasDataByIndex", _SE(js_dragonBones_CCFactory_removeTextureAtlasDataByIndex)); 
    cls->defineFunction("removeDragonBonesDataByUUID", _SE(js_dragonBones_CCFactory_removeDragonBonesDataByUUID)); 
    cls->defineFunction("getTextureAtlasDataByIndex", _SE(js_dragonBones_CCFactory_getTextureAtlasDataByIndex)); 
    cls->defineFunction("parseDragonBonesDataByPath", _SE(js_dragonBones_CCFactory_parseDragonBonesDataByPath)); 
    
    
    cls->defineStaticFunction("isInit", _SE(js_dragonBones_CCFactory_isInit_static)); 
    cls->defineStaticFunction("getFactory", _SE(js_dragonBones_CCFactory_getFactory_static)); 
    cls->defineStaticFunction("destroyFactory", _SE(js_dragonBones_CCFactory_destroyFactory_static)); 
    cls->defineStaticFunction("getClock", _SE(js_dragonBones_CCFactory_getClock_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_CCFactory));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::CCFactory>(cls);
    
    __jsb_dragonBones_CCFactory_proto = cls->getProto();
    __jsb_dragonBones_CCFactory_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_CCSlot_class = nullptr;
se::Object* __jsb_dragonBones_CCSlot_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_CCSlot) 

static bool js_delete_dragonBones_CCSlot(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_CCSlot) 

static bool js_dragonBones_CCSlot_updateWorldMatrix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCSlot *arg1 = (dragonBones::CCSlot *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCSlot>(s);
    if (nullptr == arg1) return true;
    (arg1)->updateWorldMatrix();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCSlot_updateWorldMatrix) 

bool js_register_dragonBones_CCSlot(se::Object* obj) {
    auto* cls = se::Class::create("CCSlot", obj, __jsb_dragonBones_Slot_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("updateWorldMatrix", _SE(js_dragonBones_CCSlot_updateWorldMatrix)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_CCSlot));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::CCSlot>(cls);
    
    __jsb_dragonBones_CCSlot_proto = cls->getProto();
    __jsb_dragonBones_CCSlot_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_CCArmatureCacheDisplay_class = nullptr;
se::Object* __jsb_dragonBones_CCArmatureCacheDisplay_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_CCArmatureCacheDisplay) 

static bool js_new_dragonBones_CCArmatureCacheDisplay(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    
    std::string *arg1 = 0 ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    bool arg4 ;
    std::string temp1 ;
    std::string temp2 ;
    std::string temp3 ;
    dragonBones::CCArmatureCacheDisplay *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[2], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[3], &arg4);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (dragonBones::CCArmatureCacheDisplay *)new dragonBones::CCArmatureCacheDisplay((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,arg4);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_dragonBones_CCArmatureCacheDisplay, __jsb_dragonBones_CCArmatureCacheDisplay_class, js_delete_dragonBones_CCArmatureCacheDisplay)

static bool js_delete_dragonBones_CCArmatureCacheDisplay(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_CCArmatureCacheDisplay) 

static bool js_dragonBones_CCArmatureCacheDisplay_dispose(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    if (nullptr == arg1) return true;
    (arg1)->dispose();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_dispose) 

static bool js_dragonBones_CCArmatureCacheDisplay_update(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->update(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_update) 

static bool js_dragonBones_CCArmatureCacheDisplay_render(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->render(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_render) 

static bool js_dragonBones_CCArmatureCacheDisplay_setTimeScale(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setTimeScale(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_setTimeScale) 

static bool js_dragonBones_CCArmatureCacheDisplay_getTimeScale(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    if (nullptr == arg1) return true;
    result = (float)((dragonBones::CCArmatureCacheDisplay const *)arg1)->getTimeScale();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_getTimeScale) 

static bool js_dragonBones_CCArmatureCacheDisplay_beginSchedule(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    if (nullptr == arg1) return true;
    (arg1)->beginSchedule();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_beginSchedule) 

static bool js_dragonBones_CCArmatureCacheDisplay_stopSchedule(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    if (nullptr == arg1) return true;
    (arg1)->stopSchedule();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_stopSchedule) 

static bool js_dragonBones_CCArmatureCacheDisplay_onEnable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    if (nullptr == arg1) return true;
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_onEnable) 

static bool js_dragonBones_CCArmatureCacheDisplay_onDisable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    if (nullptr == arg1) return true;
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_onDisable) 

static bool js_dragonBones_CCArmatureCacheDisplay_armature(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    dragonBones::Armature *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::Armature *)((dragonBones::CCArmatureCacheDisplay const *)arg1)->getArmature();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_armature) 

static bool js_dragonBones_CCArmatureCacheDisplay_getAnimation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    dragonBones::Animation *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::Animation *)((dragonBones::CCArmatureCacheDisplay const *)arg1)->getAnimation();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_getAnimation) 

static bool js_dragonBones_CCArmatureCacheDisplay_setColor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setColor(arg2,arg3,arg4,arg5);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_setColor) 

static bool js_dragonBones_CCArmatureCacheDisplay_setBatchEnabled(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setBatchEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_setBatchEnabled) 

static bool js_dragonBones_CCArmatureCacheDisplay_setAttachEnabled(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAttachEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_setAttachEnabled) 

static bool js_dragonBones_CCArmatureCacheDisplay_setOpacityModifyRGB(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setOpacityModifyRGB(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_setOpacityModifyRGB) 

static bool js_dragonBones_CCArmatureCacheDisplay_setDBEventCallback(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    dragonBones::CCArmatureCacheDisplay::dbEventCallback arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->setDBEventCallback(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_setDBEventCallback) 

static bool js_dragonBones_CCArmatureCacheDisplay_addDBEventListener(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->addDBEventListener((std::string const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_addDBEventListener) 

static bool js_dragonBones_CCArmatureCacheDisplay_removeDBEventListener(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->removeDBEventListener((std::string const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_removeDBEventListener) 

static bool js_dragonBones_CCArmatureCacheDisplay_dispatchDBEvent(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    std::string *arg2 = 0 ;
    dragonBones::EventObject *arg3 = (dragonBones::EventObject *) NULL ;
    std::string temp2 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->dispatchDBEvent((std::string const &)*arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_dispatchDBEvent) 

static bool js_dragonBones_CCArmatureCacheDisplay_playAnimation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    std::string *arg2 = 0 ;
    int arg3 ;
    std::string temp2 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->playAnimation((std::string const &)*arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_playAnimation) 

static bool js_dragonBones_CCArmatureCacheDisplay_updateAnimationCache(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->updateAnimationCache((std::string const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_updateAnimationCache) 

static bool js_dragonBones_CCArmatureCacheDisplay_updateAllAnimationCache(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    if (nullptr == arg1) return true;
    (arg1)->updateAllAnimationCache();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_updateAllAnimationCache) 

static bool js_dragonBones_CCArmatureCacheDisplay_getSharedBufferOffset(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    se_object_ptr result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    if (nullptr == arg1) return true;
    result = ((dragonBones::CCArmatureCacheDisplay const *)arg1)->getSharedBufferOffset();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_getSharedBufferOffset) 

static bool js_dragonBones_CCArmatureCacheDisplay_setMaterial(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    cc::Material *arg2 = (cc::Material *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setMaterial(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_setMaterial) 

static bool js_dragonBones_CCArmatureCacheDisplay_setRenderEntity(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::CCArmatureCacheDisplay *arg1 = (dragonBones::CCArmatureCacheDisplay *) NULL ;
    cc::RenderEntity *arg2 = (cc::RenderEntity *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::CCArmatureCacheDisplay>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRenderEntity(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_CCArmatureCacheDisplay_setRenderEntity) 

bool js_register_dragonBones_CCArmatureCacheDisplay(se::Object* obj) {
    auto* cls = se::Class::create("CCArmatureCacheDisplay", obj, nullptr, _SE(js_new_dragonBones_CCArmatureCacheDisplay)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("dispose", _SE(js_dragonBones_CCArmatureCacheDisplay_dispose)); 
    cls->defineFunction("update", _SE(js_dragonBones_CCArmatureCacheDisplay_update)); 
    cls->defineFunction("render", _SE(js_dragonBones_CCArmatureCacheDisplay_render)); 
    cls->defineFunction("setTimeScale", _SE(js_dragonBones_CCArmatureCacheDisplay_setTimeScale)); 
    cls->defineFunction("getTimeScale", _SE(js_dragonBones_CCArmatureCacheDisplay_getTimeScale)); 
    cls->defineFunction("beginSchedule", _SE(js_dragonBones_CCArmatureCacheDisplay_beginSchedule)); 
    cls->defineFunction("stopSchedule", _SE(js_dragonBones_CCArmatureCacheDisplay_stopSchedule)); 
    cls->defineFunction("onEnable", _SE(js_dragonBones_CCArmatureCacheDisplay_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_dragonBones_CCArmatureCacheDisplay_onDisable)); 
    cls->defineFunction("armature", _SE(js_dragonBones_CCArmatureCacheDisplay_armature)); 
    cls->defineFunction("getAnimation", _SE(js_dragonBones_CCArmatureCacheDisplay_getAnimation)); 
    cls->defineFunction("setColor", _SE(js_dragonBones_CCArmatureCacheDisplay_setColor)); 
    cls->defineFunction("setBatchEnabled", _SE(js_dragonBones_CCArmatureCacheDisplay_setBatchEnabled)); 
    cls->defineFunction("setAttachEnabled", _SE(js_dragonBones_CCArmatureCacheDisplay_setAttachEnabled)); 
    cls->defineFunction("setOpacityModifyRGB", _SE(js_dragonBones_CCArmatureCacheDisplay_setOpacityModifyRGB)); 
    cls->defineFunction("setDBEventCallback", _SE(js_dragonBones_CCArmatureCacheDisplay_setDBEventCallback)); 
    cls->defineFunction("addDBEventListener", _SE(js_dragonBones_CCArmatureCacheDisplay_addDBEventListener)); 
    cls->defineFunction("removeDBEventListener", _SE(js_dragonBones_CCArmatureCacheDisplay_removeDBEventListener)); 
    cls->defineFunction("dispatchDBEvent", _SE(js_dragonBones_CCArmatureCacheDisplay_dispatchDBEvent)); 
    cls->defineFunction("playAnimation", _SE(js_dragonBones_CCArmatureCacheDisplay_playAnimation)); 
    cls->defineFunction("updateAnimationCache", _SE(js_dragonBones_CCArmatureCacheDisplay_updateAnimationCache)); 
    cls->defineFunction("updateAllAnimationCache", _SE(js_dragonBones_CCArmatureCacheDisplay_updateAllAnimationCache)); 
    cls->defineFunction("getSharedBufferOffset", _SE(js_dragonBones_CCArmatureCacheDisplay_getSharedBufferOffset)); 
    cls->defineFunction("setMaterial", _SE(js_dragonBones_CCArmatureCacheDisplay_setMaterial)); 
    cls->defineFunction("setRenderEntity", _SE(js_dragonBones_CCArmatureCacheDisplay_setRenderEntity)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_CCArmatureCacheDisplay));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::CCArmatureCacheDisplay>(cls);
    
    __jsb_dragonBones_CCArmatureCacheDisplay_proto = cls->getProto();
    __jsb_dragonBones_CCArmatureCacheDisplay_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_ArmatureCache_class = nullptr;
se::Object* __jsb_dragonBones_ArmatureCache_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_ArmatureCache) 

static bool js_new_dragonBones_ArmatureCache(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    
    std::string *arg1 = 0 ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string temp1 ;
    std::string temp2 ;
    std::string temp3 ;
    dragonBones::ArmatureCache *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[2], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    result = (dragonBones::ArmatureCache *)new dragonBones::ArmatureCache((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_dragonBones_ArmatureCache, __jsb_dragonBones_ArmatureCache_class, js_delete_dragonBones_ArmatureCache)

static bool js_delete_dragonBones_ArmatureCache(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_ArmatureCache) 

static bool js_dragonBones_ArmatureCache_updateToFrame__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::ArmatureCache *arg1 = (dragonBones::ArmatureCache *) NULL ;
    std::string *arg2 = 0 ;
    int arg3 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureCache>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->updateToFrame((std::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_dragonBones_ArmatureCache_updateToFrame__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    dragonBones::ArmatureCache *arg1 = (dragonBones::ArmatureCache *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureCache>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->updateToFrame((std::string const &)*arg2);
    
    
    return true;
}

static bool js_dragonBones_ArmatureCache_updateToFrame(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_dragonBones_ArmatureCache_updateToFrame__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_dragonBones_ArmatureCache_updateToFrame__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_dragonBones_ArmatureCache_updateToFrame) 

static bool js_dragonBones_ArmatureCache_buildAnimationData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureCache *arg1 = (dragonBones::ArmatureCache *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::ArmatureCache::AnimationData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureCache>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (dragonBones::ArmatureCache::AnimationData *)(arg1)->buildAnimationData((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureCache_buildAnimationData) 

static bool js_dragonBones_ArmatureCache_getAnimationData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureCache *arg1 = (dragonBones::ArmatureCache *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    dragonBones::ArmatureCache::AnimationData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureCache>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (dragonBones::ArmatureCache::AnimationData *)(arg1)->getAnimationData((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureCache_getAnimationData) 

static bool js_dragonBones_ArmatureCache_getArmatureDisplay(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureCache *arg1 = (dragonBones::ArmatureCache *) NULL ;
    dragonBones::CCArmatureDisplay *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureCache>(s);
    if (nullptr == arg1) return true;
    result = (dragonBones::CCArmatureDisplay *)(arg1)->getArmatureDisplay();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureCache_getArmatureDisplay) 

static bool js_dragonBones_ArmatureCache_resetAllAnimationData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureCache *arg1 = (dragonBones::ArmatureCache *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureCache>(s);
    if (nullptr == arg1) return true;
    (arg1)->resetAllAnimationData();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureCache_resetAllAnimationData) 

static bool js_dragonBones_ArmatureCache_resetAnimationData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureCache *arg1 = (dragonBones::ArmatureCache *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureCache>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->resetAnimationData((std::string const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureCache_resetAnimationData) 

static bool js_dragonBones_ArmatureCache_FrameTime_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float arg1 ;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    dragonBones::ArmatureCache::FrameTime = arg1;
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_ArmatureCache_FrameTime_set) 

static bool js_dragonBones_ArmatureCache_FrameTime_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    float result;
    
    result = (float)dragonBones::ArmatureCache::FrameTime;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_ArmatureCache_FrameTime_get) 

static bool js_dragonBones_ArmatureCache_MaxCacheTime_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float arg1 ;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    dragonBones::ArmatureCache::MaxCacheTime = arg1;
    
    
    return true;
}
SE_BIND_PROP_SET(js_dragonBones_ArmatureCache_MaxCacheTime_set) 

static bool js_dragonBones_ArmatureCache_MaxCacheTime_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    float result;
    
    result = (float)dragonBones::ArmatureCache::MaxCacheTime;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_dragonBones_ArmatureCache_MaxCacheTime_get) 

bool js_register_dragonBones_ArmatureCache(se::Object* obj) {
    auto* cls = se::Class::create("ArmatureCache", obj, nullptr, _SE(js_new_dragonBones_ArmatureCache)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("updateToFrame", _SE(js_dragonBones_ArmatureCache_updateToFrame)); 
    cls->defineFunction("buildAnimationData", _SE(js_dragonBones_ArmatureCache_buildAnimationData)); 
    cls->defineFunction("getAnimationData", _SE(js_dragonBones_ArmatureCache_getAnimationData)); 
    cls->defineFunction("getArmatureDisplay", _SE(js_dragonBones_ArmatureCache_getArmatureDisplay)); 
    cls->defineFunction("resetAllAnimationData", _SE(js_dragonBones_ArmatureCache_resetAllAnimationData)); 
    cls->defineFunction("resetAnimationData", _SE(js_dragonBones_ArmatureCache_resetAnimationData)); 
    
    cls->defineStaticProperty("FrameTime", _SE(js_dragonBones_ArmatureCache_FrameTime_get), _SE(js_dragonBones_ArmatureCache_FrameTime_set)); 
    cls->defineStaticProperty("MaxCacheTime", _SE(js_dragonBones_ArmatureCache_MaxCacheTime_get), _SE(js_dragonBones_ArmatureCache_MaxCacheTime_set)); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_ArmatureCache));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::ArmatureCache>(cls);
    
    __jsb_dragonBones_ArmatureCache_proto = cls->getProto();
    __jsb_dragonBones_ArmatureCache_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_dragonBones_ArmatureCacheMgr_class = nullptr;
se::Object* __jsb_dragonBones_ArmatureCacheMgr_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_dragonBones_ArmatureCacheMgr) 

static bool js_dragonBones_ArmatureCacheMgr_getInstance_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureCacheMgr *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (dragonBones::ArmatureCacheMgr *)dragonBones::ArmatureCacheMgr::getInstance();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureCacheMgr_getInstance_static) 

static bool js_dragonBones_ArmatureCacheMgr_destroyInstance_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    dragonBones::ArmatureCacheMgr::destroyInstance();
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureCacheMgr_destroyInstance_static) 

static bool js_dragonBones_ArmatureCacheMgr_removeArmatureCache(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureCacheMgr *arg1 = (dragonBones::ArmatureCacheMgr *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureCacheMgr>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->removeArmatureCache((std::string const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureCacheMgr_removeArmatureCache) 

static bool js_dragonBones_ArmatureCacheMgr_buildArmatureCache(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    dragonBones::ArmatureCacheMgr *arg1 = (dragonBones::ArmatureCacheMgr *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string *arg4 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    std::string temp4 ;
    dragonBones::ArmatureCache *result = 0 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<dragonBones::ArmatureCacheMgr>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    result = (dragonBones::ArmatureCache *)(arg1)->buildArmatureCache((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_dragonBones_ArmatureCacheMgr_buildArmatureCache) 

static bool js_new_dragonBones_ArmatureCacheMgr(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    dragonBones::ArmatureCacheMgr *result;
    result = (dragonBones::ArmatureCacheMgr *)new dragonBones::ArmatureCacheMgr();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_dragonBones_ArmatureCacheMgr, __jsb_dragonBones_ArmatureCacheMgr_class, js_delete_dragonBones_ArmatureCacheMgr)

static bool js_delete_dragonBones_ArmatureCacheMgr(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_dragonBones_ArmatureCacheMgr) 

bool js_register_dragonBones_ArmatureCacheMgr(se::Object* obj) {
    auto* cls = se::Class::create("ArmatureCacheMgr", obj, nullptr, _SE(js_new_dragonBones_ArmatureCacheMgr)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("removeArmatureCache", _SE(js_dragonBones_ArmatureCacheMgr_removeArmatureCache)); 
    cls->defineFunction("buildArmatureCache", _SE(js_dragonBones_ArmatureCacheMgr_buildArmatureCache)); 
    
    
    cls->defineStaticFunction("getInstance", _SE(js_dragonBones_ArmatureCacheMgr_getInstance_static)); 
    cls->defineStaticFunction("destroyInstance", _SE(js_dragonBones_ArmatureCacheMgr_destroyInstance_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_dragonBones_ArmatureCacheMgr));
    
    
    cls->install();
    JSBClassType::registerClass<dragonBones::ArmatureCacheMgr>(cls);
    
    __jsb_dragonBones_ArmatureCacheMgr_proto = cls->getProto();
    __jsb_dragonBones_ArmatureCacheMgr_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}




bool register_all_dragonbones(se::Object* obj) {
    // Get the ns
    se::Value nsVal;
    if (!obj->getProperty("dragonBones", &nsVal, true))
    {
        se::HandleObject jsobj(se::Object::createPlainObject());
        nsVal.setObject(jsobj);
        obj->setProperty("dragonBones", nsVal);
    }
    se::Object* ns = nsVal.toObject();
    /* Register classes */
    js_register_dragonBones_Rectangle(ns); 
    js_register_dragonBones_Transform(ns); 
    js_register_dragonBones_Matrix(ns); 
    js_register_dragonBones_BaseObject(ns); 
    js_register_dragonBones_EventObject(ns); 
    js_register_dragonBones_BaseFactory(ns); 
    js_register_dragonBones_BuildArmaturePackage(ns); 
    js_register_dragonBones_DragonBonesData(ns); 
    js_register_dragonBones_TextureAtlasData(ns); 
    js_register_dragonBones_TextureData(ns); 
    js_register_dragonBones_ArmatureData(ns); 
    js_register_dragonBones_BoneData(ns); 
    js_register_dragonBones_SlotData(ns); 
    js_register_dragonBones_SkinData(ns); 
    js_register_dragonBones_AnimationData(ns); 
    js_register_dragonBones_TimelineData(ns); 
    js_register_dragonBones_WorldClock(ns); 
    js_register_dragonBones_Animation(ns); 
    js_register_dragonBones_AnimationState(ns); 
    js_register_dragonBones_BonePose(ns); 
    js_register_dragonBones_BlendState(ns); 
    js_register_dragonBones_TransformObject(ns); 
    js_register_dragonBones_Slot(ns); 
    js_register_dragonBones_Bone(ns); 
    js_register_dragonBones_Armature(ns); 
    js_register_dragonBones_CCArmatureDisplay(ns); 
    js_register_dragonBones_CCFactory(ns); 
    js_register_dragonBones_CCSlot(ns); 
    js_register_dragonBones_CCArmatureCacheDisplay(ns); 
    js_register_dragonBones_ArmatureCache(ns); 
    js_register_dragonBones_ArmatureCacheMgr(ns); 
    
    /* Register global variables & global functions */
    
    
    
    return true;
}


#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif
// clang-format on
