// clang-format off

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

/****************************************************************************
 Copyright (c) 2022-2023 Xiamen Yaji Software Co., Ltd.

 http://www.cocos.com

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights to
 use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 of the Software, and to permit persons to whom the Software is furnished to do so,
 subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
****************************************************************************/

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-variable"
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-variable"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4101)
#endif


#define SWIG_STD_MOVE(OBJ) std::move(OBJ)


#include <stdio.h>


#include "bindings/jswrapper/SeApi.h"
#include "bindings/manual/jsb_conversions.h"
#include "bindings/manual/jsb_global.h"


#include "bindings/auto/jsb_2d_auto.h"
#include "bindings/auto/jsb_assets_auto.h"
#include "bindings/auto/jsb_cocos_auto.h"
#include "bindings/auto/jsb_spine_auto.h"
using namespace spine;



se::Class* __jsb_spine_Timeline_class = nullptr;
se::Object* __jsb_spine_Timeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_Timeline) 

static bool js_delete_spine_Timeline(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_Timeline) 

static bool js_spine_Timeline_getPropertyId(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Timeline *arg1 = (spine::Timeline *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Timeline>(s);
    if (nullptr == arg1) return true;
    result = (int)(arg1)->getPropertyId();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Timeline_getPropertyId) 

bool js_register_spine_Timeline(se::Object* obj) {
    auto* cls = se::Class::create("Timeline", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getPropertyId", _SE(js_spine_Timeline_getPropertyId)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_Timeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::Timeline>(cls);
    
    __jsb_spine_Timeline_proto = cls->getProto();
    __jsb_spine_Timeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_Animation_class = nullptr;
se::Object* __jsb_spine_Animation_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_Animation) 

static bool js_delete_spine_Animation(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_Animation) 

static bool js_spine_Animation_getName(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Animation *arg1 = (spine::Animation *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Animation>(s);
    if (nullptr == arg1) return true;
    result = (spine::String *) &(arg1)->getName();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Animation_getName) 

static bool js_spine_Animation_getTimelines(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Animation *arg1 = (spine::Animation *) NULL ;
    spine::Vector< spine::Timeline * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Animation>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::Timeline * > *) &(arg1)->getTimelines();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Animation_getTimelines) 

static bool js_spine_Animation_hasTimeline(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Animation *arg1 = (spine::Animation *) NULL ;
    int arg2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (bool)(arg1)->hasTimeline(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Animation_hasTimeline) 

static bool js_spine_Animation_getDuration(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Animation *arg1 = (spine::Animation *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Animation>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getDuration();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Animation_getDuration) 

static bool js_spine_Animation_setDuration(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Animation *arg1 = (spine::Animation *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Animation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setDuration(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Animation_setDuration) 

bool js_register_spine_Animation(se::Object* obj) {
    auto* cls = se::Class::create("Animation", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getName", _SE(js_spine_Animation_getName)); 
    cls->defineFunction("getTimelines", _SE(js_spine_Animation_getTimelines)); 
    cls->defineFunction("hasTimeline", _SE(js_spine_Animation_hasTimeline)); 
    cls->defineFunction("getDuration", _SE(js_spine_Animation_getDuration)); 
    cls->defineFunction("setDuration", _SE(js_spine_Animation_setDuration)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_Animation));
    
    
    cls->install();
    JSBClassType::registerClass<spine::Animation>(cls);
    
    __jsb_spine_Animation_proto = cls->getProto();
    __jsb_spine_Animation_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_AnimationStateListenerObject_class = nullptr;
se::Object* __jsb_spine_AnimationStateListenerObject_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_AnimationStateListenerObject) 

static bool js_delete_spine_AnimationStateListenerObject(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_AnimationStateListenerObject) 

static bool js_spine_AnimationStateListenerObject_callback(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationStateListenerObject *arg1 = (spine::AnimationStateListenerObject *) NULL ;
    spine::AnimationState *arg2 = (spine::AnimationState *) NULL ;
    spine::EventType arg3 ;
    spine::TrackEntry *arg4 = (spine::TrackEntry *) NULL ;
    spine::Event *arg5 = (spine::Event *) NULL ;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationStateListenerObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->callback(arg2,arg3,arg4,arg5);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationStateListenerObject_callback) 

bool js_register_spine_AnimationStateListenerObject(se::Object* obj) {
    auto* cls = se::Class::create("AnimationStateListenerObject", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("callback", _SE(js_spine_AnimationStateListenerObject_callback)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_AnimationStateListenerObject));
    
    
    cls->install();
    JSBClassType::registerClass<spine::AnimationStateListenerObject>(cls);
    
    __jsb_spine_AnimationStateListenerObject_proto = cls->getProto();
    __jsb_spine_AnimationStateListenerObject_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_TrackEntry_class = nullptr;
se::Object* __jsb_spine_TrackEntry_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_TrackEntry) 

static bool js_delete_spine_TrackEntry(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_TrackEntry) 

static bool js_spine_TrackEntry_getTrackIndex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    result = (int)(arg1)->getTrackIndex();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getTrackIndex) 

static bool js_spine_TrackEntry_getAnimation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    spine::Animation *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    result = (spine::Animation *)(arg1)->getAnimation();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getAnimation) 

static bool js_spine_TrackEntry_getLoop(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->getLoop();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getLoop) 

static bool js_spine_TrackEntry_setLoop(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setLoop(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setLoop) 

static bool js_spine_TrackEntry_getHoldPrevious(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->getHoldPrevious();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getHoldPrevious) 

static bool js_spine_TrackEntry_setHoldPrevious(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setHoldPrevious(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setHoldPrevious) 

static bool js_spine_TrackEntry_getDelay(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getDelay();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getDelay) 

static bool js_spine_TrackEntry_setDelay(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setDelay(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setDelay) 

static bool js_spine_TrackEntry_getTrackTime(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getTrackTime();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getTrackTime) 

static bool js_spine_TrackEntry_setTrackTime(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setTrackTime(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setTrackTime) 

static bool js_spine_TrackEntry_getTrackEnd(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getTrackEnd();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getTrackEnd) 

static bool js_spine_TrackEntry_setTrackEnd(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setTrackEnd(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setTrackEnd) 

static bool js_spine_TrackEntry_getAnimationStart(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getAnimationStart();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getAnimationStart) 

static bool js_spine_TrackEntry_setAnimationStart(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAnimationStart(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setAnimationStart) 

static bool js_spine_TrackEntry_getAnimationEnd(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getAnimationEnd();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getAnimationEnd) 

static bool js_spine_TrackEntry_setAnimationEnd(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAnimationEnd(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setAnimationEnd) 

static bool js_spine_TrackEntry_getAnimationLast(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getAnimationLast();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getAnimationLast) 

static bool js_spine_TrackEntry_setAnimationLast(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAnimationLast(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setAnimationLast) 

static bool js_spine_TrackEntry_getAnimationTime(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getAnimationTime();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getAnimationTime) 

static bool js_spine_TrackEntry_getTimeScale(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getTimeScale();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getTimeScale) 

static bool js_spine_TrackEntry_setTimeScale(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setTimeScale(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setTimeScale) 

static bool js_spine_TrackEntry_getAlpha(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getAlpha();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getAlpha) 

static bool js_spine_TrackEntry_setAlpha(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAlpha(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setAlpha) 

static bool js_spine_TrackEntry_getEventThreshold(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getEventThreshold();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getEventThreshold) 

static bool js_spine_TrackEntry_setEventThreshold(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setEventThreshold(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setEventThreshold) 

static bool js_spine_TrackEntry_getAttachmentThreshold(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getAttachmentThreshold();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getAttachmentThreshold) 

static bool js_spine_TrackEntry_setAttachmentThreshold(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAttachmentThreshold(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setAttachmentThreshold) 

static bool js_spine_TrackEntry_getDrawOrderThreshold(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getDrawOrderThreshold();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getDrawOrderThreshold) 

static bool js_spine_TrackEntry_setDrawOrderThreshold(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setDrawOrderThreshold(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setDrawOrderThreshold) 

static bool js_spine_TrackEntry_getNext(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    spine::TrackEntry *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    result = (spine::TrackEntry *)(arg1)->getNext();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getNext) 

static bool js_spine_TrackEntry_isComplete(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->isComplete();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_isComplete) 

static bool js_spine_TrackEntry_getMixTime(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getMixTime();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getMixTime) 

static bool js_spine_TrackEntry_setMixTime(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setMixTime(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setMixTime) 

static bool js_spine_TrackEntry_getMixDuration(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getMixDuration();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getMixDuration) 

static bool js_spine_TrackEntry_setMixDuration(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setMixDuration(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setMixDuration) 

static bool js_spine_TrackEntry_getMixBlend(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    spine::MixBlend result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    result = (spine::MixBlend)(arg1)->getMixBlend();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getMixBlend) 

static bool js_spine_TrackEntry_setMixBlend(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    spine::MixBlend arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->setMixBlend(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setMixBlend) 

static bool js_spine_TrackEntry_getMixingFrom(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    spine::TrackEntry *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    result = (spine::TrackEntry *)(arg1)->getMixingFrom();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getMixingFrom) 

static bool js_spine_TrackEntry_getMixingTo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    spine::TrackEntry *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    result = (spine::TrackEntry *)(arg1)->getMixingTo();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getMixingTo) 

static bool js_spine_TrackEntry_resetRotationDirections(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    if (nullptr == arg1) return true;
    (arg1)->resetRotationDirections();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_resetRotationDirections) 

bool js_register_spine_TrackEntry(se::Object* obj) {
    auto* cls = se::Class::create("TrackEntry", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getTrackIndex", _SE(js_spine_TrackEntry_getTrackIndex)); 
    cls->defineFunction("getAnimation", _SE(js_spine_TrackEntry_getAnimation)); 
    cls->defineFunction("getLoop", _SE(js_spine_TrackEntry_getLoop)); 
    cls->defineFunction("setLoop", _SE(js_spine_TrackEntry_setLoop)); 
    cls->defineFunction("getHoldPrevious", _SE(js_spine_TrackEntry_getHoldPrevious)); 
    cls->defineFunction("setHoldPrevious", _SE(js_spine_TrackEntry_setHoldPrevious)); 
    cls->defineFunction("getDelay", _SE(js_spine_TrackEntry_getDelay)); 
    cls->defineFunction("setDelay", _SE(js_spine_TrackEntry_setDelay)); 
    cls->defineFunction("getTrackTime", _SE(js_spine_TrackEntry_getTrackTime)); 
    cls->defineFunction("setTrackTime", _SE(js_spine_TrackEntry_setTrackTime)); 
    cls->defineFunction("getTrackEnd", _SE(js_spine_TrackEntry_getTrackEnd)); 
    cls->defineFunction("setTrackEnd", _SE(js_spine_TrackEntry_setTrackEnd)); 
    cls->defineFunction("getAnimationStart", _SE(js_spine_TrackEntry_getAnimationStart)); 
    cls->defineFunction("setAnimationStart", _SE(js_spine_TrackEntry_setAnimationStart)); 
    cls->defineFunction("getAnimationEnd", _SE(js_spine_TrackEntry_getAnimationEnd)); 
    cls->defineFunction("setAnimationEnd", _SE(js_spine_TrackEntry_setAnimationEnd)); 
    cls->defineFunction("getAnimationLast", _SE(js_spine_TrackEntry_getAnimationLast)); 
    cls->defineFunction("setAnimationLast", _SE(js_spine_TrackEntry_setAnimationLast)); 
    cls->defineFunction("getAnimationTime", _SE(js_spine_TrackEntry_getAnimationTime)); 
    cls->defineFunction("getTimeScale", _SE(js_spine_TrackEntry_getTimeScale)); 
    cls->defineFunction("setTimeScale", _SE(js_spine_TrackEntry_setTimeScale)); 
    cls->defineFunction("getAlpha", _SE(js_spine_TrackEntry_getAlpha)); 
    cls->defineFunction("setAlpha", _SE(js_spine_TrackEntry_setAlpha)); 
    cls->defineFunction("getEventThreshold", _SE(js_spine_TrackEntry_getEventThreshold)); 
    cls->defineFunction("setEventThreshold", _SE(js_spine_TrackEntry_setEventThreshold)); 
    cls->defineFunction("getAttachmentThreshold", _SE(js_spine_TrackEntry_getAttachmentThreshold)); 
    cls->defineFunction("setAttachmentThreshold", _SE(js_spine_TrackEntry_setAttachmentThreshold)); 
    cls->defineFunction("getDrawOrderThreshold", _SE(js_spine_TrackEntry_getDrawOrderThreshold)); 
    cls->defineFunction("setDrawOrderThreshold", _SE(js_spine_TrackEntry_setDrawOrderThreshold)); 
    cls->defineFunction("getNext", _SE(js_spine_TrackEntry_getNext)); 
    cls->defineFunction("isComplete", _SE(js_spine_TrackEntry_isComplete)); 
    cls->defineFunction("getMixTime", _SE(js_spine_TrackEntry_getMixTime)); 
    cls->defineFunction("setMixTime", _SE(js_spine_TrackEntry_setMixTime)); 
    cls->defineFunction("getMixDuration", _SE(js_spine_TrackEntry_getMixDuration)); 
    cls->defineFunction("setMixDuration", _SE(js_spine_TrackEntry_setMixDuration)); 
    cls->defineFunction("getMixBlend", _SE(js_spine_TrackEntry_getMixBlend)); 
    cls->defineFunction("setMixBlend", _SE(js_spine_TrackEntry_setMixBlend)); 
    cls->defineFunction("getMixingFrom", _SE(js_spine_TrackEntry_getMixingFrom)); 
    cls->defineFunction("getMixingTo", _SE(js_spine_TrackEntry_getMixingTo)); 
    cls->defineFunction("resetRotationDirections", _SE(js_spine_TrackEntry_resetRotationDirections)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_TrackEntry));
    
    
    cls->install();
    JSBClassType::registerClass<spine::TrackEntry>(cls);
    
    __jsb_spine_TrackEntry_proto = cls->getProto();
    __jsb_spine_TrackEntry_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_EventQueueEntry_class = nullptr;
se::Object* __jsb_spine_EventQueueEntry_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_EventQueueEntry) 

static bool js_spine_EventQueueEntry__type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventQueueEntry *arg1 = (spine::EventQueueEntry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::EventQueueEntry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_type, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_spine_EventQueueEntry__type_set) 

static bool js_spine_EventQueueEntry__type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    spine::EventQueueEntry *arg1 = (spine::EventQueueEntry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::EventQueueEntry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_type, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_type, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_EventQueueEntry__type_get) 

static bool js_spine_EventQueueEntry__entry_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventQueueEntry *arg1 = (spine::EventQueueEntry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::EventQueueEntry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_entry, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_spine_EventQueueEntry__entry_set) 

static bool js_spine_EventQueueEntry__entry_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    spine::EventQueueEntry *arg1 = (spine::EventQueueEntry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::EventQueueEntry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_entry, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_entry, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_EventQueueEntry__entry_get) 

static bool js_spine_EventQueueEntry__event_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventQueueEntry *arg1 = (spine::EventQueueEntry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::EventQueueEntry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_event, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_spine_EventQueueEntry__event_set) 

static bool js_spine_EventQueueEntry__event_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    spine::EventQueueEntry *arg1 = (spine::EventQueueEntry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::EventQueueEntry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_event, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_event, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_EventQueueEntry__event_get) 

static bool js_new_spine_EventQueueEntry__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    spine::EventType arg1 ;
    spine::TrackEntry *arg2 = (spine::TrackEntry *) NULL ;
    spine::Event *arg3 = (spine::Event *) NULL ;
    spine::EventQueueEntry *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::EventQueueEntry *)new spine::EventQueueEntry(arg1,arg2,arg3);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_spine_EventQueueEntry__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    spine::EventType arg1 ;
    spine::TrackEntry *arg2 = (spine::TrackEntry *) NULL ;
    spine::EventQueueEntry *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::EventQueueEntry *)new spine::EventQueueEntry(arg1,arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_EventQueueEntry(se::State& s) // NOLINT(readability-identifier-naming)
{
    size_t argc = s.args().size();
    bool ret = false;
    
    if(argc == 3) {
        ret = js_new_spine_EventQueueEntry__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 2) {
        ret = js_new_spine_EventQueueEntry__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    SE_REPORT_ERROR("Illegal arguments for construction of EventQueueEntry");
    return false;
}
SE_BIND_CTOR(js_new_EventQueueEntry, __jsb_spine_EventQueueEntry_class, js_delete_spine_EventQueueEntry)

static bool js_delete_spine_EventQueueEntry(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_EventQueueEntry) 

bool js_register_spine_EventQueueEntry(se::Object* obj) {
    auto* cls = se::Class::create("EventQueueEntry", obj, nullptr, _SE(js_new_EventQueueEntry)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("_type", _SE(js_spine_EventQueueEntry__type_get), _SE(js_spine_EventQueueEntry__type_set)); 
    cls->defineProperty("_entry", _SE(js_spine_EventQueueEntry__entry_get), _SE(js_spine_EventQueueEntry__entry_set)); 
    cls->defineProperty("_event", _SE(js_spine_EventQueueEntry__event_get), _SE(js_spine_EventQueueEntry__event_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_EventQueueEntry));
    
    
    cls->install();
    JSBClassType::registerClass<spine::EventQueueEntry>(cls);
    
    __jsb_spine_EventQueueEntry_proto = cls->getProto();
    __jsb_spine_EventQueueEntry_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_EventQueue_class = nullptr;
se::Object* __jsb_spine_EventQueue_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_EventQueue) 

bool js_register_spine_EventQueue(se::Object* obj) {
    auto* cls = se::Class::create("EventQueue", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    
    
    
    cls->install();
    JSBClassType::registerClass<spine::EventQueue>(cls);
    
    __jsb_spine_EventQueue_proto = cls->getProto();
    __jsb_spine_EventQueue_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_AnimationState_class = nullptr;
se::Object* __jsb_spine_AnimationState_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_AnimationState) 

static bool js_delete_spine_AnimationState(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_AnimationState) 

static bool js_spine_AnimationState_update(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->update(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationState_update) 

static bool js_spine_AnimationState_clearTracks(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    if (nullptr == arg1) return true;
    (arg1)->clearTracks();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationState_clearTracks) 

static bool js_spine_AnimationState_clearTrack(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    size_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->clearTrack(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationState_clearTrack) 

static bool js_spine_AnimationState_setAnimation__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    size_t arg2 ;
    spine::String *arg3 = 0 ;
    bool arg4 ;
    spine::String temp3 ;
    spine::TrackEntry *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::TrackEntry *)(arg1)->setAnimation(arg2,(spine::String const &)*arg3,arg4);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_AnimationState_setAnimation__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    size_t arg2 ;
    spine::Animation *arg3 = (spine::Animation *) NULL ;
    bool arg4 ;
    spine::TrackEntry *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::TrackEntry *)(arg1)->setAnimation(arg2,arg3,arg4);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_AnimationState_setAnimation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_spine_AnimationState_setAnimation__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 3) {
        ok = js_spine_AnimationState_setAnimation__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_AnimationState_setAnimation) 

static bool js_spine_AnimationState_addAnimation__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    size_t arg2 ;
    spine::String *arg3 = 0 ;
    bool arg4 ;
    float arg5 ;
    spine::String temp3 ;
    spine::TrackEntry *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::TrackEntry *)(arg1)->addAnimation(arg2,(spine::String const &)*arg3,arg4,arg5);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_AnimationState_addAnimation__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    size_t arg2 ;
    spine::Animation *arg3 = (spine::Animation *) NULL ;
    bool arg4 ;
    float arg5 ;
    spine::TrackEntry *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::TrackEntry *)(arg1)->addAnimation(arg2,arg3,arg4,arg5);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_AnimationState_addAnimation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 4) {
        ok = js_spine_AnimationState_addAnimation__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 4) {
        ok = js_spine_AnimationState_addAnimation__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_AnimationState_addAnimation) 

static bool js_spine_AnimationState_setEmptyAnimation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    size_t arg2 ;
    float arg3 ;
    spine::TrackEntry *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::TrackEntry *)(arg1)->setEmptyAnimation(arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationState_setEmptyAnimation) 

static bool js_spine_AnimationState_addEmptyAnimation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    size_t arg2 ;
    float arg3 ;
    float arg4 ;
    spine::TrackEntry *result = 0 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::TrackEntry *)(arg1)->addEmptyAnimation(arg2,arg3,arg4);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationState_addEmptyAnimation) 

static bool js_spine_AnimationState_setEmptyAnimations(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setEmptyAnimations(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationState_setEmptyAnimations) 

static bool js_spine_AnimationState_getCurrent(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    size_t arg2 ;
    spine::TrackEntry *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (spine::TrackEntry *)(arg1)->getCurrent(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationState_getCurrent) 

static bool js_spine_AnimationState_getData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    spine::AnimationStateData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    if (nullptr == arg1) return true;
    result = (spine::AnimationStateData *)(arg1)->getData();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationState_getData) 

static bool js_spine_AnimationState_getTracks(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    spine::Vector< spine::TrackEntry * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::TrackEntry * > *) &(arg1)->getTracks();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationState_getTracks) 

static bool js_spine_AnimationState_getTimeScale(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getTimeScale();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationState_getTimeScale) 

static bool js_spine_AnimationState_setTimeScale(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setTimeScale(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationState_setTimeScale) 

static bool js_spine_AnimationState_disableQueue(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    if (nullptr == arg1) return true;
    (arg1)->disableQueue();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationState_disableQueue) 

static bool js_spine_AnimationState_enableQueue(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    if (nullptr == arg1) return true;
    (arg1)->enableQueue();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationState_enableQueue) 

bool js_register_spine_AnimationState(se::Object* obj) {
    auto* cls = se::Class::create("AnimationState", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("update", _SE(js_spine_AnimationState_update)); 
    cls->defineFunction("clearTracks", _SE(js_spine_AnimationState_clearTracks)); 
    cls->defineFunction("clearTrack", _SE(js_spine_AnimationState_clearTrack)); 
    cls->defineFunction("setAnimation", _SE(js_spine_AnimationState_setAnimation)); 
    cls->defineFunction("addAnimation", _SE(js_spine_AnimationState_addAnimation)); 
    cls->defineFunction("setEmptyAnimation", _SE(js_spine_AnimationState_setEmptyAnimation)); 
    cls->defineFunction("addEmptyAnimation", _SE(js_spine_AnimationState_addEmptyAnimation)); 
    cls->defineFunction("setEmptyAnimations", _SE(js_spine_AnimationState_setEmptyAnimations)); 
    cls->defineFunction("getCurrent", _SE(js_spine_AnimationState_getCurrent)); 
    cls->defineFunction("getData", _SE(js_spine_AnimationState_getData)); 
    cls->defineFunction("getTracks", _SE(js_spine_AnimationState_getTracks)); 
    cls->defineFunction("getTimeScale", _SE(js_spine_AnimationState_getTimeScale)); 
    cls->defineFunction("setTimeScale", _SE(js_spine_AnimationState_setTimeScale)); 
    cls->defineFunction("disableQueue", _SE(js_spine_AnimationState_disableQueue)); 
    cls->defineFunction("enableQueue", _SE(js_spine_AnimationState_enableQueue)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_AnimationState));
    
    
    cls->install();
    JSBClassType::registerClass<spine::AnimationState>(cls);
    
    __jsb_spine_AnimationState_proto = cls->getProto();
    __jsb_spine_AnimationState_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_AnimationStateData_class = nullptr;
se::Object* __jsb_spine_AnimationStateData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_AnimationStateData) 

static bool js_spine_AnimationStateData_getSkeletonData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationStateData *arg1 = (spine::AnimationStateData *) NULL ;
    spine::SkeletonData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationStateData>(s);
    if (nullptr == arg1) return true;
    result = (spine::SkeletonData *)(arg1)->getSkeletonData();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationStateData_getSkeletonData) 

static bool js_spine_AnimationStateData_getDefaultMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationStateData *arg1 = (spine::AnimationStateData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationStateData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getDefaultMix();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationStateData_getDefaultMix) 

static bool js_spine_AnimationStateData_setDefaultMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationStateData *arg1 = (spine::AnimationStateData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationStateData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setDefaultMix(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationStateData_setDefaultMix) 

static bool js_spine_AnimationStateData_setMix__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::AnimationStateData *arg1 = (spine::AnimationStateData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String *arg3 = 0 ;
    float arg4 ;
    spine::String temp2 ;
    spine::String temp3 ;
    
    arg1 = SE_THIS_OBJECT<spine::AnimationStateData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setMix((spine::String const &)*arg2,(spine::String const &)*arg3,arg4);
    
    
    return true;
}

static bool js_spine_AnimationStateData_setMix__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::AnimationStateData *arg1 = (spine::AnimationStateData *) NULL ;
    spine::Animation *arg2 = (spine::Animation *) NULL ;
    spine::Animation *arg3 = (spine::Animation *) NULL ;
    float arg4 ;
    
    arg1 = SE_THIS_OBJECT<spine::AnimationStateData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setMix(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_spine_AnimationStateData_setMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_spine_AnimationStateData_setMix__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 3) {
        ok = js_spine_AnimationStateData_setMix__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_AnimationStateData_setMix) 

static bool js_spine_AnimationStateData_getMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationStateData *arg1 = (spine::AnimationStateData *) NULL ;
    spine::Animation *arg2 = (spine::Animation *) NULL ;
    spine::Animation *arg3 = (spine::Animation *) NULL ;
    float result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationStateData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (float)(arg1)->getMix(arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationStateData_getMix) 

static bool js_delete_spine_AnimationStateData(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_AnimationStateData) 

bool js_register_spine_AnimationStateData(se::Object* obj) {
    auto* cls = se::Class::create("AnimationStateData", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getSkeletonData", _SE(js_spine_AnimationStateData_getSkeletonData)); 
    cls->defineFunction("getDefaultMix", _SE(js_spine_AnimationStateData_getDefaultMix)); 
    cls->defineFunction("setDefaultMix", _SE(js_spine_AnimationStateData_setDefaultMix)); 
    cls->defineFunction("setMix", _SE(js_spine_AnimationStateData_setMix)); 
    cls->defineFunction("getMix", _SE(js_spine_AnimationStateData_getMix)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_AnimationStateData));
    
    
    cls->install();
    JSBClassType::registerClass<spine::AnimationStateData>(cls);
    
    __jsb_spine_AnimationStateData_proto = cls->getProto();
    __jsb_spine_AnimationStateData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_Attachment_class = nullptr;
se::Object* __jsb_spine_Attachment_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_Attachment) 

static bool js_delete_spine_Attachment(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_Attachment) 

static bool js_spine_Attachment_getName(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Attachment *arg1 = (spine::Attachment *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Attachment>(s);
    if (nullptr == arg1) return true;
    result = (spine::String *) &((spine::Attachment const *)arg1)->getName();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Attachment_getName) 

static bool js_spine_Attachment_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Attachment *arg1 = (spine::Attachment *) NULL ;
    spine::Attachment *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Attachment>(s);
    if (nullptr == arg1) return true;
    result = (spine::Attachment *)(arg1)->copy();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Attachment_copy) 

static bool js_spine_Attachment_getRefCount(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Attachment *arg1 = (spine::Attachment *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Attachment>(s);
    if (nullptr == arg1) return true;
    result = (int)(arg1)->getRefCount();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Attachment_getRefCount) 

static bool js_spine_Attachment_reference(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Attachment *arg1 = (spine::Attachment *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Attachment>(s);
    if (nullptr == arg1) return true;
    (arg1)->reference();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Attachment_reference) 

static bool js_spine_Attachment_dereference(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Attachment *arg1 = (spine::Attachment *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Attachment>(s);
    if (nullptr == arg1) return true;
    (arg1)->dereference();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Attachment_dereference) 

bool js_register_spine_Attachment(se::Object* obj) {
    auto* cls = se::Class::create("Attachment", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getName", _SE(js_spine_Attachment_getName)); 
    cls->defineFunction("copy", _SE(js_spine_Attachment_copy)); 
    cls->defineFunction("getRefCount", _SE(js_spine_Attachment_getRefCount)); 
    cls->defineFunction("reference", _SE(js_spine_Attachment_reference)); 
    cls->defineFunction("dereference", _SE(js_spine_Attachment_dereference)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_Attachment));
    
    
    cls->install();
    JSBClassType::registerClass<spine::Attachment>(cls);
    
    __jsb_spine_Attachment_proto = cls->getProto();
    __jsb_spine_Attachment_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_AttachmentTimeline_class = nullptr;
se::Object* __jsb_spine_AttachmentTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_AttachmentTimeline) 

static bool js_spine_AttachmentTimeline_setFrame(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AttachmentTimeline *arg1 = (spine::AttachmentTimeline *) NULL ;
    int arg2 ;
    float arg3 ;
    spine::String *arg4 = 0 ;
    spine::String temp4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AttachmentTimeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    (arg1)->setFrame(arg2,arg3,(spine::String const &)*arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AttachmentTimeline_setFrame) 

static bool js_spine_AttachmentTimeline_getSlotIndex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AttachmentTimeline *arg1 = (spine::AttachmentTimeline *) NULL ;
    size_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AttachmentTimeline>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getSlotIndex();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AttachmentTimeline_getSlotIndex) 

static bool js_spine_AttachmentTimeline_setSlotIndex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AttachmentTimeline *arg1 = (spine::AttachmentTimeline *) NULL ;
    size_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AttachmentTimeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setSlotIndex(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AttachmentTimeline_setSlotIndex) 

static bool js_spine_AttachmentTimeline_getFrames(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AttachmentTimeline *arg1 = (spine::AttachmentTimeline *) NULL ;
    spine::Vector< float > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AttachmentTimeline>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< float > *) &(arg1)->getFrames();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AttachmentTimeline_getFrames) 

static bool js_spine_AttachmentTimeline_getAttachmentNames(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AttachmentTimeline *arg1 = (spine::AttachmentTimeline *) NULL ;
    spine::Vector< spine::String > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AttachmentTimeline>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::String > *) &(arg1)->getAttachmentNames();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AttachmentTimeline_getAttachmentNames) 

static bool js_spine_AttachmentTimeline_getFrameCount(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AttachmentTimeline *arg1 = (spine::AttachmentTimeline *) NULL ;
    size_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AttachmentTimeline>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getFrameCount();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AttachmentTimeline_getFrameCount) 

static bool js_delete_spine_AttachmentTimeline(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_AttachmentTimeline) 

bool js_register_spine_AttachmentTimeline(se::Object* obj) {
    auto* cls = se::Class::create("AttachmentTimeline", obj, __jsb_spine_Timeline_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("setFrame", _SE(js_spine_AttachmentTimeline_setFrame)); 
    cls->defineFunction("getSlotIndex", _SE(js_spine_AttachmentTimeline_getSlotIndex)); 
    cls->defineFunction("setSlotIndex", _SE(js_spine_AttachmentTimeline_setSlotIndex)); 
    cls->defineFunction("getFrames", _SE(js_spine_AttachmentTimeline_getFrames)); 
    cls->defineFunction("getAttachmentNames", _SE(js_spine_AttachmentTimeline_getAttachmentNames)); 
    cls->defineFunction("getFrameCount", _SE(js_spine_AttachmentTimeline_getFrameCount)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_AttachmentTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::AttachmentTimeline>(cls);
    
    __jsb_spine_AttachmentTimeline_proto = cls->getProto();
    __jsb_spine_AttachmentTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_BoundingBoxAttachment_class = nullptr;
se::Object* __jsb_spine_BoundingBoxAttachment_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_BoundingBoxAttachment) 

static bool js_spine_BoundingBoxAttachment_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoundingBoxAttachment *arg1 = (spine::BoundingBoxAttachment *) NULL ;
    spine::Attachment *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoundingBoxAttachment>(s);
    if (nullptr == arg1) return true;
    result = (spine::Attachment *)(arg1)->copy();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoundingBoxAttachment_copy) 

static bool js_delete_spine_BoundingBoxAttachment(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_BoundingBoxAttachment) 

bool js_register_spine_BoundingBoxAttachment(se::Object* obj) {
    auto* cls = se::Class::create("BoundingBoxAttachment", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("copy", _SE(js_spine_BoundingBoxAttachment_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_BoundingBoxAttachment));
    
    
    cls->install();
    JSBClassType::registerClass<spine::BoundingBoxAttachment>(cls);
    
    __jsb_spine_BoundingBoxAttachment_proto = cls->getProto();
    __jsb_spine_BoundingBoxAttachment_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_Bone_class = nullptr;
se::Object* __jsb_spine_Bone_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_Bone) 

static bool js_spine_Bone_setYDown_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    bool arg1 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    spine::Bone::setYDown(arg1);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setYDown_static) 

static bool js_spine_Bone_isYDown_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (bool)spine::Bone::isYDown();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_isYDown_static) 

static bool js_spine_Bone_update(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    (arg1)->update();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_update) 

static bool js_spine_Bone_updateWorldTransform__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    (arg1)->updateWorldTransform();
    
    
    return true;
}

static bool js_spine_Bone_updateWorldTransform__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    float arg8 ;
    
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->updateWorldTransform(arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_spine_Bone_updateWorldTransform(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 0) {
        ok = js_spine_Bone_updateWorldTransform__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 7) {
        ok = js_spine_Bone_updateWorldTransform__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_Bone_updateWorldTransform) 

static bool js_spine_Bone_setToSetupPose(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    (arg1)->setToSetupPose();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setToSetupPose) 

static bool js_spine_Bone_worldToLocalRotation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    float result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (float)(arg1)->worldToLocalRotation(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_worldToLocalRotation) 

static bool js_spine_Bone_localToWorldRotation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    float result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (float)(arg1)->localToWorldRotation(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_localToWorldRotation) 

static bool js_spine_Bone_rotateWorld(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->rotateWorld(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_rotateWorld) 

static bool js_spine_Bone_getWorldToLocalRotationX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getWorldToLocalRotationX();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getWorldToLocalRotationX) 

static bool js_spine_Bone_getWorldToLocalRotationY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getWorldToLocalRotationY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getWorldToLocalRotationY) 

static bool js_spine_Bone_getData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    spine::BoneData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (spine::BoneData *) &(arg1)->getData();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getData) 

static bool js_spine_Bone_getSkeleton(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    spine::Skeleton *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (spine::Skeleton *) &(arg1)->getSkeleton();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getSkeleton) 

static bool js_spine_Bone_getParent(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    spine::Bone *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (spine::Bone *)(arg1)->getParent();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getParent) 

static bool js_spine_Bone_getChildren(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    spine::Vector< spine::Bone * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::Bone * > *) &(arg1)->getChildren();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getChildren) 

static bool js_spine_Bone_getX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getX();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getX) 

static bool js_spine_Bone_setX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setX) 

static bool js_spine_Bone_getY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getY) 

static bool js_spine_Bone_setY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setY) 

static bool js_spine_Bone_getRotation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getRotation();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getRotation) 

static bool js_spine_Bone_setRotation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRotation(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setRotation) 

static bool js_spine_Bone_getScaleX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getScaleX();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getScaleX) 

static bool js_spine_Bone_setScaleX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setScaleX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setScaleX) 

static bool js_spine_Bone_getScaleY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getScaleY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getScaleY) 

static bool js_spine_Bone_setScaleY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setScaleY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setScaleY) 

static bool js_spine_Bone_getShearX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getShearX();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getShearX) 

static bool js_spine_Bone_setShearX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setShearX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setShearX) 

static bool js_spine_Bone_getShearY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getShearY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getShearY) 

static bool js_spine_Bone_setShearY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setShearY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setShearY) 

static bool js_spine_Bone_getAppliedRotation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getAppliedRotation();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getAppliedRotation) 

static bool js_spine_Bone_setAppliedRotation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAppliedRotation(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setAppliedRotation) 

static bool js_spine_Bone_getAX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getAX();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getAX) 

static bool js_spine_Bone_setAX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setAX) 

static bool js_spine_Bone_getAY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getAY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getAY) 

static bool js_spine_Bone_setAY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setAY) 

static bool js_spine_Bone_getAScaleX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getAScaleX();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getAScaleX) 

static bool js_spine_Bone_setAScaleX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAScaleX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setAScaleX) 

static bool js_spine_Bone_getAScaleY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getAScaleY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getAScaleY) 

static bool js_spine_Bone_setAScaleY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAScaleY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setAScaleY) 

static bool js_spine_Bone_getAShearX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getAShearX();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getAShearX) 

static bool js_spine_Bone_setAShearX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAShearX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setAShearX) 

static bool js_spine_Bone_getAShearY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getAShearY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getAShearY) 

static bool js_spine_Bone_setAShearY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAShearY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setAShearY) 

static bool js_spine_Bone_getA(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getA();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getA) 

static bool js_spine_Bone_setA(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setA(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setA) 

static bool js_spine_Bone_getB(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getB();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getB) 

static bool js_spine_Bone_setB(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setB(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setB) 

static bool js_spine_Bone_getC(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getC();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getC) 

static bool js_spine_Bone_setC(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setC(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setC) 

static bool js_spine_Bone_getD(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getD();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getD) 

static bool js_spine_Bone_setD(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setD(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setD) 

static bool js_spine_Bone_getWorldX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getWorldX();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getWorldX) 

static bool js_spine_Bone_setWorldX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setWorldX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setWorldX) 

static bool js_spine_Bone_getWorldY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getWorldY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getWorldY) 

static bool js_spine_Bone_setWorldY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setWorldY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setWorldY) 

static bool js_spine_Bone_getWorldRotationX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getWorldRotationX();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getWorldRotationX) 

static bool js_spine_Bone_getWorldRotationY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getWorldRotationY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getWorldRotationY) 

static bool js_spine_Bone_getWorldScaleX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getWorldScaleX();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getWorldScaleX) 

static bool js_spine_Bone_getWorldScaleY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getWorldScaleY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getWorldScaleY) 

static bool js_spine_Bone_isAppliedValid(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->isAppliedValid();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_isAppliedValid) 

static bool js_spine_Bone_setAppliedValid(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAppliedValid(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setAppliedValid) 

static bool js_spine_Bone_isActive(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->isActive();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_isActive) 

static bool js_spine_Bone_setActive(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setActive(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setActive) 

static bool js_delete_spine_Bone(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_Bone) 

bool js_register_spine_Bone(se::Object* obj) {
    auto* cls = se::Class::create("Bone", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("update", _SE(js_spine_Bone_update)); 
    cls->defineFunction("updateWorldTransform", _SE(js_spine_Bone_updateWorldTransform)); 
    cls->defineFunction("setToSetupPose", _SE(js_spine_Bone_setToSetupPose)); 
    cls->defineFunction("worldToLocalRotation", _SE(js_spine_Bone_worldToLocalRotation)); 
    cls->defineFunction("localToWorldRotation", _SE(js_spine_Bone_localToWorldRotation)); 
    cls->defineFunction("rotateWorld", _SE(js_spine_Bone_rotateWorld)); 
    cls->defineFunction("getWorldToLocalRotationX", _SE(js_spine_Bone_getWorldToLocalRotationX)); 
    cls->defineFunction("getWorldToLocalRotationY", _SE(js_spine_Bone_getWorldToLocalRotationY)); 
    cls->defineFunction("getData", _SE(js_spine_Bone_getData)); 
    cls->defineFunction("getSkeleton", _SE(js_spine_Bone_getSkeleton)); 
    cls->defineFunction("getParent", _SE(js_spine_Bone_getParent)); 
    cls->defineFunction("getChildren", _SE(js_spine_Bone_getChildren)); 
    cls->defineFunction("getX", _SE(js_spine_Bone_getX)); 
    cls->defineFunction("setX", _SE(js_spine_Bone_setX)); 
    cls->defineFunction("getY", _SE(js_spine_Bone_getY)); 
    cls->defineFunction("setY", _SE(js_spine_Bone_setY)); 
    cls->defineFunction("getRotation", _SE(js_spine_Bone_getRotation)); 
    cls->defineFunction("setRotation", _SE(js_spine_Bone_setRotation)); 
    cls->defineFunction("getScaleX", _SE(js_spine_Bone_getScaleX)); 
    cls->defineFunction("setScaleX", _SE(js_spine_Bone_setScaleX)); 
    cls->defineFunction("getScaleY", _SE(js_spine_Bone_getScaleY)); 
    cls->defineFunction("setScaleY", _SE(js_spine_Bone_setScaleY)); 
    cls->defineFunction("getShearX", _SE(js_spine_Bone_getShearX)); 
    cls->defineFunction("setShearX", _SE(js_spine_Bone_setShearX)); 
    cls->defineFunction("getShearY", _SE(js_spine_Bone_getShearY)); 
    cls->defineFunction("setShearY", _SE(js_spine_Bone_setShearY)); 
    cls->defineFunction("getAppliedRotation", _SE(js_spine_Bone_getAppliedRotation)); 
    cls->defineFunction("setAppliedRotation", _SE(js_spine_Bone_setAppliedRotation)); 
    cls->defineFunction("getAX", _SE(js_spine_Bone_getAX)); 
    cls->defineFunction("setAX", _SE(js_spine_Bone_setAX)); 
    cls->defineFunction("getAY", _SE(js_spine_Bone_getAY)); 
    cls->defineFunction("setAY", _SE(js_spine_Bone_setAY)); 
    cls->defineFunction("getAScaleX", _SE(js_spine_Bone_getAScaleX)); 
    cls->defineFunction("setAScaleX", _SE(js_spine_Bone_setAScaleX)); 
    cls->defineFunction("getAScaleY", _SE(js_spine_Bone_getAScaleY)); 
    cls->defineFunction("setAScaleY", _SE(js_spine_Bone_setAScaleY)); 
    cls->defineFunction("getAShearX", _SE(js_spine_Bone_getAShearX)); 
    cls->defineFunction("setAShearX", _SE(js_spine_Bone_setAShearX)); 
    cls->defineFunction("getAShearY", _SE(js_spine_Bone_getAShearY)); 
    cls->defineFunction("setAShearY", _SE(js_spine_Bone_setAShearY)); 
    cls->defineFunction("getA", _SE(js_spine_Bone_getA)); 
    cls->defineFunction("setA", _SE(js_spine_Bone_setA)); 
    cls->defineFunction("getB", _SE(js_spine_Bone_getB)); 
    cls->defineFunction("setB", _SE(js_spine_Bone_setB)); 
    cls->defineFunction("getC", _SE(js_spine_Bone_getC)); 
    cls->defineFunction("setC", _SE(js_spine_Bone_setC)); 
    cls->defineFunction("getD", _SE(js_spine_Bone_getD)); 
    cls->defineFunction("setD", _SE(js_spine_Bone_setD)); 
    cls->defineFunction("getWorldX", _SE(js_spine_Bone_getWorldX)); 
    cls->defineFunction("setWorldX", _SE(js_spine_Bone_setWorldX)); 
    cls->defineFunction("getWorldY", _SE(js_spine_Bone_getWorldY)); 
    cls->defineFunction("setWorldY", _SE(js_spine_Bone_setWorldY)); 
    cls->defineFunction("getWorldRotationX", _SE(js_spine_Bone_getWorldRotationX)); 
    cls->defineFunction("getWorldRotationY", _SE(js_spine_Bone_getWorldRotationY)); 
    cls->defineFunction("getWorldScaleX", _SE(js_spine_Bone_getWorldScaleX)); 
    cls->defineFunction("getWorldScaleY", _SE(js_spine_Bone_getWorldScaleY)); 
    cls->defineFunction("isAppliedValid", _SE(js_spine_Bone_isAppliedValid)); 
    cls->defineFunction("setAppliedValid", _SE(js_spine_Bone_setAppliedValid)); 
    cls->defineFunction("isActive", _SE(js_spine_Bone_isActive)); 
    cls->defineFunction("setActive", _SE(js_spine_Bone_setActive)); 
    
    
    cls->defineStaticFunction("setYDown", _SE(js_spine_Bone_setYDown_static)); 
    cls->defineStaticFunction("isYDown", _SE(js_spine_Bone_isYDown_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_Bone));
    
    
    cls->install();
    JSBClassType::registerClass<spine::Bone>(cls);
    
    __jsb_spine_Bone_proto = cls->getProto();
    __jsb_spine_Bone_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_BoneData_class = nullptr;
se::Object* __jsb_spine_BoneData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_BoneData) 

static bool js_spine_BoneData_getIndex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    if (nullptr == arg1) return true;
    result = (int)(arg1)->getIndex();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_getIndex) 

static bool js_spine_BoneData_getName(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    if (nullptr == arg1) return true;
    result = (spine::String *) &(arg1)->getName();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_getName) 

static bool js_spine_BoneData_getParent(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    spine::BoneData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    if (nullptr == arg1) return true;
    result = (spine::BoneData *)(arg1)->getParent();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_getParent) 

static bool js_spine_BoneData_getLength(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getLength();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_getLength) 

static bool js_spine_BoneData_setLength(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setLength(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_setLength) 

static bool js_spine_BoneData_getX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getX();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_getX) 

static bool js_spine_BoneData_setX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_setX) 

static bool js_spine_BoneData_getY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_getY) 

static bool js_spine_BoneData_setY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_setY) 

static bool js_spine_BoneData_getRotation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getRotation();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_getRotation) 

static bool js_spine_BoneData_setRotation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRotation(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_setRotation) 

static bool js_spine_BoneData_getScaleX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getScaleX();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_getScaleX) 

static bool js_spine_BoneData_setScaleX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setScaleX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_setScaleX) 

static bool js_spine_BoneData_getScaleY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getScaleY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_getScaleY) 

static bool js_spine_BoneData_setScaleY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setScaleY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_setScaleY) 

static bool js_spine_BoneData_getShearX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getShearX();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_getShearX) 

static bool js_spine_BoneData_setShearX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setShearX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_setShearX) 

static bool js_spine_BoneData_getShearY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getShearY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_getShearY) 

static bool js_spine_BoneData_setShearY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setShearY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_setShearY) 

static bool js_spine_BoneData_getTransformMode(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    spine::TransformMode result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    if (nullptr == arg1) return true;
    result = (spine::TransformMode)(arg1)->getTransformMode();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_getTransformMode) 

static bool js_spine_BoneData_setTransformMode(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    spine::TransformMode arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->setTransformMode(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_setTransformMode) 

static bool js_spine_BoneData_isSkinRequired(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->isSkinRequired();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_isSkinRequired) 

static bool js_spine_BoneData_setSkinRequired(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setSkinRequired(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_setSkinRequired) 

static bool js_delete_spine_BoneData(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_BoneData) 

bool js_register_spine_BoneData(se::Object* obj) {
    auto* cls = se::Class::create("BoneData", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getIndex", _SE(js_spine_BoneData_getIndex)); 
    cls->defineFunction("getName", _SE(js_spine_BoneData_getName)); 
    cls->defineFunction("getParent", _SE(js_spine_BoneData_getParent)); 
    cls->defineFunction("getLength", _SE(js_spine_BoneData_getLength)); 
    cls->defineFunction("setLength", _SE(js_spine_BoneData_setLength)); 
    cls->defineFunction("getX", _SE(js_spine_BoneData_getX)); 
    cls->defineFunction("setX", _SE(js_spine_BoneData_setX)); 
    cls->defineFunction("getY", _SE(js_spine_BoneData_getY)); 
    cls->defineFunction("setY", _SE(js_spine_BoneData_setY)); 
    cls->defineFunction("getRotation", _SE(js_spine_BoneData_getRotation)); 
    cls->defineFunction("setRotation", _SE(js_spine_BoneData_setRotation)); 
    cls->defineFunction("getScaleX", _SE(js_spine_BoneData_getScaleX)); 
    cls->defineFunction("setScaleX", _SE(js_spine_BoneData_setScaleX)); 
    cls->defineFunction("getScaleY", _SE(js_spine_BoneData_getScaleY)); 
    cls->defineFunction("setScaleY", _SE(js_spine_BoneData_setScaleY)); 
    cls->defineFunction("getShearX", _SE(js_spine_BoneData_getShearX)); 
    cls->defineFunction("setShearX", _SE(js_spine_BoneData_setShearX)); 
    cls->defineFunction("getShearY", _SE(js_spine_BoneData_getShearY)); 
    cls->defineFunction("setShearY", _SE(js_spine_BoneData_setShearY)); 
    cls->defineFunction("getTransformMode", _SE(js_spine_BoneData_getTransformMode)); 
    cls->defineFunction("setTransformMode", _SE(js_spine_BoneData_setTransformMode)); 
    cls->defineFunction("isSkinRequired", _SE(js_spine_BoneData_isSkinRequired)); 
    cls->defineFunction("setSkinRequired", _SE(js_spine_BoneData_setSkinRequired)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_BoneData));
    
    
    cls->install();
    JSBClassType::registerClass<spine::BoneData>(cls);
    
    __jsb_spine_BoneData_proto = cls->getProto();
    __jsb_spine_BoneData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_ClippingAttachment_class = nullptr;
se::Object* __jsb_spine_ClippingAttachment_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_ClippingAttachment) 

static bool js_spine_ClippingAttachment_getEndSlot(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ClippingAttachment *arg1 = (spine::ClippingAttachment *) NULL ;
    spine::SlotData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ClippingAttachment>(s);
    if (nullptr == arg1) return true;
    result = (spine::SlotData *)(arg1)->getEndSlot();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ClippingAttachment_getEndSlot) 

static bool js_spine_ClippingAttachment_setEndSlot(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ClippingAttachment *arg1 = (spine::ClippingAttachment *) NULL ;
    spine::SlotData *arg2 = (spine::SlotData *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ClippingAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setEndSlot(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ClippingAttachment_setEndSlot) 

static bool js_spine_ClippingAttachment_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ClippingAttachment *arg1 = (spine::ClippingAttachment *) NULL ;
    spine::Attachment *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ClippingAttachment>(s);
    if (nullptr == arg1) return true;
    result = (spine::Attachment *)(arg1)->copy();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ClippingAttachment_copy) 

static bool js_delete_spine_ClippingAttachment(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_ClippingAttachment) 

bool js_register_spine_ClippingAttachment(se::Object* obj) {
    auto* cls = se::Class::create("ClippingAttachment", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getEndSlot", _SE(js_spine_ClippingAttachment_getEndSlot)); 
    cls->defineFunction("setEndSlot", _SE(js_spine_ClippingAttachment_setEndSlot)); 
    cls->defineFunction("copy", _SE(js_spine_ClippingAttachment_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_ClippingAttachment));
    
    
    cls->install();
    JSBClassType::registerClass<spine::ClippingAttachment>(cls);
    
    __jsb_spine_ClippingAttachment_proto = cls->getProto();
    __jsb_spine_ClippingAttachment_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_Color_class = nullptr;
se::Object* __jsb_spine_Color_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_Color) 

static bool js_spine_Color_clamp(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Color *arg1 = (spine::Color *) NULL ;
    spine::Color *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Color>(s);
    if (nullptr == arg1) return true;
    result = (spine::Color *) &(arg1)->clamp();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Color_clamp) 

static bool js_spine_Color_r_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Color *arg1 = (spine::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::Color>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->r, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_spine_Color_r_set) 

static bool js_spine_Color_r_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    spine::Color *arg1 = (spine::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::Color>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->r, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_Color_r_get) 

static bool js_spine_Color_g_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Color *arg1 = (spine::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::Color>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->g, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_spine_Color_g_set) 

static bool js_spine_Color_g_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    spine::Color *arg1 = (spine::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::Color>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->g, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_Color_g_get) 

static bool js_spine_Color_b_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Color *arg1 = (spine::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::Color>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->b, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_spine_Color_b_set) 

static bool js_spine_Color_b_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    spine::Color *arg1 = (spine::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::Color>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->b, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_Color_b_get) 

static bool js_spine_Color_a_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Color *arg1 = (spine::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::Color>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->a, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_spine_Color_a_set) 

static bool js_spine_Color_a_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    spine::Color *arg1 = (spine::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::Color>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->a, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_Color_a_get) 

static bool js_delete_spine_Color(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_Color) 

bool js_register_spine_Color(se::Object* obj) {
    auto* cls = se::Class::create("Color", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("r", _SE(js_spine_Color_r_get), _SE(js_spine_Color_r_set)); 
    cls->defineProperty("g", _SE(js_spine_Color_g_get), _SE(js_spine_Color_g_set)); 
    cls->defineProperty("b", _SE(js_spine_Color_b_get), _SE(js_spine_Color_b_set)); 
    cls->defineProperty("a", _SE(js_spine_Color_a_get), _SE(js_spine_Color_a_set)); 
    
    cls->defineFunction("clamp", _SE(js_spine_Color_clamp)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_Color));
    
    
    cls->install();
    JSBClassType::registerClass<spine::Color>(cls);
    
    __jsb_spine_Color_proto = cls->getProto();
    __jsb_spine_Color_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_ColorTimeline_class = nullptr;
se::Object* __jsb_spine_ColorTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_ColorTimeline) 

static bool js_spine_ColorTimeline_ENTRIES_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    int result;
    
    result = (int)(int)spine::ColorTimeline::ENTRIES;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_ColorTimeline_ENTRIES_get) 

static bool js_spine_ColorTimeline_getPropertyId(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ColorTimeline *arg1 = (spine::ColorTimeline *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ColorTimeline>(s);
    if (nullptr == arg1) return true;
    result = (int)(arg1)->getPropertyId();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ColorTimeline_getPropertyId) 

static bool js_spine_ColorTimeline_setFrame(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ColorTimeline *arg1 = (spine::ColorTimeline *) NULL ;
    int arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ColorTimeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setFrame(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ColorTimeline_setFrame) 

static bool js_spine_ColorTimeline_getSlotIndex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ColorTimeline *arg1 = (spine::ColorTimeline *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ColorTimeline>(s);
    if (nullptr == arg1) return true;
    result = (int)(arg1)->getSlotIndex();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ColorTimeline_getSlotIndex) 

static bool js_spine_ColorTimeline_setSlotIndex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ColorTimeline *arg1 = (spine::ColorTimeline *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ColorTimeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setSlotIndex(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ColorTimeline_setSlotIndex) 

static bool js_spine_ColorTimeline_getFrames(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ColorTimeline *arg1 = (spine::ColorTimeline *) NULL ;
    spine::Vector< float > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ColorTimeline>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< float > *) &(arg1)->getFrames();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ColorTimeline_getFrames) 

static bool js_delete_spine_ColorTimeline(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_ColorTimeline) 

bool js_register_spine_ColorTimeline(se::Object* obj) {
    auto* cls = se::Class::create("ColorTimeline", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getPropertyId", _SE(js_spine_ColorTimeline_getPropertyId)); 
    cls->defineFunction("setFrame", _SE(js_spine_ColorTimeline_setFrame)); 
    cls->defineFunction("getSlotIndex", _SE(js_spine_ColorTimeline_getSlotIndex)); 
    cls->defineFunction("setSlotIndex", _SE(js_spine_ColorTimeline_setSlotIndex)); 
    cls->defineFunction("getFrames", _SE(js_spine_ColorTimeline_getFrames)); 
    
    cls->defineStaticProperty("ENTRIES", _SE(js_spine_ColorTimeline_ENTRIES_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_ColorTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::ColorTimeline>(cls);
    
    __jsb_spine_ColorTimeline_proto = cls->getProto();
    __jsb_spine_ColorTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_CurveTimeline_class = nullptr;
se::Object* __jsb_spine_CurveTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_CurveTimeline) 

static bool js_delete_spine_CurveTimeline(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_CurveTimeline) 

static bool js_spine_CurveTimeline_getFrameCount(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::CurveTimeline *arg1 = (spine::CurveTimeline *) NULL ;
    size_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::CurveTimeline>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getFrameCount();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_CurveTimeline_getFrameCount) 

static bool js_spine_CurveTimeline_setLinear(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::CurveTimeline *arg1 = (spine::CurveTimeline *) NULL ;
    size_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::CurveTimeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setLinear(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_CurveTimeline_setLinear) 

static bool js_spine_CurveTimeline_setStepped(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::CurveTimeline *arg1 = (spine::CurveTimeline *) NULL ;
    size_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::CurveTimeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setStepped(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_CurveTimeline_setStepped) 

static bool js_spine_CurveTimeline_setCurve(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::CurveTimeline *arg1 = (spine::CurveTimeline *) NULL ;
    size_t arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    
    if(argc != 5) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::CurveTimeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setCurve(arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_CurveTimeline_setCurve) 

static bool js_spine_CurveTimeline_getCurvePercent(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::CurveTimeline *arg1 = (spine::CurveTimeline *) NULL ;
    size_t arg2 ;
    float arg3 ;
    float result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::CurveTimeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (float)(arg1)->getCurvePercent(arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_CurveTimeline_getCurvePercent) 

static bool js_spine_CurveTimeline_getCurveType(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::CurveTimeline *arg1 = (spine::CurveTimeline *) NULL ;
    size_t arg2 ;
    float result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::CurveTimeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (float)(arg1)->getCurveType(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_CurveTimeline_getCurveType) 

bool js_register_spine_CurveTimeline(se::Object* obj) {
    auto* cls = se::Class::create("CurveTimeline", obj, __jsb_spine_Timeline_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getFrameCount", _SE(js_spine_CurveTimeline_getFrameCount)); 
    cls->defineFunction("setLinear", _SE(js_spine_CurveTimeline_setLinear)); 
    cls->defineFunction("setStepped", _SE(js_spine_CurveTimeline_setStepped)); 
    cls->defineFunction("setCurve", _SE(js_spine_CurveTimeline_setCurve)); 
    cls->defineFunction("getCurvePercent", _SE(js_spine_CurveTimeline_getCurvePercent)); 
    cls->defineFunction("getCurveType", _SE(js_spine_CurveTimeline_getCurveType)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_CurveTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::CurveTimeline>(cls);
    
    __jsb_spine_CurveTimeline_proto = cls->getProto();
    __jsb_spine_CurveTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_DeformTimeline_class = nullptr;
se::Object* __jsb_spine_DeformTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_DeformTimeline) 

static bool js_spine_DeformTimeline_getSlotIndex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::DeformTimeline *arg1 = (spine::DeformTimeline *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::DeformTimeline>(s);
    if (nullptr == arg1) return true;
    result = (int)(arg1)->getSlotIndex();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_DeformTimeline_getSlotIndex) 

static bool js_spine_DeformTimeline_setSlotIndex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::DeformTimeline *arg1 = (spine::DeformTimeline *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::DeformTimeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setSlotIndex(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_DeformTimeline_setSlotIndex) 

static bool js_spine_DeformTimeline_getFrames(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::DeformTimeline *arg1 = (spine::DeformTimeline *) NULL ;
    spine::Vector< float > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::DeformTimeline>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< float > *) &(arg1)->getFrames();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_DeformTimeline_getFrames) 

static bool js_spine_DeformTimeline_getAttachment(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::DeformTimeline *arg1 = (spine::DeformTimeline *) NULL ;
    spine::VertexAttachment *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::DeformTimeline>(s);
    if (nullptr == arg1) return true;
    result = (spine::VertexAttachment *)(arg1)->getAttachment();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_DeformTimeline_getAttachment) 

static bool js_spine_DeformTimeline_setAttachment(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::DeformTimeline *arg1 = (spine::DeformTimeline *) NULL ;
    spine::VertexAttachment *arg2 = (spine::VertexAttachment *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::DeformTimeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAttachment(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_DeformTimeline_setAttachment) 

static bool js_delete_spine_DeformTimeline(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_DeformTimeline) 

bool js_register_spine_DeformTimeline(se::Object* obj) {
    auto* cls = se::Class::create("DeformTimeline", obj, __jsb_spine_CurveTimeline_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getSlotIndex", _SE(js_spine_DeformTimeline_getSlotIndex)); 
    cls->defineFunction("setSlotIndex", _SE(js_spine_DeformTimeline_setSlotIndex)); 
    cls->defineFunction("getFrames", _SE(js_spine_DeformTimeline_getFrames)); 
    cls->defineFunction("getAttachment", _SE(js_spine_DeformTimeline_getAttachment)); 
    cls->defineFunction("setAttachment", _SE(js_spine_DeformTimeline_setAttachment)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_DeformTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::DeformTimeline>(cls);
    
    __jsb_spine_DeformTimeline_proto = cls->getProto();
    __jsb_spine_DeformTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_DrawOrderTimeline_class = nullptr;
se::Object* __jsb_spine_DrawOrderTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_DrawOrderTimeline) 

static bool js_spine_DrawOrderTimeline_getFrames(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::DrawOrderTimeline *arg1 = (spine::DrawOrderTimeline *) NULL ;
    spine::Vector< float > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::DrawOrderTimeline>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< float > *) &(arg1)->getFrames();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_DrawOrderTimeline_getFrames) 

static bool js_spine_DrawOrderTimeline_getFrameCount(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::DrawOrderTimeline *arg1 = (spine::DrawOrderTimeline *) NULL ;
    size_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::DrawOrderTimeline>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getFrameCount();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_DrawOrderTimeline_getFrameCount) 

static bool js_delete_spine_DrawOrderTimeline(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_DrawOrderTimeline) 

bool js_register_spine_DrawOrderTimeline(se::Object* obj) {
    auto* cls = se::Class::create("DrawOrderTimeline", obj, __jsb_spine_Timeline_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getFrames", _SE(js_spine_DrawOrderTimeline_getFrames)); 
    cls->defineFunction("getFrameCount", _SE(js_spine_DrawOrderTimeline_getFrameCount)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_DrawOrderTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::DrawOrderTimeline>(cls);
    
    __jsb_spine_DrawOrderTimeline_proto = cls->getProto();
    __jsb_spine_DrawOrderTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_Event_class = nullptr;
se::Object* __jsb_spine_Event_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_Event) 

static bool js_spine_Event_getData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Event *arg1 = (spine::Event *) NULL ;
    spine::EventData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Event>(s);
    if (nullptr == arg1) return true;
    result = (spine::EventData *) &(arg1)->getData();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Event_getData) 

static bool js_spine_Event_getTime(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Event *arg1 = (spine::Event *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Event>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getTime();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Event_getTime) 

static bool js_spine_Event_getIntValue(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Event *arg1 = (spine::Event *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Event>(s);
    if (nullptr == arg1) return true;
    result = (int)(arg1)->getIntValue();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Event_getIntValue) 

static bool js_spine_Event_setIntValue(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Event *arg1 = (spine::Event *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Event>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setIntValue(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Event_setIntValue) 

static bool js_spine_Event_getFloatValue(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Event *arg1 = (spine::Event *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Event>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getFloatValue();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Event_getFloatValue) 

static bool js_spine_Event_setFloatValue(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Event *arg1 = (spine::Event *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Event>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setFloatValue(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Event_setFloatValue) 

static bool js_spine_Event_getStringValue(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Event *arg1 = (spine::Event *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Event>(s);
    if (nullptr == arg1) return true;
    result = (spine::String *) &(arg1)->getStringValue();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Event_getStringValue) 

static bool js_spine_Event_setStringValue(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Event *arg1 = (spine::Event *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Event>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setStringValue((spine::String const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Event_setStringValue) 

static bool js_spine_Event_getVolume(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Event *arg1 = (spine::Event *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Event>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getVolume();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Event_getVolume) 

static bool js_spine_Event_setVolume(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Event *arg1 = (spine::Event *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Event>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setVolume(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Event_setVolume) 

static bool js_spine_Event_getBalance(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Event *arg1 = (spine::Event *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Event>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getBalance();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Event_getBalance) 

static bool js_spine_Event_setBalance(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Event *arg1 = (spine::Event *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Event>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setBalance(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Event_setBalance) 

static bool js_delete_spine_Event(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_Event) 

bool js_register_spine_Event(se::Object* obj) {
    auto* cls = se::Class::create("Event", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getData", _SE(js_spine_Event_getData)); 
    cls->defineFunction("getTime", _SE(js_spine_Event_getTime)); 
    cls->defineFunction("getIntValue", _SE(js_spine_Event_getIntValue)); 
    cls->defineFunction("setIntValue", _SE(js_spine_Event_setIntValue)); 
    cls->defineFunction("getFloatValue", _SE(js_spine_Event_getFloatValue)); 
    cls->defineFunction("setFloatValue", _SE(js_spine_Event_setFloatValue)); 
    cls->defineFunction("getStringValue", _SE(js_spine_Event_getStringValue)); 
    cls->defineFunction("setStringValue", _SE(js_spine_Event_setStringValue)); 
    cls->defineFunction("getVolume", _SE(js_spine_Event_getVolume)); 
    cls->defineFunction("setVolume", _SE(js_spine_Event_setVolume)); 
    cls->defineFunction("getBalance", _SE(js_spine_Event_getBalance)); 
    cls->defineFunction("setBalance", _SE(js_spine_Event_setBalance)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_Event));
    
    
    cls->install();
    JSBClassType::registerClass<spine::Event>(cls);
    
    __jsb_spine_Event_proto = cls->getProto();
    __jsb_spine_Event_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_EventData_class = nullptr;
se::Object* __jsb_spine_EventData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_EventData) 

static bool js_spine_EventData_getName(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventData *arg1 = (spine::EventData *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventData>(s);
    if (nullptr == arg1) return true;
    result = (spine::String *) &((spine::EventData const *)arg1)->getName();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventData_getName) 

static bool js_spine_EventData_getIntValue(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventData *arg1 = (spine::EventData *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventData>(s);
    if (nullptr == arg1) return true;
    result = (int)(arg1)->getIntValue();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventData_getIntValue) 

static bool js_spine_EventData_setIntValue(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventData *arg1 = (spine::EventData *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setIntValue(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventData_setIntValue) 

static bool js_spine_EventData_getFloatValue(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventData *arg1 = (spine::EventData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getFloatValue();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventData_getFloatValue) 

static bool js_spine_EventData_setFloatValue(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventData *arg1 = (spine::EventData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setFloatValue(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventData_setFloatValue) 

static bool js_spine_EventData_getStringValue(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventData *arg1 = (spine::EventData *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventData>(s);
    if (nullptr == arg1) return true;
    result = (spine::String *) &(arg1)->getStringValue();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventData_getStringValue) 

static bool js_spine_EventData_setStringValue(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventData *arg1 = (spine::EventData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setStringValue((spine::String const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventData_setStringValue) 

static bool js_spine_EventData_getAudioPath(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventData *arg1 = (spine::EventData *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventData>(s);
    if (nullptr == arg1) return true;
    result = (spine::String *) &(arg1)->getAudioPath();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventData_getAudioPath) 

static bool js_spine_EventData_setAudioPath(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventData *arg1 = (spine::EventData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setAudioPath((spine::String const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventData_setAudioPath) 

static bool js_spine_EventData_getVolume(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventData *arg1 = (spine::EventData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getVolume();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventData_getVolume) 

static bool js_spine_EventData_setVolume(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventData *arg1 = (spine::EventData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setVolume(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventData_setVolume) 

static bool js_spine_EventData_getBalance(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventData *arg1 = (spine::EventData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getBalance();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventData_getBalance) 

static bool js_spine_EventData_setBalance(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventData *arg1 = (spine::EventData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setBalance(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventData_setBalance) 

static bool js_delete_spine_EventData(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_EventData) 

bool js_register_spine_EventData(se::Object* obj) {
    auto* cls = se::Class::create("EventData", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getName", _SE(js_spine_EventData_getName)); 
    cls->defineFunction("getIntValue", _SE(js_spine_EventData_getIntValue)); 
    cls->defineFunction("setIntValue", _SE(js_spine_EventData_setIntValue)); 
    cls->defineFunction("getFloatValue", _SE(js_spine_EventData_getFloatValue)); 
    cls->defineFunction("setFloatValue", _SE(js_spine_EventData_setFloatValue)); 
    cls->defineFunction("getStringValue", _SE(js_spine_EventData_getStringValue)); 
    cls->defineFunction("setStringValue", _SE(js_spine_EventData_setStringValue)); 
    cls->defineFunction("getAudioPath", _SE(js_spine_EventData_getAudioPath)); 
    cls->defineFunction("setAudioPath", _SE(js_spine_EventData_setAudioPath)); 
    cls->defineFunction("getVolume", _SE(js_spine_EventData_getVolume)); 
    cls->defineFunction("setVolume", _SE(js_spine_EventData_setVolume)); 
    cls->defineFunction("getBalance", _SE(js_spine_EventData_getBalance)); 
    cls->defineFunction("setBalance", _SE(js_spine_EventData_setBalance)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_EventData));
    
    
    cls->install();
    JSBClassType::registerClass<spine::EventData>(cls);
    
    __jsb_spine_EventData_proto = cls->getProto();
    __jsb_spine_EventData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_EventTimeline_class = nullptr;
se::Object* __jsb_spine_EventTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_EventTimeline) 

static bool js_delete_spine_EventTimeline(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_EventTimeline) 

static bool js_spine_EventTimeline_setFrame(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventTimeline *arg1 = (spine::EventTimeline *) NULL ;
    size_t arg2 ;
    spine::Event *arg3 = (spine::Event *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventTimeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setFrame(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventTimeline_setFrame) 

static bool js_spine_EventTimeline_getFrames(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventTimeline *arg1 = (spine::EventTimeline *) NULL ;
    spine::Vector< float > result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventTimeline>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getFrames();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventTimeline_getFrames) 

static bool js_spine_EventTimeline_getEvents(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventTimeline *arg1 = (spine::EventTimeline *) NULL ;
    spine::Vector< spine::Event * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventTimeline>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::Event * > *) &(arg1)->getEvents();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventTimeline_getEvents) 

static bool js_spine_EventTimeline_getFrameCount(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventTimeline *arg1 = (spine::EventTimeline *) NULL ;
    size_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventTimeline>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getFrameCount();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventTimeline_getFrameCount) 

bool js_register_spine_EventTimeline(se::Object* obj) {
    auto* cls = se::Class::create("EventTimeline", obj, __jsb_spine_Timeline_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("setFrame", _SE(js_spine_EventTimeline_setFrame)); 
    cls->defineFunction("getFrames", _SE(js_spine_EventTimeline_getFrames)); 
    cls->defineFunction("getEvents", _SE(js_spine_EventTimeline_getEvents)); 
    cls->defineFunction("getFrameCount", _SE(js_spine_EventTimeline_getFrameCount)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_EventTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::EventTimeline>(cls);
    
    __jsb_spine_EventTimeline_proto = cls->getProto();
    __jsb_spine_EventTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_IkConstraint_class = nullptr;
se::Object* __jsb_spine_IkConstraint_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_IkConstraint) 

static bool js_spine_IkConstraint_update(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    if (nullptr == arg1) return true;
    (arg1)->update();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_update) 

static bool js_spine_IkConstraint_getOrder(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    if (nullptr == arg1) return true;
    result = (int)(arg1)->getOrder();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_getOrder) 

static bool js_spine_IkConstraint_getData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    spine::IkConstraintData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    if (nullptr == arg1) return true;
    result = (spine::IkConstraintData *) &(arg1)->getData();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_getData) 

static bool js_spine_IkConstraint_getBones(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    spine::Vector< spine::Bone * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::Bone * > *) &(arg1)->getBones();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_getBones) 

static bool js_spine_IkConstraint_getTarget(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    spine::Bone *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    if (nullptr == arg1) return true;
    result = (spine::Bone *)(arg1)->getTarget();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_getTarget) 

static bool js_spine_IkConstraint_setTarget(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    spine::Bone *arg2 = (spine::Bone *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setTarget(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_setTarget) 

static bool js_spine_IkConstraint_getBendDirection(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    if (nullptr == arg1) return true;
    result = (int)(arg1)->getBendDirection();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_getBendDirection) 

static bool js_spine_IkConstraint_setBendDirection(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setBendDirection(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_setBendDirection) 

static bool js_spine_IkConstraint_getCompress(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->getCompress();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_getCompress) 

static bool js_spine_IkConstraint_setCompress(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setCompress(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_setCompress) 

static bool js_spine_IkConstraint_getStretch(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->getStretch();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_getStretch) 

static bool js_spine_IkConstraint_setStretch(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setStretch(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_setStretch) 

static bool js_spine_IkConstraint_getMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getMix();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_getMix) 

static bool js_spine_IkConstraint_setMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setMix(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_setMix) 

static bool js_spine_IkConstraint_getSoftness(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getSoftness();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_getSoftness) 

static bool js_spine_IkConstraint_setSoftness(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setSoftness(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_setSoftness) 

static bool js_spine_IkConstraint_isActive(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->isActive();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_isActive) 

static bool js_spine_IkConstraint_setActive(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setActive(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_setActive) 

static bool js_delete_spine_IkConstraint(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_IkConstraint) 

bool js_register_spine_IkConstraint(se::Object* obj) {
    auto* cls = se::Class::create("IkConstraint", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("update", _SE(js_spine_IkConstraint_update)); 
    cls->defineFunction("getOrder", _SE(js_spine_IkConstraint_getOrder)); 
    cls->defineFunction("getData", _SE(js_spine_IkConstraint_getData)); 
    cls->defineFunction("getBones", _SE(js_spine_IkConstraint_getBones)); 
    cls->defineFunction("getTarget", _SE(js_spine_IkConstraint_getTarget)); 
    cls->defineFunction("setTarget", _SE(js_spine_IkConstraint_setTarget)); 
    cls->defineFunction("getBendDirection", _SE(js_spine_IkConstraint_getBendDirection)); 
    cls->defineFunction("setBendDirection", _SE(js_spine_IkConstraint_setBendDirection)); 
    cls->defineFunction("getCompress", _SE(js_spine_IkConstraint_getCompress)); 
    cls->defineFunction("setCompress", _SE(js_spine_IkConstraint_setCompress)); 
    cls->defineFunction("getStretch", _SE(js_spine_IkConstraint_getStretch)); 
    cls->defineFunction("setStretch", _SE(js_spine_IkConstraint_setStretch)); 
    cls->defineFunction("getMix", _SE(js_spine_IkConstraint_getMix)); 
    cls->defineFunction("setMix", _SE(js_spine_IkConstraint_setMix)); 
    cls->defineFunction("getSoftness", _SE(js_spine_IkConstraint_getSoftness)); 
    cls->defineFunction("setSoftness", _SE(js_spine_IkConstraint_setSoftness)); 
    cls->defineFunction("isActive", _SE(js_spine_IkConstraint_isActive)); 
    cls->defineFunction("setActive", _SE(js_spine_IkConstraint_setActive)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_IkConstraint));
    
    
    cls->install();
    JSBClassType::registerClass<spine::IkConstraint>(cls);
    
    __jsb_spine_IkConstraint_proto = cls->getProto();
    __jsb_spine_IkConstraint_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_IkConstraintData_class = nullptr;
se::Object* __jsb_spine_IkConstraintData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_IkConstraintData) 

static bool js_spine_IkConstraintData_getBones(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    spine::Vector< spine::BoneData * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::BoneData * > *) &(arg1)->getBones();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_getBones) 

static bool js_spine_IkConstraintData_getTarget(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    spine::BoneData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (spine::BoneData *)(arg1)->getTarget();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_getTarget) 

static bool js_spine_IkConstraintData_setTarget(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    spine::BoneData *arg2 = (spine::BoneData *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setTarget(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_setTarget) 

static bool js_spine_IkConstraintData_getBendDirection(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (int)(arg1)->getBendDirection();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_getBendDirection) 

static bool js_spine_IkConstraintData_setBendDirection(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setBendDirection(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_setBendDirection) 

static bool js_spine_IkConstraintData_getCompress(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->getCompress();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_getCompress) 

static bool js_spine_IkConstraintData_setCompress(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setCompress(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_setCompress) 

static bool js_spine_IkConstraintData_getStretch(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->getStretch();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_getStretch) 

static bool js_spine_IkConstraintData_setStretch(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setStretch(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_setStretch) 

static bool js_spine_IkConstraintData_getUniform(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->getUniform();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_getUniform) 

static bool js_spine_IkConstraintData_setUniform(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setUniform(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_setUniform) 

static bool js_spine_IkConstraintData_getMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getMix();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_getMix) 

static bool js_spine_IkConstraintData_setMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setMix(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_setMix) 

static bool js_spine_IkConstraintData_getSoftness(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getSoftness();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_getSoftness) 

static bool js_spine_IkConstraintData_setSoftness(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setSoftness(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_setSoftness) 

static bool js_delete_spine_IkConstraintData(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_IkConstraintData) 

bool js_register_spine_IkConstraintData(se::Object* obj) {
    auto* cls = se::Class::create("IkConstraintData", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getBones", _SE(js_spine_IkConstraintData_getBones)); 
    cls->defineFunction("getTarget", _SE(js_spine_IkConstraintData_getTarget)); 
    cls->defineFunction("setTarget", _SE(js_spine_IkConstraintData_setTarget)); 
    cls->defineFunction("getBendDirection", _SE(js_spine_IkConstraintData_getBendDirection)); 
    cls->defineFunction("setBendDirection", _SE(js_spine_IkConstraintData_setBendDirection)); 
    cls->defineFunction("getCompress", _SE(js_spine_IkConstraintData_getCompress)); 
    cls->defineFunction("setCompress", _SE(js_spine_IkConstraintData_setCompress)); 
    cls->defineFunction("getStretch", _SE(js_spine_IkConstraintData_getStretch)); 
    cls->defineFunction("setStretch", _SE(js_spine_IkConstraintData_setStretch)); 
    cls->defineFunction("getUniform", _SE(js_spine_IkConstraintData_getUniform)); 
    cls->defineFunction("setUniform", _SE(js_spine_IkConstraintData_setUniform)); 
    cls->defineFunction("getMix", _SE(js_spine_IkConstraintData_getMix)); 
    cls->defineFunction("setMix", _SE(js_spine_IkConstraintData_setMix)); 
    cls->defineFunction("getSoftness", _SE(js_spine_IkConstraintData_getSoftness)); 
    cls->defineFunction("setSoftness", _SE(js_spine_IkConstraintData_setSoftness)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_IkConstraintData));
    
    
    cls->install();
    JSBClassType::registerClass<spine::IkConstraintData>(cls);
    
    __jsb_spine_IkConstraintData_proto = cls->getProto();
    __jsb_spine_IkConstraintData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_IkConstraintTimeline_class = nullptr;
se::Object* __jsb_spine_IkConstraintTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_IkConstraintTimeline) 

static bool js_spine_IkConstraintTimeline_ENTRIES_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    int result;
    
    result = (int)(int)spine::IkConstraintTimeline::ENTRIES;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_IkConstraintTimeline_ENTRIES_get) 

static bool js_spine_IkConstraintTimeline_setFrame(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintTimeline *arg1 = (spine::IkConstraintTimeline *) NULL ;
    int arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    int arg6 ;
    bool arg7 ;
    bool arg8 ;
    
    if(argc != 7) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 7);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintTimeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setFrame(arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintTimeline_setFrame) 

static bool js_delete_spine_IkConstraintTimeline(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_IkConstraintTimeline) 

bool js_register_spine_IkConstraintTimeline(se::Object* obj) {
    auto* cls = se::Class::create("IkConstraintTimeline", obj, __jsb_spine_CurveTimeline_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("setFrame", _SE(js_spine_IkConstraintTimeline_setFrame)); 
    
    cls->defineStaticProperty("ENTRIES", _SE(js_spine_IkConstraintTimeline_ENTRIES_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_IkConstraintTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::IkConstraintTimeline>(cls);
    
    __jsb_spine_IkConstraintTimeline_proto = cls->getProto();
    __jsb_spine_IkConstraintTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_MeshAttachment_class = nullptr;
se::Object* __jsb_spine_MeshAttachment_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_MeshAttachment) 

static bool js_delete_spine_MeshAttachment(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_MeshAttachment) 

static bool js_spine_MeshAttachment_updateUVs(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    (arg1)->updateUVs();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_updateUVs) 

static bool js_spine_MeshAttachment_getHullLength(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    result = (int)(arg1)->getHullLength();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getHullLength) 

static bool js_spine_MeshAttachment_setHullLength(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setHullLength(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setHullLength) 

static bool js_spine_MeshAttachment_getRegionUVs(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    spine::Vector< float > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< float > *) &(arg1)->getRegionUVs();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getRegionUVs) 

static bool js_spine_MeshAttachment_getUVs(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    spine::Vector< float > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< float > *) &(arg1)->getUVs();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getUVs) 

static bool js_spine_MeshAttachment_getTriangles(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    spine::Vector< unsigned short > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< unsigned short > *) &(arg1)->getTriangles();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getTriangles) 

static bool js_spine_MeshAttachment_getColor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    spine::Color *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    result = (spine::Color *) &(arg1)->getColor();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getColor) 

static bool js_spine_MeshAttachment_getPath(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    result = (spine::String *) &(arg1)->getPath();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getPath) 

static bool js_spine_MeshAttachment_setPath(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setPath((spine::String const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setPath) 

static bool js_spine_MeshAttachment_getRegionU(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getRegionU();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getRegionU) 

static bool js_spine_MeshAttachment_setRegionU(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRegionU(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setRegionU) 

static bool js_spine_MeshAttachment_getRegionV(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getRegionV();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getRegionV) 

static bool js_spine_MeshAttachment_setRegionV(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRegionV(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setRegionV) 

static bool js_spine_MeshAttachment_getRegionU2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getRegionU2();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getRegionU2) 

static bool js_spine_MeshAttachment_setRegionU2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRegionU2(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setRegionU2) 

static bool js_spine_MeshAttachment_getRegionV2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getRegionV2();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getRegionV2) 

static bool js_spine_MeshAttachment_setRegionV2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRegionV2(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setRegionV2) 

static bool js_spine_MeshAttachment_getRegionRotate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->getRegionRotate();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getRegionRotate) 

static bool js_spine_MeshAttachment_setRegionRotate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRegionRotate(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setRegionRotate) 

static bool js_spine_MeshAttachment_getRegionDegrees(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    result = (int)(arg1)->getRegionDegrees();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getRegionDegrees) 

static bool js_spine_MeshAttachment_setRegionDegrees(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRegionDegrees(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setRegionDegrees) 

static bool js_spine_MeshAttachment_getRegionOffsetX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getRegionOffsetX();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getRegionOffsetX) 

static bool js_spine_MeshAttachment_setRegionOffsetX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRegionOffsetX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setRegionOffsetX) 

static bool js_spine_MeshAttachment_getRegionOffsetY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getRegionOffsetY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getRegionOffsetY) 

static bool js_spine_MeshAttachment_setRegionOffsetY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRegionOffsetY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setRegionOffsetY) 

static bool js_spine_MeshAttachment_getRegionWidth(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getRegionWidth();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getRegionWidth) 

static bool js_spine_MeshAttachment_setRegionWidth(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRegionWidth(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setRegionWidth) 

static bool js_spine_MeshAttachment_getRegionHeight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getRegionHeight();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getRegionHeight) 

static bool js_spine_MeshAttachment_setRegionHeight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRegionHeight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setRegionHeight) 

static bool js_spine_MeshAttachment_getRegionOriginalWidth(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getRegionOriginalWidth();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getRegionOriginalWidth) 

static bool js_spine_MeshAttachment_setRegionOriginalWidth(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRegionOriginalWidth(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setRegionOriginalWidth) 

static bool js_spine_MeshAttachment_getRegionOriginalHeight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getRegionOriginalHeight();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getRegionOriginalHeight) 

static bool js_spine_MeshAttachment_setRegionOriginalHeight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRegionOriginalHeight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setRegionOriginalHeight) 

static bool js_spine_MeshAttachment_getParentMesh(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    spine::MeshAttachment *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    result = (spine::MeshAttachment *)(arg1)->getParentMesh();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getParentMesh) 

static bool js_spine_MeshAttachment_setParentMesh(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    spine::MeshAttachment *arg2 = (spine::MeshAttachment *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setParentMesh(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setParentMesh) 

static bool js_spine_MeshAttachment_getEdges(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    spine::Vector< unsigned short > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< unsigned short > *) &(arg1)->getEdges();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getEdges) 

static bool js_spine_MeshAttachment_getWidth(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getWidth();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getWidth) 

static bool js_spine_MeshAttachment_setWidth(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setWidth(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setWidth) 

static bool js_spine_MeshAttachment_getHeight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getHeight();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getHeight) 

static bool js_spine_MeshAttachment_setHeight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setHeight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setHeight) 

static bool js_spine_MeshAttachment_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    spine::Attachment *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    result = (spine::Attachment *)(arg1)->copy();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_copy) 

static bool js_spine_MeshAttachment_newLinkedMesh(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    spine::MeshAttachment *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    if (nullptr == arg1) return true;
    result = (spine::MeshAttachment *)(arg1)->newLinkedMesh();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_newLinkedMesh) 

bool js_register_spine_MeshAttachment(se::Object* obj) {
    auto* cls = se::Class::create("MeshAttachment", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("updateUVs", _SE(js_spine_MeshAttachment_updateUVs)); 
    cls->defineFunction("getHullLength", _SE(js_spine_MeshAttachment_getHullLength)); 
    cls->defineFunction("setHullLength", _SE(js_spine_MeshAttachment_setHullLength)); 
    cls->defineFunction("getRegionUVs", _SE(js_spine_MeshAttachment_getRegionUVs)); 
    cls->defineFunction("getUVs", _SE(js_spine_MeshAttachment_getUVs)); 
    cls->defineFunction("getTriangles", _SE(js_spine_MeshAttachment_getTriangles)); 
    cls->defineFunction("getColor", _SE(js_spine_MeshAttachment_getColor)); 
    cls->defineFunction("getPath", _SE(js_spine_MeshAttachment_getPath)); 
    cls->defineFunction("setPath", _SE(js_spine_MeshAttachment_setPath)); 
    cls->defineFunction("getRegionU", _SE(js_spine_MeshAttachment_getRegionU)); 
    cls->defineFunction("setRegionU", _SE(js_spine_MeshAttachment_setRegionU)); 
    cls->defineFunction("getRegionV", _SE(js_spine_MeshAttachment_getRegionV)); 
    cls->defineFunction("setRegionV", _SE(js_spine_MeshAttachment_setRegionV)); 
    cls->defineFunction("getRegionU2", _SE(js_spine_MeshAttachment_getRegionU2)); 
    cls->defineFunction("setRegionU2", _SE(js_spine_MeshAttachment_setRegionU2)); 
    cls->defineFunction("getRegionV2", _SE(js_spine_MeshAttachment_getRegionV2)); 
    cls->defineFunction("setRegionV2", _SE(js_spine_MeshAttachment_setRegionV2)); 
    cls->defineFunction("getRegionRotate", _SE(js_spine_MeshAttachment_getRegionRotate)); 
    cls->defineFunction("setRegionRotate", _SE(js_spine_MeshAttachment_setRegionRotate)); 
    cls->defineFunction("getRegionDegrees", _SE(js_spine_MeshAttachment_getRegionDegrees)); 
    cls->defineFunction("setRegionDegrees", _SE(js_spine_MeshAttachment_setRegionDegrees)); 
    cls->defineFunction("getRegionOffsetX", _SE(js_spine_MeshAttachment_getRegionOffsetX)); 
    cls->defineFunction("setRegionOffsetX", _SE(js_spine_MeshAttachment_setRegionOffsetX)); 
    cls->defineFunction("getRegionOffsetY", _SE(js_spine_MeshAttachment_getRegionOffsetY)); 
    cls->defineFunction("setRegionOffsetY", _SE(js_spine_MeshAttachment_setRegionOffsetY)); 
    cls->defineFunction("getRegionWidth", _SE(js_spine_MeshAttachment_getRegionWidth)); 
    cls->defineFunction("setRegionWidth", _SE(js_spine_MeshAttachment_setRegionWidth)); 
    cls->defineFunction("getRegionHeight", _SE(js_spine_MeshAttachment_getRegionHeight)); 
    cls->defineFunction("setRegionHeight", _SE(js_spine_MeshAttachment_setRegionHeight)); 
    cls->defineFunction("getRegionOriginalWidth", _SE(js_spine_MeshAttachment_getRegionOriginalWidth)); 
    cls->defineFunction("setRegionOriginalWidth", _SE(js_spine_MeshAttachment_setRegionOriginalWidth)); 
    cls->defineFunction("getRegionOriginalHeight", _SE(js_spine_MeshAttachment_getRegionOriginalHeight)); 
    cls->defineFunction("setRegionOriginalHeight", _SE(js_spine_MeshAttachment_setRegionOriginalHeight)); 
    cls->defineFunction("getParentMesh", _SE(js_spine_MeshAttachment_getParentMesh)); 
    cls->defineFunction("setParentMesh", _SE(js_spine_MeshAttachment_setParentMesh)); 
    cls->defineFunction("getEdges", _SE(js_spine_MeshAttachment_getEdges)); 
    cls->defineFunction("getWidth", _SE(js_spine_MeshAttachment_getWidth)); 
    cls->defineFunction("setWidth", _SE(js_spine_MeshAttachment_setWidth)); 
    cls->defineFunction("getHeight", _SE(js_spine_MeshAttachment_getHeight)); 
    cls->defineFunction("setHeight", _SE(js_spine_MeshAttachment_setHeight)); 
    cls->defineFunction("copy", _SE(js_spine_MeshAttachment_copy)); 
    cls->defineFunction("newLinkedMesh", _SE(js_spine_MeshAttachment_newLinkedMesh)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_MeshAttachment));
    
    
    cls->install();
    JSBClassType::registerClass<spine::MeshAttachment>(cls);
    
    __jsb_spine_MeshAttachment_proto = cls->getProto();
    __jsb_spine_MeshAttachment_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_PathAttachment_class = nullptr;
se::Object* __jsb_spine_PathAttachment_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_PathAttachment) 

static bool js_spine_PathAttachment_getLengths(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathAttachment *arg1 = (spine::PathAttachment *) NULL ;
    spine::Vector< float > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathAttachment>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< float > *) &(arg1)->getLengths();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathAttachment_getLengths) 

static bool js_spine_PathAttachment_isClosed(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathAttachment *arg1 = (spine::PathAttachment *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathAttachment>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->isClosed();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathAttachment_isClosed) 

static bool js_spine_PathAttachment_setClosed(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathAttachment *arg1 = (spine::PathAttachment *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setClosed(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathAttachment_setClosed) 

static bool js_spine_PathAttachment_isConstantSpeed(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathAttachment *arg1 = (spine::PathAttachment *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathAttachment>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->isConstantSpeed();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathAttachment_isConstantSpeed) 

static bool js_spine_PathAttachment_setConstantSpeed(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathAttachment *arg1 = (spine::PathAttachment *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setConstantSpeed(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathAttachment_setConstantSpeed) 

static bool js_spine_PathAttachment_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathAttachment *arg1 = (spine::PathAttachment *) NULL ;
    spine::Attachment *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathAttachment>(s);
    if (nullptr == arg1) return true;
    result = (spine::Attachment *)(arg1)->copy();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathAttachment_copy) 

static bool js_delete_spine_PathAttachment(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_PathAttachment) 

bool js_register_spine_PathAttachment(se::Object* obj) {
    auto* cls = se::Class::create("PathAttachment", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getLengths", _SE(js_spine_PathAttachment_getLengths)); 
    cls->defineFunction("isClosed", _SE(js_spine_PathAttachment_isClosed)); 
    cls->defineFunction("setClosed", _SE(js_spine_PathAttachment_setClosed)); 
    cls->defineFunction("isConstantSpeed", _SE(js_spine_PathAttachment_isConstantSpeed)); 
    cls->defineFunction("setConstantSpeed", _SE(js_spine_PathAttachment_setConstantSpeed)); 
    cls->defineFunction("copy", _SE(js_spine_PathAttachment_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_PathAttachment));
    
    
    cls->install();
    JSBClassType::registerClass<spine::PathAttachment>(cls);
    
    __jsb_spine_PathAttachment_proto = cls->getProto();
    __jsb_spine_PathAttachment_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_PathConstraint_class = nullptr;
se::Object* __jsb_spine_PathConstraint_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_PathConstraint) 

static bool js_spine_PathConstraint_apply(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    if (nullptr == arg1) return true;
    (arg1)->apply();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_apply) 

static bool js_spine_PathConstraint_update(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    if (nullptr == arg1) return true;
    (arg1)->update();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_update) 

static bool js_spine_PathConstraint_getOrder(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    if (nullptr == arg1) return true;
    result = (int)(arg1)->getOrder();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_getOrder) 

static bool js_spine_PathConstraint_getPosition(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getPosition();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_getPosition) 

static bool js_spine_PathConstraint_setPosition(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPosition(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_setPosition) 

static bool js_spine_PathConstraint_getSpacing(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getSpacing();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_getSpacing) 

static bool js_spine_PathConstraint_setSpacing(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setSpacing(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_setSpacing) 

static bool js_spine_PathConstraint_getRotateMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getRotateMix();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_getRotateMix) 

static bool js_spine_PathConstraint_setRotateMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRotateMix(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_setRotateMix) 

static bool js_spine_PathConstraint_getTranslateMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getTranslateMix();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_getTranslateMix) 

static bool js_spine_PathConstraint_setTranslateMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setTranslateMix(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_setTranslateMix) 

static bool js_spine_PathConstraint_getBones(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    spine::Vector< spine::Bone * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::Bone * > *) &(arg1)->getBones();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_getBones) 

static bool js_spine_PathConstraint_getTarget(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    spine::Slot *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    if (nullptr == arg1) return true;
    result = (spine::Slot *)(arg1)->getTarget();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_getTarget) 

static bool js_spine_PathConstraint_setTarget(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    spine::Slot *arg2 = (spine::Slot *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setTarget(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_setTarget) 

static bool js_spine_PathConstraint_getData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    spine::PathConstraintData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    if (nullptr == arg1) return true;
    result = (spine::PathConstraintData *) &(arg1)->getData();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_getData) 

static bool js_spine_PathConstraint_isActive(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->isActive();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_isActive) 

static bool js_spine_PathConstraint_setActive(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setActive(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_setActive) 

static bool js_delete_spine_PathConstraint(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_PathConstraint) 

bool js_register_spine_PathConstraint(se::Object* obj) {
    auto* cls = se::Class::create("PathConstraint", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("apply", _SE(js_spine_PathConstraint_apply)); 
    cls->defineFunction("update", _SE(js_spine_PathConstraint_update)); 
    cls->defineFunction("getOrder", _SE(js_spine_PathConstraint_getOrder)); 
    cls->defineFunction("getPosition", _SE(js_spine_PathConstraint_getPosition)); 
    cls->defineFunction("setPosition", _SE(js_spine_PathConstraint_setPosition)); 
    cls->defineFunction("getSpacing", _SE(js_spine_PathConstraint_getSpacing)); 
    cls->defineFunction("setSpacing", _SE(js_spine_PathConstraint_setSpacing)); 
    cls->defineFunction("getRotateMix", _SE(js_spine_PathConstraint_getRotateMix)); 
    cls->defineFunction("setRotateMix", _SE(js_spine_PathConstraint_setRotateMix)); 
    cls->defineFunction("getTranslateMix", _SE(js_spine_PathConstraint_getTranslateMix)); 
    cls->defineFunction("setTranslateMix", _SE(js_spine_PathConstraint_setTranslateMix)); 
    cls->defineFunction("getBones", _SE(js_spine_PathConstraint_getBones)); 
    cls->defineFunction("getTarget", _SE(js_spine_PathConstraint_getTarget)); 
    cls->defineFunction("setTarget", _SE(js_spine_PathConstraint_setTarget)); 
    cls->defineFunction("getData", _SE(js_spine_PathConstraint_getData)); 
    cls->defineFunction("isActive", _SE(js_spine_PathConstraint_isActive)); 
    cls->defineFunction("setActive", _SE(js_spine_PathConstraint_setActive)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_PathConstraint));
    
    
    cls->install();
    JSBClassType::registerClass<spine::PathConstraint>(cls);
    
    __jsb_spine_PathConstraint_proto = cls->getProto();
    __jsb_spine_PathConstraint_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_PathConstraintData_class = nullptr;
se::Object* __jsb_spine_PathConstraintData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_PathConstraintData) 

static bool js_spine_PathConstraintData_getBones(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    spine::Vector< spine::BoneData * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::BoneData * > *) &(arg1)->getBones();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_getBones) 

static bool js_spine_PathConstraintData_getTarget(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    spine::SlotData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (spine::SlotData *)(arg1)->getTarget();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_getTarget) 

static bool js_spine_PathConstraintData_setTarget(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    spine::SlotData *arg2 = (spine::SlotData *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setTarget(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_setTarget) 

static bool js_spine_PathConstraintData_getPositionMode(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    spine::PositionMode result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (spine::PositionMode)(arg1)->getPositionMode();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_getPositionMode) 

static bool js_spine_PathConstraintData_setPositionMode(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    spine::PositionMode arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->setPositionMode(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_setPositionMode) 

static bool js_spine_PathConstraintData_getSpacingMode(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    spine::SpacingMode result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (spine::SpacingMode)(arg1)->getSpacingMode();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_getSpacingMode) 

static bool js_spine_PathConstraintData_setSpacingMode(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    spine::SpacingMode arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->setSpacingMode(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_setSpacingMode) 

static bool js_spine_PathConstraintData_getRotateMode(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    spine::RotateMode result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (spine::RotateMode)(arg1)->getRotateMode();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_getRotateMode) 

static bool js_spine_PathConstraintData_setRotateMode(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    spine::RotateMode arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->setRotateMode(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_setRotateMode) 

static bool js_spine_PathConstraintData_getOffsetRotation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getOffsetRotation();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_getOffsetRotation) 

static bool js_spine_PathConstraintData_setOffsetRotation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setOffsetRotation(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_setOffsetRotation) 

static bool js_spine_PathConstraintData_getPosition(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getPosition();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_getPosition) 

static bool js_spine_PathConstraintData_setPosition(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPosition(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_setPosition) 

static bool js_spine_PathConstraintData_getSpacing(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getSpacing();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_getSpacing) 

static bool js_spine_PathConstraintData_setSpacing(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setSpacing(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_setSpacing) 

static bool js_spine_PathConstraintData_getRotateMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getRotateMix();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_getRotateMix) 

static bool js_spine_PathConstraintData_setRotateMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRotateMix(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_setRotateMix) 

static bool js_spine_PathConstraintData_getTranslateMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getTranslateMix();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_getTranslateMix) 

static bool js_spine_PathConstraintData_setTranslateMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setTranslateMix(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_setTranslateMix) 

static bool js_delete_spine_PathConstraintData(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_PathConstraintData) 

bool js_register_spine_PathConstraintData(se::Object* obj) {
    auto* cls = se::Class::create("PathConstraintData", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getBones", _SE(js_spine_PathConstraintData_getBones)); 
    cls->defineFunction("getTarget", _SE(js_spine_PathConstraintData_getTarget)); 
    cls->defineFunction("setTarget", _SE(js_spine_PathConstraintData_setTarget)); 
    cls->defineFunction("getPositionMode", _SE(js_spine_PathConstraintData_getPositionMode)); 
    cls->defineFunction("setPositionMode", _SE(js_spine_PathConstraintData_setPositionMode)); 
    cls->defineFunction("getSpacingMode", _SE(js_spine_PathConstraintData_getSpacingMode)); 
    cls->defineFunction("setSpacingMode", _SE(js_spine_PathConstraintData_setSpacingMode)); 
    cls->defineFunction("getRotateMode", _SE(js_spine_PathConstraintData_getRotateMode)); 
    cls->defineFunction("setRotateMode", _SE(js_spine_PathConstraintData_setRotateMode)); 
    cls->defineFunction("getOffsetRotation", _SE(js_spine_PathConstraintData_getOffsetRotation)); 
    cls->defineFunction("setOffsetRotation", _SE(js_spine_PathConstraintData_setOffsetRotation)); 
    cls->defineFunction("getPosition", _SE(js_spine_PathConstraintData_getPosition)); 
    cls->defineFunction("setPosition", _SE(js_spine_PathConstraintData_setPosition)); 
    cls->defineFunction("getSpacing", _SE(js_spine_PathConstraintData_getSpacing)); 
    cls->defineFunction("setSpacing", _SE(js_spine_PathConstraintData_setSpacing)); 
    cls->defineFunction("getRotateMix", _SE(js_spine_PathConstraintData_getRotateMix)); 
    cls->defineFunction("setRotateMix", _SE(js_spine_PathConstraintData_setRotateMix)); 
    cls->defineFunction("getTranslateMix", _SE(js_spine_PathConstraintData_getTranslateMix)); 
    cls->defineFunction("setTranslateMix", _SE(js_spine_PathConstraintData_setTranslateMix)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_PathConstraintData));
    
    
    cls->install();
    JSBClassType::registerClass<spine::PathConstraintData>(cls);
    
    __jsb_spine_PathConstraintData_proto = cls->getProto();
    __jsb_spine_PathConstraintData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_PathConstraintMixTimeline_class = nullptr;
se::Object* __jsb_spine_PathConstraintMixTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_PathConstraintMixTimeline) 

static bool js_spine_PathConstraintMixTimeline_ENTRIES_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    int result;
    
    result = (int)(int)spine::PathConstraintMixTimeline::ENTRIES;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_PathConstraintMixTimeline_ENTRIES_get) 

static bool js_delete_spine_PathConstraintMixTimeline(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_PathConstraintMixTimeline) 

bool js_register_spine_PathConstraintMixTimeline(se::Object* obj) {
    auto* cls = se::Class::create("PathConstraintMixTimeline", obj, __jsb_spine_CurveTimeline_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("ENTRIES", _SE(js_spine_PathConstraintMixTimeline_ENTRIES_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_PathConstraintMixTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::PathConstraintMixTimeline>(cls);
    
    __jsb_spine_PathConstraintMixTimeline_proto = cls->getProto();
    __jsb_spine_PathConstraintMixTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_PathConstraintPositionTimeline_class = nullptr;
se::Object* __jsb_spine_PathConstraintPositionTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_PathConstraintPositionTimeline) 

static bool js_spine_PathConstraintPositionTimeline_ENTRIES_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    int result;
    
    result = (int)(int)spine::PathConstraintPositionTimeline::ENTRIES;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_PathConstraintPositionTimeline_ENTRIES_get) 

static bool js_delete_spine_PathConstraintPositionTimeline(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_PathConstraintPositionTimeline) 

static bool js_spine_PathConstraintPositionTimeline_setFrame(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintPositionTimeline *arg1 = (spine::PathConstraintPositionTimeline *) NULL ;
    int arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintPositionTimeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setFrame(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintPositionTimeline_setFrame) 

bool js_register_spine_PathConstraintPositionTimeline(se::Object* obj) {
    auto* cls = se::Class::create("PathConstraintPositionTimeline", obj, __jsb_spine_CurveTimeline_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("setFrame", _SE(js_spine_PathConstraintPositionTimeline_setFrame)); 
    
    cls->defineStaticProperty("ENTRIES", _SE(js_spine_PathConstraintPositionTimeline_ENTRIES_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_PathConstraintPositionTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::PathConstraintPositionTimeline>(cls);
    
    __jsb_spine_PathConstraintPositionTimeline_proto = cls->getProto();
    __jsb_spine_PathConstraintPositionTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_PathConstraintSpacingTimeline_class = nullptr;
se::Object* __jsb_spine_PathConstraintSpacingTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_PathConstraintSpacingTimeline) 

static bool js_delete_spine_PathConstraintSpacingTimeline(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_PathConstraintSpacingTimeline) 

bool js_register_spine_PathConstraintSpacingTimeline(se::Object* obj) {
    auto* cls = se::Class::create("PathConstraintSpacingTimeline", obj, __jsb_spine_PathConstraintPositionTimeline_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_PathConstraintSpacingTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::PathConstraintSpacingTimeline>(cls);
    
    __jsb_spine_PathConstraintSpacingTimeline_proto = cls->getProto();
    __jsb_spine_PathConstraintSpacingTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_PointAttachment_class = nullptr;
se::Object* __jsb_spine_PointAttachment_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_PointAttachment) 

static bool js_spine_PointAttachment_getX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PointAttachment *arg1 = (spine::PointAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PointAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getX();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PointAttachment_getX) 

static bool js_spine_PointAttachment_setX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PointAttachment *arg1 = (spine::PointAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PointAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PointAttachment_setX) 

static bool js_spine_PointAttachment_getY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PointAttachment *arg1 = (spine::PointAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PointAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PointAttachment_getY) 

static bool js_spine_PointAttachment_setY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PointAttachment *arg1 = (spine::PointAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PointAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PointAttachment_setY) 

static bool js_spine_PointAttachment_getRotation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PointAttachment *arg1 = (spine::PointAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PointAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getRotation();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PointAttachment_getRotation) 

static bool js_spine_PointAttachment_setRotation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PointAttachment *arg1 = (spine::PointAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PointAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRotation(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PointAttachment_setRotation) 

static bool js_delete_spine_PointAttachment(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_PointAttachment) 

bool js_register_spine_PointAttachment(se::Object* obj) {
    auto* cls = se::Class::create("PointAttachment", obj, __jsb_spine_Attachment_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getX", _SE(js_spine_PointAttachment_getX)); 
    cls->defineFunction("setX", _SE(js_spine_PointAttachment_setX)); 
    cls->defineFunction("getY", _SE(js_spine_PointAttachment_getY)); 
    cls->defineFunction("setY", _SE(js_spine_PointAttachment_setY)); 
    cls->defineFunction("getRotation", _SE(js_spine_PointAttachment_getRotation)); 
    cls->defineFunction("setRotation", _SE(js_spine_PointAttachment_setRotation)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_PointAttachment));
    
    
    cls->install();
    JSBClassType::registerClass<spine::PointAttachment>(cls);
    
    __jsb_spine_PointAttachment_proto = cls->getProto();
    __jsb_spine_PointAttachment_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_RegionAttachment_class = nullptr;
se::Object* __jsb_spine_RegionAttachment_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_RegionAttachment) 

static bool js_spine_RegionAttachment_updateOffset(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    (arg1)->updateOffset();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_updateOffset) 

static bool js_spine_RegionAttachment_setUVs(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    bool arg6 ;
    
    if(argc != 5) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setUVs(arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setUVs) 

static bool js_spine_RegionAttachment_getX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getX();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getX) 

static bool js_spine_RegionAttachment_setX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setX) 

static bool js_spine_RegionAttachment_getY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getY) 

static bool js_spine_RegionAttachment_setY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setY) 

static bool js_spine_RegionAttachment_getRotation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getRotation();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getRotation) 

static bool js_spine_RegionAttachment_setRotation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRotation(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setRotation) 

static bool js_spine_RegionAttachment_getScaleX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getScaleX();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getScaleX) 

static bool js_spine_RegionAttachment_setScaleX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setScaleX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setScaleX) 

static bool js_spine_RegionAttachment_getScaleY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getScaleY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getScaleY) 

static bool js_spine_RegionAttachment_setScaleY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setScaleY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setScaleY) 

static bool js_spine_RegionAttachment_getWidth(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getWidth();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getWidth) 

static bool js_spine_RegionAttachment_setWidth(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setWidth(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setWidth) 

static bool js_spine_RegionAttachment_getHeight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getHeight();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getHeight) 

static bool js_spine_RegionAttachment_setHeight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setHeight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setHeight) 

static bool js_spine_RegionAttachment_getColor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    spine::Color *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    result = (spine::Color *) &(arg1)->getColor();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getColor) 

static bool js_spine_RegionAttachment_getPath(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    result = (spine::String *) &(arg1)->getPath();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getPath) 

static bool js_spine_RegionAttachment_setPath(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setPath((spine::String const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setPath) 

static bool js_spine_RegionAttachment_getRegionOffsetX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getRegionOffsetX();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getRegionOffsetX) 

static bool js_spine_RegionAttachment_setRegionOffsetX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRegionOffsetX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setRegionOffsetX) 

static bool js_spine_RegionAttachment_getRegionOffsetY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getRegionOffsetY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getRegionOffsetY) 

static bool js_spine_RegionAttachment_setRegionOffsetY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRegionOffsetY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setRegionOffsetY) 

static bool js_spine_RegionAttachment_getRegionWidth(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getRegionWidth();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getRegionWidth) 

static bool js_spine_RegionAttachment_setRegionWidth(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRegionWidth(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setRegionWidth) 

static bool js_spine_RegionAttachment_getRegionHeight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getRegionHeight();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getRegionHeight) 

static bool js_spine_RegionAttachment_setRegionHeight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRegionHeight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setRegionHeight) 

static bool js_spine_RegionAttachment_getRegionOriginalWidth(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getRegionOriginalWidth();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getRegionOriginalWidth) 

static bool js_spine_RegionAttachment_setRegionOriginalWidth(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRegionOriginalWidth(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setRegionOriginalWidth) 

static bool js_spine_RegionAttachment_getRegionOriginalHeight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getRegionOriginalHeight();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getRegionOriginalHeight) 

static bool js_spine_RegionAttachment_setRegionOriginalHeight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRegionOriginalHeight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setRegionOriginalHeight) 

static bool js_spine_RegionAttachment_getOffset(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    spine::Vector< float > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< float > *) &(arg1)->getOffset();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getOffset) 

static bool js_spine_RegionAttachment_getUVs(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    spine::Vector< float > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< float > *) &(arg1)->getUVs();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getUVs) 

static bool js_delete_spine_RegionAttachment(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_RegionAttachment) 

bool js_register_spine_RegionAttachment(se::Object* obj) {
    auto* cls = se::Class::create("RegionAttachment", obj, __jsb_spine_Attachment_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("updateOffset", _SE(js_spine_RegionAttachment_updateOffset)); 
    cls->defineFunction("setUVs", _SE(js_spine_RegionAttachment_setUVs)); 
    cls->defineFunction("getX", _SE(js_spine_RegionAttachment_getX)); 
    cls->defineFunction("setX", _SE(js_spine_RegionAttachment_setX)); 
    cls->defineFunction("getY", _SE(js_spine_RegionAttachment_getY)); 
    cls->defineFunction("setY", _SE(js_spine_RegionAttachment_setY)); 
    cls->defineFunction("getRotation", _SE(js_spine_RegionAttachment_getRotation)); 
    cls->defineFunction("setRotation", _SE(js_spine_RegionAttachment_setRotation)); 
    cls->defineFunction("getScaleX", _SE(js_spine_RegionAttachment_getScaleX)); 
    cls->defineFunction("setScaleX", _SE(js_spine_RegionAttachment_setScaleX)); 
    cls->defineFunction("getScaleY", _SE(js_spine_RegionAttachment_getScaleY)); 
    cls->defineFunction("setScaleY", _SE(js_spine_RegionAttachment_setScaleY)); 
    cls->defineFunction("getWidth", _SE(js_spine_RegionAttachment_getWidth)); 
    cls->defineFunction("setWidth", _SE(js_spine_RegionAttachment_setWidth)); 
    cls->defineFunction("getHeight", _SE(js_spine_RegionAttachment_getHeight)); 
    cls->defineFunction("setHeight", _SE(js_spine_RegionAttachment_setHeight)); 
    cls->defineFunction("getColor", _SE(js_spine_RegionAttachment_getColor)); 
    cls->defineFunction("getPath", _SE(js_spine_RegionAttachment_getPath)); 
    cls->defineFunction("setPath", _SE(js_spine_RegionAttachment_setPath)); 
    cls->defineFunction("getRegionOffsetX", _SE(js_spine_RegionAttachment_getRegionOffsetX)); 
    cls->defineFunction("setRegionOffsetX", _SE(js_spine_RegionAttachment_setRegionOffsetX)); 
    cls->defineFunction("getRegionOffsetY", _SE(js_spine_RegionAttachment_getRegionOffsetY)); 
    cls->defineFunction("setRegionOffsetY", _SE(js_spine_RegionAttachment_setRegionOffsetY)); 
    cls->defineFunction("getRegionWidth", _SE(js_spine_RegionAttachment_getRegionWidth)); 
    cls->defineFunction("setRegionWidth", _SE(js_spine_RegionAttachment_setRegionWidth)); 
    cls->defineFunction("getRegionHeight", _SE(js_spine_RegionAttachment_getRegionHeight)); 
    cls->defineFunction("setRegionHeight", _SE(js_spine_RegionAttachment_setRegionHeight)); 
    cls->defineFunction("getRegionOriginalWidth", _SE(js_spine_RegionAttachment_getRegionOriginalWidth)); 
    cls->defineFunction("setRegionOriginalWidth", _SE(js_spine_RegionAttachment_setRegionOriginalWidth)); 
    cls->defineFunction("getRegionOriginalHeight", _SE(js_spine_RegionAttachment_getRegionOriginalHeight)); 
    cls->defineFunction("setRegionOriginalHeight", _SE(js_spine_RegionAttachment_setRegionOriginalHeight)); 
    cls->defineFunction("getOffset", _SE(js_spine_RegionAttachment_getOffset)); 
    cls->defineFunction("getUVs", _SE(js_spine_RegionAttachment_getUVs)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_RegionAttachment));
    
    
    cls->install();
    JSBClassType::registerClass<spine::RegionAttachment>(cls);
    
    __jsb_spine_RegionAttachment_proto = cls->getProto();
    __jsb_spine_RegionAttachment_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_RotateTimeline_class = nullptr;
se::Object* __jsb_spine_RotateTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_RotateTimeline) 

static bool js_spine_RotateTimeline_setFrame(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RotateTimeline *arg1 = (spine::RotateTimeline *) NULL ;
    int arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RotateTimeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setFrame(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RotateTimeline_setFrame) 

static bool js_spine_RotateTimeline_getBoneIndex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RotateTimeline *arg1 = (spine::RotateTimeline *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RotateTimeline>(s);
    if (nullptr == arg1) return true;
    result = (int)(arg1)->getBoneIndex();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RotateTimeline_getBoneIndex) 

static bool js_spine_RotateTimeline_setBoneIndex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RotateTimeline *arg1 = (spine::RotateTimeline *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RotateTimeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setBoneIndex(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RotateTimeline_setBoneIndex) 

static bool js_spine_RotateTimeline_getFrames(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RotateTimeline *arg1 = (spine::RotateTimeline *) NULL ;
    spine::Vector< float > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RotateTimeline>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< float > *) &(arg1)->getFrames();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RotateTimeline_getFrames) 

static bool js_delete_spine_RotateTimeline(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_RotateTimeline) 

bool js_register_spine_RotateTimeline(se::Object* obj) {
    auto* cls = se::Class::create("RotateTimeline", obj, __jsb_spine_CurveTimeline_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("setFrame", _SE(js_spine_RotateTimeline_setFrame)); 
    cls->defineFunction("getBoneIndex", _SE(js_spine_RotateTimeline_getBoneIndex)); 
    cls->defineFunction("setBoneIndex", _SE(js_spine_RotateTimeline_setBoneIndex)); 
    cls->defineFunction("getFrames", _SE(js_spine_RotateTimeline_getFrames)); 
    
    cls->defineStaticProperty("ENTRIES", nullptr, nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_RotateTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::RotateTimeline>(cls);
    
    __jsb_spine_RotateTimeline_proto = cls->getProto();
    __jsb_spine_RotateTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_ScaleTimeline_class = nullptr;
se::Object* __jsb_spine_ScaleTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_ScaleTimeline) 

static bool js_spine_ScaleTimeline_getPropertyId(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ScaleTimeline *arg1 = (spine::ScaleTimeline *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ScaleTimeline>(s);
    if (nullptr == arg1) return true;
    result = (int)(arg1)->getPropertyId();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ScaleTimeline_getPropertyId) 

static bool js_delete_spine_ScaleTimeline(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_ScaleTimeline) 

bool js_register_spine_ScaleTimeline(se::Object* obj) {
    auto* cls = se::Class::create("ScaleTimeline", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getPropertyId", _SE(js_spine_ScaleTimeline_getPropertyId)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_ScaleTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::ScaleTimeline>(cls);
    
    __jsb_spine_ScaleTimeline_proto = cls->getProto();
    __jsb_spine_ScaleTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_ShearTimeline_class = nullptr;
se::Object* __jsb_spine_ShearTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_ShearTimeline) 

static bool js_spine_ShearTimeline_getPropertyId(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ShearTimeline *arg1 = (spine::ShearTimeline *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ShearTimeline>(s);
    if (nullptr == arg1) return true;
    result = (int)(arg1)->getPropertyId();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ShearTimeline_getPropertyId) 

static bool js_delete_spine_ShearTimeline(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_ShearTimeline) 

bool js_register_spine_ShearTimeline(se::Object* obj) {
    auto* cls = se::Class::create("ShearTimeline", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getPropertyId", _SE(js_spine_ShearTimeline_getPropertyId)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_ShearTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::ShearTimeline>(cls);
    
    __jsb_spine_ShearTimeline_proto = cls->getProto();
    __jsb_spine_ShearTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_Skeleton_class = nullptr;
se::Object* __jsb_spine_Skeleton_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_Skeleton) 

static bool js_delete_spine_Skeleton(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_Skeleton) 

static bool js_spine_Skeleton_updateCache(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    (arg1)->updateCache();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_updateCache) 

static bool js_spine_Skeleton_printUpdateCache(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    (arg1)->printUpdateCache();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_printUpdateCache) 

static bool js_spine_Skeleton_updateWorldTransform(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    (arg1)->updateWorldTransform();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_updateWorldTransform) 

static bool js_spine_Skeleton_setToSetupPose(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    (arg1)->setToSetupPose();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_setToSetupPose) 

static bool js_spine_Skeleton_setBonesToSetupPose(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    (arg1)->setBonesToSetupPose();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_setBonesToSetupPose) 

static bool js_spine_Skeleton_setSlotsToSetupPose(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    (arg1)->setSlotsToSetupPose();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_setSlotsToSetupPose) 

static bool js_spine_Skeleton_findBone(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    spine::Bone *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (spine::Bone *)(arg1)->findBone((spine::String const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_findBone) 

static bool js_spine_Skeleton_findBoneIndex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    int result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (int)(arg1)->findBoneIndex((spine::String const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_findBoneIndex) 

static bool js_spine_Skeleton_findSlot(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    spine::Slot *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (spine::Slot *)(arg1)->findSlot((spine::String const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_findSlot) 

static bool js_spine_Skeleton_findSlotIndex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    int result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (int)(arg1)->findSlotIndex((spine::String const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_findSlotIndex) 

static bool js_spine_Skeleton_setSkin__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setSkin((spine::String const &)*arg2);
    
    
    return true;
}

static bool js_spine_Skeleton_setSkin__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::Skin *arg2 = (spine::Skin *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setSkin(arg2);
    
    
    return true;
}

static bool js_spine_Skeleton_setSkin(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_spine_Skeleton_setSkin__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_spine_Skeleton_setSkin__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_Skeleton_setSkin) 

static bool js_spine_Skeleton_getAttachment__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String *arg3 = 0 ;
    spine::String temp2 ;
    spine::String temp3 ;
    spine::Attachment *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    result = (spine::Attachment *)(arg1)->getAttachment((spine::String const &)*arg2,(spine::String const &)*arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_Skeleton_getAttachment__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    int arg2 ;
    spine::String *arg3 = 0 ;
    spine::String temp3 ;
    spine::Attachment *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    result = (spine::Attachment *)(arg1)->getAttachment(arg2,(spine::String const &)*arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_Skeleton_getAttachment(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_spine_Skeleton_getAttachment__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_spine_Skeleton_getAttachment__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_Skeleton_getAttachment) 

static bool js_spine_Skeleton_setAttachment(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String *arg3 = 0 ;
    spine::String temp2 ;
    spine::String temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setAttachment((spine::String const &)*arg2,(spine::String const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_setAttachment) 

static bool js_spine_Skeleton_findIkConstraint(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    spine::IkConstraint *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (spine::IkConstraint *)(arg1)->findIkConstraint((spine::String const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_findIkConstraint) 

static bool js_spine_Skeleton_findTransformConstraint(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    spine::TransformConstraint *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (spine::TransformConstraint *)(arg1)->findTransformConstraint((spine::String const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_findTransformConstraint) 

static bool js_spine_Skeleton_findPathConstraint(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    spine::PathConstraint *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (spine::PathConstraint *)(arg1)->findPathConstraint((spine::String const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_findPathConstraint) 

static bool js_spine_Skeleton_update(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->update(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_update) 

static bool js_spine_Skeleton_getRootBone(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::Bone *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    result = (spine::Bone *)(arg1)->getRootBone();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getRootBone) 

static bool js_spine_Skeleton_getData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::SkeletonData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    result = (spine::SkeletonData *)(arg1)->getData();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getData) 

static bool js_spine_Skeleton_getBones(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::Vector< spine::Bone * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::Bone * > *) &(arg1)->getBones();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getBones) 

static bool js_spine_Skeleton_getUpdateCacheList(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::Vector< spine::Updatable * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::Updatable * > *) &(arg1)->getUpdateCacheList();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getUpdateCacheList) 

static bool js_spine_Skeleton_getSlots(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::Vector< spine::Slot * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::Slot * > *) &(arg1)->getSlots();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getSlots) 

static bool js_spine_Skeleton_getDrawOrder(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::Vector< spine::Slot * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::Slot * > *) &(arg1)->getDrawOrder();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getDrawOrder) 

static bool js_spine_Skeleton_getIkConstraints(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::Vector< spine::IkConstraint * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::IkConstraint * > *) &(arg1)->getIkConstraints();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getIkConstraints) 

static bool js_spine_Skeleton_getPathConstraints(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::Vector< spine::PathConstraint * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::PathConstraint * > *) &(arg1)->getPathConstraints();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getPathConstraints) 

static bool js_spine_Skeleton_getTransformConstraints(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::Vector< spine::TransformConstraint * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::TransformConstraint * > *) &(arg1)->getTransformConstraints();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getTransformConstraints) 

static bool js_spine_Skeleton_getSkin(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::Skin *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    result = (spine::Skin *)(arg1)->getSkin();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getSkin) 

static bool js_spine_Skeleton_getColor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::Color *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    result = (spine::Color *) &(arg1)->getColor();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getColor) 

static bool js_spine_Skeleton_getTime(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getTime();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getTime) 

static bool js_spine_Skeleton_setTime(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setTime(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_setTime) 

static bool js_spine_Skeleton_setPosition(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    float arg2 ;
    float arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPosition(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_setPosition) 

static bool js_spine_Skeleton_getX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getX();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getX) 

static bool js_spine_Skeleton_setX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_setX) 

static bool js_spine_Skeleton_getY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getY) 

static bool js_spine_Skeleton_setY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_setY) 

static bool js_spine_Skeleton_getScaleX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getScaleX();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getScaleX) 

static bool js_spine_Skeleton_setScaleX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setScaleX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_setScaleX) 

static bool js_spine_Skeleton_getScaleY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getScaleY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getScaleY) 

static bool js_spine_Skeleton_setScaleY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setScaleY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_setScaleY) 

bool js_register_spine_Skeleton(se::Object* obj) {
    auto* cls = se::Class::create("Skeleton", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("updateCache", _SE(js_spine_Skeleton_updateCache)); 
    cls->defineFunction("printUpdateCache", _SE(js_spine_Skeleton_printUpdateCache)); 
    cls->defineFunction("updateWorldTransform", _SE(js_spine_Skeleton_updateWorldTransform)); 
    cls->defineFunction("setToSetupPose", _SE(js_spine_Skeleton_setToSetupPose)); 
    cls->defineFunction("setBonesToSetupPose", _SE(js_spine_Skeleton_setBonesToSetupPose)); 
    cls->defineFunction("setSlotsToSetupPose", _SE(js_spine_Skeleton_setSlotsToSetupPose)); 
    cls->defineFunction("findBone", _SE(js_spine_Skeleton_findBone)); 
    cls->defineFunction("findBoneIndex", _SE(js_spine_Skeleton_findBoneIndex)); 
    cls->defineFunction("findSlot", _SE(js_spine_Skeleton_findSlot)); 
    cls->defineFunction("findSlotIndex", _SE(js_spine_Skeleton_findSlotIndex)); 
    cls->defineFunction("setSkin", _SE(js_spine_Skeleton_setSkin)); 
    cls->defineFunction("getAttachment", _SE(js_spine_Skeleton_getAttachment)); 
    cls->defineFunction("setAttachment", _SE(js_spine_Skeleton_setAttachment)); 
    cls->defineFunction("findIkConstraint", _SE(js_spine_Skeleton_findIkConstraint)); 
    cls->defineFunction("findTransformConstraint", _SE(js_spine_Skeleton_findTransformConstraint)); 
    cls->defineFunction("findPathConstraint", _SE(js_spine_Skeleton_findPathConstraint)); 
    cls->defineFunction("update", _SE(js_spine_Skeleton_update)); 
    cls->defineFunction("getRootBone", _SE(js_spine_Skeleton_getRootBone)); 
    cls->defineFunction("getData", _SE(js_spine_Skeleton_getData)); 
    cls->defineFunction("getBones", _SE(js_spine_Skeleton_getBones)); 
    cls->defineFunction("getUpdateCacheList", _SE(js_spine_Skeleton_getUpdateCacheList)); 
    cls->defineFunction("getSlots", _SE(js_spine_Skeleton_getSlots)); 
    cls->defineFunction("getDrawOrder", _SE(js_spine_Skeleton_getDrawOrder)); 
    cls->defineFunction("getIkConstraints", _SE(js_spine_Skeleton_getIkConstraints)); 
    cls->defineFunction("getPathConstraints", _SE(js_spine_Skeleton_getPathConstraints)); 
    cls->defineFunction("getTransformConstraints", _SE(js_spine_Skeleton_getTransformConstraints)); 
    cls->defineFunction("getSkin", _SE(js_spine_Skeleton_getSkin)); 
    cls->defineFunction("getColor", _SE(js_spine_Skeleton_getColor)); 
    cls->defineFunction("getTime", _SE(js_spine_Skeleton_getTime)); 
    cls->defineFunction("setTime", _SE(js_spine_Skeleton_setTime)); 
    cls->defineFunction("setPosition", _SE(js_spine_Skeleton_setPosition)); 
    cls->defineFunction("getX", _SE(js_spine_Skeleton_getX)); 
    cls->defineFunction("setX", _SE(js_spine_Skeleton_setX)); 
    cls->defineFunction("getY", _SE(js_spine_Skeleton_getY)); 
    cls->defineFunction("setY", _SE(js_spine_Skeleton_setY)); 
    cls->defineFunction("getScaleX", _SE(js_spine_Skeleton_getScaleX)); 
    cls->defineFunction("setScaleX", _SE(js_spine_Skeleton_setScaleX)); 
    cls->defineFunction("getScaleY", _SE(js_spine_Skeleton_getScaleY)); 
    cls->defineFunction("setScaleY", _SE(js_spine_Skeleton_setScaleY)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_Skeleton));
    
    
    cls->install();
    JSBClassType::registerClass<spine::Skeleton>(cls);
    
    __jsb_spine_Skeleton_proto = cls->getProto();
    __jsb_spine_Skeleton_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_Slot_class = nullptr;
se::Object* __jsb_spine_Slot_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_Slot) 

static bool js_spine_Slot_setToSetupPose(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Slot *arg1 = (spine::Slot *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Slot>(s);
    if (nullptr == arg1) return true;
    (arg1)->setToSetupPose();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Slot_setToSetupPose) 

static bool js_spine_Slot_getData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Slot *arg1 = (spine::Slot *) NULL ;
    spine::SlotData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Slot>(s);
    if (nullptr == arg1) return true;
    result = (spine::SlotData *) &(arg1)->getData();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Slot_getData) 

static bool js_spine_Slot_getBone(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Slot *arg1 = (spine::Slot *) NULL ;
    spine::Bone *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Slot>(s);
    if (nullptr == arg1) return true;
    result = (spine::Bone *) &(arg1)->getBone();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Slot_getBone) 

static bool js_spine_Slot_getSkeleton(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Slot *arg1 = (spine::Slot *) NULL ;
    spine::Skeleton *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Slot>(s);
    if (nullptr == arg1) return true;
    result = (spine::Skeleton *) &(arg1)->getSkeleton();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Slot_getSkeleton) 

static bool js_spine_Slot_getColor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Slot *arg1 = (spine::Slot *) NULL ;
    spine::Color *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Slot>(s);
    if (nullptr == arg1) return true;
    result = (spine::Color *) &(arg1)->getColor();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Slot_getColor) 

static bool js_spine_Slot_getDarkColor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Slot *arg1 = (spine::Slot *) NULL ;
    spine::Color *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Slot>(s);
    if (nullptr == arg1) return true;
    result = (spine::Color *) &(arg1)->getDarkColor();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Slot_getDarkColor) 

static bool js_spine_Slot_hasDarkColor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Slot *arg1 = (spine::Slot *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Slot>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->hasDarkColor();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Slot_hasDarkColor) 

static bool js_spine_Slot_getAttachment(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Slot *arg1 = (spine::Slot *) NULL ;
    spine::Attachment *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Slot>(s);
    if (nullptr == arg1) return true;
    result = (spine::Attachment *)(arg1)->getAttachment();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Slot_getAttachment) 

static bool js_spine_Slot_setAttachment(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Slot *arg1 = (spine::Slot *) NULL ;
    spine::Attachment *arg2 = (spine::Attachment *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Slot>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAttachment(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Slot_setAttachment) 

static bool js_spine_Slot_getAttachmentTime(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Slot *arg1 = (spine::Slot *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Slot>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getAttachmentTime();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Slot_getAttachmentTime) 

static bool js_spine_Slot_setAttachmentTime(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Slot *arg1 = (spine::Slot *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Slot>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAttachmentTime(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Slot_setAttachmentTime) 

static bool js_spine_Slot_getDeform(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Slot *arg1 = (spine::Slot *) NULL ;
    spine::Vector< float > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Slot>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< float > *) &(arg1)->getDeform();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Slot_getDeform) 

static bool js_delete_spine_Slot(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_Slot) 

bool js_register_spine_Slot(se::Object* obj) {
    auto* cls = se::Class::create("Slot", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("setToSetupPose", _SE(js_spine_Slot_setToSetupPose)); 
    cls->defineFunction("getData", _SE(js_spine_Slot_getData)); 
    cls->defineFunction("getBone", _SE(js_spine_Slot_getBone)); 
    cls->defineFunction("getSkeleton", _SE(js_spine_Slot_getSkeleton)); 
    cls->defineFunction("getColor", _SE(js_spine_Slot_getColor)); 
    cls->defineFunction("getDarkColor", _SE(js_spine_Slot_getDarkColor)); 
    cls->defineFunction("hasDarkColor", _SE(js_spine_Slot_hasDarkColor)); 
    cls->defineFunction("getAttachment", _SE(js_spine_Slot_getAttachment)); 
    cls->defineFunction("setAttachment", _SE(js_spine_Slot_setAttachment)); 
    cls->defineFunction("getAttachmentTime", _SE(js_spine_Slot_getAttachmentTime)); 
    cls->defineFunction("setAttachmentTime", _SE(js_spine_Slot_setAttachmentTime)); 
    cls->defineFunction("getDeform", _SE(js_spine_Slot_getDeform)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_Slot));
    
    
    cls->install();
    JSBClassType::registerClass<spine::Slot>(cls);
    
    __jsb_spine_Slot_proto = cls->getProto();
    __jsb_spine_Slot_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_Skin_class = nullptr;
se::Object* __jsb_spine_Skin_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_Skin) 

static bool js_delete_spine_Skin(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_Skin) 

static bool js_spine_Skin_setAttachment(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skin *arg1 = (spine::Skin *) NULL ;
    size_t arg2 ;
    spine::String *arg3 = 0 ;
    spine::Attachment *arg4 = (spine::Attachment *) NULL ;
    spine::String temp3 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skin>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAttachment(arg2,(spine::String const &)*arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skin_setAttachment) 

static bool js_spine_Skin_getAttachment(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skin *arg1 = (spine::Skin *) NULL ;
    size_t arg2 ;
    spine::String *arg3 = 0 ;
    spine::String temp3 ;
    spine::Attachment *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skin>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    result = (spine::Attachment *)(arg1)->getAttachment(arg2,(spine::String const &)*arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skin_getAttachment) 

static bool js_spine_Skin_removeAttachment(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skin *arg1 = (spine::Skin *) NULL ;
    size_t arg2 ;
    spine::String *arg3 = 0 ;
    spine::String temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skin>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->removeAttachment(arg2,(spine::String const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skin_removeAttachment) 

static bool js_spine_Skin_getName(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skin *arg1 = (spine::Skin *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skin>(s);
    if (nullptr == arg1) return true;
    result = (spine::String *) &(arg1)->getName();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skin_getName) 

static bool js_spine_Skin_addSkin(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skin *arg1 = (spine::Skin *) NULL ;
    spine::Skin *arg2 = (spine::Skin *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skin>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addSkin(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skin_addSkin) 

static bool js_spine_Skin_copySkin(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skin *arg1 = (spine::Skin *) NULL ;
    spine::Skin *arg2 = (spine::Skin *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skin>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->copySkin(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skin_copySkin) 

static bool js_spine_Skin_getBones(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skin *arg1 = (spine::Skin *) NULL ;
    spine::Vector< spine::BoneData * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skin>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::BoneData * > *) &(arg1)->getBones();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skin_getBones) 

static bool js_spine_Skin_getConstraints(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skin *arg1 = (spine::Skin *) NULL ;
    spine::Vector< spine::ConstraintData * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skin>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::ConstraintData * > *) &(arg1)->getConstraints();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skin_getConstraints) 

bool js_register_spine_Skin(se::Object* obj) {
    auto* cls = se::Class::create("Skin", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("setAttachment", _SE(js_spine_Skin_setAttachment)); 
    cls->defineFunction("getAttachment", _SE(js_spine_Skin_getAttachment)); 
    cls->defineFunction("removeAttachment", _SE(js_spine_Skin_removeAttachment)); 
    cls->defineFunction("getName", _SE(js_spine_Skin_getName)); 
    cls->defineFunction("addSkin", _SE(js_spine_Skin_addSkin)); 
    cls->defineFunction("copySkin", _SE(js_spine_Skin_copySkin)); 
    cls->defineFunction("getBones", _SE(js_spine_Skin_getBones)); 
    cls->defineFunction("getConstraints", _SE(js_spine_Skin_getConstraints)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_Skin));
    
    
    cls->install();
    JSBClassType::registerClass<spine::Skin>(cls);
    
    __jsb_spine_Skin_proto = cls->getProto();
    __jsb_spine_Skin_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_SkeletonBounds_class = nullptr;
se::Object* __jsb_spine_SkeletonBounds_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_SkeletonBounds) 

static bool js_spine_SkeletonBounds_aabbcontainsPoint(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonBounds *arg1 = (spine::SkeletonBounds *) NULL ;
    float arg2 ;
    float arg3 ;
    bool result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonBounds>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (bool)(arg1)->aabbcontainsPoint(arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonBounds_aabbcontainsPoint) 

static bool js_spine_SkeletonBounds_aabbintersectsSegment(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonBounds *arg1 = (spine::SkeletonBounds *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    bool result;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonBounds>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (bool)(arg1)->aabbintersectsSegment(arg2,arg3,arg4,arg5);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonBounds_aabbintersectsSegment) 

static bool js_spine_SkeletonBounds_containsPoint__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonBounds *arg1 = (spine::SkeletonBounds *) NULL ;
    spine::Polygon *arg2 = (spine::Polygon *) NULL ;
    float arg3 ;
    float arg4 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonBounds>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (bool)(arg1)->containsPoint(arg2,arg3,arg4);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}

static bool js_spine_SkeletonBounds_containsPoint__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonBounds *arg1 = (spine::SkeletonBounds *) NULL ;
    float arg2 ;
    float arg3 ;
    spine::BoundingBoxAttachment *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonBounds>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::BoundingBoxAttachment *)(arg1)->containsPoint(arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonBounds_containsPoint(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_spine_SkeletonBounds_containsPoint__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_spine_SkeletonBounds_containsPoint__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonBounds_containsPoint) 

static bool js_spine_SkeletonBounds_intersectsSegment__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonBounds *arg1 = (spine::SkeletonBounds *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    spine::BoundingBoxAttachment *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonBounds>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::BoundingBoxAttachment *)(arg1)->intersectsSegment(arg2,arg3,arg4,arg5);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonBounds_intersectsSegment__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonBounds *arg1 = (spine::SkeletonBounds *) NULL ;
    spine::Polygon *arg2 = (spine::Polygon *) NULL ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonBounds>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (bool)(arg1)->intersectsSegment(arg2,arg3,arg4,arg5,arg6);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}

static bool js_spine_SkeletonBounds_intersectsSegment(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 4) {
        ok = js_spine_SkeletonBounds_intersectsSegment__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 5) {
        ok = js_spine_SkeletonBounds_intersectsSegment__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonBounds_intersectsSegment) 

static bool js_spine_SkeletonBounds_getPolygon(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonBounds *arg1 = (spine::SkeletonBounds *) NULL ;
    spine::BoundingBoxAttachment *arg2 = (spine::BoundingBoxAttachment *) NULL ;
    spine::Polygon *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonBounds>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::Polygon *)(arg1)->getPolygon(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonBounds_getPolygon) 

static bool js_spine_SkeletonBounds_getWidth(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonBounds *arg1 = (spine::SkeletonBounds *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonBounds>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getWidth();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonBounds_getWidth) 

static bool js_spine_SkeletonBounds_getHeight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonBounds *arg1 = (spine::SkeletonBounds *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonBounds>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getHeight();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonBounds_getHeight) 

static bool js_delete_spine_SkeletonBounds(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_SkeletonBounds) 

bool js_register_spine_SkeletonBounds(se::Object* obj) {
    auto* cls = se::Class::create("SkeletonBounds", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("aabbcontainsPoint", _SE(js_spine_SkeletonBounds_aabbcontainsPoint)); 
    cls->defineFunction("aabbintersectsSegment", _SE(js_spine_SkeletonBounds_aabbintersectsSegment)); 
    cls->defineFunction("containsPoint", _SE(js_spine_SkeletonBounds_containsPoint)); 
    cls->defineFunction("intersectsSegment", _SE(js_spine_SkeletonBounds_intersectsSegment)); 
    cls->defineFunction("getPolygon", _SE(js_spine_SkeletonBounds_getPolygon)); 
    cls->defineFunction("getWidth", _SE(js_spine_SkeletonBounds_getWidth)); 
    cls->defineFunction("getHeight", _SE(js_spine_SkeletonBounds_getHeight)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_SkeletonBounds));
    
    
    cls->install();
    JSBClassType::registerClass<spine::SkeletonBounds>(cls);
    
    __jsb_spine_SkeletonBounds_proto = cls->getProto();
    __jsb_spine_SkeletonBounds_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_Polygon_class = nullptr;
se::Object* __jsb_spine_Polygon_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_Polygon) 

static bool js_spine_Polygon__count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Polygon *arg1 = (spine::Polygon *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::Polygon>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_count, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_spine_Polygon__count_set) 

static bool js_spine_Polygon__count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    spine::Polygon *arg1 = (spine::Polygon *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::Polygon>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_count, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_Polygon__count_get) 

static bool js_delete_spine_Polygon(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_Polygon) 

bool js_register_spine_Polygon(se::Object* obj) {
    auto* cls = se::Class::create("Polygon", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("_count", _SE(js_spine_Polygon__count_get), _SE(js_spine_Polygon__count_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_Polygon));
    
    
    cls->install();
    JSBClassType::registerClass<spine::Polygon>(cls);
    
    __jsb_spine_Polygon_proto = cls->getProto();
    __jsb_spine_Polygon_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_SkeletonData_class = nullptr;
se::Object* __jsb_spine_SkeletonData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_SkeletonData) 

static bool js_delete_spine_SkeletonData(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_SkeletonData) 

static bool js_spine_SkeletonData_findBone(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    spine::BoneData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (spine::BoneData *)(arg1)->findBone((spine::String const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_findBone) 

static bool js_spine_SkeletonData_findBoneIndex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    int result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (int)(arg1)->findBoneIndex((spine::String const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_findBoneIndex) 

static bool js_spine_SkeletonData_findSlot(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    spine::SlotData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (spine::SlotData *)(arg1)->findSlot((spine::String const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_findSlot) 

static bool js_spine_SkeletonData_findSlotIndex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    int result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (int)(arg1)->findSlotIndex((spine::String const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_findSlotIndex) 

static bool js_spine_SkeletonData_findSkin(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    spine::Skin *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (spine::Skin *)(arg1)->findSkin((spine::String const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_findSkin) 

static bool js_spine_SkeletonData_findEvent(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    spine::EventData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (spine::EventData *)(arg1)->findEvent((spine::String const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_findEvent) 

static bool js_spine_SkeletonData_findAnimation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    spine::Animation *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (spine::Animation *)(arg1)->findAnimation((spine::String const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_findAnimation) 

static bool js_spine_SkeletonData_findIkConstraint(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    spine::IkConstraintData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (spine::IkConstraintData *)(arg1)->findIkConstraint((spine::String const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_findIkConstraint) 

static bool js_spine_SkeletonData_findTransformConstraint(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    spine::TransformConstraintData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (spine::TransformConstraintData *)(arg1)->findTransformConstraint((spine::String const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_findTransformConstraint) 

static bool js_spine_SkeletonData_findPathConstraint(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    spine::PathConstraintData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (spine::PathConstraintData *)(arg1)->findPathConstraint((spine::String const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_findPathConstraint) 

static bool js_spine_SkeletonData_findPathConstraintIndex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    int result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (int)(arg1)->findPathConstraintIndex((spine::String const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_findPathConstraintIndex) 

static bool js_spine_SkeletonData_getName(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    result = (spine::String *) &(arg1)->getName();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getName) 

static bool js_spine_SkeletonData_setName(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setName((spine::String const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_setName) 

static bool js_spine_SkeletonData_getBones(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::Vector< spine::BoneData * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::BoneData * > *) &(arg1)->getBones();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getBones) 

static bool js_spine_SkeletonData_getSlots(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::Vector< spine::SlotData * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::SlotData * > *) &(arg1)->getSlots();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getSlots) 

static bool js_spine_SkeletonData_getSkins(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::Vector< spine::Skin * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::Skin * > *) &(arg1)->getSkins();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getSkins) 

static bool js_spine_SkeletonData_getDefaultSkin(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::Skin *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    result = (spine::Skin *)(arg1)->getDefaultSkin();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getDefaultSkin) 

static bool js_spine_SkeletonData_setDefaultSkin(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::Skin *arg2 = (spine::Skin *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setDefaultSkin(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_setDefaultSkin) 

static bool js_spine_SkeletonData_getEvents(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::Vector< spine::EventData * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::EventData * > *) &(arg1)->getEvents();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getEvents) 

static bool js_spine_SkeletonData_getAnimations(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::Vector< spine::Animation * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::Animation * > *) &(arg1)->getAnimations();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getAnimations) 

static bool js_spine_SkeletonData_getIkConstraints(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::Vector< spine::IkConstraintData * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::IkConstraintData * > *) &(arg1)->getIkConstraints();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getIkConstraints) 

static bool js_spine_SkeletonData_getTransformConstraints(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::Vector< spine::TransformConstraintData * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::TransformConstraintData * > *) &(arg1)->getTransformConstraints();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getTransformConstraints) 

static bool js_spine_SkeletonData_getPathConstraints(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::Vector< spine::PathConstraintData * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::PathConstraintData * > *) &(arg1)->getPathConstraints();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getPathConstraints) 

static bool js_spine_SkeletonData_getX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getX();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getX) 

static bool js_spine_SkeletonData_setX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_setX) 

static bool js_spine_SkeletonData_getY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getY) 

static bool js_spine_SkeletonData_setY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_setY) 

static bool js_spine_SkeletonData_getWidth(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getWidth();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getWidth) 

static bool js_spine_SkeletonData_setWidth(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setWidth(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_setWidth) 

static bool js_spine_SkeletonData_getHeight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getHeight();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getHeight) 

static bool js_spine_SkeletonData_setHeight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setHeight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_setHeight) 

static bool js_spine_SkeletonData_getVersion(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    result = (spine::String *) &(arg1)->getVersion();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getVersion) 

static bool js_spine_SkeletonData_setVersion(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setVersion((spine::String const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_setVersion) 

static bool js_spine_SkeletonData_getHash(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    result = (spine::String *) &(arg1)->getHash();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getHash) 

static bool js_spine_SkeletonData_setHash(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setHash((spine::String const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_setHash) 

static bool js_spine_SkeletonData_getImagesPath(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    result = (spine::String *) &(arg1)->getImagesPath();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getImagesPath) 

static bool js_spine_SkeletonData_setImagesPath(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setImagesPath((spine::String const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_setImagesPath) 

static bool js_spine_SkeletonData_getAudioPath(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    result = (spine::String *) &(arg1)->getAudioPath();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getAudioPath) 

static bool js_spine_SkeletonData_setAudioPath(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setAudioPath((spine::String const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_setAudioPath) 

static bool js_spine_SkeletonData_getFps(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getFps();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getFps) 

static bool js_spine_SkeletonData_setFps(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setFps(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_setFps) 

bool js_register_spine_SkeletonData(se::Object* obj) {
    auto* cls = se::Class::create("SkeletonData", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("findBone", _SE(js_spine_SkeletonData_findBone)); 
    cls->defineFunction("findBoneIndex", _SE(js_spine_SkeletonData_findBoneIndex)); 
    cls->defineFunction("findSlot", _SE(js_spine_SkeletonData_findSlot)); 
    cls->defineFunction("findSlotIndex", _SE(js_spine_SkeletonData_findSlotIndex)); 
    cls->defineFunction("findSkin", _SE(js_spine_SkeletonData_findSkin)); 
    cls->defineFunction("findEvent", _SE(js_spine_SkeletonData_findEvent)); 
    cls->defineFunction("findAnimation", _SE(js_spine_SkeletonData_findAnimation)); 
    cls->defineFunction("findIkConstraint", _SE(js_spine_SkeletonData_findIkConstraint)); 
    cls->defineFunction("findTransformConstraint", _SE(js_spine_SkeletonData_findTransformConstraint)); 
    cls->defineFunction("findPathConstraint", _SE(js_spine_SkeletonData_findPathConstraint)); 
    cls->defineFunction("findPathConstraintIndex", _SE(js_spine_SkeletonData_findPathConstraintIndex)); 
    cls->defineFunction("getName", _SE(js_spine_SkeletonData_getName)); 
    cls->defineFunction("setName", _SE(js_spine_SkeletonData_setName)); 
    cls->defineFunction("getBones", _SE(js_spine_SkeletonData_getBones)); 
    cls->defineFunction("getSlots", _SE(js_spine_SkeletonData_getSlots)); 
    cls->defineFunction("getSkins", _SE(js_spine_SkeletonData_getSkins)); 
    cls->defineFunction("getDefaultSkin", _SE(js_spine_SkeletonData_getDefaultSkin)); 
    cls->defineFunction("setDefaultSkin", _SE(js_spine_SkeletonData_setDefaultSkin)); 
    cls->defineFunction("getEvents", _SE(js_spine_SkeletonData_getEvents)); 
    cls->defineFunction("getAnimations", _SE(js_spine_SkeletonData_getAnimations)); 
    cls->defineFunction("getIkConstraints", _SE(js_spine_SkeletonData_getIkConstraints)); 
    cls->defineFunction("getTransformConstraints", _SE(js_spine_SkeletonData_getTransformConstraints)); 
    cls->defineFunction("getPathConstraints", _SE(js_spine_SkeletonData_getPathConstraints)); 
    cls->defineFunction("getX", _SE(js_spine_SkeletonData_getX)); 
    cls->defineFunction("setX", _SE(js_spine_SkeletonData_setX)); 
    cls->defineFunction("getY", _SE(js_spine_SkeletonData_getY)); 
    cls->defineFunction("setY", _SE(js_spine_SkeletonData_setY)); 
    cls->defineFunction("getWidth", _SE(js_spine_SkeletonData_getWidth)); 
    cls->defineFunction("setWidth", _SE(js_spine_SkeletonData_setWidth)); 
    cls->defineFunction("getHeight", _SE(js_spine_SkeletonData_getHeight)); 
    cls->defineFunction("setHeight", _SE(js_spine_SkeletonData_setHeight)); 
    cls->defineFunction("getVersion", _SE(js_spine_SkeletonData_getVersion)); 
    cls->defineFunction("setVersion", _SE(js_spine_SkeletonData_setVersion)); 
    cls->defineFunction("getHash", _SE(js_spine_SkeletonData_getHash)); 
    cls->defineFunction("setHash", _SE(js_spine_SkeletonData_setHash)); 
    cls->defineFunction("getImagesPath", _SE(js_spine_SkeletonData_getImagesPath)); 
    cls->defineFunction("setImagesPath", _SE(js_spine_SkeletonData_setImagesPath)); 
    cls->defineFunction("getAudioPath", _SE(js_spine_SkeletonData_getAudioPath)); 
    cls->defineFunction("setAudioPath", _SE(js_spine_SkeletonData_setAudioPath)); 
    cls->defineFunction("getFps", _SE(js_spine_SkeletonData_getFps)); 
    cls->defineFunction("setFps", _SE(js_spine_SkeletonData_setFps)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_SkeletonData));
    
    
    cls->install();
    JSBClassType::registerClass<spine::SkeletonData>(cls);
    
    __jsb_spine_SkeletonData_proto = cls->getProto();
    __jsb_spine_SkeletonData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_SlotData_class = nullptr;
se::Object* __jsb_spine_SlotData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_SlotData) 

static bool js_spine_SlotData_getIndex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SlotData *arg1 = (spine::SlotData *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SlotData>(s);
    if (nullptr == arg1) return true;
    result = (int)(arg1)->getIndex();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SlotData_getIndex) 

static bool js_spine_SlotData_getName(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SlotData *arg1 = (spine::SlotData *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SlotData>(s);
    if (nullptr == arg1) return true;
    result = (spine::String *) &(arg1)->getName();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SlotData_getName) 

static bool js_spine_SlotData_getBoneData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SlotData *arg1 = (spine::SlotData *) NULL ;
    spine::BoneData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SlotData>(s);
    if (nullptr == arg1) return true;
    result = (spine::BoneData *) &(arg1)->getBoneData();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SlotData_getBoneData) 

static bool js_spine_SlotData_getColor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SlotData *arg1 = (spine::SlotData *) NULL ;
    spine::Color *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SlotData>(s);
    if (nullptr == arg1) return true;
    result = (spine::Color *) &(arg1)->getColor();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SlotData_getColor) 

static bool js_spine_SlotData_getDarkColor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SlotData *arg1 = (spine::SlotData *) NULL ;
    spine::Color *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SlotData>(s);
    if (nullptr == arg1) return true;
    result = (spine::Color *) &(arg1)->getDarkColor();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SlotData_getDarkColor) 

static bool js_spine_SlotData_hasDarkColor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SlotData *arg1 = (spine::SlotData *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SlotData>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->hasDarkColor();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SlotData_hasDarkColor) 

static bool js_spine_SlotData_setHasDarkColor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SlotData *arg1 = (spine::SlotData *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SlotData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setHasDarkColor(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SlotData_setHasDarkColor) 

static bool js_spine_SlotData_getAttachmentName(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SlotData *arg1 = (spine::SlotData *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SlotData>(s);
    if (nullptr == arg1) return true;
    result = (spine::String *) &(arg1)->getAttachmentName();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SlotData_getAttachmentName) 

static bool js_spine_SlotData_setAttachmentName(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SlotData *arg1 = (spine::SlotData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SlotData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setAttachmentName((spine::String const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SlotData_setAttachmentName) 

static bool js_spine_SlotData_getBlendMode(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SlotData *arg1 = (spine::SlotData *) NULL ;
    spine::BlendMode result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SlotData>(s);
    if (nullptr == arg1) return true;
    result = (spine::BlendMode)(arg1)->getBlendMode();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SlotData_getBlendMode) 

static bool js_spine_SlotData_setBlendMode(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SlotData *arg1 = (spine::SlotData *) NULL ;
    spine::BlendMode arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SlotData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->setBlendMode(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SlotData_setBlendMode) 

static bool js_delete_spine_SlotData(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_SlotData) 

bool js_register_spine_SlotData(se::Object* obj) {
    auto* cls = se::Class::create("SlotData", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getIndex", _SE(js_spine_SlotData_getIndex)); 
    cls->defineFunction("getName", _SE(js_spine_SlotData_getName)); 
    cls->defineFunction("getBoneData", _SE(js_spine_SlotData_getBoneData)); 
    cls->defineFunction("getColor", _SE(js_spine_SlotData_getColor)); 
    cls->defineFunction("getDarkColor", _SE(js_spine_SlotData_getDarkColor)); 
    cls->defineFunction("hasDarkColor", _SE(js_spine_SlotData_hasDarkColor)); 
    cls->defineFunction("setHasDarkColor", _SE(js_spine_SlotData_setHasDarkColor)); 
    cls->defineFunction("getAttachmentName", _SE(js_spine_SlotData_getAttachmentName)); 
    cls->defineFunction("setAttachmentName", _SE(js_spine_SlotData_setAttachmentName)); 
    cls->defineFunction("getBlendMode", _SE(js_spine_SlotData_getBlendMode)); 
    cls->defineFunction("setBlendMode", _SE(js_spine_SlotData_setBlendMode)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_SlotData));
    
    
    cls->install();
    JSBClassType::registerClass<spine::SlotData>(cls);
    
    __jsb_spine_SlotData_proto = cls->getProto();
    __jsb_spine_SlotData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_TransformConstraint_class = nullptr;
se::Object* __jsb_spine_TransformConstraint_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_TransformConstraint) 

static bool js_spine_TransformConstraint_apply(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    if (nullptr == arg1) return true;
    (arg1)->apply();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_apply) 

static bool js_spine_TransformConstraint_update(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    if (nullptr == arg1) return true;
    (arg1)->update();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_update) 

static bool js_spine_TransformConstraint_getOrder(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    if (nullptr == arg1) return true;
    result = (int)(arg1)->getOrder();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_getOrder) 

static bool js_spine_TransformConstraint_getData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    spine::TransformConstraintData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    if (nullptr == arg1) return true;
    result = (spine::TransformConstraintData *) &(arg1)->getData();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_getData) 

static bool js_spine_TransformConstraint_getBones(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    spine::Vector< spine::Bone * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::Bone * > *) &(arg1)->getBones();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_getBones) 

static bool js_spine_TransformConstraint_getTarget(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    spine::Bone *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    if (nullptr == arg1) return true;
    result = (spine::Bone *)(arg1)->getTarget();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_getTarget) 

static bool js_spine_TransformConstraint_setTarget(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    spine::Bone *arg2 = (spine::Bone *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setTarget(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_setTarget) 

static bool js_spine_TransformConstraint_getRotateMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getRotateMix();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_getRotateMix) 

static bool js_spine_TransformConstraint_setRotateMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRotateMix(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_setRotateMix) 

static bool js_spine_TransformConstraint_getTranslateMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getTranslateMix();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_getTranslateMix) 

static bool js_spine_TransformConstraint_setTranslateMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setTranslateMix(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_setTranslateMix) 

static bool js_spine_TransformConstraint_getScaleMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getScaleMix();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_getScaleMix) 

static bool js_spine_TransformConstraint_setScaleMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setScaleMix(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_setScaleMix) 

static bool js_spine_TransformConstraint_getShearMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getShearMix();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_getShearMix) 

static bool js_spine_TransformConstraint_setShearMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setShearMix(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_setShearMix) 

static bool js_spine_TransformConstraint_isActive(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->isActive();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_isActive) 

static bool js_spine_TransformConstraint_setActive(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setActive(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_setActive) 

static bool js_delete_spine_TransformConstraint(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_TransformConstraint) 

bool js_register_spine_TransformConstraint(se::Object* obj) {
    auto* cls = se::Class::create("TransformConstraint", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("apply", _SE(js_spine_TransformConstraint_apply)); 
    cls->defineFunction("update", _SE(js_spine_TransformConstraint_update)); 
    cls->defineFunction("getOrder", _SE(js_spine_TransformConstraint_getOrder)); 
    cls->defineFunction("getData", _SE(js_spine_TransformConstraint_getData)); 
    cls->defineFunction("getBones", _SE(js_spine_TransformConstraint_getBones)); 
    cls->defineFunction("getTarget", _SE(js_spine_TransformConstraint_getTarget)); 
    cls->defineFunction("setTarget", _SE(js_spine_TransformConstraint_setTarget)); 
    cls->defineFunction("getRotateMix", _SE(js_spine_TransformConstraint_getRotateMix)); 
    cls->defineFunction("setRotateMix", _SE(js_spine_TransformConstraint_setRotateMix)); 
    cls->defineFunction("getTranslateMix", _SE(js_spine_TransformConstraint_getTranslateMix)); 
    cls->defineFunction("setTranslateMix", _SE(js_spine_TransformConstraint_setTranslateMix)); 
    cls->defineFunction("getScaleMix", _SE(js_spine_TransformConstraint_getScaleMix)); 
    cls->defineFunction("setScaleMix", _SE(js_spine_TransformConstraint_setScaleMix)); 
    cls->defineFunction("getShearMix", _SE(js_spine_TransformConstraint_getShearMix)); 
    cls->defineFunction("setShearMix", _SE(js_spine_TransformConstraint_setShearMix)); 
    cls->defineFunction("isActive", _SE(js_spine_TransformConstraint_isActive)); 
    cls->defineFunction("setActive", _SE(js_spine_TransformConstraint_setActive)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_TransformConstraint));
    
    
    cls->install();
    JSBClassType::registerClass<spine::TransformConstraint>(cls);
    
    __jsb_spine_TransformConstraint_proto = cls->getProto();
    __jsb_spine_TransformConstraint_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_TransformConstraintData_class = nullptr;
se::Object* __jsb_spine_TransformConstraintData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_TransformConstraintData) 

static bool js_spine_TransformConstraintData_getBones(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    spine::Vector< spine::BoneData * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< spine::BoneData * > *) &(arg1)->getBones();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_getBones) 

static bool js_spine_TransformConstraintData_getTarget(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    spine::BoneData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (spine::BoneData *)(arg1)->getTarget();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_getTarget) 

static bool js_spine_TransformConstraintData_getRotateMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getRotateMix();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_getRotateMix) 

static bool js_spine_TransformConstraintData_getTranslateMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getTranslateMix();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_getTranslateMix) 

static bool js_spine_TransformConstraintData_getScaleMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getScaleMix();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_getScaleMix) 

static bool js_spine_TransformConstraintData_getShearMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getShearMix();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_getShearMix) 

static bool js_spine_TransformConstraintData_getOffsetRotation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getOffsetRotation();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_getOffsetRotation) 

static bool js_spine_TransformConstraintData_getOffsetX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getOffsetX();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_getOffsetX) 

static bool js_spine_TransformConstraintData_getOffsetY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getOffsetY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_getOffsetY) 

static bool js_spine_TransformConstraintData_getOffsetScaleX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getOffsetScaleX();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_getOffsetScaleX) 

static bool js_spine_TransformConstraintData_getOffsetScaleY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getOffsetScaleY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_getOffsetScaleY) 

static bool js_spine_TransformConstraintData_getOffsetShearY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getOffsetShearY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_getOffsetShearY) 

static bool js_spine_TransformConstraintData_isRelative(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->isRelative();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_isRelative) 

static bool js_spine_TransformConstraintData_isLocal(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->isLocal();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_isLocal) 

static bool js_delete_spine_TransformConstraintData(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_TransformConstraintData) 

bool js_register_spine_TransformConstraintData(se::Object* obj) {
    auto* cls = se::Class::create("TransformConstraintData", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getBones", _SE(js_spine_TransformConstraintData_getBones)); 
    cls->defineFunction("getTarget", _SE(js_spine_TransformConstraintData_getTarget)); 
    cls->defineFunction("getRotateMix", _SE(js_spine_TransformConstraintData_getRotateMix)); 
    cls->defineFunction("getTranslateMix", _SE(js_spine_TransformConstraintData_getTranslateMix)); 
    cls->defineFunction("getScaleMix", _SE(js_spine_TransformConstraintData_getScaleMix)); 
    cls->defineFunction("getShearMix", _SE(js_spine_TransformConstraintData_getShearMix)); 
    cls->defineFunction("getOffsetRotation", _SE(js_spine_TransformConstraintData_getOffsetRotation)); 
    cls->defineFunction("getOffsetX", _SE(js_spine_TransformConstraintData_getOffsetX)); 
    cls->defineFunction("getOffsetY", _SE(js_spine_TransformConstraintData_getOffsetY)); 
    cls->defineFunction("getOffsetScaleX", _SE(js_spine_TransformConstraintData_getOffsetScaleX)); 
    cls->defineFunction("getOffsetScaleY", _SE(js_spine_TransformConstraintData_getOffsetScaleY)); 
    cls->defineFunction("getOffsetShearY", _SE(js_spine_TransformConstraintData_getOffsetShearY)); 
    cls->defineFunction("isRelative", _SE(js_spine_TransformConstraintData_isRelative)); 
    cls->defineFunction("isLocal", _SE(js_spine_TransformConstraintData_isLocal)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_TransformConstraintData));
    
    
    cls->install();
    JSBClassType::registerClass<spine::TransformConstraintData>(cls);
    
    __jsb_spine_TransformConstraintData_proto = cls->getProto();
    __jsb_spine_TransformConstraintData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_TransformConstraintTimeline_class = nullptr;
se::Object* __jsb_spine_TransformConstraintTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_TransformConstraintTimeline) 

static bool js_spine_TransformConstraintTimeline_ENTRIES_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    int result;
    
    result = (int)(int)spine::TransformConstraintTimeline::ENTRIES;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_TransformConstraintTimeline_ENTRIES_get) 

static bool js_spine_TransformConstraintTimeline_setFrame(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintTimeline *arg1 = (spine::TransformConstraintTimeline *) NULL ;
    size_t arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintTimeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setFrame(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintTimeline_setFrame) 

static bool js_delete_spine_TransformConstraintTimeline(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_TransformConstraintTimeline) 

bool js_register_spine_TransformConstraintTimeline(se::Object* obj) {
    auto* cls = se::Class::create("TransformConstraintTimeline", obj, __jsb_spine_CurveTimeline_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("setFrame", _SE(js_spine_TransformConstraintTimeline_setFrame)); 
    
    cls->defineStaticProperty("ENTRIES", _SE(js_spine_TransformConstraintTimeline_ENTRIES_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_TransformConstraintTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::TransformConstraintTimeline>(cls);
    
    __jsb_spine_TransformConstraintTimeline_proto = cls->getProto();
    __jsb_spine_TransformConstraintTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_TranslateTimeline_class = nullptr;
se::Object* __jsb_spine_TranslateTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_TranslateTimeline) 

static bool js_spine_TranslateTimeline_ENTRIES_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    int result;
    
    result = (int)(int)spine::TranslateTimeline::ENTRIES;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_TranslateTimeline_ENTRIES_get) 

static bool js_delete_spine_TranslateTimeline(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_TranslateTimeline) 

static bool js_spine_TranslateTimeline_setFrame(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TranslateTimeline *arg1 = (spine::TranslateTimeline *) NULL ;
    int arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TranslateTimeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setFrame(arg2,arg3,arg4,arg5);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TranslateTimeline_setFrame) 

bool js_register_spine_TranslateTimeline(se::Object* obj) {
    auto* cls = se::Class::create("TranslateTimeline", obj, __jsb_spine_CurveTimeline_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("setFrame", _SE(js_spine_TranslateTimeline_setFrame)); 
    
    cls->defineStaticProperty("ENTRIES", _SE(js_spine_TranslateTimeline_ENTRIES_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_TranslateTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::TranslateTimeline>(cls);
    
    __jsb_spine_TranslateTimeline_proto = cls->getProto();
    __jsb_spine_TranslateTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_TwoColorTimeline_class = nullptr;
se::Object* __jsb_spine_TwoColorTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_TwoColorTimeline) 

static bool js_spine_TwoColorTimeline_ENTRIES_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    int result;
    
    result = (int)(int)spine::TwoColorTimeline::ENTRIES;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_TwoColorTimeline_ENTRIES_get) 

static bool js_spine_TwoColorTimeline_setFrame(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TwoColorTimeline *arg1 = (spine::TwoColorTimeline *) NULL ;
    int arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    float arg8 ;
    float arg9 ;
    float arg10 ;
    
    if(argc != 9) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 9);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TwoColorTimeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[8], &arg10, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setFrame(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TwoColorTimeline_setFrame) 

static bool js_spine_TwoColorTimeline_getSlotIndex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TwoColorTimeline *arg1 = (spine::TwoColorTimeline *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TwoColorTimeline>(s);
    if (nullptr == arg1) return true;
    result = (int)(arg1)->getSlotIndex();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TwoColorTimeline_getSlotIndex) 

static bool js_spine_TwoColorTimeline_setSlotIndex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TwoColorTimeline *arg1 = (spine::TwoColorTimeline *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TwoColorTimeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setSlotIndex(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TwoColorTimeline_setSlotIndex) 

static bool js_delete_spine_TwoColorTimeline(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_TwoColorTimeline) 

bool js_register_spine_TwoColorTimeline(se::Object* obj) {
    auto* cls = se::Class::create("TwoColorTimeline", obj, __jsb_spine_CurveTimeline_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("setFrame", _SE(js_spine_TwoColorTimeline_setFrame)); 
    cls->defineFunction("getSlotIndex", _SE(js_spine_TwoColorTimeline_getSlotIndex)); 
    cls->defineFunction("setSlotIndex", _SE(js_spine_TwoColorTimeline_setSlotIndex)); 
    
    cls->defineStaticProperty("ENTRIES", _SE(js_spine_TwoColorTimeline_ENTRIES_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_TwoColorTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::TwoColorTimeline>(cls);
    
    __jsb_spine_TwoColorTimeline_proto = cls->getProto();
    __jsb_spine_TwoColorTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_VertexAttachment_class = nullptr;
se::Object* __jsb_spine_VertexAttachment_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_VertexAttachment) 

static bool js_delete_spine_VertexAttachment(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_VertexAttachment) 

static bool js_spine_VertexAttachment_getId(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexAttachment *arg1 = (spine::VertexAttachment *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexAttachment>(s);
    if (nullptr == arg1) return true;
    result = (int)(arg1)->getId();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexAttachment_getId) 

static bool js_spine_VertexAttachment_getVertices(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexAttachment *arg1 = (spine::VertexAttachment *) NULL ;
    spine::Vector< float > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexAttachment>(s);
    if (nullptr == arg1) return true;
    result = (spine::Vector< float > *) &(arg1)->getVertices();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexAttachment_getVertices) 

static bool js_spine_VertexAttachment_getWorldVerticesLength(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexAttachment *arg1 = (spine::VertexAttachment *) NULL ;
    size_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexAttachment>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getWorldVerticesLength();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexAttachment_getWorldVerticesLength) 

static bool js_spine_VertexAttachment_setWorldVerticesLength(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexAttachment *arg1 = (spine::VertexAttachment *) NULL ;
    size_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setWorldVerticesLength(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexAttachment_setWorldVerticesLength) 

static bool js_spine_VertexAttachment_getDeformAttachment(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexAttachment *arg1 = (spine::VertexAttachment *) NULL ;
    spine::VertexAttachment *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexAttachment>(s);
    if (nullptr == arg1) return true;
    result = (spine::VertexAttachment *)(arg1)->getDeformAttachment();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexAttachment_getDeformAttachment) 

static bool js_spine_VertexAttachment_setDeformAttachment(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexAttachment *arg1 = (spine::VertexAttachment *) NULL ;
    spine::VertexAttachment *arg2 = (spine::VertexAttachment *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setDeformAttachment(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexAttachment_setDeformAttachment) 

static bool js_spine_VertexAttachment_copyTo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexAttachment *arg1 = (spine::VertexAttachment *) NULL ;
    spine::VertexAttachment *arg2 = (spine::VertexAttachment *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->copyTo(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexAttachment_copyTo) 

bool js_register_spine_VertexAttachment(se::Object* obj) {
    auto* cls = se::Class::create("VertexAttachment", obj, __jsb_spine_Attachment_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getId", _SE(js_spine_VertexAttachment_getId)); 
    cls->defineFunction("getVertices", _SE(js_spine_VertexAttachment_getVertices)); 
    cls->defineFunction("getWorldVerticesLength", _SE(js_spine_VertexAttachment_getWorldVerticesLength)); 
    cls->defineFunction("setWorldVerticesLength", _SE(js_spine_VertexAttachment_setWorldVerticesLength)); 
    cls->defineFunction("getDeformAttachment", _SE(js_spine_VertexAttachment_getDeformAttachment)); 
    cls->defineFunction("setDeformAttachment", _SE(js_spine_VertexAttachment_setDeformAttachment)); 
    cls->defineFunction("copyTo", _SE(js_spine_VertexAttachment_copyTo)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_VertexAttachment));
    
    
    cls->install();
    JSBClassType::registerClass<spine::VertexAttachment>(cls);
    
    __jsb_spine_VertexAttachment_proto = cls->getProto();
    __jsb_spine_VertexAttachment_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_VertexEffect_class = nullptr;
se::Object* __jsb_spine_VertexEffect_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_VertexEffect) 

static bool js_delete_spine_VertexEffect(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_VertexEffect) 

bool js_register_spine_VertexEffect(se::Object* obj) {
    auto* cls = se::Class::create("VertexEffect", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_VertexEffect));
    
    
    cls->install();
    JSBClassType::registerClass<spine::VertexEffect>(cls);
    
    __jsb_spine_VertexEffect_proto = cls->getProto();
    __jsb_spine_VertexEffect_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_JitterVertexEffect_class = nullptr;
se::Object* __jsb_spine_JitterVertexEffect_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_JitterVertexEffect) 

static bool js_spine_JitterVertexEffect_setJitterX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::JitterVertexEffect *arg1 = (spine::JitterVertexEffect *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::JitterVertexEffect>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setJitterX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_JitterVertexEffect_setJitterX) 

static bool js_spine_JitterVertexEffect_getJitterX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::JitterVertexEffect *arg1 = (spine::JitterVertexEffect *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::JitterVertexEffect>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getJitterX();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_JitterVertexEffect_getJitterX) 

static bool js_spine_JitterVertexEffect_setJitterY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::JitterVertexEffect *arg1 = (spine::JitterVertexEffect *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::JitterVertexEffect>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setJitterY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_JitterVertexEffect_setJitterY) 

static bool js_spine_JitterVertexEffect_getJitterY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::JitterVertexEffect *arg1 = (spine::JitterVertexEffect *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::JitterVertexEffect>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getJitterY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_JitterVertexEffect_getJitterY) 

static bool js_delete_spine_JitterVertexEffect(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_JitterVertexEffect) 

bool js_register_spine_JitterVertexEffect(se::Object* obj) {
    auto* cls = se::Class::create("JitterVertexEffect", obj, __jsb_spine_VertexEffect_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("setJitterX", _SE(js_spine_JitterVertexEffect_setJitterX)); 
    cls->defineFunction("getJitterX", _SE(js_spine_JitterVertexEffect_getJitterX)); 
    cls->defineFunction("setJitterY", _SE(js_spine_JitterVertexEffect_setJitterY)); 
    cls->defineFunction("getJitterY", _SE(js_spine_JitterVertexEffect_getJitterY)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_JitterVertexEffect));
    
    
    cls->install();
    JSBClassType::registerClass<spine::JitterVertexEffect>(cls);
    
    __jsb_spine_JitterVertexEffect_proto = cls->getProto();
    __jsb_spine_JitterVertexEffect_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_SwirlVertexEffect_class = nullptr;
se::Object* __jsb_spine_SwirlVertexEffect_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_SwirlVertexEffect) 

static bool js_spine_SwirlVertexEffect_setCenterX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SwirlVertexEffect *arg1 = (spine::SwirlVertexEffect *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SwirlVertexEffect>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setCenterX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SwirlVertexEffect_setCenterX) 

static bool js_spine_SwirlVertexEffect_getCenterX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SwirlVertexEffect *arg1 = (spine::SwirlVertexEffect *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SwirlVertexEffect>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getCenterX();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SwirlVertexEffect_getCenterX) 

static bool js_spine_SwirlVertexEffect_setCenterY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SwirlVertexEffect *arg1 = (spine::SwirlVertexEffect *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SwirlVertexEffect>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setCenterY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SwirlVertexEffect_setCenterY) 

static bool js_spine_SwirlVertexEffect_getCenterY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SwirlVertexEffect *arg1 = (spine::SwirlVertexEffect *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SwirlVertexEffect>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getCenterY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SwirlVertexEffect_getCenterY) 

static bool js_spine_SwirlVertexEffect_setRadius(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SwirlVertexEffect *arg1 = (spine::SwirlVertexEffect *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SwirlVertexEffect>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRadius(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SwirlVertexEffect_setRadius) 

static bool js_spine_SwirlVertexEffect_getRadius(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SwirlVertexEffect *arg1 = (spine::SwirlVertexEffect *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SwirlVertexEffect>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getRadius();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SwirlVertexEffect_getRadius) 

static bool js_spine_SwirlVertexEffect_setAngle(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SwirlVertexEffect *arg1 = (spine::SwirlVertexEffect *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SwirlVertexEffect>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAngle(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SwirlVertexEffect_setAngle) 

static bool js_spine_SwirlVertexEffect_getAngle(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SwirlVertexEffect *arg1 = (spine::SwirlVertexEffect *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SwirlVertexEffect>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getAngle();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SwirlVertexEffect_getAngle) 

static bool js_spine_SwirlVertexEffect_setWorldX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SwirlVertexEffect *arg1 = (spine::SwirlVertexEffect *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SwirlVertexEffect>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setWorldX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SwirlVertexEffect_setWorldX) 

static bool js_spine_SwirlVertexEffect_getWorldX(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SwirlVertexEffect *arg1 = (spine::SwirlVertexEffect *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SwirlVertexEffect>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getWorldX();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SwirlVertexEffect_getWorldX) 

static bool js_spine_SwirlVertexEffect_setWorldY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SwirlVertexEffect *arg1 = (spine::SwirlVertexEffect *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SwirlVertexEffect>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setWorldY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SwirlVertexEffect_setWorldY) 

static bool js_spine_SwirlVertexEffect_getWorldY(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SwirlVertexEffect *arg1 = (spine::SwirlVertexEffect *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SwirlVertexEffect>(s);
    if (nullptr == arg1) return true;
    result = (float)(arg1)->getWorldY();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SwirlVertexEffect_getWorldY) 

static bool js_delete_spine_SwirlVertexEffect(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_SwirlVertexEffect) 

bool js_register_spine_SwirlVertexEffect(se::Object* obj) {
    auto* cls = se::Class::create("SwirlVertexEffect", obj, __jsb_spine_VertexEffect_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("setCenterX", _SE(js_spine_SwirlVertexEffect_setCenterX)); 
    cls->defineFunction("getCenterX", _SE(js_spine_SwirlVertexEffect_getCenterX)); 
    cls->defineFunction("setCenterY", _SE(js_spine_SwirlVertexEffect_setCenterY)); 
    cls->defineFunction("getCenterY", _SE(js_spine_SwirlVertexEffect_getCenterY)); 
    cls->defineFunction("setRadius", _SE(js_spine_SwirlVertexEffect_setRadius)); 
    cls->defineFunction("getRadius", _SE(js_spine_SwirlVertexEffect_getRadius)); 
    cls->defineFunction("setAngle", _SE(js_spine_SwirlVertexEffect_setAngle)); 
    cls->defineFunction("getAngle", _SE(js_spine_SwirlVertexEffect_getAngle)); 
    cls->defineFunction("setWorldX", _SE(js_spine_SwirlVertexEffect_setWorldX)); 
    cls->defineFunction("getWorldX", _SE(js_spine_SwirlVertexEffect_getWorldX)); 
    cls->defineFunction("setWorldY", _SE(js_spine_SwirlVertexEffect_setWorldY)); 
    cls->defineFunction("getWorldY", _SE(js_spine_SwirlVertexEffect_getWorldY)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_SwirlVertexEffect));
    
    
    cls->install();
    JSBClassType::registerClass<spine::SwirlVertexEffect>(cls);
    
    __jsb_spine_SwirlVertexEffect_proto = cls->getProto();
    __jsb_spine_SwirlVertexEffect_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_ConstraintData_class = nullptr;
se::Object* __jsb_spine_ConstraintData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_ConstraintData) 

static bool js_delete_spine_ConstraintData(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_ConstraintData) 

static bool js_spine_ConstraintData_getName(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ConstraintData *arg1 = (spine::ConstraintData *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (spine::String *) &(arg1)->getName();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ConstraintData_getName) 

static bool js_spine_ConstraintData_getOrder(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ConstraintData *arg1 = (spine::ConstraintData *) NULL ;
    size_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->getOrder();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ConstraintData_getOrder) 

static bool js_spine_ConstraintData_setOrder(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ConstraintData *arg1 = (spine::ConstraintData *) NULL ;
    size_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ConstraintData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setOrder(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ConstraintData_setOrder) 

static bool js_spine_ConstraintData_isSkinRequired(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ConstraintData *arg1 = (spine::ConstraintData *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ConstraintData>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->isSkinRequired();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ConstraintData_isSkinRequired) 

static bool js_spine_ConstraintData_setSkinRequired(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ConstraintData *arg1 = (spine::ConstraintData *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ConstraintData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setSkinRequired(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ConstraintData_setSkinRequired) 

bool js_register_spine_ConstraintData(se::Object* obj) {
    auto* cls = se::Class::create("ConstraintData", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getName", _SE(js_spine_ConstraintData_getName)); 
    cls->defineFunction("getOrder", _SE(js_spine_ConstraintData_getOrder)); 
    cls->defineFunction("setOrder", _SE(js_spine_ConstraintData_setOrder)); 
    cls->defineFunction("isSkinRequired", _SE(js_spine_ConstraintData_isSkinRequired)); 
    cls->defineFunction("setSkinRequired", _SE(js_spine_ConstraintData_setSkinRequired)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_ConstraintData));
    
    
    cls->install();
    JSBClassType::registerClass<spine::ConstraintData>(cls);
    
    __jsb_spine_ConstraintData_proto = cls->getProto();
    __jsb_spine_ConstraintData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_VertexEffectDelegate_class = nullptr;
se::Object* __jsb_spine_VertexEffectDelegate_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_VertexEffectDelegate) 

static bool js_new_spine_VertexEffectDelegate(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    spine::VertexEffectDelegate *result;
    result = (spine::VertexEffectDelegate *)new spine::VertexEffectDelegate();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_spine_VertexEffectDelegate, __jsb_spine_VertexEffectDelegate_class, js_delete_spine_VertexEffectDelegate)

static bool js_delete_spine_VertexEffectDelegate(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_VertexEffectDelegate) 

static bool js_spine_VertexEffectDelegate_initJitter(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexEffectDelegate *arg1 = (spine::VertexEffectDelegate *) NULL ;
    float arg2 ;
    float arg3 ;
    spine::JitterVertexEffect *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexEffectDelegate>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::JitterVertexEffect *)(arg1)->initJitter(arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexEffectDelegate_initJitter) 

static bool js_spine_VertexEffectDelegate_initSwirlWithPow(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexEffectDelegate *arg1 = (spine::VertexEffectDelegate *) NULL ;
    float arg2 ;
    int arg3 ;
    spine::SwirlVertexEffect *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexEffectDelegate>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::SwirlVertexEffect *)(arg1)->initSwirlWithPow(arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexEffectDelegate_initSwirlWithPow) 

static bool js_spine_VertexEffectDelegate_initSwirlWithPowOut(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexEffectDelegate *arg1 = (spine::VertexEffectDelegate *) NULL ;
    float arg2 ;
    int arg3 ;
    spine::SwirlVertexEffect *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexEffectDelegate>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::SwirlVertexEffect *)(arg1)->initSwirlWithPowOut(arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexEffectDelegate_initSwirlWithPowOut) 

static bool js_spine_VertexEffectDelegate_getVertexEffect(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexEffectDelegate *arg1 = (spine::VertexEffectDelegate *) NULL ;
    spine::VertexEffect *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexEffectDelegate>(s);
    if (nullptr == arg1) return true;
    result = (spine::VertexEffect *)(arg1)->getVertexEffect();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexEffectDelegate_getVertexEffect) 

static bool js_spine_VertexEffectDelegate_getJitterVertexEffect(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexEffectDelegate *arg1 = (spine::VertexEffectDelegate *) NULL ;
    spine::JitterVertexEffect *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexEffectDelegate>(s);
    if (nullptr == arg1) return true;
    result = (spine::JitterVertexEffect *)(arg1)->getJitterVertexEffect();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexEffectDelegate_getJitterVertexEffect) 

static bool js_spine_VertexEffectDelegate_getSwirlVertexEffect(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexEffectDelegate *arg1 = (spine::VertexEffectDelegate *) NULL ;
    spine::SwirlVertexEffect *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexEffectDelegate>(s);
    if (nullptr == arg1) return true;
    result = (spine::SwirlVertexEffect *)(arg1)->getSwirlVertexEffect();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexEffectDelegate_getSwirlVertexEffect) 

static bool js_spine_VertexEffectDelegate_getEffectType(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexEffectDelegate *arg1 = (spine::VertexEffectDelegate *) NULL ;
    std::string *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexEffectDelegate>(s);
    if (nullptr == arg1) return true;
    result = (std::string *) &((spine::VertexEffectDelegate const *)arg1)->getEffectType();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexEffectDelegate_getEffectType) 

static bool js_spine_VertexEffectDelegate_clear(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexEffectDelegate *arg1 = (spine::VertexEffectDelegate *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexEffectDelegate>(s);
    if (nullptr == arg1) return true;
    (arg1)->clear();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexEffectDelegate_clear) 

bool js_register_spine_VertexEffectDelegate(se::Object* obj) {
    auto* cls = se::Class::create("VertexEffectDelegate", obj, nullptr, _SE(js_new_spine_VertexEffectDelegate)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("initJitter", _SE(js_spine_VertexEffectDelegate_initJitter)); 
    cls->defineFunction("initSwirlWithPow", _SE(js_spine_VertexEffectDelegate_initSwirlWithPow)); 
    cls->defineFunction("initSwirlWithPowOut", _SE(js_spine_VertexEffectDelegate_initSwirlWithPowOut)); 
    cls->defineFunction("getVertexEffect", _SE(js_spine_VertexEffectDelegate_getVertexEffect)); 
    cls->defineFunction("getJitterVertexEffect", _SE(js_spine_VertexEffectDelegate_getJitterVertexEffect)); 
    cls->defineFunction("getSwirlVertexEffect", _SE(js_spine_VertexEffectDelegate_getSwirlVertexEffect)); 
    cls->defineFunction("getEffectType", _SE(js_spine_VertexEffectDelegate_getEffectType)); 
    cls->defineFunction("clear", _SE(js_spine_VertexEffectDelegate_clear)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_VertexEffectDelegate));
    
    
    cls->install();
    JSBClassType::registerClass<spine::VertexEffectDelegate>(cls);
    
    __jsb_spine_VertexEffectDelegate_proto = cls->getProto();
    __jsb_spine_VertexEffectDelegate_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_SkeletonRenderer_class = nullptr;
se::Object* __jsb_spine_SkeletonRenderer_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_SkeletonRenderer) 

static bool js_spine_SkeletonRenderer_create_static__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    std::string *arg1 = 0 ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp1 ;
    std::string temp2 ;
    spine::SkeletonRenderer *result = 0 ;
    
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::SkeletonRenderer *)spine::SkeletonRenderer::createWithFile((std::string const &)*arg1,(std::string const &)*arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonRenderer_create_static__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    std::string *arg1 = 0 ;
    std::string *arg2 = 0 ;
    std::string temp1 ;
    std::string temp2 ;
    spine::SkeletonRenderer *result = 0 ;
    
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (spine::SkeletonRenderer *)spine::SkeletonRenderer::createWithFile((std::string const &)*arg1,(std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonRenderer_create_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_spine_SkeletonRenderer_create_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_spine_SkeletonRenderer_create_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_create_static) 

static bool js_spine_SkeletonRenderer_update(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->update(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_update) 

static bool js_spine_SkeletonRenderer_render(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->render(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_render) 

static bool js_spine_SkeletonRenderer_getBoundingBox(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    cc::Rect result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    result = ((spine::SkeletonRenderer const *)arg1)->getBoundingBox();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_getBoundingBox) 

static bool js_spine_SkeletonRenderer_getSkeleton(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    spine::Skeleton *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    result = (spine::Skeleton *)((spine::SkeletonRenderer const *)arg1)->getSkeleton();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_getSkeleton) 

static bool js_spine_SkeletonRenderer_setTimeScale(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setTimeScale(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setTimeScale) 

static bool js_spine_SkeletonRenderer_getTimeScale(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    result = (float)((spine::SkeletonRenderer const *)arg1)->getTimeScale();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_getTimeScale) 

static bool js_spine_SkeletonRenderer_updateWorldTransform(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    (arg1)->updateWorldTransform();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_updateWorldTransform) 

static bool js_spine_SkeletonRenderer_setToSetupPose(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    (arg1)->setToSetupPose();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setToSetupPose) 

static bool js_spine_SkeletonRenderer_setBonesToSetupPose(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    (arg1)->setBonesToSetupPose();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setBonesToSetupPose) 

static bool js_spine_SkeletonRenderer_setSlotsToSetupPose(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    (arg1)->setSlotsToSetupPose();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setSlotsToSetupPose) 

static bool js_spine_SkeletonRenderer_paused(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->paused(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_paused) 

static bool js_spine_SkeletonRenderer_findBone(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    spine::Bone *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (spine::Bone *)((spine::SkeletonRenderer const *)arg1)->findBone((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_findBone) 

static bool js_spine_SkeletonRenderer_findSlot(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    spine::Slot *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (spine::Slot *)((spine::SkeletonRenderer const *)arg1)->findSlot((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_findSlot) 

static bool js_spine_SkeletonRenderer_setSkin__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setSkin((std::string const &)*arg2);
    
    
    return true;
}

static bool js_spine_SkeletonRenderer_setSkin__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    char *arg2 = (char *) NULL ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = (char *) temp2.c_str(); 
    (arg1)->setSkin((char const *)arg2);
    
    
    return true;
}

static bool js_spine_SkeletonRenderer_setSkin(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_spine_SkeletonRenderer_setSkin__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_spine_SkeletonRenderer_setSkin__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setSkin) 

static bool js_spine_SkeletonRenderer_getAttachment(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    spine::Attachment *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    result = (spine::Attachment *)((spine::SkeletonRenderer const *)arg1)->getAttachment((std::string const &)*arg2,(std::string const &)*arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_getAttachment) 

static bool js_spine_SkeletonRenderer_setAttachment__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    result = (bool)(arg1)->setAttachment((std::string const &)*arg2,(std::string const &)*arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}

static bool js_spine_SkeletonRenderer_setAttachment__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    std::string *arg2 = 0 ;
    char *arg3 = (char *) NULL ;
    std::string temp2 ;
    ccstd::string temp3 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = (char *) temp3.c_str(); 
    result = (bool)(arg1)->setAttachment((std::string const &)*arg2,(char const *)arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}

static bool js_spine_SkeletonRenderer_setAttachment(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_spine_SkeletonRenderer_setAttachment__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_spine_SkeletonRenderer_setAttachment__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setAttachment) 

static bool js_spine_SkeletonRenderer_setUseTint(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setUseTint(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setUseTint) 

static bool js_spine_SkeletonRenderer_setVertexEffectDelegate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    spine::VertexEffectDelegate *arg2 = (spine::VertexEffectDelegate *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setVertexEffectDelegate(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setVertexEffectDelegate) 

static bool js_spine_SkeletonRenderer_setSlotsRange(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    int arg2 ;
    int arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setSlotsRange(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setSlotsRange) 

static bool js_spine_SkeletonRenderer_getDebugData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    se_object_ptr result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    result = ((spine::SkeletonRenderer const *)arg1)->getDebugData();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_getDebugData) 

static bool js_spine_SkeletonRenderer_getSharedBufferOffset(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    se_object_ptr result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    result = ((spine::SkeletonRenderer const *)arg1)->getSharedBufferOffset();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_getSharedBufferOffset) 

static bool js_spine_SkeletonRenderer_setColor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setColor(arg2,arg3,arg4,arg5);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setColor) 

static bool js_spine_SkeletonRenderer_setBatchEnabled(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setBatchEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setBatchEnabled) 

static bool js_spine_SkeletonRenderer_setDebugBonesEnabled(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setDebugBonesEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setDebugBonesEnabled) 

static bool js_spine_SkeletonRenderer_setDebugSlotsEnabled(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setDebugSlotsEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setDebugSlotsEnabled) 

static bool js_spine_SkeletonRenderer_setDebugMeshEnabled(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setDebugMeshEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setDebugMeshEnabled) 

static bool js_spine_SkeletonRenderer_setAttachEnabled(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAttachEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setAttachEnabled) 

static bool js_spine_SkeletonRenderer_setOpacityModifyRGB(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setOpacityModifyRGB(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setOpacityModifyRGB) 

static bool js_spine_SkeletonRenderer_isOpacityModifyRGB(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    result = (bool)((spine::SkeletonRenderer const *)arg1)->isOpacityModifyRGB();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_isOpacityModifyRGB) 

static bool js_spine_SkeletonRenderer_beginSchedule(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    (arg1)->beginSchedule();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_beginSchedule) 

static bool js_spine_SkeletonRenderer_stopSchedule(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    (arg1)->stopSchedule();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_stopSchedule) 

static bool js_spine_SkeletonRenderer_onEnable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_onEnable) 

static bool js_spine_SkeletonRenderer_onDisable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_onDisable) 

static bool js_new_spine_SkeletonRenderer__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    spine::SkeletonRenderer *result;
    result = (spine::SkeletonRenderer *)new spine::SkeletonRenderer();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_spine_SkeletonRenderer__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    bool arg2 ;
    bool arg3 ;
    bool arg4 ;
    spine::SkeletonRenderer *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg3);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg4);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::SkeletonRenderer *)new spine::SkeletonRenderer(arg1,arg2,arg3,arg4);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_spine_SkeletonRenderer__SWIG_2(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    bool arg2 ;
    bool arg3 ;
    spine::SkeletonRenderer *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg3);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::SkeletonRenderer *)new spine::SkeletonRenderer(arg1,arg2,arg3);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_spine_SkeletonRenderer__SWIG_3(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    bool arg2 ;
    spine::SkeletonRenderer *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::SkeletonRenderer *)new spine::SkeletonRenderer(arg1,arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_spine_SkeletonRenderer__SWIG_4(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::SkeletonRenderer *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::SkeletonRenderer *)new spine::SkeletonRenderer(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_spine_SkeletonRenderer__SWIG_5(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    bool arg2 ;
    spine::SkeletonRenderer *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::SkeletonRenderer *)new spine::SkeletonRenderer(arg1,arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_spine_SkeletonRenderer__SWIG_6(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::SkeletonRenderer *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::SkeletonRenderer *)new spine::SkeletonRenderer(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_spine_SkeletonRenderer__SWIG_7(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    std::string *arg1 = 0 ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp1 ;
    std::string temp2 ;
    spine::SkeletonRenderer *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::SkeletonRenderer *)new spine::SkeletonRenderer((std::string const &)*arg1,(std::string const &)*arg2,arg3);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_spine_SkeletonRenderer__SWIG_8(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    std::string *arg1 = 0 ;
    std::string *arg2 = 0 ;
    std::string temp1 ;
    std::string temp2 ;
    spine::SkeletonRenderer *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (spine::SkeletonRenderer *)new spine::SkeletonRenderer((std::string const &)*arg1,(std::string const &)*arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_SkeletonRenderer(se::State& s) // NOLINT(readability-identifier-naming)
{
    size_t argc = s.args().size();
    bool ret = false;
    
    if(argc == 0) {
        ret = js_new_spine_SkeletonRenderer__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 4) {
        ret = js_new_spine_SkeletonRenderer__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 3) {
        ret = js_new_spine_SkeletonRenderer__SWIG_2(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 2) {
        ret = js_new_spine_SkeletonRenderer__SWIG_3(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 1) {
        ret = js_new_spine_SkeletonRenderer__SWIG_4(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 2) {
        ret = js_new_spine_SkeletonRenderer__SWIG_5(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 1) {
        ret = js_new_spine_SkeletonRenderer__SWIG_6(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 3) {
        ret = js_new_spine_SkeletonRenderer__SWIG_7(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 2) {
        ret = js_new_spine_SkeletonRenderer__SWIG_8(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    SE_REPORT_ERROR("Illegal arguments for construction of SkeletonRenderer");
    return false;
}
SE_BIND_CTOR(js_new_SkeletonRenderer, __jsb_spine_SkeletonRenderer_class, js_delete_spine_SkeletonRenderer)

static bool js_delete_spine_SkeletonRenderer(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_SkeletonRenderer) 

static bool js_spine_SkeletonRenderer_initWithUUID(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->initWithUUID((std::string const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_initWithUUID) 

static bool js_spine_SkeletonRenderer_initWithSkeleton__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    spine::Skeleton *arg2 = (spine::Skeleton *) NULL ;
    bool arg3 ;
    bool arg4 ;
    bool arg5 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->initWithSkeleton(arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_spine_SkeletonRenderer_initWithSkeleton__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    spine::Skeleton *arg2 = (spine::Skeleton *) NULL ;
    bool arg3 ;
    bool arg4 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->initWithSkeleton(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_spine_SkeletonRenderer_initWithSkeleton__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    spine::Skeleton *arg2 = (spine::Skeleton *) NULL ;
    bool arg3 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->initWithSkeleton(arg2,arg3);
    
    
    return true;
}

static bool js_spine_SkeletonRenderer_initWithSkeleton__SWIG_3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    spine::Skeleton *arg2 = (spine::Skeleton *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->initWithSkeleton(arg2);
    
    
    return true;
}

static bool js_spine_SkeletonRenderer_initWithSkeleton(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 4) {
        ok = js_spine_SkeletonRenderer_initWithSkeleton__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 3) {
        ok = js_spine_SkeletonRenderer_initWithSkeleton__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_spine_SkeletonRenderer_initWithSkeleton__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_spine_SkeletonRenderer_initWithSkeleton__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_initWithSkeleton) 

static bool js_spine_SkeletonRenderer_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    (arg1)->initialize();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_initialize) 

static bool js_spine_SkeletonRenderer_setMaterial(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    cc::Material *arg2 = (cc::Material *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setMaterial(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setMaterial) 

static bool js_spine_SkeletonRenderer_setRenderEntity(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    cc::RenderEntity *arg2 = (cc::RenderEntity *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRenderEntity(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setRenderEntity) 

bool js_register_spine_SkeletonRenderer(se::Object* obj) {
    auto* cls = se::Class::create("SkeletonRenderer", obj, nullptr, _SE(js_new_SkeletonRenderer)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("update", _SE(js_spine_SkeletonRenderer_update)); 
    cls->defineFunction("render", _SE(js_spine_SkeletonRenderer_render)); 
    cls->defineFunction("getBoundingBox", _SE(js_spine_SkeletonRenderer_getBoundingBox)); 
    cls->defineFunction("getSkeleton", _SE(js_spine_SkeletonRenderer_getSkeleton)); 
    cls->defineFunction("setTimeScale", _SE(js_spine_SkeletonRenderer_setTimeScale)); 
    cls->defineFunction("getTimeScale", _SE(js_spine_SkeletonRenderer_getTimeScale)); 
    cls->defineFunction("updateWorldTransform", _SE(js_spine_SkeletonRenderer_updateWorldTransform)); 
    cls->defineFunction("setToSetupPose", _SE(js_spine_SkeletonRenderer_setToSetupPose)); 
    cls->defineFunction("setBonesToSetupPose", _SE(js_spine_SkeletonRenderer_setBonesToSetupPose)); 
    cls->defineFunction("setSlotsToSetupPose", _SE(js_spine_SkeletonRenderer_setSlotsToSetupPose)); 
    cls->defineFunction("paused", _SE(js_spine_SkeletonRenderer_paused)); 
    cls->defineFunction("findBone", _SE(js_spine_SkeletonRenderer_findBone)); 
    cls->defineFunction("findSlot", _SE(js_spine_SkeletonRenderer_findSlot)); 
    cls->defineFunction("setSkin", _SE(js_spine_SkeletonRenderer_setSkin)); 
    cls->defineFunction("getAttachment", _SE(js_spine_SkeletonRenderer_getAttachment)); 
    cls->defineFunction("setAttachment", _SE(js_spine_SkeletonRenderer_setAttachment)); 
    cls->defineFunction("setUseTint", _SE(js_spine_SkeletonRenderer_setUseTint)); 
    cls->defineFunction("setVertexEffectDelegate", _SE(js_spine_SkeletonRenderer_setVertexEffectDelegate)); 
    cls->defineFunction("setSlotsRange", _SE(js_spine_SkeletonRenderer_setSlotsRange)); 
    cls->defineFunction("getDebugData", _SE(js_spine_SkeletonRenderer_getDebugData)); 
    cls->defineFunction("getSharedBufferOffset", _SE(js_spine_SkeletonRenderer_getSharedBufferOffset)); 
    cls->defineFunction("setColor", _SE(js_spine_SkeletonRenderer_setColor)); 
    cls->defineFunction("setBatchEnabled", _SE(js_spine_SkeletonRenderer_setBatchEnabled)); 
    cls->defineFunction("setDebugBonesEnabled", _SE(js_spine_SkeletonRenderer_setDebugBonesEnabled)); 
    cls->defineFunction("setDebugSlotsEnabled", _SE(js_spine_SkeletonRenderer_setDebugSlotsEnabled)); 
    cls->defineFunction("setDebugMeshEnabled", _SE(js_spine_SkeletonRenderer_setDebugMeshEnabled)); 
    cls->defineFunction("setAttachEnabled", _SE(js_spine_SkeletonRenderer_setAttachEnabled)); 
    cls->defineFunction("setOpacityModifyRGB", _SE(js_spine_SkeletonRenderer_setOpacityModifyRGB)); 
    cls->defineFunction("isOpacityModifyRGB", _SE(js_spine_SkeletonRenderer_isOpacityModifyRGB)); 
    cls->defineFunction("beginSchedule", _SE(js_spine_SkeletonRenderer_beginSchedule)); 
    cls->defineFunction("stopSchedule", _SE(js_spine_SkeletonRenderer_stopSchedule)); 
    cls->defineFunction("onEnable", _SE(js_spine_SkeletonRenderer_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_spine_SkeletonRenderer_onDisable)); 
    cls->defineFunction("initWithUUID", _SE(js_spine_SkeletonRenderer_initWithUUID)); 
    cls->defineFunction("initWithSkeleton", _SE(js_spine_SkeletonRenderer_initWithSkeleton)); 
    cls->defineFunction("initialize", _SE(js_spine_SkeletonRenderer_initialize)); 
    cls->defineFunction("setMaterial", _SE(js_spine_SkeletonRenderer_setMaterial)); 
    cls->defineFunction("setRenderEntity", _SE(js_spine_SkeletonRenderer_setRenderEntity)); 
    
    
    cls->defineStaticFunction("create", _SE(js_spine_SkeletonRenderer_create_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_SkeletonRenderer));
    
    
    cls->install();
    JSBClassType::registerClass<spine::SkeletonRenderer>(cls);
    
    __jsb_spine_SkeletonRenderer_proto = cls->getProto();
    __jsb_spine_SkeletonRenderer_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_SkeletonAnimation_class = nullptr;
se::Object* __jsb_spine_SkeletonAnimation_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_SkeletonAnimation) 

static bool js_spine_SkeletonAnimation_createWithJsonFile_static__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    std::string *arg1 = 0 ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp1 ;
    std::string temp2 ;
    spine::SkeletonAnimation *result = 0 ;
    
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::SkeletonAnimation *)spine::SkeletonAnimation::createWithJsonFile((std::string const &)*arg1,(std::string const &)*arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonAnimation_createWithJsonFile_static__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    std::string *arg1 = 0 ;
    std::string *arg2 = 0 ;
    std::string temp1 ;
    std::string temp2 ;
    spine::SkeletonAnimation *result = 0 ;
    
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (spine::SkeletonAnimation *)spine::SkeletonAnimation::createWithJsonFile((std::string const &)*arg1,(std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonAnimation_createWithJsonFile_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_spine_SkeletonAnimation_createWithJsonFile_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_spine_SkeletonAnimation_createWithJsonFile_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_createWithJsonFile_static) 

static bool js_spine_SkeletonAnimation_createWithBinaryFile_static__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    std::string *arg1 = 0 ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp1 ;
    std::string temp2 ;
    spine::SkeletonAnimation *result = 0 ;
    
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::SkeletonAnimation *)spine::SkeletonAnimation::createWithBinaryFile((std::string const &)*arg1,(std::string const &)*arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonAnimation_createWithBinaryFile_static__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    std::string *arg1 = 0 ;
    std::string *arg2 = 0 ;
    std::string temp1 ;
    std::string temp2 ;
    spine::SkeletonAnimation *result = 0 ;
    
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (spine::SkeletonAnimation *)spine::SkeletonAnimation::createWithBinaryFile((std::string const &)*arg1,(std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonAnimation_createWithBinaryFile_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_spine_SkeletonAnimation_createWithBinaryFile_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_spine_SkeletonAnimation_createWithBinaryFile_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_createWithBinaryFile_static) 

static bool js_spine_SkeletonAnimation_setGlobalTimeScale_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float arg1 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    spine::SkeletonAnimation::setGlobalTimeScale(arg1);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setGlobalTimeScale_static) 

static bool js_spine_SkeletonAnimation_update(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->update(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_update) 

static bool js_spine_SkeletonAnimation_setAnimationStateData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::AnimationStateData *arg2 = (spine::AnimationStateData *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAnimationStateData(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setAnimationStateData) 

static bool js_spine_SkeletonAnimation_setMix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    float arg4 ;
    std::string temp2 ;
    std::string temp3 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setMix((std::string const &)*arg2,(std::string const &)*arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setMix) 

static bool js_spine_SkeletonAnimation_setAnimation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    int arg2 ;
    std::string *arg3 = 0 ;
    bool arg4 ;
    std::string temp3 ;
    spine::TrackEntry *result = 0 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::TrackEntry *)(arg1)->setAnimation(arg2,(std::string const &)*arg3,arg4);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setAnimation) 

static bool js_spine_SkeletonAnimation_addAnimation__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    int arg2 ;
    std::string *arg3 = 0 ;
    bool arg4 ;
    float arg5 ;
    std::string temp3 ;
    spine::TrackEntry *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::TrackEntry *)(arg1)->addAnimation(arg2,(std::string const &)*arg3,arg4,arg5);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonAnimation_addAnimation__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    int arg2 ;
    std::string *arg3 = 0 ;
    bool arg4 ;
    std::string temp3 ;
    spine::TrackEntry *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::TrackEntry *)(arg1)->addAnimation(arg2,(std::string const &)*arg3,arg4);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonAnimation_addAnimation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 4) {
        ok = js_spine_SkeletonAnimation_addAnimation__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 3) {
        ok = js_spine_SkeletonAnimation_addAnimation__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_addAnimation) 

static bool js_spine_SkeletonAnimation_setEmptyAnimation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    int arg2 ;
    float arg3 ;
    spine::TrackEntry *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::TrackEntry *)(arg1)->setEmptyAnimation(arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setEmptyAnimation) 

static bool js_spine_SkeletonAnimation_setEmptyAnimations(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setEmptyAnimations(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setEmptyAnimations) 

static bool js_spine_SkeletonAnimation_addEmptyAnimation__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    int arg2 ;
    float arg3 ;
    float arg4 ;
    spine::TrackEntry *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::TrackEntry *)(arg1)->addEmptyAnimation(arg2,arg3,arg4);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonAnimation_addEmptyAnimation__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    int arg2 ;
    float arg3 ;
    spine::TrackEntry *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::TrackEntry *)(arg1)->addEmptyAnimation(arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonAnimation_addEmptyAnimation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_spine_SkeletonAnimation_addEmptyAnimation__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_spine_SkeletonAnimation_addEmptyAnimation__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_addEmptyAnimation) 

static bool js_spine_SkeletonAnimation_findAnimation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    spine::Animation *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (spine::Animation *)((spine::SkeletonAnimation const *)arg1)->findAnimation((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_findAnimation) 

static bool js_spine_SkeletonAnimation_getCurrent__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    int arg2 ;
    spine::TrackEntry *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::TrackEntry *)(arg1)->getCurrent(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonAnimation_getCurrent__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::TrackEntry *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    result = (spine::TrackEntry *)(arg1)->getCurrent();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonAnimation_getCurrent(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_spine_SkeletonAnimation_getCurrent__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 0) {
        ok = js_spine_SkeletonAnimation_getCurrent__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_getCurrent) 

static bool js_spine_SkeletonAnimation_clearTracks(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    (arg1)->clearTracks();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_clearTracks) 

static bool js_spine_SkeletonAnimation_clearTrack__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    int arg2 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->clearTrack(arg2);
    
    
    return true;
}

static bool js_spine_SkeletonAnimation_clearTrack__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    (arg1)->clearTrack();
    
    
    return true;
}

static bool js_spine_SkeletonAnimation_clearTrack(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_spine_SkeletonAnimation_clearTrack__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 0) {
        ok = js_spine_SkeletonAnimation_clearTrack__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_clearTrack) 

static bool js_spine_SkeletonAnimation_setStartListener(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::StartListener *arg2 = 0 ;
    spine::StartListener temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setStartListener((spine::StartListener const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setStartListener) 

static bool js_spine_SkeletonAnimation_setInterruptListener(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::InterruptListener *arg2 = 0 ;
    spine::InterruptListener temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setInterruptListener((spine::InterruptListener const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setInterruptListener) 

static bool js_spine_SkeletonAnimation_setEndListener(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::EndListener *arg2 = 0 ;
    spine::EndListener temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setEndListener((spine::EndListener const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setEndListener) 

static bool js_spine_SkeletonAnimation_setDisposeListener(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::DisposeListener *arg2 = 0 ;
    spine::DisposeListener temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setDisposeListener((spine::DisposeListener const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setDisposeListener) 

static bool js_spine_SkeletonAnimation_setCompleteListenerNative(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::CompleteListener *arg2 = 0 ;
    spine::CompleteListener temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setCompleteListener((spine::CompleteListener const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setCompleteListenerNative) 

static bool js_spine_SkeletonAnimation_setEventListener(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::EventListener *arg2 = 0 ;
    spine::EventListener temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setEventListener((spine::EventListener const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setEventListener) 

static bool js_spine_SkeletonAnimation_setTrackStartListener(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::TrackEntry *arg2 = (spine::TrackEntry *) NULL ;
    spine::StartListener *arg3 = 0 ;
    spine::StartListener temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setTrackStartListener(arg2,(spine::StartListener const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setTrackStartListener) 

static bool js_spine_SkeletonAnimation_setTrackInterruptListener(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::TrackEntry *arg2 = (spine::TrackEntry *) NULL ;
    spine::InterruptListener *arg3 = 0 ;
    spine::InterruptListener temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setTrackInterruptListener(arg2,(spine::InterruptListener const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setTrackInterruptListener) 

static bool js_spine_SkeletonAnimation_setTrackEndListener(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::TrackEntry *arg2 = (spine::TrackEntry *) NULL ;
    spine::EndListener *arg3 = 0 ;
    spine::EndListener temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setTrackEndListener(arg2,(spine::EndListener const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setTrackEndListener) 

static bool js_spine_SkeletonAnimation_setTrackDisposeListener(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::TrackEntry *arg2 = (spine::TrackEntry *) NULL ;
    spine::DisposeListener *arg3 = 0 ;
    spine::DisposeListener temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setTrackDisposeListener(arg2,(spine::DisposeListener const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setTrackDisposeListener) 

static bool js_spine_SkeletonAnimation_setTrackCompleteListenerNative(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::TrackEntry *arg2 = (spine::TrackEntry *) NULL ;
    spine::CompleteListener *arg3 = 0 ;
    spine::CompleteListener temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setTrackCompleteListener(arg2,(spine::CompleteListener const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setTrackCompleteListenerNative) 

static bool js_spine_SkeletonAnimation_setTrackEventListener(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::TrackEntry *arg2 = (spine::TrackEntry *) NULL ;
    spine::EventListener *arg3 = 0 ;
    spine::EventListener temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setTrackEventListener(arg2,(spine::EventListener const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setTrackEventListener) 

static bool js_spine_SkeletonAnimation_getState(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::AnimationState *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    if (nullptr == arg1) return true;
    result = (spine::AnimationState *)((spine::SkeletonAnimation const *)arg1)->getState();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_getState) 

static bool js_new_spine_SkeletonAnimation(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    spine::SkeletonAnimation *result;
    result = (spine::SkeletonAnimation *)new spine::SkeletonAnimation();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_spine_SkeletonAnimation, __jsb_spine_SkeletonAnimation_class, js_delete_spine_SkeletonAnimation)

static bool js_delete_spine_SkeletonAnimation(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_SkeletonAnimation) 

static bool js_spine_SkeletonAnimation_GlobalTimeScale_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float arg1 ;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    spine::SkeletonAnimation::GlobalTimeScale = arg1;
    
    
    return true;
}
SE_BIND_PROP_SET(js_spine_SkeletonAnimation_GlobalTimeScale_set) 

static bool js_spine_SkeletonAnimation_GlobalTimeScale_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    float result;
    
    result = (float)spine::SkeletonAnimation::GlobalTimeScale;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_SkeletonAnimation_GlobalTimeScale_get) 

bool js_register_spine_SkeletonAnimation(se::Object* obj) {
    auto* cls = se::Class::create("SkeletonAnimation", obj, __jsb_spine_SkeletonRenderer_proto, _SE(js_new_spine_SkeletonAnimation)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("update", _SE(js_spine_SkeletonAnimation_update)); 
    cls->defineFunction("setAnimationStateData", _SE(js_spine_SkeletonAnimation_setAnimationStateData)); 
    cls->defineFunction("setMix", _SE(js_spine_SkeletonAnimation_setMix)); 
    cls->defineFunction("setAnimation", _SE(js_spine_SkeletonAnimation_setAnimation)); 
    cls->defineFunction("addAnimation", _SE(js_spine_SkeletonAnimation_addAnimation)); 
    cls->defineFunction("setEmptyAnimation", _SE(js_spine_SkeletonAnimation_setEmptyAnimation)); 
    cls->defineFunction("setEmptyAnimations", _SE(js_spine_SkeletonAnimation_setEmptyAnimations)); 
    cls->defineFunction("addEmptyAnimation", _SE(js_spine_SkeletonAnimation_addEmptyAnimation)); 
    cls->defineFunction("findAnimation", _SE(js_spine_SkeletonAnimation_findAnimation)); 
    cls->defineFunction("getCurrent", _SE(js_spine_SkeletonAnimation_getCurrent)); 
    cls->defineFunction("clearTracks", _SE(js_spine_SkeletonAnimation_clearTracks)); 
    cls->defineFunction("clearTrack", _SE(js_spine_SkeletonAnimation_clearTrack)); 
    cls->defineFunction("setStartListener", _SE(js_spine_SkeletonAnimation_setStartListener)); 
    cls->defineFunction("setInterruptListener", _SE(js_spine_SkeletonAnimation_setInterruptListener)); 
    cls->defineFunction("setEndListener", _SE(js_spine_SkeletonAnimation_setEndListener)); 
    cls->defineFunction("setDisposeListener", _SE(js_spine_SkeletonAnimation_setDisposeListener)); 
    cls->defineFunction("setCompleteListenerNative", _SE(js_spine_SkeletonAnimation_setCompleteListenerNative)); 
    cls->defineFunction("setEventListener", _SE(js_spine_SkeletonAnimation_setEventListener)); 
    cls->defineFunction("setTrackStartListener", _SE(js_spine_SkeletonAnimation_setTrackStartListener)); 
    cls->defineFunction("setTrackInterruptListener", _SE(js_spine_SkeletonAnimation_setTrackInterruptListener)); 
    cls->defineFunction("setTrackEndListener", _SE(js_spine_SkeletonAnimation_setTrackEndListener)); 
    cls->defineFunction("setTrackDisposeListener", _SE(js_spine_SkeletonAnimation_setTrackDisposeListener)); 
    cls->defineFunction("setTrackCompleteListenerNative", _SE(js_spine_SkeletonAnimation_setTrackCompleteListenerNative)); 
    cls->defineFunction("setTrackEventListener", _SE(js_spine_SkeletonAnimation_setTrackEventListener)); 
    cls->defineFunction("getState", _SE(js_spine_SkeletonAnimation_getState)); 
    
    cls->defineStaticProperty("GlobalTimeScale", _SE(js_spine_SkeletonAnimation_GlobalTimeScale_get), _SE(js_spine_SkeletonAnimation_GlobalTimeScale_set)); 
    
    cls->defineStaticFunction("createWithJsonFile", _SE(js_spine_SkeletonAnimation_createWithJsonFile_static)); 
    cls->defineStaticFunction("createWithBinaryFile", _SE(js_spine_SkeletonAnimation_createWithBinaryFile_static)); 
    cls->defineStaticFunction("setGlobalTimeScale", _SE(js_spine_SkeletonAnimation_setGlobalTimeScale_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_SkeletonAnimation));
    
    
    cls->install();
    JSBClassType::registerClass<spine::SkeletonAnimation>(cls);
    
    __jsb_spine_SkeletonAnimation_proto = cls->getProto();
    __jsb_spine_SkeletonAnimation_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_SkeletonDataMgr_class = nullptr;
se::Object* __jsb_spine_SkeletonDataMgr_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_SkeletonDataMgr) 

static bool js_spine_SkeletonDataMgr_getInstance_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonDataMgr *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (spine::SkeletonDataMgr *)spine::SkeletonDataMgr::getInstance();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonDataMgr_getInstance_static) 

static bool js_new_spine_SkeletonDataMgr(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    spine::SkeletonDataMgr *result;
    result = (spine::SkeletonDataMgr *)new spine::SkeletonDataMgr();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_spine_SkeletonDataMgr, __jsb_spine_SkeletonDataMgr_class, js_delete_spine_SkeletonDataMgr)

static bool js_delete_spine_SkeletonDataMgr(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_SkeletonDataMgr) 

static bool js_spine_SkeletonDataMgr_setDestroyCallback(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonDataMgr *arg1 = (spine::SkeletonDataMgr *) NULL ;
    spine::SkeletonDataMgr::destroyCallback arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonDataMgr>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->setDestroyCallback(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonDataMgr_setDestroyCallback) 

bool js_register_spine_SkeletonDataMgr(se::Object* obj) {
    auto* cls = se::Class::create("SkeletonDataMgr", obj, nullptr, _SE(js_new_spine_SkeletonDataMgr)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("setDestroyCallback", _SE(js_spine_SkeletonDataMgr_setDestroyCallback)); 
    
    
    cls->defineStaticFunction("getInstance", _SE(js_spine_SkeletonDataMgr_getInstance_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_SkeletonDataMgr));
    
    
    cls->install();
    JSBClassType::registerClass<spine::SkeletonDataMgr>(cls);
    
    __jsb_spine_SkeletonDataMgr_proto = cls->getProto();
    __jsb_spine_SkeletonDataMgr_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_SkeletonCacheAnimation_class = nullptr;
se::Object* __jsb_spine_SkeletonCacheAnimation_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_SkeletonCacheAnimation) 

static bool js_new_spine_SkeletonCacheAnimation(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    
    std::string *arg1 = 0 ;
    bool arg2 ;
    std::string temp1 ;
    spine::SkeletonCacheAnimation *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    
    ok &= sevalue_to_native(args[1], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (spine::SkeletonCacheAnimation *)new spine::SkeletonCacheAnimation((std::string const &)*arg1,arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_spine_SkeletonCacheAnimation, __jsb_spine_SkeletonCacheAnimation_class, js_delete_spine_SkeletonCacheAnimation)

static bool js_delete_spine_SkeletonCacheAnimation(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_SkeletonCacheAnimation) 

static bool js_spine_SkeletonCacheAnimation_update(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->update(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_update) 

static bool js_spine_SkeletonCacheAnimation_getSkeleton(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    spine::Skeleton *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    result = (spine::Skeleton *)((spine::SkeletonCacheAnimation const *)arg1)->getSkeleton();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_getSkeleton) 

static bool js_spine_SkeletonCacheAnimation_setTimeScale(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setTimeScale(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setTimeScale) 

static bool js_spine_SkeletonCacheAnimation_getTimeScale(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    result = (float)((spine::SkeletonCacheAnimation const *)arg1)->getTimeScale();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_getTimeScale) 

static bool js_spine_SkeletonCacheAnimation_paused(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->paused(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_paused) 

static bool js_spine_SkeletonCacheAnimation_findBone(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    spine::Bone *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (spine::Bone *)((spine::SkeletonCacheAnimation const *)arg1)->findBone((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_findBone) 

static bool js_spine_SkeletonCacheAnimation_findSlot(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    spine::Slot *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (spine::Slot *)((spine::SkeletonCacheAnimation const *)arg1)->findSlot((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_findSlot) 

static bool js_spine_SkeletonCacheAnimation_setSkin__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setSkin((std::string const &)*arg2);
    
    
    return true;
}

static bool js_spine_SkeletonCacheAnimation_setSkin__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    char *arg2 = (char *) NULL ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = (char *) temp2.c_str(); 
    (arg1)->setSkin((char const *)arg2);
    
    
    return true;
}

static bool js_spine_SkeletonCacheAnimation_setSkin(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_spine_SkeletonCacheAnimation_setSkin__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_spine_SkeletonCacheAnimation_setSkin__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setSkin) 

static bool js_spine_SkeletonCacheAnimation_getAttachment(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    spine::Attachment *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    result = (spine::Attachment *)((spine::SkeletonCacheAnimation const *)arg1)->getAttachment((std::string const &)*arg2,(std::string const &)*arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_getAttachment) 

static bool js_spine_SkeletonCacheAnimation_setAttachment__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    result = (bool)(arg1)->setAttachment((std::string const &)*arg2,(std::string const &)*arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}

static bool js_spine_SkeletonCacheAnimation_setAttachment__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    std::string *arg2 = 0 ;
    char *arg3 = (char *) NULL ;
    std::string temp2 ;
    ccstd::string temp3 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = (char *) temp3.c_str(); 
    result = (bool)(arg1)->setAttachment((std::string const &)*arg2,(char const *)arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}

static bool js_spine_SkeletonCacheAnimation_setAttachment(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_spine_SkeletonCacheAnimation_setAttachment__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_spine_SkeletonCacheAnimation_setAttachment__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setAttachment) 

static bool js_spine_SkeletonCacheAnimation_setColor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setColor(arg2,arg3,arg4,arg5);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setColor) 

static bool js_spine_SkeletonCacheAnimation_setBatchEnabled(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setBatchEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setBatchEnabled) 

static bool js_spine_SkeletonCacheAnimation_setAttachEnabled(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAttachEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setAttachEnabled) 

static bool js_spine_SkeletonCacheAnimation_setOpacityModifyRGB(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setOpacityModifyRGB(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setOpacityModifyRGB) 

static bool js_spine_SkeletonCacheAnimation_isOpacityModifyRGB(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    result = (bool)((spine::SkeletonCacheAnimation const *)arg1)->isOpacityModifyRGB();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_isOpacityModifyRGB) 

static bool js_spine_SkeletonCacheAnimation_beginSchedule(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    (arg1)->beginSchedule();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_beginSchedule) 

static bool js_spine_SkeletonCacheAnimation_stopSchedule(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    (arg1)->stopSchedule();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_stopSchedule) 

static bool js_spine_SkeletonCacheAnimation_onEnable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_onEnable) 

static bool js_spine_SkeletonCacheAnimation_onDisable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_onDisable) 

static bool js_spine_SkeletonCacheAnimation_setUseTint(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setUseTint(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setUseTint) 

static bool js_spine_SkeletonCacheAnimation_setAnimation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    std::string *arg2 = 0 ;
    bool arg3 ;
    std::string temp2 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAnimation((std::string const &)*arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setAnimation) 

static bool js_spine_SkeletonCacheAnimation_addAnimation__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    std::string *arg2 = 0 ;
    bool arg3 ;
    float arg4 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addAnimation((std::string const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_spine_SkeletonCacheAnimation_addAnimation__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    std::string *arg2 = 0 ;
    bool arg3 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addAnimation((std::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_spine_SkeletonCacheAnimation_addAnimation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_spine_SkeletonCacheAnimation_addAnimation__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_spine_SkeletonCacheAnimation_addAnimation__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_addAnimation) 

static bool js_spine_SkeletonCacheAnimation_findAnimation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    spine::Animation *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (spine::Animation *)((spine::SkeletonCacheAnimation const *)arg1)->findAnimation((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_findAnimation) 

static bool js_spine_SkeletonCacheAnimation_setStartListener(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    spine::SkeletonCacheAnimation::CacheFrameEvent *arg2 = 0 ;
    spine::SkeletonCacheAnimation::CacheFrameEvent temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setStartListener((spine::SkeletonCacheAnimation::CacheFrameEvent const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setStartListener) 

static bool js_spine_SkeletonCacheAnimation_setEndListener(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    spine::SkeletonCacheAnimation::CacheFrameEvent *arg2 = 0 ;
    spine::SkeletonCacheAnimation::CacheFrameEvent temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setEndListener((spine::SkeletonCacheAnimation::CacheFrameEvent const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setEndListener) 

static bool js_spine_SkeletonCacheAnimation_setCompleteListener(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    spine::SkeletonCacheAnimation::CacheFrameEvent *arg2 = 0 ;
    spine::SkeletonCacheAnimation::CacheFrameEvent temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setCompleteListener((spine::SkeletonCacheAnimation::CacheFrameEvent const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setCompleteListener) 

static bool js_spine_SkeletonCacheAnimation_updateAnimationCache(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->updateAnimationCache((std::string const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_updateAnimationCache) 

static bool js_spine_SkeletonCacheAnimation_updateAllAnimationCache(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    (arg1)->updateAllAnimationCache();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_updateAllAnimationCache) 

static bool js_spine_SkeletonCacheAnimation_setToSetupPose(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    (arg1)->setToSetupPose();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setToSetupPose) 

static bool js_spine_SkeletonCacheAnimation_setBonesToSetupPose(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    (arg1)->setBonesToSetupPose();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setBonesToSetupPose) 

static bool js_spine_SkeletonCacheAnimation_setSlotsToSetupPose(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    (arg1)->setSlotsToSetupPose();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setSlotsToSetupPose) 

static bool js_spine_SkeletonCacheAnimation_getSharedBufferOffset(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    se_object_ptr result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    result = ((spine::SkeletonCacheAnimation const *)arg1)->getSharedBufferOffset();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_getSharedBufferOffset) 

static bool js_spine_SkeletonCacheAnimation_setMaterial(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    cc::Material *arg2 = (cc::Material *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setMaterial(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setMaterial) 

static bool js_spine_SkeletonCacheAnimation_setRenderEntity(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    cc::RenderEntity *arg2 = (cc::RenderEntity *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRenderEntity(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setRenderEntity) 

bool js_register_spine_SkeletonCacheAnimation(se::Object* obj) {
    auto* cls = se::Class::create("SkeletonCacheAnimation", obj, nullptr, _SE(js_new_spine_SkeletonCacheAnimation)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("update", _SE(js_spine_SkeletonCacheAnimation_update)); 
    cls->defineFunction("getSkeleton", _SE(js_spine_SkeletonCacheAnimation_getSkeleton)); 
    cls->defineFunction("setTimeScale", _SE(js_spine_SkeletonCacheAnimation_setTimeScale)); 
    cls->defineFunction("getTimeScale", _SE(js_spine_SkeletonCacheAnimation_getTimeScale)); 
    cls->defineFunction("paused", _SE(js_spine_SkeletonCacheAnimation_paused)); 
    cls->defineFunction("findBone", _SE(js_spine_SkeletonCacheAnimation_findBone)); 
    cls->defineFunction("findSlot", _SE(js_spine_SkeletonCacheAnimation_findSlot)); 
    cls->defineFunction("setSkin", _SE(js_spine_SkeletonCacheAnimation_setSkin)); 
    cls->defineFunction("getAttachment", _SE(js_spine_SkeletonCacheAnimation_getAttachment)); 
    cls->defineFunction("setAttachment", _SE(js_spine_SkeletonCacheAnimation_setAttachment)); 
    cls->defineFunction("setColor", _SE(js_spine_SkeletonCacheAnimation_setColor)); 
    cls->defineFunction("setBatchEnabled", _SE(js_spine_SkeletonCacheAnimation_setBatchEnabled)); 
    cls->defineFunction("setAttachEnabled", _SE(js_spine_SkeletonCacheAnimation_setAttachEnabled)); 
    cls->defineFunction("setOpacityModifyRGB", _SE(js_spine_SkeletonCacheAnimation_setOpacityModifyRGB)); 
    cls->defineFunction("isOpacityModifyRGB", _SE(js_spine_SkeletonCacheAnimation_isOpacityModifyRGB)); 
    cls->defineFunction("beginSchedule", _SE(js_spine_SkeletonCacheAnimation_beginSchedule)); 
    cls->defineFunction("stopSchedule", _SE(js_spine_SkeletonCacheAnimation_stopSchedule)); 
    cls->defineFunction("onEnable", _SE(js_spine_SkeletonCacheAnimation_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_spine_SkeletonCacheAnimation_onDisable)); 
    cls->defineFunction("setUseTint", _SE(js_spine_SkeletonCacheAnimation_setUseTint)); 
    cls->defineFunction("setAnimation", _SE(js_spine_SkeletonCacheAnimation_setAnimation)); 
    cls->defineFunction("addAnimation", _SE(js_spine_SkeletonCacheAnimation_addAnimation)); 
    cls->defineFunction("findAnimation", _SE(js_spine_SkeletonCacheAnimation_findAnimation)); 
    cls->defineFunction("setStartListener", _SE(js_spine_SkeletonCacheAnimation_setStartListener)); 
    cls->defineFunction("setEndListener", _SE(js_spine_SkeletonCacheAnimation_setEndListener)); 
    cls->defineFunction("setCompleteListener", _SE(js_spine_SkeletonCacheAnimation_setCompleteListener)); 
    cls->defineFunction("updateAnimationCache", _SE(js_spine_SkeletonCacheAnimation_updateAnimationCache)); 
    cls->defineFunction("updateAllAnimationCache", _SE(js_spine_SkeletonCacheAnimation_updateAllAnimationCache)); 
    cls->defineFunction("setToSetupPose", _SE(js_spine_SkeletonCacheAnimation_setToSetupPose)); 
    cls->defineFunction("setBonesToSetupPose", _SE(js_spine_SkeletonCacheAnimation_setBonesToSetupPose)); 
    cls->defineFunction("setSlotsToSetupPose", _SE(js_spine_SkeletonCacheAnimation_setSlotsToSetupPose)); 
    cls->defineFunction("getSharedBufferOffset", _SE(js_spine_SkeletonCacheAnimation_getSharedBufferOffset)); 
    cls->defineFunction("setMaterial", _SE(js_spine_SkeletonCacheAnimation_setMaterial)); 
    cls->defineFunction("setRenderEntity", _SE(js_spine_SkeletonCacheAnimation_setRenderEntity)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_SkeletonCacheAnimation));
    
    
    cls->install();
    JSBClassType::registerClass<spine::SkeletonCacheAnimation>(cls);
    
    __jsb_spine_SkeletonCacheAnimation_proto = cls->getProto();
    __jsb_spine_SkeletonCacheAnimation_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_SkeletonCacheMgr_class = nullptr;
se::Object* __jsb_spine_SkeletonCacheMgr_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_SkeletonCacheMgr) 

static bool js_spine_SkeletonCacheMgr_getInstance_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheMgr *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (spine::SkeletonCacheMgr *)spine::SkeletonCacheMgr::getInstance();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheMgr_getInstance_static) 

static bool js_spine_SkeletonCacheMgr_destroyInstance_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    spine::SkeletonCacheMgr::destroyInstance();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheMgr_destroyInstance_static) 

static bool js_spine_SkeletonCacheMgr_removeSkeletonCache(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheMgr *arg1 = (spine::SkeletonCacheMgr *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheMgr>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->removeSkeletonCache((std::string const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheMgr_removeSkeletonCache) 

static bool js_spine_SkeletonCacheMgr_buildSkeletonCache(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheMgr *arg1 = (spine::SkeletonCacheMgr *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    SkeletonCache *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheMgr>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (SkeletonCache *)(arg1)->buildSkeletonCache((std::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheMgr_buildSkeletonCache) 

static bool js_new_spine_SkeletonCacheMgr(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    spine::SkeletonCacheMgr *result;
    result = (spine::SkeletonCacheMgr *)new spine::SkeletonCacheMgr();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_spine_SkeletonCacheMgr, __jsb_spine_SkeletonCacheMgr_class, js_delete_spine_SkeletonCacheMgr)

static bool js_delete_spine_SkeletonCacheMgr(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_SkeletonCacheMgr) 

bool js_register_spine_SkeletonCacheMgr(se::Object* obj) {
    auto* cls = se::Class::create("SkeletonCacheMgr", obj, nullptr, _SE(js_new_spine_SkeletonCacheMgr)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("removeSkeletonCache", _SE(js_spine_SkeletonCacheMgr_removeSkeletonCache)); 
    cls->defineFunction("buildSkeletonCache", _SE(js_spine_SkeletonCacheMgr_buildSkeletonCache)); 
    
    
    cls->defineStaticFunction("getInstance", _SE(js_spine_SkeletonCacheMgr_getInstance_static)); 
    cls->defineStaticFunction("destroyInstance", _SE(js_spine_SkeletonCacheMgr_destroyInstance_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_SkeletonCacheMgr));
    
    
    cls->install();
    JSBClassType::registerClass<spine::SkeletonCacheMgr>(cls);
    
    __jsb_spine_SkeletonCacheMgr_proto = cls->getProto();
    __jsb_spine_SkeletonCacheMgr_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}




bool register_all_spine(se::Object* obj) {
    // Get the ns
    se::Value nsVal;
    if (!obj->getProperty("spine", &nsVal, true))
    {
        se::HandleObject jsobj(se::Object::createPlainObject());
        nsVal.setObject(jsobj);
        obj->setProperty("spine", nsVal);
    }
    se::Object* ns = nsVal.toObject();
    /* Register classes */
    js_register_spine_Timeline(ns); 
    js_register_spine_Animation(ns); 
    js_register_spine_AnimationStateListenerObject(ns); 
    js_register_spine_TrackEntry(ns); 
    js_register_spine_EventQueueEntry(ns); 
    js_register_spine_EventQueue(ns); 
    js_register_spine_AnimationState(ns); 
    js_register_spine_AnimationStateData(ns); 
    js_register_spine_Attachment(ns); 
    js_register_spine_AttachmentTimeline(ns); 
    js_register_spine_BoundingBoxAttachment(ns); 
    js_register_spine_Bone(ns); 
    js_register_spine_BoneData(ns); 
    js_register_spine_ClippingAttachment(ns); 
    js_register_spine_Color(ns); 
    js_register_spine_ColorTimeline(ns); 
    js_register_spine_CurveTimeline(ns); 
    js_register_spine_DeformTimeline(ns); 
    js_register_spine_DrawOrderTimeline(ns); 
    js_register_spine_Event(ns); 
    js_register_spine_EventData(ns); 
    js_register_spine_EventTimeline(ns); 
    js_register_spine_IkConstraint(ns); 
    js_register_spine_IkConstraintData(ns); 
    js_register_spine_IkConstraintTimeline(ns); 
    js_register_spine_MeshAttachment(ns); 
    js_register_spine_PathAttachment(ns); 
    js_register_spine_PathConstraint(ns); 
    js_register_spine_PathConstraintData(ns); 
    js_register_spine_PathConstraintMixTimeline(ns); 
    js_register_spine_PathConstraintPositionTimeline(ns); 
    js_register_spine_PathConstraintSpacingTimeline(ns); 
    js_register_spine_PointAttachment(ns); 
    js_register_spine_RegionAttachment(ns); 
    js_register_spine_RotateTimeline(ns); 
    js_register_spine_ScaleTimeline(ns); 
    js_register_spine_ShearTimeline(ns); 
    js_register_spine_Skeleton(ns); 
    js_register_spine_Slot(ns); 
    js_register_spine_Skin(ns); 
    js_register_spine_SkeletonBounds(ns); 
    js_register_spine_Polygon(ns); 
    js_register_spine_SkeletonData(ns); 
    js_register_spine_SlotData(ns); 
    js_register_spine_TransformConstraint(ns); 
    js_register_spine_TransformConstraintData(ns); 
    js_register_spine_TransformConstraintTimeline(ns); 
    js_register_spine_TranslateTimeline(ns); 
    js_register_spine_TwoColorTimeline(ns); 
    js_register_spine_VertexAttachment(ns); 
    js_register_spine_VertexEffect(ns); 
    js_register_spine_JitterVertexEffect(ns); 
    js_register_spine_SwirlVertexEffect(ns); 
    js_register_spine_ConstraintData(ns); 
    js_register_spine_VertexEffectDelegate(ns); 
    js_register_spine_SkeletonRenderer(ns); 
    js_register_spine_SkeletonAnimation(ns); 
    js_register_spine_SkeletonDataMgr(ns); 
    js_register_spine_SkeletonCacheAnimation(ns); 
    js_register_spine_SkeletonCacheMgr(ns); 
    
    /* Register global variables & global functions */
    
    
    
    return true;
}


#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif
// clang-format on
