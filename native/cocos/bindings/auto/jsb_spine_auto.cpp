// clang-format off

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.1.0
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

/****************************************************************************
 Copyright (c) 2022 Xiamen Yaji Software Co., Ltd.

 http://www.cocos.com

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated engine source code (the "Software"), a limited,
 worldwide, royalty-free, non-assignable, revocable and non-exclusive license
 to use Cocos Creator solely to develop games on your target platforms. You shall
 not use Cocos Creator software for developing other software or tools that's
 used for developing games. You are not granted to publish, distribute,
 sublicense, and/or sell copies of Cocos Creator.

 The software or tools in this License Agreement are licensed, not sold.
 Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
****************************************************************************/

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static 
#endif



#include <stdio.h>


#include "bindings/jswrapper/SeApi.h"
#include "bindings/manual/jsb_conversions.h"
#include "bindings/manual/jsb_global.h"


#include "bindings/auto/jsb_spine_auto.h"
using namespace spine;



se::Class* __jsb_spine_Timeline_class = nullptr;
se::Object* __jsb_spine_Timeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_Timeline) 

static bool js_delete_spine_Timeline(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_Timeline) 

static bool js_spine_Timeline_getPropertyId(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Timeline *arg1 = (spine::Timeline *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Timeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)(arg1)->getPropertyId();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Timeline_getPropertyId) 

bool js_register_spine_Timeline(se::Object* obj) {
    auto* cls = se::Class::create("Timeline", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("getPropertyId", _SE(js_spine_Timeline_getPropertyId)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_Timeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::Timeline>(cls);
    
    __jsb_spine_Timeline_proto = cls->getProto();
    __jsb_spine_Timeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_Animation_class = nullptr;
se::Object* __jsb_spine_Animation_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_Animation) 

static bool js_delete_spine_Animation(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_Animation) 

static bool js_spine_Animation_getName(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Animation *arg1 = (spine::Animation *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::String *) &(arg1)->getName();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_getName, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Animation_getName) 

static bool js_spine_Animation_getTimelines(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Animation *arg1 = (spine::Animation *) NULL ;
    spine::Vector< spine::Timeline * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::Timeline * > *) &(arg1)->getTimelines();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Animation_getTimelines, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Animation_getTimelines) 

static bool js_spine_Animation_hasTimeline(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Animation *arg1 = (spine::Animation *) NULL ;
    int arg2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_hasTimeline,2,SWIGTYPE_int"); 
    result = (bool)(arg1)->hasTimeline(arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Animation_hasTimeline) 

static bool js_spine_Animation_getDuration(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Animation *arg1 = (spine::Animation *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getDuration();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Animation_getDuration) 

static bool js_spine_Animation_setDuration(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Animation *arg1 = (spine::Animation *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Animation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Animation_setDuration,2,SWIGTYPE_float"); 
    (arg1)->setDuration(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Animation_setDuration) 

bool js_register_spine_Animation(se::Object* obj) {
    auto* cls = se::Class::create("Animation", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("getName", _SE(js_spine_Animation_getName)); 
    cls->defineFunction("getTimelines", _SE(js_spine_Animation_getTimelines)); 
    cls->defineFunction("hasTimeline", _SE(js_spine_Animation_hasTimeline)); 
    cls->defineFunction("getDuration", _SE(js_spine_Animation_getDuration)); 
    cls->defineFunction("setDuration", _SE(js_spine_Animation_setDuration)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_Animation));
    
    
    cls->install();
    JSBClassType::registerClass<spine::Animation>(cls);
    
    __jsb_spine_Animation_proto = cls->getProto();
    __jsb_spine_Animation_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_AnimationStateListenerObject_class = nullptr;
se::Object* __jsb_spine_AnimationStateListenerObject_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_AnimationStateListenerObject) 

static bool js_delete_spine_AnimationStateListenerObject(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_AnimationStateListenerObject) 

static bool js_spine_AnimationStateListenerObject_callback(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationStateListenerObject *arg1 = (spine::AnimationStateListenerObject *) NULL ;
    spine::AnimationState *arg2 = (spine::AnimationState *) NULL ;
    spine::EventType arg3 ;
    spine::TrackEntry *arg4 = (spine::TrackEntry *) NULL ;
    spine::Event *arg5 = (spine::Event *) NULL ;
    int32_t temp3 ;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationStateListenerObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "AnimationStateListenerObject_callback,2,SWIGTYPE_p_spine__AnimationState"); 
    // %typemap(in) enum SWIGTYPE (int32_t temp3)
    ok &= sevalue_to_native(args[1], &temp3);
    SE_PRECONDITION2(ok, false, "AnimationStateListenerObject_callback,3,SWIGTYPE_spine__EventType");
    arg3 = (spine::EventType)temp3;
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "AnimationStateListenerObject_callback,4,SWIGTYPE_p_spine__TrackEntry"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "AnimationStateListenerObject_callback,5,SWIGTYPE_p_spine__Event"); 
    (arg1)->callback(arg2,arg3,arg4,arg5);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationStateListenerObject_callback) 

bool js_register_spine_AnimationStateListenerObject(se::Object* obj) {
    auto* cls = se::Class::create("AnimationStateListenerObject", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("callback", _SE(js_spine_AnimationStateListenerObject_callback)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_AnimationStateListenerObject));
    
    
    cls->install();
    JSBClassType::registerClass<spine::AnimationStateListenerObject>(cls);
    
    __jsb_spine_AnimationStateListenerObject_proto = cls->getProto();
    __jsb_spine_AnimationStateListenerObject_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_TrackEntry_class = nullptr;
se::Object* __jsb_spine_TrackEntry_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_TrackEntry) 

static bool js_delete_spine_TrackEntry(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_TrackEntry) 

static bool js_spine_TrackEntry_getTrackIndex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)(arg1)->getTrackIndex();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getTrackIndex) 

static bool js_spine_TrackEntry_getAnimation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    spine::Animation *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Animation *)(arg1)->getAnimation();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TrackEntry_getAnimation, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getAnimation) 

static bool js_spine_TrackEntry_getLoop(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->getLoop();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getLoop) 

static bool js_spine_TrackEntry_setLoop(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "TrackEntry_setLoop,2,SWIGTYPE_bool"); 
    (arg1)->setLoop(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setLoop) 

static bool js_spine_TrackEntry_getHoldPrevious(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->getHoldPrevious();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getHoldPrevious) 

static bool js_spine_TrackEntry_setHoldPrevious(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "TrackEntry_setHoldPrevious,2,SWIGTYPE_bool"); 
    (arg1)->setHoldPrevious(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setHoldPrevious) 

static bool js_spine_TrackEntry_getDelay(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getDelay();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getDelay) 

static bool js_spine_TrackEntry_setDelay(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "TrackEntry_setDelay,2,SWIGTYPE_float"); 
    (arg1)->setDelay(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setDelay) 

static bool js_spine_TrackEntry_getTrackTime(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getTrackTime();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getTrackTime) 

static bool js_spine_TrackEntry_setTrackTime(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "TrackEntry_setTrackTime,2,SWIGTYPE_float"); 
    (arg1)->setTrackTime(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setTrackTime) 

static bool js_spine_TrackEntry_getTrackEnd(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getTrackEnd();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getTrackEnd) 

static bool js_spine_TrackEntry_setTrackEnd(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "TrackEntry_setTrackEnd,2,SWIGTYPE_float"); 
    (arg1)->setTrackEnd(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setTrackEnd) 

static bool js_spine_TrackEntry_getAnimationStart(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getAnimationStart();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getAnimationStart) 

static bool js_spine_TrackEntry_setAnimationStart(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "TrackEntry_setAnimationStart,2,SWIGTYPE_float"); 
    (arg1)->setAnimationStart(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setAnimationStart) 

static bool js_spine_TrackEntry_getAnimationEnd(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getAnimationEnd();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getAnimationEnd) 

static bool js_spine_TrackEntry_setAnimationEnd(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "TrackEntry_setAnimationEnd,2,SWIGTYPE_float"); 
    (arg1)->setAnimationEnd(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setAnimationEnd) 

static bool js_spine_TrackEntry_getAnimationLast(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getAnimationLast();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getAnimationLast) 

static bool js_spine_TrackEntry_setAnimationLast(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "TrackEntry_setAnimationLast,2,SWIGTYPE_float"); 
    (arg1)->setAnimationLast(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setAnimationLast) 

static bool js_spine_TrackEntry_getAnimationTime(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getAnimationTime();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getAnimationTime) 

static bool js_spine_TrackEntry_getTimeScale(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getTimeScale();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getTimeScale) 

static bool js_spine_TrackEntry_setTimeScale(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "TrackEntry_setTimeScale,2,SWIGTYPE_float"); 
    (arg1)->setTimeScale(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setTimeScale) 

static bool js_spine_TrackEntry_getAlpha(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getAlpha();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getAlpha) 

static bool js_spine_TrackEntry_setAlpha(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "TrackEntry_setAlpha,2,SWIGTYPE_float"); 
    (arg1)->setAlpha(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setAlpha) 

static bool js_spine_TrackEntry_getEventThreshold(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getEventThreshold();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getEventThreshold) 

static bool js_spine_TrackEntry_setEventThreshold(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "TrackEntry_setEventThreshold,2,SWIGTYPE_float"); 
    (arg1)->setEventThreshold(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setEventThreshold) 

static bool js_spine_TrackEntry_getAttachmentThreshold(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getAttachmentThreshold();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getAttachmentThreshold) 

static bool js_spine_TrackEntry_setAttachmentThreshold(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "TrackEntry_setAttachmentThreshold,2,SWIGTYPE_float"); 
    (arg1)->setAttachmentThreshold(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setAttachmentThreshold) 

static bool js_spine_TrackEntry_getDrawOrderThreshold(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getDrawOrderThreshold();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getDrawOrderThreshold) 

static bool js_spine_TrackEntry_setDrawOrderThreshold(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "TrackEntry_setDrawOrderThreshold,2,SWIGTYPE_float"); 
    (arg1)->setDrawOrderThreshold(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setDrawOrderThreshold) 

static bool js_spine_TrackEntry_getNext(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    spine::TrackEntry *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::TrackEntry *)(arg1)->getNext();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TrackEntry_getNext, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getNext) 

static bool js_spine_TrackEntry_isComplete(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->isComplete();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_isComplete) 

static bool js_spine_TrackEntry_getMixTime(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getMixTime();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getMixTime) 

static bool js_spine_TrackEntry_setMixTime(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "TrackEntry_setMixTime,2,SWIGTYPE_float"); 
    (arg1)->setMixTime(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setMixTime) 

static bool js_spine_TrackEntry_getMixDuration(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getMixDuration();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getMixDuration) 

static bool js_spine_TrackEntry_setMixDuration(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "TrackEntry_setMixDuration,2,SWIGTYPE_float"); 
    (arg1)->setMixDuration(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setMixDuration) 

static bool js_spine_TrackEntry_getMixBlend(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    spine::MixBlend result;
    int32_t temp ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::MixBlend)(arg1)->getMixBlend();
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getMixBlend) 

static bool js_spine_TrackEntry_setMixBlend(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    spine::MixBlend arg2 ;
    int32_t temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TrackEntry_setMixBlend,2,SWIGTYPE_spine__MixBlend");
    arg2 = (spine::MixBlend)temp2;
    (arg1)->setMixBlend(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_setMixBlend) 

static bool js_spine_TrackEntry_getMixingFrom(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    spine::TrackEntry *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::TrackEntry *)(arg1)->getMixingFrom();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TrackEntry_getMixingFrom, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getMixingFrom) 

static bool js_spine_TrackEntry_getMixingTo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    spine::TrackEntry *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::TrackEntry *)(arg1)->getMixingTo();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TrackEntry_getMixingTo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_getMixingTo) 

static bool js_spine_TrackEntry_resetRotationDirections(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TrackEntry *arg1 = (spine::TrackEntry *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TrackEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->resetRotationDirections();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TrackEntry_resetRotationDirections) 

bool js_register_spine_TrackEntry(se::Object* obj) {
    auto* cls = se::Class::create("TrackEntry", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("getTrackIndex", _SE(js_spine_TrackEntry_getTrackIndex)); 
    cls->defineFunction("getAnimation", _SE(js_spine_TrackEntry_getAnimation)); 
    cls->defineFunction("getLoop", _SE(js_spine_TrackEntry_getLoop)); 
    cls->defineFunction("setLoop", _SE(js_spine_TrackEntry_setLoop)); 
    cls->defineFunction("getHoldPrevious", _SE(js_spine_TrackEntry_getHoldPrevious)); 
    cls->defineFunction("setHoldPrevious", _SE(js_spine_TrackEntry_setHoldPrevious)); 
    cls->defineFunction("getDelay", _SE(js_spine_TrackEntry_getDelay)); 
    cls->defineFunction("setDelay", _SE(js_spine_TrackEntry_setDelay)); 
    cls->defineFunction("getTrackTime", _SE(js_spine_TrackEntry_getTrackTime)); 
    cls->defineFunction("setTrackTime", _SE(js_spine_TrackEntry_setTrackTime)); 
    cls->defineFunction("getTrackEnd", _SE(js_spine_TrackEntry_getTrackEnd)); 
    cls->defineFunction("setTrackEnd", _SE(js_spine_TrackEntry_setTrackEnd)); 
    cls->defineFunction("getAnimationStart", _SE(js_spine_TrackEntry_getAnimationStart)); 
    cls->defineFunction("setAnimationStart", _SE(js_spine_TrackEntry_setAnimationStart)); 
    cls->defineFunction("getAnimationEnd", _SE(js_spine_TrackEntry_getAnimationEnd)); 
    cls->defineFunction("setAnimationEnd", _SE(js_spine_TrackEntry_setAnimationEnd)); 
    cls->defineFunction("getAnimationLast", _SE(js_spine_TrackEntry_getAnimationLast)); 
    cls->defineFunction("setAnimationLast", _SE(js_spine_TrackEntry_setAnimationLast)); 
    cls->defineFunction("getAnimationTime", _SE(js_spine_TrackEntry_getAnimationTime)); 
    cls->defineFunction("getTimeScale", _SE(js_spine_TrackEntry_getTimeScale)); 
    cls->defineFunction("setTimeScale", _SE(js_spine_TrackEntry_setTimeScale)); 
    cls->defineFunction("getAlpha", _SE(js_spine_TrackEntry_getAlpha)); 
    cls->defineFunction("setAlpha", _SE(js_spine_TrackEntry_setAlpha)); 
    cls->defineFunction("getEventThreshold", _SE(js_spine_TrackEntry_getEventThreshold)); 
    cls->defineFunction("setEventThreshold", _SE(js_spine_TrackEntry_setEventThreshold)); 
    cls->defineFunction("getAttachmentThreshold", _SE(js_spine_TrackEntry_getAttachmentThreshold)); 
    cls->defineFunction("setAttachmentThreshold", _SE(js_spine_TrackEntry_setAttachmentThreshold)); 
    cls->defineFunction("getDrawOrderThreshold", _SE(js_spine_TrackEntry_getDrawOrderThreshold)); 
    cls->defineFunction("setDrawOrderThreshold", _SE(js_spine_TrackEntry_setDrawOrderThreshold)); 
    cls->defineFunction("getNext", _SE(js_spine_TrackEntry_getNext)); 
    cls->defineFunction("isComplete", _SE(js_spine_TrackEntry_isComplete)); 
    cls->defineFunction("getMixTime", _SE(js_spine_TrackEntry_getMixTime)); 
    cls->defineFunction("setMixTime", _SE(js_spine_TrackEntry_setMixTime)); 
    cls->defineFunction("getMixDuration", _SE(js_spine_TrackEntry_getMixDuration)); 
    cls->defineFunction("setMixDuration", _SE(js_spine_TrackEntry_setMixDuration)); 
    cls->defineFunction("getMixBlend", _SE(js_spine_TrackEntry_getMixBlend)); 
    cls->defineFunction("setMixBlend", _SE(js_spine_TrackEntry_setMixBlend)); 
    cls->defineFunction("getMixingFrom", _SE(js_spine_TrackEntry_getMixingFrom)); 
    cls->defineFunction("getMixingTo", _SE(js_spine_TrackEntry_getMixingTo)); 
    cls->defineFunction("resetRotationDirections", _SE(js_spine_TrackEntry_resetRotationDirections)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_TrackEntry));
    
    
    cls->install();
    JSBClassType::registerClass<spine::TrackEntry>(cls);
    
    __jsb_spine_TrackEntry_proto = cls->getProto();
    __jsb_spine_TrackEntry_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_EventQueueEntry_class = nullptr;
se::Object* __jsb_spine_EventQueueEntry_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_EventQueueEntry) 

static bool js_spine_EventQueueEntry__type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventQueueEntry *arg1 = (spine::EventQueueEntry *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<spine::EventQueueEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "EventQueueEntry__type_set,2,SWIGTYPE_spine__EventType");
    arg1->_type = (spine::EventType)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_spine_EventQueueEntry__type_set) 

static bool js_spine_EventQueueEntry__type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    spine::EventQueueEntry *arg1 = (spine::EventQueueEntry *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<spine::EventQueueEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->_type));
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_EventQueueEntry__type_get) 

static bool js_spine_EventQueueEntry__entry_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventQueueEntry *arg1 = (spine::EventQueueEntry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::EventQueueEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->_entry, s.thisObject());
    SE_PRECONDITION2(ok, false, "EventQueueEntry__entry_set,2,SWIGTYPE_p_spine__TrackEntry"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_spine_EventQueueEntry__entry_set) 

static bool js_spine_EventQueueEntry__entry_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    spine::EventQueueEntry *arg1 = (spine::EventQueueEntry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::EventQueueEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->_entry, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "EventQueueEntry__entry_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_entry, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_EventQueueEntry__entry_get) 

static bool js_spine_EventQueueEntry__event_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventQueueEntry *arg1 = (spine::EventQueueEntry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::EventQueueEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->_event, s.thisObject());
    SE_PRECONDITION2(ok, false, "EventQueueEntry__event_set,2,SWIGTYPE_p_spine__Event"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_spine_EventQueueEntry__event_set) 

static bool js_spine_EventQueueEntry__event_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    spine::EventQueueEntry *arg1 = (spine::EventQueueEntry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::EventQueueEntry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->_event, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "EventQueueEntry__event_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_event, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_EventQueueEntry__event_get) 

static bool js_new_spine_EventQueueEntry__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    spine::EventType arg1 ;
    spine::TrackEntry *arg2 = (spine::TrackEntry *) NULL ;
    spine::Event *arg3 = (spine::Event *) NULL ;
    int32_t temp1 ;
    spine::EventQueueEntry *result;
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "new_EventQueueEntry,1,SWIGTYPE_spine__EventType");
    arg1 = (spine::EventType)temp1;
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_EventQueueEntry,2,SWIGTYPE_p_spine__TrackEntry"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_EventQueueEntry,3,SWIGTYPE_p_spine__Event"); 
    result = (spine::EventQueueEntry *)new spine::EventQueueEntry(arg1,arg2,arg3);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_spine_EventQueueEntry__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    spine::EventType arg1 ;
    spine::TrackEntry *arg2 = (spine::TrackEntry *) NULL ;
    int32_t temp1 ;
    spine::EventQueueEntry *result;
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "new_EventQueueEntry,1,SWIGTYPE_spine__EventType");
    arg1 = (spine::EventType)temp1;
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_EventQueueEntry,2,SWIGTYPE_p_spine__TrackEntry"); 
    result = (spine::EventQueueEntry *)new spine::EventQueueEntry(arg1,arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_EventQueueEntry(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_ctor_dispatcher
    size_t argc = s.args().size();
    bool ret = false;
    
    // switch all cases by means of series of if-returns.
    
    // js_ctor_dispatch_case
    if(argc == 3) {
        ret = js_new_spine_EventQueueEntry__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 2) {
        ret = js_new_spine_EventQueueEntry__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    
    // default:
    SE_REPORT_ERROR("Illegal arguments for construction of EventQueueEntry");
    return false;
}
SE_BIND_CTOR(js_new_EventQueueEntry, __jsb_spine_EventQueueEntry_class, js_delete_spine_EventQueueEntry)

static bool js_delete_spine_EventQueueEntry(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_EventQueueEntry) 

bool js_register_spine_EventQueueEntry(se::Object* obj) {
    auto* cls = se::Class::create("EventQueueEntry", obj, nullptr, _SE(js_new_EventQueueEntry)); 
    
    cls->defineProperty("_type", _SE(js_spine_EventQueueEntry__type_get), _SE(js_spine_EventQueueEntry__type_set)); 
    cls->defineProperty("_entry", _SE(js_spine_EventQueueEntry__entry_get), _SE(js_spine_EventQueueEntry__entry_set)); 
    cls->defineProperty("_event", _SE(js_spine_EventQueueEntry__event_get), _SE(js_spine_EventQueueEntry__event_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_EventQueueEntry));
    
    
    cls->install();
    JSBClassType::registerClass<spine::EventQueueEntry>(cls);
    
    __jsb_spine_EventQueueEntry_proto = cls->getProto();
    __jsb_spine_EventQueueEntry_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_EventQueue_class = nullptr;
se::Object* __jsb_spine_EventQueue_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_EventQueue) 

bool js_register_spine_EventQueue(se::Object* obj) {
    auto* cls = se::Class::create("EventQueue", obj, nullptr, nullptr); 
    
    
    
    
    
    
    cls->install();
    JSBClassType::registerClass<spine::EventQueue>(cls);
    
    __jsb_spine_EventQueue_proto = cls->getProto();
    __jsb_spine_EventQueue_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_AnimationState_class = nullptr;
se::Object* __jsb_spine_AnimationState_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_AnimationState) 

static bool js_delete_spine_AnimationState(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_AnimationState) 

static bool js_spine_AnimationState_update(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState_update,2,SWIGTYPE_float"); 
    (arg1)->update(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationState_update) 

static bool js_spine_AnimationState_clearTracks(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->clearTracks();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationState_clearTracks) 

static bool js_spine_AnimationState_clearTrack(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    size_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState_clearTrack,2,SWIGTYPE_size_t");
    
    (arg1)->clearTrack(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationState_clearTrack) 

static bool js_spine_AnimationState_setAnimation__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    size_t arg2 ;
    spine::String *arg3 = 0 ;
    bool arg4 ;
    spine::String temp3 ;
    spine::TrackEntry *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState_setAnimation,2,SWIGTYPE_size_t");
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "AnimationState_setAnimation,3,SWIGTYPE_p_spine__String");
    arg3 = &temp3;
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "AnimationState_setAnimation,4,SWIGTYPE_bool"); 
    result = (spine::TrackEntry *)(arg1)->setAnimation(arg2,(spine::String const &)*arg3,arg4);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AnimationState_setAnimation, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_AnimationState_setAnimation__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    size_t arg2 ;
    spine::Animation *arg3 = (spine::Animation *) NULL ;
    bool arg4 ;
    spine::TrackEntry *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState_setAnimation,2,SWIGTYPE_size_t");
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "AnimationState_setAnimation,3,SWIGTYPE_p_spine__Animation"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "AnimationState_setAnimation,4,SWIGTYPE_bool"); 
    result = (spine::TrackEntry *)(arg1)->setAnimation(arg2,arg3,arg4);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AnimationState_setAnimation, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_AnimationState_setAnimation(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_spine_AnimationState_setAnimation__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_spine_AnimationState_setAnimation__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_AnimationState_setAnimation) 

static bool js_spine_AnimationState_addAnimation__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    size_t arg2 ;
    spine::String *arg3 = 0 ;
    bool arg4 ;
    float arg5 ;
    spine::String temp3 ;
    spine::TrackEntry *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState_addAnimation,2,SWIGTYPE_size_t");
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "AnimationState_addAnimation,3,SWIGTYPE_p_spine__String");
    arg3 = &temp3;
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "AnimationState_addAnimation,4,SWIGTYPE_bool"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState_addAnimation,5,SWIGTYPE_float"); 
    result = (spine::TrackEntry *)(arg1)->addAnimation(arg2,(spine::String const &)*arg3,arg4,arg5);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AnimationState_addAnimation, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_AnimationState_addAnimation__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    size_t arg2 ;
    spine::Animation *arg3 = (spine::Animation *) NULL ;
    bool arg4 ;
    float arg5 ;
    spine::TrackEntry *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState_addAnimation,2,SWIGTYPE_size_t");
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "AnimationState_addAnimation,3,SWIGTYPE_p_spine__Animation"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "AnimationState_addAnimation,4,SWIGTYPE_bool"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState_addAnimation,5,SWIGTYPE_float"); 
    result = (spine::TrackEntry *)(arg1)->addAnimation(arg2,arg3,arg4,arg5);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AnimationState_addAnimation, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_AnimationState_addAnimation(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 4) {
        ok = js_spine_AnimationState_addAnimation__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_spine_AnimationState_addAnimation__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_AnimationState_addAnimation) 

static bool js_spine_AnimationState_setEmptyAnimation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    size_t arg2 ;
    float arg3 ;
    spine::TrackEntry *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState_setEmptyAnimation,2,SWIGTYPE_size_t");
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState_setEmptyAnimation,3,SWIGTYPE_float"); 
    result = (spine::TrackEntry *)(arg1)->setEmptyAnimation(arg2,arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AnimationState_setEmptyAnimation, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationState_setEmptyAnimation) 

static bool js_spine_AnimationState_addEmptyAnimation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    size_t arg2 ;
    float arg3 ;
    float arg4 ;
    spine::TrackEntry *result = 0 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState_addEmptyAnimation,2,SWIGTYPE_size_t");
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState_addEmptyAnimation,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState_addEmptyAnimation,4,SWIGTYPE_float"); 
    result = (spine::TrackEntry *)(arg1)->addEmptyAnimation(arg2,arg3,arg4);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AnimationState_addEmptyAnimation, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationState_addEmptyAnimation) 

static bool js_spine_AnimationState_setEmptyAnimations(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState_setEmptyAnimations,2,SWIGTYPE_float"); 
    (arg1)->setEmptyAnimations(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationState_setEmptyAnimations) 

static bool js_spine_AnimationState_getCurrent(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    size_t arg2 ;
    spine::TrackEntry *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState_getCurrent,2,SWIGTYPE_size_t");
    
    result = (spine::TrackEntry *)(arg1)->getCurrent(arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AnimationState_getCurrent, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationState_getCurrent) 

static bool js_spine_AnimationState_getData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    spine::AnimationStateData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::AnimationStateData *)(arg1)->getData();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AnimationState_getData, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationState_getData) 

static bool js_spine_AnimationState_getTracks(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    spine::Vector< spine::TrackEntry * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::TrackEntry * > *) &(arg1)->getTracks();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AnimationState_getTracks, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationState_getTracks) 

static bool js_spine_AnimationState_getTimeScale(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getTimeScale();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationState_getTimeScale) 

static bool js_spine_AnimationState_setTimeScale(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationState_setTimeScale,2,SWIGTYPE_float"); 
    (arg1)->setTimeScale(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationState_setTimeScale) 

static bool js_spine_AnimationState_disableQueue(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->disableQueue();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationState_disableQueue) 

static bool js_spine_AnimationState_enableQueue(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationState *arg1 = (spine::AnimationState *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->enableQueue();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationState_enableQueue) 

bool js_register_spine_AnimationState(se::Object* obj) {
    auto* cls = se::Class::create("AnimationState", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("update", _SE(js_spine_AnimationState_update)); 
    cls->defineFunction("clearTracks", _SE(js_spine_AnimationState_clearTracks)); 
    cls->defineFunction("clearTrack", _SE(js_spine_AnimationState_clearTrack)); 
    cls->defineFunction("setAnimation", _SE(js_spine_AnimationState_setAnimation)); 
    cls->defineFunction("addAnimation", _SE(js_spine_AnimationState_addAnimation)); 
    cls->defineFunction("setEmptyAnimation", _SE(js_spine_AnimationState_setEmptyAnimation)); 
    cls->defineFunction("addEmptyAnimation", _SE(js_spine_AnimationState_addEmptyAnimation)); 
    cls->defineFunction("setEmptyAnimations", _SE(js_spine_AnimationState_setEmptyAnimations)); 
    cls->defineFunction("getCurrent", _SE(js_spine_AnimationState_getCurrent)); 
    cls->defineFunction("getData", _SE(js_spine_AnimationState_getData)); 
    cls->defineFunction("getTracks", _SE(js_spine_AnimationState_getTracks)); 
    cls->defineFunction("getTimeScale", _SE(js_spine_AnimationState_getTimeScale)); 
    cls->defineFunction("setTimeScale", _SE(js_spine_AnimationState_setTimeScale)); 
    cls->defineFunction("disableQueue", _SE(js_spine_AnimationState_disableQueue)); 
    cls->defineFunction("enableQueue", _SE(js_spine_AnimationState_enableQueue)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_AnimationState));
    
    
    cls->install();
    JSBClassType::registerClass<spine::AnimationState>(cls);
    
    __jsb_spine_AnimationState_proto = cls->getProto();
    __jsb_spine_AnimationState_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_AnimationStateData_class = nullptr;
se::Object* __jsb_spine_AnimationStateData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_AnimationStateData) 

static bool js_spine_AnimationStateData_getSkeletonData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationStateData *arg1 = (spine::AnimationStateData *) NULL ;
    spine::SkeletonData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationStateData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::SkeletonData *)(arg1)->getSkeletonData();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AnimationStateData_getSkeletonData, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationStateData_getSkeletonData) 

static bool js_spine_AnimationStateData_getDefaultMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationStateData *arg1 = (spine::AnimationStateData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationStateData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getDefaultMix();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationStateData_getDefaultMix) 

static bool js_spine_AnimationStateData_setDefaultMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationStateData *arg1 = (spine::AnimationStateData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationStateData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationStateData_setDefaultMix,2,SWIGTYPE_float"); 
    (arg1)->setDefaultMix(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationStateData_setDefaultMix) 

static bool js_spine_AnimationStateData_setMix__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::AnimationStateData *arg1 = (spine::AnimationStateData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String *arg3 = 0 ;
    float arg4 ;
    spine::String temp2 ;
    spine::String temp3 ;
    
    arg1 = SE_THIS_OBJECT<spine::AnimationStateData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "AnimationStateData_setMix,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "AnimationStateData_setMix,3,SWIGTYPE_p_spine__String");
    arg3 = &temp3;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationStateData_setMix,4,SWIGTYPE_float"); 
    (arg1)->setMix((spine::String const &)*arg2,(spine::String const &)*arg3,arg4);
    
    
    return true;
}

static bool js_spine_AnimationStateData_setMix__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::AnimationStateData *arg1 = (spine::AnimationStateData *) NULL ;
    spine::Animation *arg2 = (spine::Animation *) NULL ;
    spine::Animation *arg3 = (spine::Animation *) NULL ;
    float arg4 ;
    
    arg1 = SE_THIS_OBJECT<spine::AnimationStateData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "AnimationStateData_setMix,2,SWIGTYPE_p_spine__Animation"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "AnimationStateData_setMix,3,SWIGTYPE_p_spine__Animation"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "AnimationStateData_setMix,4,SWIGTYPE_float"); 
    (arg1)->setMix(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_spine_AnimationStateData_setMix(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_spine_AnimationStateData_setMix__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_spine_AnimationStateData_setMix__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_AnimationStateData_setMix) 

static bool js_spine_AnimationStateData_getMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AnimationStateData *arg1 = (spine::AnimationStateData *) NULL ;
    spine::Animation *arg2 = (spine::Animation *) NULL ;
    spine::Animation *arg3 = (spine::Animation *) NULL ;
    float result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AnimationStateData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "AnimationStateData_getMix,2,SWIGTYPE_p_spine__Animation"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "AnimationStateData_getMix,3,SWIGTYPE_p_spine__Animation"); 
    result = (float)(arg1)->getMix(arg2,arg3);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AnimationStateData_getMix) 

static bool js_delete_spine_AnimationStateData(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_AnimationStateData) 

bool js_register_spine_AnimationStateData(se::Object* obj) {
    auto* cls = se::Class::create("AnimationStateData", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("getSkeletonData", _SE(js_spine_AnimationStateData_getSkeletonData)); 
    cls->defineFunction("getDefaultMix", _SE(js_spine_AnimationStateData_getDefaultMix)); 
    cls->defineFunction("setDefaultMix", _SE(js_spine_AnimationStateData_setDefaultMix)); 
    cls->defineFunction("setMix", _SE(js_spine_AnimationStateData_setMix)); 
    cls->defineFunction("getMix", _SE(js_spine_AnimationStateData_getMix)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_AnimationStateData));
    
    
    cls->install();
    JSBClassType::registerClass<spine::AnimationStateData>(cls);
    
    __jsb_spine_AnimationStateData_proto = cls->getProto();
    __jsb_spine_AnimationStateData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_Attachment_class = nullptr;
se::Object* __jsb_spine_Attachment_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_Attachment) 

static bool js_delete_spine_Attachment(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_Attachment) 

static bool js_spine_Attachment_getName(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Attachment *arg1 = (spine::Attachment *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Attachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::String *) &((spine::Attachment const *)arg1)->getName();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Attachment_getName, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Attachment_getName) 

static bool js_spine_Attachment_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Attachment *arg1 = (spine::Attachment *) NULL ;
    spine::Attachment *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Attachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Attachment *)(arg1)->copy();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Attachment_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Attachment_copy) 

static bool js_spine_Attachment_getRefCount(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Attachment *arg1 = (spine::Attachment *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Attachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)(arg1)->getRefCount();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Attachment_getRefCount) 

static bool js_spine_Attachment_reference(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Attachment *arg1 = (spine::Attachment *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Attachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->reference();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Attachment_reference) 

static bool js_spine_Attachment_dereference(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Attachment *arg1 = (spine::Attachment *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Attachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->dereference();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Attachment_dereference) 

bool js_register_spine_Attachment(se::Object* obj) {
    auto* cls = se::Class::create("Attachment", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("getName", _SE(js_spine_Attachment_getName)); 
    cls->defineFunction("copy", _SE(js_spine_Attachment_copy)); 
    cls->defineFunction("getRefCount", _SE(js_spine_Attachment_getRefCount)); 
    cls->defineFunction("reference", _SE(js_spine_Attachment_reference)); 
    cls->defineFunction("dereference", _SE(js_spine_Attachment_dereference)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_Attachment));
    
    
    cls->install();
    JSBClassType::registerClass<spine::Attachment>(cls);
    
    __jsb_spine_Attachment_proto = cls->getProto();
    __jsb_spine_Attachment_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_AttachmentTimeline_class = nullptr;
se::Object* __jsb_spine_AttachmentTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_AttachmentTimeline) 

static bool js_spine_AttachmentTimeline_setFrame(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AttachmentTimeline *arg1 = (spine::AttachmentTimeline *) NULL ;
    int arg2 ;
    float arg3 ;
    spine::String *arg4 = 0 ;
    spine::String temp4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AttachmentTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "AttachmentTimeline_setFrame,2,SWIGTYPE_int"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "AttachmentTimeline_setFrame,3,SWIGTYPE_float"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "AttachmentTimeline_setFrame,4,SWIGTYPE_p_spine__String");
    arg4 = &temp4;
    
    (arg1)->setFrame(arg2,arg3,(spine::String const &)*arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AttachmentTimeline_setFrame) 

static bool js_spine_AttachmentTimeline_getSlotIndex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AttachmentTimeline *arg1 = (spine::AttachmentTimeline *) NULL ;
    size_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AttachmentTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getSlotIndex();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AttachmentTimeline_getSlotIndex) 

static bool js_spine_AttachmentTimeline_setSlotIndex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AttachmentTimeline *arg1 = (spine::AttachmentTimeline *) NULL ;
    size_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AttachmentTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "AttachmentTimeline_setSlotIndex,2,SWIGTYPE_size_t");
    
    (arg1)->setSlotIndex(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AttachmentTimeline_setSlotIndex) 

static bool js_spine_AttachmentTimeline_getFrames(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AttachmentTimeline *arg1 = (spine::AttachmentTimeline *) NULL ;
    spine::Vector< float > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AttachmentTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< float > *) &(arg1)->getFrames();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AttachmentTimeline_getFrames, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AttachmentTimeline_getFrames) 

static bool js_spine_AttachmentTimeline_getAttachmentNames(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AttachmentTimeline *arg1 = (spine::AttachmentTimeline *) NULL ;
    spine::Vector< spine::String > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AttachmentTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::String > *) &(arg1)->getAttachmentNames();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AttachmentTimeline_getAttachmentNames, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AttachmentTimeline_getAttachmentNames) 

static bool js_spine_AttachmentTimeline_getFrameCount(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::AttachmentTimeline *arg1 = (spine::AttachmentTimeline *) NULL ;
    size_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::AttachmentTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getFrameCount();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_AttachmentTimeline_getFrameCount) 

static bool js_delete_spine_AttachmentTimeline(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_AttachmentTimeline) 

bool js_register_spine_AttachmentTimeline(se::Object* obj) {
    auto* cls = se::Class::create("AttachmentTimeline", obj, __jsb_spine_Timeline_proto, nullptr); 
    
    
    cls->defineFunction("setFrame", _SE(js_spine_AttachmentTimeline_setFrame)); 
    cls->defineFunction("getSlotIndex", _SE(js_spine_AttachmentTimeline_getSlotIndex)); 
    cls->defineFunction("setSlotIndex", _SE(js_spine_AttachmentTimeline_setSlotIndex)); 
    cls->defineFunction("getFrames", _SE(js_spine_AttachmentTimeline_getFrames)); 
    cls->defineFunction("getAttachmentNames", _SE(js_spine_AttachmentTimeline_getAttachmentNames)); 
    cls->defineFunction("getFrameCount", _SE(js_spine_AttachmentTimeline_getFrameCount)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_AttachmentTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::AttachmentTimeline>(cls);
    
    __jsb_spine_AttachmentTimeline_proto = cls->getProto();
    __jsb_spine_AttachmentTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_BoundingBoxAttachment_class = nullptr;
se::Object* __jsb_spine_BoundingBoxAttachment_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_BoundingBoxAttachment) 

static bool js_spine_BoundingBoxAttachment_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoundingBoxAttachment *arg1 = (spine::BoundingBoxAttachment *) NULL ;
    spine::Attachment *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoundingBoxAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Attachment *)(arg1)->copy();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BoundingBoxAttachment_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoundingBoxAttachment_copy) 

static bool js_delete_spine_BoundingBoxAttachment(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_BoundingBoxAttachment) 

bool js_register_spine_BoundingBoxAttachment(se::Object* obj) {
    auto* cls = se::Class::create("BoundingBoxAttachment", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("copy", _SE(js_spine_BoundingBoxAttachment_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_BoundingBoxAttachment));
    
    
    cls->install();
    JSBClassType::registerClass<spine::BoundingBoxAttachment>(cls);
    
    __jsb_spine_BoundingBoxAttachment_proto = cls->getProto();
    __jsb_spine_BoundingBoxAttachment_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_Bone_class = nullptr;
se::Object* __jsb_spine_Bone_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_Bone) 

static bool js_spine_Bone_setYDown_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    bool arg1 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1);
    SE_PRECONDITION2(ok, false, "Bone_setYDown,1,SWIGTYPE_bool"); 
    spine::Bone::setYDown(arg1);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setYDown_static) 

static bool js_spine_Bone_isYDown_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (bool)spine::Bone::isYDown();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_isYDown_static) 

static bool js_spine_Bone_update(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->update();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_update) 

static bool js_spine_Bone_updateWorldTransform__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->updateWorldTransform();
    
    
    return true;
}

static bool js_spine_Bone_updateWorldTransform__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    float arg8 ;
    
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_updateWorldTransform,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_updateWorldTransform,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_updateWorldTransform,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_updateWorldTransform,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_updateWorldTransform,6,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg7, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_updateWorldTransform,7,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[6], &arg8, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_updateWorldTransform,8,SWIGTYPE_float"); 
    (arg1)->updateWorldTransform(arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_spine_Bone_updateWorldTransform(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 0) {
        ok = js_spine_Bone_updateWorldTransform__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 7) {
        ok = js_spine_Bone_updateWorldTransform__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_Bone_updateWorldTransform) 

static bool js_spine_Bone_setToSetupPose(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->setToSetupPose();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setToSetupPose) 

static bool js_spine_Bone_worldToLocalRotation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    float result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_worldToLocalRotation,2,SWIGTYPE_float"); 
    result = (float)(arg1)->worldToLocalRotation(arg2);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_worldToLocalRotation) 

static bool js_spine_Bone_localToWorldRotation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    float result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_localToWorldRotation,2,SWIGTYPE_float"); 
    result = (float)(arg1)->localToWorldRotation(arg2);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_localToWorldRotation) 

static bool js_spine_Bone_rotateWorld(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_rotateWorld,2,SWIGTYPE_float"); 
    (arg1)->rotateWorld(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_rotateWorld) 

static bool js_spine_Bone_getWorldToLocalRotationX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getWorldToLocalRotationX();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getWorldToLocalRotationX) 

static bool js_spine_Bone_getWorldToLocalRotationY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getWorldToLocalRotationY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getWorldToLocalRotationY) 

static bool js_spine_Bone_getData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    spine::BoneData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::BoneData *) &(arg1)->getData();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Bone_getData, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getData) 

static bool js_spine_Bone_getSkeleton(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    spine::Skeleton *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Skeleton *) &(arg1)->getSkeleton();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Bone_getSkeleton, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getSkeleton) 

static bool js_spine_Bone_getParent(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    spine::Bone *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Bone *)(arg1)->getParent();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Bone_getParent, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getParent) 

static bool js_spine_Bone_getChildren(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    spine::Vector< spine::Bone * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::Bone * > *) &(arg1)->getChildren();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Bone_getChildren, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getChildren) 

static bool js_spine_Bone_getX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getX();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getX) 

static bool js_spine_Bone_setX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_setX,2,SWIGTYPE_float"); 
    (arg1)->setX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setX) 

static bool js_spine_Bone_getY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getY) 

static bool js_spine_Bone_setY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_setY,2,SWIGTYPE_float"); 
    (arg1)->setY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setY) 

static bool js_spine_Bone_getRotation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getRotation();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getRotation) 

static bool js_spine_Bone_setRotation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_setRotation,2,SWIGTYPE_float"); 
    (arg1)->setRotation(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setRotation) 

static bool js_spine_Bone_getScaleX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getScaleX();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getScaleX) 

static bool js_spine_Bone_setScaleX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_setScaleX,2,SWIGTYPE_float"); 
    (arg1)->setScaleX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setScaleX) 

static bool js_spine_Bone_getScaleY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getScaleY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getScaleY) 

static bool js_spine_Bone_setScaleY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_setScaleY,2,SWIGTYPE_float"); 
    (arg1)->setScaleY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setScaleY) 

static bool js_spine_Bone_getShearX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getShearX();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getShearX) 

static bool js_spine_Bone_setShearX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_setShearX,2,SWIGTYPE_float"); 
    (arg1)->setShearX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setShearX) 

static bool js_spine_Bone_getShearY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getShearY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getShearY) 

static bool js_spine_Bone_setShearY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_setShearY,2,SWIGTYPE_float"); 
    (arg1)->setShearY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setShearY) 

static bool js_spine_Bone_getAppliedRotation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getAppliedRotation();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getAppliedRotation) 

static bool js_spine_Bone_setAppliedRotation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_setAppliedRotation,2,SWIGTYPE_float"); 
    (arg1)->setAppliedRotation(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setAppliedRotation) 

static bool js_spine_Bone_getAX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getAX();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getAX) 

static bool js_spine_Bone_setAX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_setAX,2,SWIGTYPE_float"); 
    (arg1)->setAX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setAX) 

static bool js_spine_Bone_getAY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getAY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getAY) 

static bool js_spine_Bone_setAY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_setAY,2,SWIGTYPE_float"); 
    (arg1)->setAY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setAY) 

static bool js_spine_Bone_getAScaleX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getAScaleX();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getAScaleX) 

static bool js_spine_Bone_setAScaleX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_setAScaleX,2,SWIGTYPE_float"); 
    (arg1)->setAScaleX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setAScaleX) 

static bool js_spine_Bone_getAScaleY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getAScaleY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getAScaleY) 

static bool js_spine_Bone_setAScaleY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_setAScaleY,2,SWIGTYPE_float"); 
    (arg1)->setAScaleY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setAScaleY) 

static bool js_spine_Bone_getAShearX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getAShearX();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getAShearX) 

static bool js_spine_Bone_setAShearX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_setAShearX,2,SWIGTYPE_float"); 
    (arg1)->setAShearX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setAShearX) 

static bool js_spine_Bone_getAShearY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getAShearY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getAShearY) 

static bool js_spine_Bone_setAShearY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_setAShearY,2,SWIGTYPE_float"); 
    (arg1)->setAShearY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setAShearY) 

static bool js_spine_Bone_getA(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getA();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getA) 

static bool js_spine_Bone_setA(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_setA,2,SWIGTYPE_float"); 
    (arg1)->setA(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setA) 

static bool js_spine_Bone_getB(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getB();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getB) 

static bool js_spine_Bone_setB(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_setB,2,SWIGTYPE_float"); 
    (arg1)->setB(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setB) 

static bool js_spine_Bone_getC(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getC();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getC) 

static bool js_spine_Bone_setC(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_setC,2,SWIGTYPE_float"); 
    (arg1)->setC(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setC) 

static bool js_spine_Bone_getD(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getD();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getD) 

static bool js_spine_Bone_setD(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_setD,2,SWIGTYPE_float"); 
    (arg1)->setD(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setD) 

static bool js_spine_Bone_getWorldX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getWorldX();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getWorldX) 

static bool js_spine_Bone_setWorldX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_setWorldX,2,SWIGTYPE_float"); 
    (arg1)->setWorldX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setWorldX) 

static bool js_spine_Bone_getWorldY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getWorldY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getWorldY) 

static bool js_spine_Bone_setWorldY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Bone_setWorldY,2,SWIGTYPE_float"); 
    (arg1)->setWorldY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setWorldY) 

static bool js_spine_Bone_getWorldRotationX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getWorldRotationX();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getWorldRotationX) 

static bool js_spine_Bone_getWorldRotationY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getWorldRotationY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getWorldRotationY) 

static bool js_spine_Bone_getWorldScaleX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getWorldScaleX();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getWorldScaleX) 

static bool js_spine_Bone_getWorldScaleY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getWorldScaleY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_getWorldScaleY) 

static bool js_spine_Bone_isAppliedValid(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->isAppliedValid();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_isAppliedValid) 

static bool js_spine_Bone_setAppliedValid(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Bone_setAppliedValid,2,SWIGTYPE_bool"); 
    (arg1)->setAppliedValid(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setAppliedValid) 

static bool js_spine_Bone_isActive(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->isActive();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_isActive) 

static bool js_spine_Bone_setActive(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Bone *arg1 = (spine::Bone *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Bone>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Bone_setActive,2,SWIGTYPE_bool"); 
    (arg1)->setActive(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Bone_setActive) 

static bool js_delete_spine_Bone(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_Bone) 

bool js_register_spine_Bone(se::Object* obj) {
    auto* cls = se::Class::create("Bone", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("update", _SE(js_spine_Bone_update)); 
    cls->defineFunction("updateWorldTransform", _SE(js_spine_Bone_updateWorldTransform)); 
    cls->defineFunction("setToSetupPose", _SE(js_spine_Bone_setToSetupPose)); 
    cls->defineFunction("worldToLocalRotation", _SE(js_spine_Bone_worldToLocalRotation)); 
    cls->defineFunction("localToWorldRotation", _SE(js_spine_Bone_localToWorldRotation)); 
    cls->defineFunction("rotateWorld", _SE(js_spine_Bone_rotateWorld)); 
    cls->defineFunction("getWorldToLocalRotationX", _SE(js_spine_Bone_getWorldToLocalRotationX)); 
    cls->defineFunction("getWorldToLocalRotationY", _SE(js_spine_Bone_getWorldToLocalRotationY)); 
    cls->defineFunction("getData", _SE(js_spine_Bone_getData)); 
    cls->defineFunction("getSkeleton", _SE(js_spine_Bone_getSkeleton)); 
    cls->defineFunction("getParent", _SE(js_spine_Bone_getParent)); 
    cls->defineFunction("getChildren", _SE(js_spine_Bone_getChildren)); 
    cls->defineFunction("getX", _SE(js_spine_Bone_getX)); 
    cls->defineFunction("setX", _SE(js_spine_Bone_setX)); 
    cls->defineFunction("getY", _SE(js_spine_Bone_getY)); 
    cls->defineFunction("setY", _SE(js_spine_Bone_setY)); 
    cls->defineFunction("getRotation", _SE(js_spine_Bone_getRotation)); 
    cls->defineFunction("setRotation", _SE(js_spine_Bone_setRotation)); 
    cls->defineFunction("getScaleX", _SE(js_spine_Bone_getScaleX)); 
    cls->defineFunction("setScaleX", _SE(js_spine_Bone_setScaleX)); 
    cls->defineFunction("getScaleY", _SE(js_spine_Bone_getScaleY)); 
    cls->defineFunction("setScaleY", _SE(js_spine_Bone_setScaleY)); 
    cls->defineFunction("getShearX", _SE(js_spine_Bone_getShearX)); 
    cls->defineFunction("setShearX", _SE(js_spine_Bone_setShearX)); 
    cls->defineFunction("getShearY", _SE(js_spine_Bone_getShearY)); 
    cls->defineFunction("setShearY", _SE(js_spine_Bone_setShearY)); 
    cls->defineFunction("getAppliedRotation", _SE(js_spine_Bone_getAppliedRotation)); 
    cls->defineFunction("setAppliedRotation", _SE(js_spine_Bone_setAppliedRotation)); 
    cls->defineFunction("getAX", _SE(js_spine_Bone_getAX)); 
    cls->defineFunction("setAX", _SE(js_spine_Bone_setAX)); 
    cls->defineFunction("getAY", _SE(js_spine_Bone_getAY)); 
    cls->defineFunction("setAY", _SE(js_spine_Bone_setAY)); 
    cls->defineFunction("getAScaleX", _SE(js_spine_Bone_getAScaleX)); 
    cls->defineFunction("setAScaleX", _SE(js_spine_Bone_setAScaleX)); 
    cls->defineFunction("getAScaleY", _SE(js_spine_Bone_getAScaleY)); 
    cls->defineFunction("setAScaleY", _SE(js_spine_Bone_setAScaleY)); 
    cls->defineFunction("getAShearX", _SE(js_spine_Bone_getAShearX)); 
    cls->defineFunction("setAShearX", _SE(js_spine_Bone_setAShearX)); 
    cls->defineFunction("getAShearY", _SE(js_spine_Bone_getAShearY)); 
    cls->defineFunction("setAShearY", _SE(js_spine_Bone_setAShearY)); 
    cls->defineFunction("getA", _SE(js_spine_Bone_getA)); 
    cls->defineFunction("setA", _SE(js_spine_Bone_setA)); 
    cls->defineFunction("getB", _SE(js_spine_Bone_getB)); 
    cls->defineFunction("setB", _SE(js_spine_Bone_setB)); 
    cls->defineFunction("getC", _SE(js_spine_Bone_getC)); 
    cls->defineFunction("setC", _SE(js_spine_Bone_setC)); 
    cls->defineFunction("getD", _SE(js_spine_Bone_getD)); 
    cls->defineFunction("setD", _SE(js_spine_Bone_setD)); 
    cls->defineFunction("getWorldX", _SE(js_spine_Bone_getWorldX)); 
    cls->defineFunction("setWorldX", _SE(js_spine_Bone_setWorldX)); 
    cls->defineFunction("getWorldY", _SE(js_spine_Bone_getWorldY)); 
    cls->defineFunction("setWorldY", _SE(js_spine_Bone_setWorldY)); 
    cls->defineFunction("getWorldRotationX", _SE(js_spine_Bone_getWorldRotationX)); 
    cls->defineFunction("getWorldRotationY", _SE(js_spine_Bone_getWorldRotationY)); 
    cls->defineFunction("getWorldScaleX", _SE(js_spine_Bone_getWorldScaleX)); 
    cls->defineFunction("getWorldScaleY", _SE(js_spine_Bone_getWorldScaleY)); 
    cls->defineFunction("isAppliedValid", _SE(js_spine_Bone_isAppliedValid)); 
    cls->defineFunction("setAppliedValid", _SE(js_spine_Bone_setAppliedValid)); 
    cls->defineFunction("isActive", _SE(js_spine_Bone_isActive)); 
    cls->defineFunction("setActive", _SE(js_spine_Bone_setActive)); 
    
    
    cls->defineStaticFunction("setYDown", _SE(js_spine_Bone_setYDown_static)); 
    cls->defineStaticFunction("isYDown", _SE(js_spine_Bone_isYDown_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_Bone));
    
    
    cls->install();
    JSBClassType::registerClass<spine::Bone>(cls);
    
    __jsb_spine_Bone_proto = cls->getProto();
    __jsb_spine_Bone_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_BoneData_class = nullptr;
se::Object* __jsb_spine_BoneData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_BoneData) 

static bool js_spine_BoneData_getIndex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)(arg1)->getIndex();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_getIndex) 

static bool js_spine_BoneData_getName(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::String *) &(arg1)->getName();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BoneData_getName, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_getName) 

static bool js_spine_BoneData_getParent(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    spine::BoneData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::BoneData *)(arg1)->getParent();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BoneData_getParent, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_getParent) 

static bool js_spine_BoneData_getLength(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getLength();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_getLength) 

static bool js_spine_BoneData_setLength(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "BoneData_setLength,2,SWIGTYPE_float"); 
    (arg1)->setLength(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_setLength) 

static bool js_spine_BoneData_getX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getX();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_getX) 

static bool js_spine_BoneData_setX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "BoneData_setX,2,SWIGTYPE_float"); 
    (arg1)->setX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_setX) 

static bool js_spine_BoneData_getY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_getY) 

static bool js_spine_BoneData_setY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "BoneData_setY,2,SWIGTYPE_float"); 
    (arg1)->setY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_setY) 

static bool js_spine_BoneData_getRotation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getRotation();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_getRotation) 

static bool js_spine_BoneData_setRotation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "BoneData_setRotation,2,SWIGTYPE_float"); 
    (arg1)->setRotation(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_setRotation) 

static bool js_spine_BoneData_getScaleX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getScaleX();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_getScaleX) 

static bool js_spine_BoneData_setScaleX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "BoneData_setScaleX,2,SWIGTYPE_float"); 
    (arg1)->setScaleX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_setScaleX) 

static bool js_spine_BoneData_getScaleY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getScaleY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_getScaleY) 

static bool js_spine_BoneData_setScaleY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "BoneData_setScaleY,2,SWIGTYPE_float"); 
    (arg1)->setScaleY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_setScaleY) 

static bool js_spine_BoneData_getShearX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getShearX();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_getShearX) 

static bool js_spine_BoneData_setShearX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "BoneData_setShearX,2,SWIGTYPE_float"); 
    (arg1)->setShearX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_setShearX) 

static bool js_spine_BoneData_getShearY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getShearY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_getShearY) 

static bool js_spine_BoneData_setShearY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "BoneData_setShearY,2,SWIGTYPE_float"); 
    (arg1)->setShearY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_setShearY) 

static bool js_spine_BoneData_getTransformMode(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    spine::TransformMode result;
    int32_t temp ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::TransformMode)(arg1)->getTransformMode();
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_getTransformMode) 

static bool js_spine_BoneData_setTransformMode(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    spine::TransformMode arg2 ;
    int32_t temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "BoneData_setTransformMode,2,SWIGTYPE_spine__TransformMode");
    arg2 = (spine::TransformMode)temp2;
    (arg1)->setTransformMode(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_setTransformMode) 

static bool js_spine_BoneData_isSkinRequired(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->isSkinRequired();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_isSkinRequired) 

static bool js_spine_BoneData_setSkinRequired(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::BoneData *arg1 = (spine::BoneData *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::BoneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "BoneData_setSkinRequired,2,SWIGTYPE_bool"); 
    (arg1)->setSkinRequired(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_BoneData_setSkinRequired) 

static bool js_delete_spine_BoneData(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_BoneData) 

bool js_register_spine_BoneData(se::Object* obj) {
    auto* cls = se::Class::create("BoneData", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("getIndex", _SE(js_spine_BoneData_getIndex)); 
    cls->defineFunction("getName", _SE(js_spine_BoneData_getName)); 
    cls->defineFunction("getParent", _SE(js_spine_BoneData_getParent)); 
    cls->defineFunction("getLength", _SE(js_spine_BoneData_getLength)); 
    cls->defineFunction("setLength", _SE(js_spine_BoneData_setLength)); 
    cls->defineFunction("getX", _SE(js_spine_BoneData_getX)); 
    cls->defineFunction("setX", _SE(js_spine_BoneData_setX)); 
    cls->defineFunction("getY", _SE(js_spine_BoneData_getY)); 
    cls->defineFunction("setY", _SE(js_spine_BoneData_setY)); 
    cls->defineFunction("getRotation", _SE(js_spine_BoneData_getRotation)); 
    cls->defineFunction("setRotation", _SE(js_spine_BoneData_setRotation)); 
    cls->defineFunction("getScaleX", _SE(js_spine_BoneData_getScaleX)); 
    cls->defineFunction("setScaleX", _SE(js_spine_BoneData_setScaleX)); 
    cls->defineFunction("getScaleY", _SE(js_spine_BoneData_getScaleY)); 
    cls->defineFunction("setScaleY", _SE(js_spine_BoneData_setScaleY)); 
    cls->defineFunction("getShearX", _SE(js_spine_BoneData_getShearX)); 
    cls->defineFunction("setShearX", _SE(js_spine_BoneData_setShearX)); 
    cls->defineFunction("getShearY", _SE(js_spine_BoneData_getShearY)); 
    cls->defineFunction("setShearY", _SE(js_spine_BoneData_setShearY)); 
    cls->defineFunction("getTransformMode", _SE(js_spine_BoneData_getTransformMode)); 
    cls->defineFunction("setTransformMode", _SE(js_spine_BoneData_setTransformMode)); 
    cls->defineFunction("isSkinRequired", _SE(js_spine_BoneData_isSkinRequired)); 
    cls->defineFunction("setSkinRequired", _SE(js_spine_BoneData_setSkinRequired)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_BoneData));
    
    
    cls->install();
    JSBClassType::registerClass<spine::BoneData>(cls);
    
    __jsb_spine_BoneData_proto = cls->getProto();
    __jsb_spine_BoneData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_ClippingAttachment_class = nullptr;
se::Object* __jsb_spine_ClippingAttachment_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_ClippingAttachment) 

static bool js_spine_ClippingAttachment_getEndSlot(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ClippingAttachment *arg1 = (spine::ClippingAttachment *) NULL ;
    spine::SlotData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ClippingAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::SlotData *)(arg1)->getEndSlot();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ClippingAttachment_getEndSlot, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ClippingAttachment_getEndSlot) 

static bool js_spine_ClippingAttachment_setEndSlot(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ClippingAttachment *arg1 = (spine::ClippingAttachment *) NULL ;
    spine::SlotData *arg2 = (spine::SlotData *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ClippingAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ClippingAttachment_setEndSlot,2,SWIGTYPE_p_spine__SlotData"); 
    (arg1)->setEndSlot(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ClippingAttachment_setEndSlot) 

static bool js_spine_ClippingAttachment_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ClippingAttachment *arg1 = (spine::ClippingAttachment *) NULL ;
    spine::Attachment *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ClippingAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Attachment *)(arg1)->copy();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ClippingAttachment_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ClippingAttachment_copy) 

static bool js_delete_spine_ClippingAttachment(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_ClippingAttachment) 

bool js_register_spine_ClippingAttachment(se::Object* obj) {
    auto* cls = se::Class::create("ClippingAttachment", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("getEndSlot", _SE(js_spine_ClippingAttachment_getEndSlot)); 
    cls->defineFunction("setEndSlot", _SE(js_spine_ClippingAttachment_setEndSlot)); 
    cls->defineFunction("copy", _SE(js_spine_ClippingAttachment_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_ClippingAttachment));
    
    
    cls->install();
    JSBClassType::registerClass<spine::ClippingAttachment>(cls);
    
    __jsb_spine_ClippingAttachment_proto = cls->getProto();
    __jsb_spine_ClippingAttachment_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_Color_class = nullptr;
se::Object* __jsb_spine_Color_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_Color) 

static bool js_spine_Color_clamp(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Color *arg1 = (spine::Color *) NULL ;
    spine::Color *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Color *) &(arg1)->clamp();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Color_clamp, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Color_clamp) 

static bool js_spine_Color_r_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Color *arg1 = (spine::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->r, nullptr);
    SE_PRECONDITION2(ok, false, "Color_r_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_spine_Color_r_set) 

static bool js_spine_Color_r_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    spine::Color *arg1 = (spine::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->r, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_Color_r_get) 

static bool js_spine_Color_g_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Color *arg1 = (spine::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->g, nullptr);
    SE_PRECONDITION2(ok, false, "Color_g_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_spine_Color_g_set) 

static bool js_spine_Color_g_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    spine::Color *arg1 = (spine::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->g, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_Color_g_get) 

static bool js_spine_Color_b_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Color *arg1 = (spine::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->b, nullptr);
    SE_PRECONDITION2(ok, false, "Color_b_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_spine_Color_b_set) 

static bool js_spine_Color_b_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    spine::Color *arg1 = (spine::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->b, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_Color_b_get) 

static bool js_spine_Color_a_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Color *arg1 = (spine::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->a, nullptr);
    SE_PRECONDITION2(ok, false, "Color_a_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_spine_Color_a_set) 

static bool js_spine_Color_a_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    spine::Color *arg1 = (spine::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->a, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_Color_a_get) 

static bool js_delete_spine_Color(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_Color) 

bool js_register_spine_Color(se::Object* obj) {
    auto* cls = se::Class::create("Color", obj, nullptr, nullptr); 
    
    cls->defineProperty("r", _SE(js_spine_Color_r_get), _SE(js_spine_Color_r_set)); 
    cls->defineProperty("g", _SE(js_spine_Color_g_get), _SE(js_spine_Color_g_set)); 
    cls->defineProperty("b", _SE(js_spine_Color_b_get), _SE(js_spine_Color_b_set)); 
    cls->defineProperty("a", _SE(js_spine_Color_a_get), _SE(js_spine_Color_a_set)); 
    
    cls->defineFunction("clamp", _SE(js_spine_Color_clamp)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_Color));
    
    
    cls->install();
    JSBClassType::registerClass<spine::Color>(cls);
    
    __jsb_spine_Color_proto = cls->getProto();
    __jsb_spine_Color_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_ColorTimeline_class = nullptr;
se::Object* __jsb_spine_ColorTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_ColorTimeline) 

static bool js_spine_ColorTimeline_ENTRIES_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    int result;
    
    result = (int)(int)spine::ColorTimeline::ENTRIES;
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_ColorTimeline_ENTRIES_get) 

static bool js_spine_ColorTimeline_getPropertyId(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ColorTimeline *arg1 = (spine::ColorTimeline *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ColorTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)(arg1)->getPropertyId();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ColorTimeline_getPropertyId) 

static bool js_spine_ColorTimeline_setFrame(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ColorTimeline *arg1 = (spine::ColorTimeline *) NULL ;
    int arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ColorTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ColorTimeline_setFrame,2,SWIGTYPE_int"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "ColorTimeline_setFrame,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "ColorTimeline_setFrame,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "ColorTimeline_setFrame,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "ColorTimeline_setFrame,6,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg7, nullptr);
    SE_PRECONDITION2(ok, false, "ColorTimeline_setFrame,7,SWIGTYPE_float"); 
    (arg1)->setFrame(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ColorTimeline_setFrame) 

static bool js_spine_ColorTimeline_getSlotIndex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ColorTimeline *arg1 = (spine::ColorTimeline *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ColorTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)(arg1)->getSlotIndex();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ColorTimeline_getSlotIndex) 

static bool js_spine_ColorTimeline_setSlotIndex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ColorTimeline *arg1 = (spine::ColorTimeline *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ColorTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ColorTimeline_setSlotIndex,2,SWIGTYPE_int"); 
    (arg1)->setSlotIndex(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ColorTimeline_setSlotIndex) 

static bool js_spine_ColorTimeline_getFrames(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ColorTimeline *arg1 = (spine::ColorTimeline *) NULL ;
    spine::Vector< float > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ColorTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< float > *) &(arg1)->getFrames();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ColorTimeline_getFrames, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ColorTimeline_getFrames) 

static bool js_delete_spine_ColorTimeline(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_ColorTimeline) 

bool js_register_spine_ColorTimeline(se::Object* obj) {
    auto* cls = se::Class::create("ColorTimeline", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("getPropertyId", _SE(js_spine_ColorTimeline_getPropertyId)); 
    cls->defineFunction("setFrame", _SE(js_spine_ColorTimeline_setFrame)); 
    cls->defineFunction("getSlotIndex", _SE(js_spine_ColorTimeline_getSlotIndex)); 
    cls->defineFunction("setSlotIndex", _SE(js_spine_ColorTimeline_setSlotIndex)); 
    cls->defineFunction("getFrames", _SE(js_spine_ColorTimeline_getFrames)); 
    
    cls->defineStaticProperty("ENTRIES", _SE(js_spine_ColorTimeline_ENTRIES_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_ColorTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::ColorTimeline>(cls);
    
    __jsb_spine_ColorTimeline_proto = cls->getProto();
    __jsb_spine_ColorTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_CurveTimeline_class = nullptr;
se::Object* __jsb_spine_CurveTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_CurveTimeline) 

static bool js_delete_spine_CurveTimeline(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_CurveTimeline) 

static bool js_spine_CurveTimeline_getFrameCount(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::CurveTimeline *arg1 = (spine::CurveTimeline *) NULL ;
    size_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::CurveTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getFrameCount();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_CurveTimeline_getFrameCount) 

static bool js_spine_CurveTimeline_setLinear(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::CurveTimeline *arg1 = (spine::CurveTimeline *) NULL ;
    size_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::CurveTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "CurveTimeline_setLinear,2,SWIGTYPE_size_t");
    
    (arg1)->setLinear(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_CurveTimeline_setLinear) 

static bool js_spine_CurveTimeline_setStepped(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::CurveTimeline *arg1 = (spine::CurveTimeline *) NULL ;
    size_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::CurveTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "CurveTimeline_setStepped,2,SWIGTYPE_size_t");
    
    (arg1)->setStepped(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_CurveTimeline_setStepped) 

static bool js_spine_CurveTimeline_setCurve(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::CurveTimeline *arg1 = (spine::CurveTimeline *) NULL ;
    size_t arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    
    if(argc != 5) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::CurveTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "CurveTimeline_setCurve,2,SWIGTYPE_size_t");
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "CurveTimeline_setCurve,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "CurveTimeline_setCurve,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "CurveTimeline_setCurve,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "CurveTimeline_setCurve,6,SWIGTYPE_float"); 
    (arg1)->setCurve(arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_CurveTimeline_setCurve) 

static bool js_spine_CurveTimeline_getCurvePercent(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::CurveTimeline *arg1 = (spine::CurveTimeline *) NULL ;
    size_t arg2 ;
    float arg3 ;
    float result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::CurveTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "CurveTimeline_getCurvePercent,2,SWIGTYPE_size_t");
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "CurveTimeline_getCurvePercent,3,SWIGTYPE_float"); 
    result = (float)(arg1)->getCurvePercent(arg2,arg3);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_CurveTimeline_getCurvePercent) 

static bool js_spine_CurveTimeline_getCurveType(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::CurveTimeline *arg1 = (spine::CurveTimeline *) NULL ;
    size_t arg2 ;
    float result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::CurveTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "CurveTimeline_getCurveType,2,SWIGTYPE_size_t");
    
    result = (float)(arg1)->getCurveType(arg2);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_CurveTimeline_getCurveType) 

bool js_register_spine_CurveTimeline(se::Object* obj) {
    auto* cls = se::Class::create("CurveTimeline", obj, __jsb_spine_Timeline_proto, nullptr); 
    
    
    cls->defineFunction("getFrameCount", _SE(js_spine_CurveTimeline_getFrameCount)); 
    cls->defineFunction("setLinear", _SE(js_spine_CurveTimeline_setLinear)); 
    cls->defineFunction("setStepped", _SE(js_spine_CurveTimeline_setStepped)); 
    cls->defineFunction("setCurve", _SE(js_spine_CurveTimeline_setCurve)); 
    cls->defineFunction("getCurvePercent", _SE(js_spine_CurveTimeline_getCurvePercent)); 
    cls->defineFunction("getCurveType", _SE(js_spine_CurveTimeline_getCurveType)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_CurveTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::CurveTimeline>(cls);
    
    __jsb_spine_CurveTimeline_proto = cls->getProto();
    __jsb_spine_CurveTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_DeformTimeline_class = nullptr;
se::Object* __jsb_spine_DeformTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_DeformTimeline) 

static bool js_spine_DeformTimeline_getSlotIndex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::DeformTimeline *arg1 = (spine::DeformTimeline *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::DeformTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)(arg1)->getSlotIndex();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_DeformTimeline_getSlotIndex) 

static bool js_spine_DeformTimeline_setSlotIndex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::DeformTimeline *arg1 = (spine::DeformTimeline *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::DeformTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "DeformTimeline_setSlotIndex,2,SWIGTYPE_int"); 
    (arg1)->setSlotIndex(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_DeformTimeline_setSlotIndex) 

static bool js_spine_DeformTimeline_getFrames(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::DeformTimeline *arg1 = (spine::DeformTimeline *) NULL ;
    spine::Vector< float > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::DeformTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< float > *) &(arg1)->getFrames();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeformTimeline_getFrames, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_DeformTimeline_getFrames) 

static bool js_spine_DeformTimeline_getAttachment(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::DeformTimeline *arg1 = (spine::DeformTimeline *) NULL ;
    spine::VertexAttachment *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::DeformTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::VertexAttachment *)(arg1)->getAttachment();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeformTimeline_getAttachment, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_DeformTimeline_getAttachment) 

static bool js_spine_DeformTimeline_setAttachment(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::DeformTimeline *arg1 = (spine::DeformTimeline *) NULL ;
    spine::VertexAttachment *arg2 = (spine::VertexAttachment *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::DeformTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DeformTimeline_setAttachment,2,SWIGTYPE_p_spine__VertexAttachment"); 
    (arg1)->setAttachment(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_DeformTimeline_setAttachment) 

static bool js_delete_spine_DeformTimeline(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_DeformTimeline) 

bool js_register_spine_DeformTimeline(se::Object* obj) {
    auto* cls = se::Class::create("DeformTimeline", obj, __jsb_spine_CurveTimeline_proto, nullptr); 
    
    
    cls->defineFunction("getSlotIndex", _SE(js_spine_DeformTimeline_getSlotIndex)); 
    cls->defineFunction("setSlotIndex", _SE(js_spine_DeformTimeline_setSlotIndex)); 
    cls->defineFunction("getFrames", _SE(js_spine_DeformTimeline_getFrames)); 
    cls->defineFunction("getAttachment", _SE(js_spine_DeformTimeline_getAttachment)); 
    cls->defineFunction("setAttachment", _SE(js_spine_DeformTimeline_setAttachment)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_DeformTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::DeformTimeline>(cls);
    
    __jsb_spine_DeformTimeline_proto = cls->getProto();
    __jsb_spine_DeformTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_DrawOrderTimeline_class = nullptr;
se::Object* __jsb_spine_DrawOrderTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_DrawOrderTimeline) 

static bool js_spine_DrawOrderTimeline_getFrames(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::DrawOrderTimeline *arg1 = (spine::DrawOrderTimeline *) NULL ;
    spine::Vector< float > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::DrawOrderTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< float > *) &(arg1)->getFrames();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DrawOrderTimeline_getFrames, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_DrawOrderTimeline_getFrames) 

static bool js_spine_DrawOrderTimeline_getFrameCount(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::DrawOrderTimeline *arg1 = (spine::DrawOrderTimeline *) NULL ;
    size_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::DrawOrderTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getFrameCount();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_DrawOrderTimeline_getFrameCount) 

static bool js_delete_spine_DrawOrderTimeline(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_DrawOrderTimeline) 

bool js_register_spine_DrawOrderTimeline(se::Object* obj) {
    auto* cls = se::Class::create("DrawOrderTimeline", obj, __jsb_spine_Timeline_proto, nullptr); 
    
    
    cls->defineFunction("getFrames", _SE(js_spine_DrawOrderTimeline_getFrames)); 
    cls->defineFunction("getFrameCount", _SE(js_spine_DrawOrderTimeline_getFrameCount)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_DrawOrderTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::DrawOrderTimeline>(cls);
    
    __jsb_spine_DrawOrderTimeline_proto = cls->getProto();
    __jsb_spine_DrawOrderTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_Event_class = nullptr;
se::Object* __jsb_spine_Event_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_Event) 

static bool js_spine_Event_getData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Event *arg1 = (spine::Event *) NULL ;
    spine::EventData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Event>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::EventData *) &(arg1)->getData();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Event_getData, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Event_getData) 

static bool js_spine_Event_getTime(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Event *arg1 = (spine::Event *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Event>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getTime();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Event_getTime) 

static bool js_spine_Event_getIntValue(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Event *arg1 = (spine::Event *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Event>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)(arg1)->getIntValue();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Event_getIntValue) 

static bool js_spine_Event_setIntValue(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Event *arg1 = (spine::Event *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Event>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Event_setIntValue,2,SWIGTYPE_int"); 
    (arg1)->setIntValue(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Event_setIntValue) 

static bool js_spine_Event_getFloatValue(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Event *arg1 = (spine::Event *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Event>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getFloatValue();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Event_getFloatValue) 

static bool js_spine_Event_setFloatValue(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Event *arg1 = (spine::Event *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Event>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Event_setFloatValue,2,SWIGTYPE_float"); 
    (arg1)->setFloatValue(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Event_setFloatValue) 

static bool js_spine_Event_getStringValue(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Event *arg1 = (spine::Event *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Event>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::String *) &(arg1)->getStringValue();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Event_getStringValue, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Event_getStringValue) 

static bool js_spine_Event_setStringValue(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Event *arg1 = (spine::Event *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Event>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Event_setStringValue,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    (arg1)->setStringValue((spine::String const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Event_setStringValue) 

static bool js_spine_Event_getVolume(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Event *arg1 = (spine::Event *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Event>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getVolume();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Event_getVolume) 

static bool js_spine_Event_setVolume(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Event *arg1 = (spine::Event *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Event>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Event_setVolume,2,SWIGTYPE_float"); 
    (arg1)->setVolume(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Event_setVolume) 

static bool js_spine_Event_getBalance(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Event *arg1 = (spine::Event *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Event>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getBalance();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Event_getBalance) 

static bool js_spine_Event_setBalance(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Event *arg1 = (spine::Event *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Event>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Event_setBalance,2,SWIGTYPE_float"); 
    (arg1)->setBalance(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Event_setBalance) 

static bool js_delete_spine_Event(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_Event) 

bool js_register_spine_Event(se::Object* obj) {
    auto* cls = se::Class::create("Event", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("getData", _SE(js_spine_Event_getData)); 
    cls->defineFunction("getTime", _SE(js_spine_Event_getTime)); 
    cls->defineFunction("getIntValue", _SE(js_spine_Event_getIntValue)); 
    cls->defineFunction("setIntValue", _SE(js_spine_Event_setIntValue)); 
    cls->defineFunction("getFloatValue", _SE(js_spine_Event_getFloatValue)); 
    cls->defineFunction("setFloatValue", _SE(js_spine_Event_setFloatValue)); 
    cls->defineFunction("getStringValue", _SE(js_spine_Event_getStringValue)); 
    cls->defineFunction("setStringValue", _SE(js_spine_Event_setStringValue)); 
    cls->defineFunction("getVolume", _SE(js_spine_Event_getVolume)); 
    cls->defineFunction("setVolume", _SE(js_spine_Event_setVolume)); 
    cls->defineFunction("getBalance", _SE(js_spine_Event_getBalance)); 
    cls->defineFunction("setBalance", _SE(js_spine_Event_setBalance)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_Event));
    
    
    cls->install();
    JSBClassType::registerClass<spine::Event>(cls);
    
    __jsb_spine_Event_proto = cls->getProto();
    __jsb_spine_Event_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_EventData_class = nullptr;
se::Object* __jsb_spine_EventData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_EventData) 

static bool js_spine_EventData_getName(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventData *arg1 = (spine::EventData *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::String *) &((spine::EventData const *)arg1)->getName();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "EventData_getName, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventData_getName) 

static bool js_spine_EventData_getIntValue(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventData *arg1 = (spine::EventData *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)(arg1)->getIntValue();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventData_getIntValue) 

static bool js_spine_EventData_setIntValue(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventData *arg1 = (spine::EventData *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "EventData_setIntValue,2,SWIGTYPE_int"); 
    (arg1)->setIntValue(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventData_setIntValue) 

static bool js_spine_EventData_getFloatValue(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventData *arg1 = (spine::EventData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getFloatValue();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventData_getFloatValue) 

static bool js_spine_EventData_setFloatValue(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventData *arg1 = (spine::EventData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "EventData_setFloatValue,2,SWIGTYPE_float"); 
    (arg1)->setFloatValue(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventData_setFloatValue) 

static bool js_spine_EventData_getStringValue(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventData *arg1 = (spine::EventData *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::String *) &(arg1)->getStringValue();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "EventData_getStringValue, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventData_getStringValue) 

static bool js_spine_EventData_setStringValue(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventData *arg1 = (spine::EventData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "EventData_setStringValue,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    (arg1)->setStringValue((spine::String const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventData_setStringValue) 

static bool js_spine_EventData_getAudioPath(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventData *arg1 = (spine::EventData *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::String *) &(arg1)->getAudioPath();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "EventData_getAudioPath, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventData_getAudioPath) 

static bool js_spine_EventData_setAudioPath(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventData *arg1 = (spine::EventData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "EventData_setAudioPath,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    (arg1)->setAudioPath((spine::String const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventData_setAudioPath) 

static bool js_spine_EventData_getVolume(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventData *arg1 = (spine::EventData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getVolume();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventData_getVolume) 

static bool js_spine_EventData_setVolume(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventData *arg1 = (spine::EventData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "EventData_setVolume,2,SWIGTYPE_float"); 
    (arg1)->setVolume(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventData_setVolume) 

static bool js_spine_EventData_getBalance(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventData *arg1 = (spine::EventData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getBalance();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventData_getBalance) 

static bool js_spine_EventData_setBalance(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventData *arg1 = (spine::EventData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "EventData_setBalance,2,SWIGTYPE_float"); 
    (arg1)->setBalance(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventData_setBalance) 

static bool js_delete_spine_EventData(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_EventData) 

bool js_register_spine_EventData(se::Object* obj) {
    auto* cls = se::Class::create("EventData", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("getName", _SE(js_spine_EventData_getName)); 
    cls->defineFunction("getIntValue", _SE(js_spine_EventData_getIntValue)); 
    cls->defineFunction("setIntValue", _SE(js_spine_EventData_setIntValue)); 
    cls->defineFunction("getFloatValue", _SE(js_spine_EventData_getFloatValue)); 
    cls->defineFunction("setFloatValue", _SE(js_spine_EventData_setFloatValue)); 
    cls->defineFunction("getStringValue", _SE(js_spine_EventData_getStringValue)); 
    cls->defineFunction("setStringValue", _SE(js_spine_EventData_setStringValue)); 
    cls->defineFunction("getAudioPath", _SE(js_spine_EventData_getAudioPath)); 
    cls->defineFunction("setAudioPath", _SE(js_spine_EventData_setAudioPath)); 
    cls->defineFunction("getVolume", _SE(js_spine_EventData_getVolume)); 
    cls->defineFunction("setVolume", _SE(js_spine_EventData_setVolume)); 
    cls->defineFunction("getBalance", _SE(js_spine_EventData_getBalance)); 
    cls->defineFunction("setBalance", _SE(js_spine_EventData_setBalance)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_EventData));
    
    
    cls->install();
    JSBClassType::registerClass<spine::EventData>(cls);
    
    __jsb_spine_EventData_proto = cls->getProto();
    __jsb_spine_EventData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_EventTimeline_class = nullptr;
se::Object* __jsb_spine_EventTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_EventTimeline) 

static bool js_delete_spine_EventTimeline(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_EventTimeline) 

static bool js_spine_EventTimeline_setFrame(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventTimeline *arg1 = (spine::EventTimeline *) NULL ;
    size_t arg2 ;
    spine::Event *arg3 = (spine::Event *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "EventTimeline_setFrame,2,SWIGTYPE_size_t");
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "EventTimeline_setFrame,3,SWIGTYPE_p_spine__Event"); 
    (arg1)->setFrame(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventTimeline_setFrame) 

static bool js_spine_EventTimeline_getFrames(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventTimeline *arg1 = (spine::EventTimeline *) NULL ;
    spine::Vector< float > result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getFrames();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "EventTimeline_getFrames, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventTimeline_getFrames) 

static bool js_spine_EventTimeline_getEvents(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventTimeline *arg1 = (spine::EventTimeline *) NULL ;
    spine::Vector< spine::Event * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::Event * > *) &(arg1)->getEvents();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "EventTimeline_getEvents, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventTimeline_getEvents) 

static bool js_spine_EventTimeline_getFrameCount(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::EventTimeline *arg1 = (spine::EventTimeline *) NULL ;
    size_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::EventTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getFrameCount();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_EventTimeline_getFrameCount) 

bool js_register_spine_EventTimeline(se::Object* obj) {
    auto* cls = se::Class::create("EventTimeline", obj, __jsb_spine_Timeline_proto, nullptr); 
    
    
    cls->defineFunction("setFrame", _SE(js_spine_EventTimeline_setFrame)); 
    cls->defineFunction("getFrames", _SE(js_spine_EventTimeline_getFrames)); 
    cls->defineFunction("getEvents", _SE(js_spine_EventTimeline_getEvents)); 
    cls->defineFunction("getFrameCount", _SE(js_spine_EventTimeline_getFrameCount)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_EventTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::EventTimeline>(cls);
    
    __jsb_spine_EventTimeline_proto = cls->getProto();
    __jsb_spine_EventTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_IkConstraint_class = nullptr;
se::Object* __jsb_spine_IkConstraint_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_IkConstraint) 

static bool js_spine_IkConstraint_update(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->update();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_update) 

static bool js_spine_IkConstraint_getOrder(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)(arg1)->getOrder();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_getOrder) 

static bool js_spine_IkConstraint_getData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    spine::IkConstraintData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::IkConstraintData *) &(arg1)->getData();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IkConstraint_getData, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_getData) 

static bool js_spine_IkConstraint_getBones(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    spine::Vector< spine::Bone * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::Bone * > *) &(arg1)->getBones();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IkConstraint_getBones, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_getBones) 

static bool js_spine_IkConstraint_getTarget(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    spine::Bone *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Bone *)(arg1)->getTarget();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IkConstraint_getTarget, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_getTarget) 

static bool js_spine_IkConstraint_setTarget(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    spine::Bone *arg2 = (spine::Bone *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "IkConstraint_setTarget,2,SWIGTYPE_p_spine__Bone"); 
    (arg1)->setTarget(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_setTarget) 

static bool js_spine_IkConstraint_getBendDirection(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)(arg1)->getBendDirection();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_getBendDirection) 

static bool js_spine_IkConstraint_setBendDirection(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "IkConstraint_setBendDirection,2,SWIGTYPE_int"); 
    (arg1)->setBendDirection(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_setBendDirection) 

static bool js_spine_IkConstraint_getCompress(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->getCompress();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_getCompress) 

static bool js_spine_IkConstraint_setCompress(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "IkConstraint_setCompress,2,SWIGTYPE_bool"); 
    (arg1)->setCompress(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_setCompress) 

static bool js_spine_IkConstraint_getStretch(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->getStretch();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_getStretch) 

static bool js_spine_IkConstraint_setStretch(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "IkConstraint_setStretch,2,SWIGTYPE_bool"); 
    (arg1)->setStretch(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_setStretch) 

static bool js_spine_IkConstraint_getMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getMix();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_getMix) 

static bool js_spine_IkConstraint_setMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "IkConstraint_setMix,2,SWIGTYPE_float"); 
    (arg1)->setMix(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_setMix) 

static bool js_spine_IkConstraint_getSoftness(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getSoftness();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_getSoftness) 

static bool js_spine_IkConstraint_setSoftness(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "IkConstraint_setSoftness,2,SWIGTYPE_float"); 
    (arg1)->setSoftness(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_setSoftness) 

static bool js_spine_IkConstraint_isActive(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->isActive();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_isActive) 

static bool js_spine_IkConstraint_setActive(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraint *arg1 = (spine::IkConstraint *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "IkConstraint_setActive,2,SWIGTYPE_bool"); 
    (arg1)->setActive(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraint_setActive) 

static bool js_delete_spine_IkConstraint(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_IkConstraint) 

bool js_register_spine_IkConstraint(se::Object* obj) {
    auto* cls = se::Class::create("IkConstraint", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("update", _SE(js_spine_IkConstraint_update)); 
    cls->defineFunction("getOrder", _SE(js_spine_IkConstraint_getOrder)); 
    cls->defineFunction("getData", _SE(js_spine_IkConstraint_getData)); 
    cls->defineFunction("getBones", _SE(js_spine_IkConstraint_getBones)); 
    cls->defineFunction("getTarget", _SE(js_spine_IkConstraint_getTarget)); 
    cls->defineFunction("setTarget", _SE(js_spine_IkConstraint_setTarget)); 
    cls->defineFunction("getBendDirection", _SE(js_spine_IkConstraint_getBendDirection)); 
    cls->defineFunction("setBendDirection", _SE(js_spine_IkConstraint_setBendDirection)); 
    cls->defineFunction("getCompress", _SE(js_spine_IkConstraint_getCompress)); 
    cls->defineFunction("setCompress", _SE(js_spine_IkConstraint_setCompress)); 
    cls->defineFunction("getStretch", _SE(js_spine_IkConstraint_getStretch)); 
    cls->defineFunction("setStretch", _SE(js_spine_IkConstraint_setStretch)); 
    cls->defineFunction("getMix", _SE(js_spine_IkConstraint_getMix)); 
    cls->defineFunction("setMix", _SE(js_spine_IkConstraint_setMix)); 
    cls->defineFunction("getSoftness", _SE(js_spine_IkConstraint_getSoftness)); 
    cls->defineFunction("setSoftness", _SE(js_spine_IkConstraint_setSoftness)); 
    cls->defineFunction("isActive", _SE(js_spine_IkConstraint_isActive)); 
    cls->defineFunction("setActive", _SE(js_spine_IkConstraint_setActive)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_IkConstraint));
    
    
    cls->install();
    JSBClassType::registerClass<spine::IkConstraint>(cls);
    
    __jsb_spine_IkConstraint_proto = cls->getProto();
    __jsb_spine_IkConstraint_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_IkConstraintData_class = nullptr;
se::Object* __jsb_spine_IkConstraintData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_IkConstraintData) 

static bool js_spine_IkConstraintData_getBones(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    spine::Vector< spine::BoneData * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::BoneData * > *) &(arg1)->getBones();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IkConstraintData_getBones, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_getBones) 

static bool js_spine_IkConstraintData_getTarget(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    spine::BoneData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::BoneData *)(arg1)->getTarget();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IkConstraintData_getTarget, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_getTarget) 

static bool js_spine_IkConstraintData_setTarget(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    spine::BoneData *arg2 = (spine::BoneData *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "IkConstraintData_setTarget,2,SWIGTYPE_p_spine__BoneData"); 
    (arg1)->setTarget(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_setTarget) 

static bool js_spine_IkConstraintData_getBendDirection(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)(arg1)->getBendDirection();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_getBendDirection) 

static bool js_spine_IkConstraintData_setBendDirection(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "IkConstraintData_setBendDirection,2,SWIGTYPE_int"); 
    (arg1)->setBendDirection(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_setBendDirection) 

static bool js_spine_IkConstraintData_getCompress(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->getCompress();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_getCompress) 

static bool js_spine_IkConstraintData_setCompress(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "IkConstraintData_setCompress,2,SWIGTYPE_bool"); 
    (arg1)->setCompress(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_setCompress) 

static bool js_spine_IkConstraintData_getStretch(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->getStretch();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_getStretch) 

static bool js_spine_IkConstraintData_setStretch(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "IkConstraintData_setStretch,2,SWIGTYPE_bool"); 
    (arg1)->setStretch(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_setStretch) 

static bool js_spine_IkConstraintData_getUniform(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->getUniform();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_getUniform) 

static bool js_spine_IkConstraintData_setUniform(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "IkConstraintData_setUniform,2,SWIGTYPE_bool"); 
    (arg1)->setUniform(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_setUniform) 

static bool js_spine_IkConstraintData_getMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getMix();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_getMix) 

static bool js_spine_IkConstraintData_setMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "IkConstraintData_setMix,2,SWIGTYPE_float"); 
    (arg1)->setMix(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_setMix) 

static bool js_spine_IkConstraintData_getSoftness(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getSoftness();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_getSoftness) 

static bool js_spine_IkConstraintData_setSoftness(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintData *arg1 = (spine::IkConstraintData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "IkConstraintData_setSoftness,2,SWIGTYPE_float"); 
    (arg1)->setSoftness(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintData_setSoftness) 

static bool js_delete_spine_IkConstraintData(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_IkConstraintData) 

bool js_register_spine_IkConstraintData(se::Object* obj) {
    auto* cls = se::Class::create("IkConstraintData", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("getBones", _SE(js_spine_IkConstraintData_getBones)); 
    cls->defineFunction("getTarget", _SE(js_spine_IkConstraintData_getTarget)); 
    cls->defineFunction("setTarget", _SE(js_spine_IkConstraintData_setTarget)); 
    cls->defineFunction("getBendDirection", _SE(js_spine_IkConstraintData_getBendDirection)); 
    cls->defineFunction("setBendDirection", _SE(js_spine_IkConstraintData_setBendDirection)); 
    cls->defineFunction("getCompress", _SE(js_spine_IkConstraintData_getCompress)); 
    cls->defineFunction("setCompress", _SE(js_spine_IkConstraintData_setCompress)); 
    cls->defineFunction("getStretch", _SE(js_spine_IkConstraintData_getStretch)); 
    cls->defineFunction("setStretch", _SE(js_spine_IkConstraintData_setStretch)); 
    cls->defineFunction("getUniform", _SE(js_spine_IkConstraintData_getUniform)); 
    cls->defineFunction("setUniform", _SE(js_spine_IkConstraintData_setUniform)); 
    cls->defineFunction("getMix", _SE(js_spine_IkConstraintData_getMix)); 
    cls->defineFunction("setMix", _SE(js_spine_IkConstraintData_setMix)); 
    cls->defineFunction("getSoftness", _SE(js_spine_IkConstraintData_getSoftness)); 
    cls->defineFunction("setSoftness", _SE(js_spine_IkConstraintData_setSoftness)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_IkConstraintData));
    
    
    cls->install();
    JSBClassType::registerClass<spine::IkConstraintData>(cls);
    
    __jsb_spine_IkConstraintData_proto = cls->getProto();
    __jsb_spine_IkConstraintData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_IkConstraintTimeline_class = nullptr;
se::Object* __jsb_spine_IkConstraintTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_IkConstraintTimeline) 

static bool js_spine_IkConstraintTimeline_ENTRIES_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    int result;
    
    result = (int)(int)spine::IkConstraintTimeline::ENTRIES;
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_IkConstraintTimeline_ENTRIES_get) 

static bool js_spine_IkConstraintTimeline_setFrame(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::IkConstraintTimeline *arg1 = (spine::IkConstraintTimeline *) NULL ;
    int arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    int arg6 ;
    bool arg7 ;
    bool arg8 ;
    
    if(argc != 7) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 7);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::IkConstraintTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "IkConstraintTimeline_setFrame,2,SWIGTYPE_int"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "IkConstraintTimeline_setFrame,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "IkConstraintTimeline_setFrame,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "IkConstraintTimeline_setFrame,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "IkConstraintTimeline_setFrame,6,SWIGTYPE_int"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "IkConstraintTimeline_setFrame,7,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "IkConstraintTimeline_setFrame,8,SWIGTYPE_bool"); 
    (arg1)->setFrame(arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_IkConstraintTimeline_setFrame) 

static bool js_delete_spine_IkConstraintTimeline(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_IkConstraintTimeline) 

bool js_register_spine_IkConstraintTimeline(se::Object* obj) {
    auto* cls = se::Class::create("IkConstraintTimeline", obj, __jsb_spine_CurveTimeline_proto, nullptr); 
    
    
    cls->defineFunction("setFrame", _SE(js_spine_IkConstraintTimeline_setFrame)); 
    
    cls->defineStaticProperty("ENTRIES", _SE(js_spine_IkConstraintTimeline_ENTRIES_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_IkConstraintTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::IkConstraintTimeline>(cls);
    
    __jsb_spine_IkConstraintTimeline_proto = cls->getProto();
    __jsb_spine_IkConstraintTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_MeshAttachment_class = nullptr;
se::Object* __jsb_spine_MeshAttachment_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_MeshAttachment) 

static bool js_delete_spine_MeshAttachment(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_MeshAttachment) 

static bool js_spine_MeshAttachment_updateUVs(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->updateUVs();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_updateUVs) 

static bool js_spine_MeshAttachment_getHullLength(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)(arg1)->getHullLength();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getHullLength) 

static bool js_spine_MeshAttachment_setHullLength(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "MeshAttachment_setHullLength,2,SWIGTYPE_int"); 
    (arg1)->setHullLength(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setHullLength) 

static bool js_spine_MeshAttachment_getRegionUVs(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    spine::Vector< float > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< float > *) &(arg1)->getRegionUVs();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MeshAttachment_getRegionUVs, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getRegionUVs) 

static bool js_spine_MeshAttachment_getUVs(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    spine::Vector< float > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< float > *) &(arg1)->getUVs();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MeshAttachment_getUVs, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getUVs) 

static bool js_spine_MeshAttachment_getTriangles(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    spine::Vector< unsigned short > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< unsigned short > *) &(arg1)->getTriangles();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MeshAttachment_getTriangles, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getTriangles) 

static bool js_spine_MeshAttachment_getColor(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    spine::Color *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Color *) &(arg1)->getColor();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MeshAttachment_getColor, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getColor) 

static bool js_spine_MeshAttachment_getPath(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::String *) &(arg1)->getPath();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MeshAttachment_getPath, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getPath) 

static bool js_spine_MeshAttachment_setPath(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "MeshAttachment_setPath,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    (arg1)->setPath((spine::String const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setPath) 

static bool js_spine_MeshAttachment_getRegionU(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getRegionU();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getRegionU) 

static bool js_spine_MeshAttachment_setRegionU(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "MeshAttachment_setRegionU,2,SWIGTYPE_float"); 
    (arg1)->setRegionU(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setRegionU) 

static bool js_spine_MeshAttachment_getRegionV(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getRegionV();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getRegionV) 

static bool js_spine_MeshAttachment_setRegionV(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "MeshAttachment_setRegionV,2,SWIGTYPE_float"); 
    (arg1)->setRegionV(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setRegionV) 

static bool js_spine_MeshAttachment_getRegionU2(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getRegionU2();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getRegionU2) 

static bool js_spine_MeshAttachment_setRegionU2(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "MeshAttachment_setRegionU2,2,SWIGTYPE_float"); 
    (arg1)->setRegionU2(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setRegionU2) 

static bool js_spine_MeshAttachment_getRegionV2(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getRegionV2();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getRegionV2) 

static bool js_spine_MeshAttachment_setRegionV2(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "MeshAttachment_setRegionV2,2,SWIGTYPE_float"); 
    (arg1)->setRegionV2(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setRegionV2) 

static bool js_spine_MeshAttachment_getRegionRotate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->getRegionRotate();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getRegionRotate) 

static bool js_spine_MeshAttachment_setRegionRotate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "MeshAttachment_setRegionRotate,2,SWIGTYPE_bool"); 
    (arg1)->setRegionRotate(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setRegionRotate) 

static bool js_spine_MeshAttachment_getRegionDegrees(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)(arg1)->getRegionDegrees();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getRegionDegrees) 

static bool js_spine_MeshAttachment_setRegionDegrees(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "MeshAttachment_setRegionDegrees,2,SWIGTYPE_int"); 
    (arg1)->setRegionDegrees(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setRegionDegrees) 

static bool js_spine_MeshAttachment_getRegionOffsetX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getRegionOffsetX();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getRegionOffsetX) 

static bool js_spine_MeshAttachment_setRegionOffsetX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "MeshAttachment_setRegionOffsetX,2,SWIGTYPE_float"); 
    (arg1)->setRegionOffsetX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setRegionOffsetX) 

static bool js_spine_MeshAttachment_getRegionOffsetY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getRegionOffsetY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getRegionOffsetY) 

static bool js_spine_MeshAttachment_setRegionOffsetY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "MeshAttachment_setRegionOffsetY,2,SWIGTYPE_float"); 
    (arg1)->setRegionOffsetY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setRegionOffsetY) 

static bool js_spine_MeshAttachment_getRegionWidth(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getRegionWidth();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getRegionWidth) 

static bool js_spine_MeshAttachment_setRegionWidth(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "MeshAttachment_setRegionWidth,2,SWIGTYPE_float"); 
    (arg1)->setRegionWidth(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setRegionWidth) 

static bool js_spine_MeshAttachment_getRegionHeight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getRegionHeight();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getRegionHeight) 

static bool js_spine_MeshAttachment_setRegionHeight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "MeshAttachment_setRegionHeight,2,SWIGTYPE_float"); 
    (arg1)->setRegionHeight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setRegionHeight) 

static bool js_spine_MeshAttachment_getRegionOriginalWidth(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getRegionOriginalWidth();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getRegionOriginalWidth) 

static bool js_spine_MeshAttachment_setRegionOriginalWidth(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "MeshAttachment_setRegionOriginalWidth,2,SWIGTYPE_float"); 
    (arg1)->setRegionOriginalWidth(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setRegionOriginalWidth) 

static bool js_spine_MeshAttachment_getRegionOriginalHeight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getRegionOriginalHeight();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getRegionOriginalHeight) 

static bool js_spine_MeshAttachment_setRegionOriginalHeight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "MeshAttachment_setRegionOriginalHeight,2,SWIGTYPE_float"); 
    (arg1)->setRegionOriginalHeight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setRegionOriginalHeight) 

static bool js_spine_MeshAttachment_getParentMesh(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    spine::MeshAttachment *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::MeshAttachment *)(arg1)->getParentMesh();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MeshAttachment_getParentMesh, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getParentMesh) 

static bool js_spine_MeshAttachment_setParentMesh(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    spine::MeshAttachment *arg2 = (spine::MeshAttachment *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "MeshAttachment_setParentMesh,2,SWIGTYPE_p_spine__MeshAttachment"); 
    (arg1)->setParentMesh(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setParentMesh) 

static bool js_spine_MeshAttachment_getEdges(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    spine::Vector< unsigned short > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< unsigned short > *) &(arg1)->getEdges();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MeshAttachment_getEdges, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getEdges) 

static bool js_spine_MeshAttachment_getWidth(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getWidth();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getWidth) 

static bool js_spine_MeshAttachment_setWidth(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "MeshAttachment_setWidth,2,SWIGTYPE_float"); 
    (arg1)->setWidth(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setWidth) 

static bool js_spine_MeshAttachment_getHeight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getHeight();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_getHeight) 

static bool js_spine_MeshAttachment_setHeight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "MeshAttachment_setHeight,2,SWIGTYPE_float"); 
    (arg1)->setHeight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_setHeight) 

static bool js_spine_MeshAttachment_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    spine::Attachment *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Attachment *)(arg1)->copy();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MeshAttachment_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_copy) 

static bool js_spine_MeshAttachment_newLinkedMesh(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::MeshAttachment *arg1 = (spine::MeshAttachment *) NULL ;
    spine::MeshAttachment *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::MeshAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::MeshAttachment *)(arg1)->newLinkedMesh();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MeshAttachment_newLinkedMesh, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_MeshAttachment_newLinkedMesh) 

bool js_register_spine_MeshAttachment(se::Object* obj) {
    auto* cls = se::Class::create("MeshAttachment", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("updateUVs", _SE(js_spine_MeshAttachment_updateUVs)); 
    cls->defineFunction("getHullLength", _SE(js_spine_MeshAttachment_getHullLength)); 
    cls->defineFunction("setHullLength", _SE(js_spine_MeshAttachment_setHullLength)); 
    cls->defineFunction("getRegionUVs", _SE(js_spine_MeshAttachment_getRegionUVs)); 
    cls->defineFunction("getUVs", _SE(js_spine_MeshAttachment_getUVs)); 
    cls->defineFunction("getTriangles", _SE(js_spine_MeshAttachment_getTriangles)); 
    cls->defineFunction("getColor", _SE(js_spine_MeshAttachment_getColor)); 
    cls->defineFunction("getPath", _SE(js_spine_MeshAttachment_getPath)); 
    cls->defineFunction("setPath", _SE(js_spine_MeshAttachment_setPath)); 
    cls->defineFunction("getRegionU", _SE(js_spine_MeshAttachment_getRegionU)); 
    cls->defineFunction("setRegionU", _SE(js_spine_MeshAttachment_setRegionU)); 
    cls->defineFunction("getRegionV", _SE(js_spine_MeshAttachment_getRegionV)); 
    cls->defineFunction("setRegionV", _SE(js_spine_MeshAttachment_setRegionV)); 
    cls->defineFunction("getRegionU2", _SE(js_spine_MeshAttachment_getRegionU2)); 
    cls->defineFunction("setRegionU2", _SE(js_spine_MeshAttachment_setRegionU2)); 
    cls->defineFunction("getRegionV2", _SE(js_spine_MeshAttachment_getRegionV2)); 
    cls->defineFunction("setRegionV2", _SE(js_spine_MeshAttachment_setRegionV2)); 
    cls->defineFunction("getRegionRotate", _SE(js_spine_MeshAttachment_getRegionRotate)); 
    cls->defineFunction("setRegionRotate", _SE(js_spine_MeshAttachment_setRegionRotate)); 
    cls->defineFunction("getRegionDegrees", _SE(js_spine_MeshAttachment_getRegionDegrees)); 
    cls->defineFunction("setRegionDegrees", _SE(js_spine_MeshAttachment_setRegionDegrees)); 
    cls->defineFunction("getRegionOffsetX", _SE(js_spine_MeshAttachment_getRegionOffsetX)); 
    cls->defineFunction("setRegionOffsetX", _SE(js_spine_MeshAttachment_setRegionOffsetX)); 
    cls->defineFunction("getRegionOffsetY", _SE(js_spine_MeshAttachment_getRegionOffsetY)); 
    cls->defineFunction("setRegionOffsetY", _SE(js_spine_MeshAttachment_setRegionOffsetY)); 
    cls->defineFunction("getRegionWidth", _SE(js_spine_MeshAttachment_getRegionWidth)); 
    cls->defineFunction("setRegionWidth", _SE(js_spine_MeshAttachment_setRegionWidth)); 
    cls->defineFunction("getRegionHeight", _SE(js_spine_MeshAttachment_getRegionHeight)); 
    cls->defineFunction("setRegionHeight", _SE(js_spine_MeshAttachment_setRegionHeight)); 
    cls->defineFunction("getRegionOriginalWidth", _SE(js_spine_MeshAttachment_getRegionOriginalWidth)); 
    cls->defineFunction("setRegionOriginalWidth", _SE(js_spine_MeshAttachment_setRegionOriginalWidth)); 
    cls->defineFunction("getRegionOriginalHeight", _SE(js_spine_MeshAttachment_getRegionOriginalHeight)); 
    cls->defineFunction("setRegionOriginalHeight", _SE(js_spine_MeshAttachment_setRegionOriginalHeight)); 
    cls->defineFunction("getParentMesh", _SE(js_spine_MeshAttachment_getParentMesh)); 
    cls->defineFunction("setParentMesh", _SE(js_spine_MeshAttachment_setParentMesh)); 
    cls->defineFunction("getEdges", _SE(js_spine_MeshAttachment_getEdges)); 
    cls->defineFunction("getWidth", _SE(js_spine_MeshAttachment_getWidth)); 
    cls->defineFunction("setWidth", _SE(js_spine_MeshAttachment_setWidth)); 
    cls->defineFunction("getHeight", _SE(js_spine_MeshAttachment_getHeight)); 
    cls->defineFunction("setHeight", _SE(js_spine_MeshAttachment_setHeight)); 
    cls->defineFunction("copy", _SE(js_spine_MeshAttachment_copy)); 
    cls->defineFunction("newLinkedMesh", _SE(js_spine_MeshAttachment_newLinkedMesh)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_MeshAttachment));
    
    
    cls->install();
    JSBClassType::registerClass<spine::MeshAttachment>(cls);
    
    __jsb_spine_MeshAttachment_proto = cls->getProto();
    __jsb_spine_MeshAttachment_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_PathAttachment_class = nullptr;
se::Object* __jsb_spine_PathAttachment_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_PathAttachment) 

static bool js_spine_PathAttachment_getLengths(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathAttachment *arg1 = (spine::PathAttachment *) NULL ;
    spine::Vector< float > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< float > *) &(arg1)->getLengths();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PathAttachment_getLengths, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathAttachment_getLengths) 

static bool js_spine_PathAttachment_isClosed(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathAttachment *arg1 = (spine::PathAttachment *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->isClosed();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathAttachment_isClosed) 

static bool js_spine_PathAttachment_setClosed(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathAttachment *arg1 = (spine::PathAttachment *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "PathAttachment_setClosed,2,SWIGTYPE_bool"); 
    (arg1)->setClosed(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathAttachment_setClosed) 

static bool js_spine_PathAttachment_isConstantSpeed(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathAttachment *arg1 = (spine::PathAttachment *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->isConstantSpeed();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathAttachment_isConstantSpeed) 

static bool js_spine_PathAttachment_setConstantSpeed(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathAttachment *arg1 = (spine::PathAttachment *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "PathAttachment_setConstantSpeed,2,SWIGTYPE_bool"); 
    (arg1)->setConstantSpeed(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathAttachment_setConstantSpeed) 

static bool js_spine_PathAttachment_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathAttachment *arg1 = (spine::PathAttachment *) NULL ;
    spine::Attachment *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Attachment *)(arg1)->copy();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PathAttachment_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathAttachment_copy) 

static bool js_delete_spine_PathAttachment(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_PathAttachment) 

bool js_register_spine_PathAttachment(se::Object* obj) {
    auto* cls = se::Class::create("PathAttachment", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("getLengths", _SE(js_spine_PathAttachment_getLengths)); 
    cls->defineFunction("isClosed", _SE(js_spine_PathAttachment_isClosed)); 
    cls->defineFunction("setClosed", _SE(js_spine_PathAttachment_setClosed)); 
    cls->defineFunction("isConstantSpeed", _SE(js_spine_PathAttachment_isConstantSpeed)); 
    cls->defineFunction("setConstantSpeed", _SE(js_spine_PathAttachment_setConstantSpeed)); 
    cls->defineFunction("copy", _SE(js_spine_PathAttachment_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_PathAttachment));
    
    
    cls->install();
    JSBClassType::registerClass<spine::PathAttachment>(cls);
    
    __jsb_spine_PathAttachment_proto = cls->getProto();
    __jsb_spine_PathAttachment_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_PathConstraint_class = nullptr;
se::Object* __jsb_spine_PathConstraint_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_PathConstraint) 

static bool js_spine_PathConstraint_apply(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->apply();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_apply) 

static bool js_spine_PathConstraint_update(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->update();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_update) 

static bool js_spine_PathConstraint_getOrder(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)(arg1)->getOrder();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_getOrder) 

static bool js_spine_PathConstraint_getPosition(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getPosition();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_getPosition) 

static bool js_spine_PathConstraint_setPosition(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "PathConstraint_setPosition,2,SWIGTYPE_float"); 
    (arg1)->setPosition(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_setPosition) 

static bool js_spine_PathConstraint_getSpacing(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getSpacing();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_getSpacing) 

static bool js_spine_PathConstraint_setSpacing(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "PathConstraint_setSpacing,2,SWIGTYPE_float"); 
    (arg1)->setSpacing(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_setSpacing) 

static bool js_spine_PathConstraint_getRotateMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getRotateMix();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_getRotateMix) 

static bool js_spine_PathConstraint_setRotateMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "PathConstraint_setRotateMix,2,SWIGTYPE_float"); 
    (arg1)->setRotateMix(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_setRotateMix) 

static bool js_spine_PathConstraint_getTranslateMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getTranslateMix();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_getTranslateMix) 

static bool js_spine_PathConstraint_setTranslateMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "PathConstraint_setTranslateMix,2,SWIGTYPE_float"); 
    (arg1)->setTranslateMix(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_setTranslateMix) 

static bool js_spine_PathConstraint_getBones(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    spine::Vector< spine::Bone * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::Bone * > *) &(arg1)->getBones();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PathConstraint_getBones, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_getBones) 

static bool js_spine_PathConstraint_getTarget(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    spine::Slot *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Slot *)(arg1)->getTarget();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PathConstraint_getTarget, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_getTarget) 

static bool js_spine_PathConstraint_setTarget(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    spine::Slot *arg2 = (spine::Slot *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "PathConstraint_setTarget,2,SWIGTYPE_p_spine__Slot"); 
    (arg1)->setTarget(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_setTarget) 

static bool js_spine_PathConstraint_getData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    spine::PathConstraintData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::PathConstraintData *) &(arg1)->getData();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PathConstraint_getData, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_getData) 

static bool js_spine_PathConstraint_isActive(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->isActive();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_isActive) 

static bool js_spine_PathConstraint_setActive(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraint *arg1 = (spine::PathConstraint *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "PathConstraint_setActive,2,SWIGTYPE_bool"); 
    (arg1)->setActive(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraint_setActive) 

static bool js_delete_spine_PathConstraint(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_PathConstraint) 

bool js_register_spine_PathConstraint(se::Object* obj) {
    auto* cls = se::Class::create("PathConstraint", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("apply", _SE(js_spine_PathConstraint_apply)); 
    cls->defineFunction("update", _SE(js_spine_PathConstraint_update)); 
    cls->defineFunction("getOrder", _SE(js_spine_PathConstraint_getOrder)); 
    cls->defineFunction("getPosition", _SE(js_spine_PathConstraint_getPosition)); 
    cls->defineFunction("setPosition", _SE(js_spine_PathConstraint_setPosition)); 
    cls->defineFunction("getSpacing", _SE(js_spine_PathConstraint_getSpacing)); 
    cls->defineFunction("setSpacing", _SE(js_spine_PathConstraint_setSpacing)); 
    cls->defineFunction("getRotateMix", _SE(js_spine_PathConstraint_getRotateMix)); 
    cls->defineFunction("setRotateMix", _SE(js_spine_PathConstraint_setRotateMix)); 
    cls->defineFunction("getTranslateMix", _SE(js_spine_PathConstraint_getTranslateMix)); 
    cls->defineFunction("setTranslateMix", _SE(js_spine_PathConstraint_setTranslateMix)); 
    cls->defineFunction("getBones", _SE(js_spine_PathConstraint_getBones)); 
    cls->defineFunction("getTarget", _SE(js_spine_PathConstraint_getTarget)); 
    cls->defineFunction("setTarget", _SE(js_spine_PathConstraint_setTarget)); 
    cls->defineFunction("getData", _SE(js_spine_PathConstraint_getData)); 
    cls->defineFunction("isActive", _SE(js_spine_PathConstraint_isActive)); 
    cls->defineFunction("setActive", _SE(js_spine_PathConstraint_setActive)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_PathConstraint));
    
    
    cls->install();
    JSBClassType::registerClass<spine::PathConstraint>(cls);
    
    __jsb_spine_PathConstraint_proto = cls->getProto();
    __jsb_spine_PathConstraint_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_PathConstraintData_class = nullptr;
se::Object* __jsb_spine_PathConstraintData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_PathConstraintData) 

static bool js_spine_PathConstraintData_getBones(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    spine::Vector< spine::BoneData * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::BoneData * > *) &(arg1)->getBones();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PathConstraintData_getBones, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_getBones) 

static bool js_spine_PathConstraintData_getTarget(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    spine::SlotData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::SlotData *)(arg1)->getTarget();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PathConstraintData_getTarget, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_getTarget) 

static bool js_spine_PathConstraintData_setTarget(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    spine::SlotData *arg2 = (spine::SlotData *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "PathConstraintData_setTarget,2,SWIGTYPE_p_spine__SlotData"); 
    (arg1)->setTarget(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_setTarget) 

static bool js_spine_PathConstraintData_getPositionMode(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    spine::PositionMode result;
    int32_t temp ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::PositionMode)(arg1)->getPositionMode();
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_getPositionMode) 

static bool js_spine_PathConstraintData_setPositionMode(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    spine::PositionMode arg2 ;
    int32_t temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "PathConstraintData_setPositionMode,2,SWIGTYPE_spine__PositionMode");
    arg2 = (spine::PositionMode)temp2;
    (arg1)->setPositionMode(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_setPositionMode) 

static bool js_spine_PathConstraintData_getSpacingMode(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    spine::SpacingMode result;
    int32_t temp ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::SpacingMode)(arg1)->getSpacingMode();
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_getSpacingMode) 

static bool js_spine_PathConstraintData_setSpacingMode(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    spine::SpacingMode arg2 ;
    int32_t temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "PathConstraintData_setSpacingMode,2,SWIGTYPE_spine__SpacingMode");
    arg2 = (spine::SpacingMode)temp2;
    (arg1)->setSpacingMode(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_setSpacingMode) 

static bool js_spine_PathConstraintData_getRotateMode(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    spine::RotateMode result;
    int32_t temp ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::RotateMode)(arg1)->getRotateMode();
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_getRotateMode) 

static bool js_spine_PathConstraintData_setRotateMode(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    spine::RotateMode arg2 ;
    int32_t temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "PathConstraintData_setRotateMode,2,SWIGTYPE_spine__RotateMode");
    arg2 = (spine::RotateMode)temp2;
    (arg1)->setRotateMode(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_setRotateMode) 

static bool js_spine_PathConstraintData_getOffsetRotation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getOffsetRotation();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_getOffsetRotation) 

static bool js_spine_PathConstraintData_setOffsetRotation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "PathConstraintData_setOffsetRotation,2,SWIGTYPE_float"); 
    (arg1)->setOffsetRotation(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_setOffsetRotation) 

static bool js_spine_PathConstraintData_getPosition(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getPosition();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_getPosition) 

static bool js_spine_PathConstraintData_setPosition(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "PathConstraintData_setPosition,2,SWIGTYPE_float"); 
    (arg1)->setPosition(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_setPosition) 

static bool js_spine_PathConstraintData_getSpacing(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getSpacing();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_getSpacing) 

static bool js_spine_PathConstraintData_setSpacing(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "PathConstraintData_setSpacing,2,SWIGTYPE_float"); 
    (arg1)->setSpacing(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_setSpacing) 

static bool js_spine_PathConstraintData_getRotateMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getRotateMix();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_getRotateMix) 

static bool js_spine_PathConstraintData_setRotateMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "PathConstraintData_setRotateMix,2,SWIGTYPE_float"); 
    (arg1)->setRotateMix(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_setRotateMix) 

static bool js_spine_PathConstraintData_getTranslateMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getTranslateMix();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_getTranslateMix) 

static bool js_spine_PathConstraintData_setTranslateMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintData *arg1 = (spine::PathConstraintData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "PathConstraintData_setTranslateMix,2,SWIGTYPE_float"); 
    (arg1)->setTranslateMix(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintData_setTranslateMix) 

static bool js_delete_spine_PathConstraintData(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_PathConstraintData) 

bool js_register_spine_PathConstraintData(se::Object* obj) {
    auto* cls = se::Class::create("PathConstraintData", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("getBones", _SE(js_spine_PathConstraintData_getBones)); 
    cls->defineFunction("getTarget", _SE(js_spine_PathConstraintData_getTarget)); 
    cls->defineFunction("setTarget", _SE(js_spine_PathConstraintData_setTarget)); 
    cls->defineFunction("getPositionMode", _SE(js_spine_PathConstraintData_getPositionMode)); 
    cls->defineFunction("setPositionMode", _SE(js_spine_PathConstraintData_setPositionMode)); 
    cls->defineFunction("getSpacingMode", _SE(js_spine_PathConstraintData_getSpacingMode)); 
    cls->defineFunction("setSpacingMode", _SE(js_spine_PathConstraintData_setSpacingMode)); 
    cls->defineFunction("getRotateMode", _SE(js_spine_PathConstraintData_getRotateMode)); 
    cls->defineFunction("setRotateMode", _SE(js_spine_PathConstraintData_setRotateMode)); 
    cls->defineFunction("getOffsetRotation", _SE(js_spine_PathConstraintData_getOffsetRotation)); 
    cls->defineFunction("setOffsetRotation", _SE(js_spine_PathConstraintData_setOffsetRotation)); 
    cls->defineFunction("getPosition", _SE(js_spine_PathConstraintData_getPosition)); 
    cls->defineFunction("setPosition", _SE(js_spine_PathConstraintData_setPosition)); 
    cls->defineFunction("getSpacing", _SE(js_spine_PathConstraintData_getSpacing)); 
    cls->defineFunction("setSpacing", _SE(js_spine_PathConstraintData_setSpacing)); 
    cls->defineFunction("getRotateMix", _SE(js_spine_PathConstraintData_getRotateMix)); 
    cls->defineFunction("setRotateMix", _SE(js_spine_PathConstraintData_setRotateMix)); 
    cls->defineFunction("getTranslateMix", _SE(js_spine_PathConstraintData_getTranslateMix)); 
    cls->defineFunction("setTranslateMix", _SE(js_spine_PathConstraintData_setTranslateMix)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_PathConstraintData));
    
    
    cls->install();
    JSBClassType::registerClass<spine::PathConstraintData>(cls);
    
    __jsb_spine_PathConstraintData_proto = cls->getProto();
    __jsb_spine_PathConstraintData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_PathConstraintMixTimeline_class = nullptr;
se::Object* __jsb_spine_PathConstraintMixTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_PathConstraintMixTimeline) 

static bool js_spine_PathConstraintMixTimeline_ENTRIES_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    int result;
    
    result = (int)(int)spine::PathConstraintMixTimeline::ENTRIES;
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_PathConstraintMixTimeline_ENTRIES_get) 

static bool js_delete_spine_PathConstraintMixTimeline(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_PathConstraintMixTimeline) 

bool js_register_spine_PathConstraintMixTimeline(se::Object* obj) {
    auto* cls = se::Class::create("PathConstraintMixTimeline", obj, __jsb_spine_CurveTimeline_proto, nullptr); 
    
    
    
    cls->defineStaticProperty("ENTRIES", _SE(js_spine_PathConstraintMixTimeline_ENTRIES_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_PathConstraintMixTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::PathConstraintMixTimeline>(cls);
    
    __jsb_spine_PathConstraintMixTimeline_proto = cls->getProto();
    __jsb_spine_PathConstraintMixTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_PathConstraintPositionTimeline_class = nullptr;
se::Object* __jsb_spine_PathConstraintPositionTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_PathConstraintPositionTimeline) 

static bool js_spine_PathConstraintPositionTimeline_ENTRIES_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    int result;
    
    result = (int)(int)spine::PathConstraintPositionTimeline::ENTRIES;
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_PathConstraintPositionTimeline_ENTRIES_get) 

static bool js_delete_spine_PathConstraintPositionTimeline(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_PathConstraintPositionTimeline) 

static bool js_spine_PathConstraintPositionTimeline_setFrame(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PathConstraintPositionTimeline *arg1 = (spine::PathConstraintPositionTimeline *) NULL ;
    int arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PathConstraintPositionTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "PathConstraintPositionTimeline_setFrame,2,SWIGTYPE_int"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "PathConstraintPositionTimeline_setFrame,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "PathConstraintPositionTimeline_setFrame,4,SWIGTYPE_float"); 
    (arg1)->setFrame(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PathConstraintPositionTimeline_setFrame) 

bool js_register_spine_PathConstraintPositionTimeline(se::Object* obj) {
    auto* cls = se::Class::create("PathConstraintPositionTimeline", obj, __jsb_spine_CurveTimeline_proto, nullptr); 
    
    
    cls->defineFunction("setFrame", _SE(js_spine_PathConstraintPositionTimeline_setFrame)); 
    
    cls->defineStaticProperty("ENTRIES", _SE(js_spine_PathConstraintPositionTimeline_ENTRIES_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_PathConstraintPositionTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::PathConstraintPositionTimeline>(cls);
    
    __jsb_spine_PathConstraintPositionTimeline_proto = cls->getProto();
    __jsb_spine_PathConstraintPositionTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_PathConstraintSpacingTimeline_class = nullptr;
se::Object* __jsb_spine_PathConstraintSpacingTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_PathConstraintSpacingTimeline) 

static bool js_delete_spine_PathConstraintSpacingTimeline(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_PathConstraintSpacingTimeline) 

bool js_register_spine_PathConstraintSpacingTimeline(se::Object* obj) {
    auto* cls = se::Class::create("PathConstraintSpacingTimeline", obj, __jsb_spine_PathConstraintPositionTimeline_proto, nullptr); 
    
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_PathConstraintSpacingTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::PathConstraintSpacingTimeline>(cls);
    
    __jsb_spine_PathConstraintSpacingTimeline_proto = cls->getProto();
    __jsb_spine_PathConstraintSpacingTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_PointAttachment_class = nullptr;
se::Object* __jsb_spine_PointAttachment_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_PointAttachment) 

static bool js_spine_PointAttachment_getX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PointAttachment *arg1 = (spine::PointAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PointAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getX();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PointAttachment_getX) 

static bool js_spine_PointAttachment_setX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PointAttachment *arg1 = (spine::PointAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PointAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "PointAttachment_setX,2,SWIGTYPE_float"); 
    (arg1)->setX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PointAttachment_setX) 

static bool js_spine_PointAttachment_getY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PointAttachment *arg1 = (spine::PointAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PointAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PointAttachment_getY) 

static bool js_spine_PointAttachment_setY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PointAttachment *arg1 = (spine::PointAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PointAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "PointAttachment_setY,2,SWIGTYPE_float"); 
    (arg1)->setY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PointAttachment_setY) 

static bool js_spine_PointAttachment_getRotation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PointAttachment *arg1 = (spine::PointAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PointAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getRotation();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PointAttachment_getRotation) 

static bool js_spine_PointAttachment_setRotation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::PointAttachment *arg1 = (spine::PointAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::PointAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "PointAttachment_setRotation,2,SWIGTYPE_float"); 
    (arg1)->setRotation(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_PointAttachment_setRotation) 

static bool js_delete_spine_PointAttachment(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_PointAttachment) 

bool js_register_spine_PointAttachment(se::Object* obj) {
    auto* cls = se::Class::create("PointAttachment", obj, __jsb_spine_Attachment_proto, nullptr); 
    
    
    cls->defineFunction("getX", _SE(js_spine_PointAttachment_getX)); 
    cls->defineFunction("setX", _SE(js_spine_PointAttachment_setX)); 
    cls->defineFunction("getY", _SE(js_spine_PointAttachment_getY)); 
    cls->defineFunction("setY", _SE(js_spine_PointAttachment_setY)); 
    cls->defineFunction("getRotation", _SE(js_spine_PointAttachment_getRotation)); 
    cls->defineFunction("setRotation", _SE(js_spine_PointAttachment_setRotation)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_PointAttachment));
    
    
    cls->install();
    JSBClassType::registerClass<spine::PointAttachment>(cls);
    
    __jsb_spine_PointAttachment_proto = cls->getProto();
    __jsb_spine_PointAttachment_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_RegionAttachment_class = nullptr;
se::Object* __jsb_spine_RegionAttachment_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_RegionAttachment) 

static bool js_spine_RegionAttachment_updateOffset(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->updateOffset();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_updateOffset) 

static bool js_spine_RegionAttachment_setUVs(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    bool arg6 ;
    
    if(argc != 5) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RegionAttachment_setUVs,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "RegionAttachment_setUVs,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "RegionAttachment_setUVs,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "RegionAttachment_setUVs,5,SWIGTYPE_float"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "RegionAttachment_setUVs,6,SWIGTYPE_bool"); 
    (arg1)->setUVs(arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setUVs) 

static bool js_spine_RegionAttachment_getX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getX();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getX) 

static bool js_spine_RegionAttachment_setX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RegionAttachment_setX,2,SWIGTYPE_float"); 
    (arg1)->setX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setX) 

static bool js_spine_RegionAttachment_getY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getY) 

static bool js_spine_RegionAttachment_setY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RegionAttachment_setY,2,SWIGTYPE_float"); 
    (arg1)->setY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setY) 

static bool js_spine_RegionAttachment_getRotation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getRotation();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getRotation) 

static bool js_spine_RegionAttachment_setRotation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RegionAttachment_setRotation,2,SWIGTYPE_float"); 
    (arg1)->setRotation(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setRotation) 

static bool js_spine_RegionAttachment_getScaleX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getScaleX();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getScaleX) 

static bool js_spine_RegionAttachment_setScaleX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RegionAttachment_setScaleX,2,SWIGTYPE_float"); 
    (arg1)->setScaleX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setScaleX) 

static bool js_spine_RegionAttachment_getScaleY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getScaleY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getScaleY) 

static bool js_spine_RegionAttachment_setScaleY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RegionAttachment_setScaleY,2,SWIGTYPE_float"); 
    (arg1)->setScaleY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setScaleY) 

static bool js_spine_RegionAttachment_getWidth(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getWidth();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getWidth) 

static bool js_spine_RegionAttachment_setWidth(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RegionAttachment_setWidth,2,SWIGTYPE_float"); 
    (arg1)->setWidth(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setWidth) 

static bool js_spine_RegionAttachment_getHeight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getHeight();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getHeight) 

static bool js_spine_RegionAttachment_setHeight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RegionAttachment_setHeight,2,SWIGTYPE_float"); 
    (arg1)->setHeight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setHeight) 

static bool js_spine_RegionAttachment_getColor(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    spine::Color *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Color *) &(arg1)->getColor();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RegionAttachment_getColor, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getColor) 

static bool js_spine_RegionAttachment_getPath(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::String *) &(arg1)->getPath();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RegionAttachment_getPath, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getPath) 

static bool js_spine_RegionAttachment_setPath(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RegionAttachment_setPath,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    (arg1)->setPath((spine::String const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setPath) 

static bool js_spine_RegionAttachment_getRegionOffsetX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getRegionOffsetX();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getRegionOffsetX) 

static bool js_spine_RegionAttachment_setRegionOffsetX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RegionAttachment_setRegionOffsetX,2,SWIGTYPE_float"); 
    (arg1)->setRegionOffsetX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setRegionOffsetX) 

static bool js_spine_RegionAttachment_getRegionOffsetY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getRegionOffsetY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getRegionOffsetY) 

static bool js_spine_RegionAttachment_setRegionOffsetY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RegionAttachment_setRegionOffsetY,2,SWIGTYPE_float"); 
    (arg1)->setRegionOffsetY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setRegionOffsetY) 

static bool js_spine_RegionAttachment_getRegionWidth(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getRegionWidth();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getRegionWidth) 

static bool js_spine_RegionAttachment_setRegionWidth(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RegionAttachment_setRegionWidth,2,SWIGTYPE_float"); 
    (arg1)->setRegionWidth(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setRegionWidth) 

static bool js_spine_RegionAttachment_getRegionHeight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getRegionHeight();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getRegionHeight) 

static bool js_spine_RegionAttachment_setRegionHeight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RegionAttachment_setRegionHeight,2,SWIGTYPE_float"); 
    (arg1)->setRegionHeight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setRegionHeight) 

static bool js_spine_RegionAttachment_getRegionOriginalWidth(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getRegionOriginalWidth();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getRegionOriginalWidth) 

static bool js_spine_RegionAttachment_setRegionOriginalWidth(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RegionAttachment_setRegionOriginalWidth,2,SWIGTYPE_float"); 
    (arg1)->setRegionOriginalWidth(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setRegionOriginalWidth) 

static bool js_spine_RegionAttachment_getRegionOriginalHeight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getRegionOriginalHeight();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getRegionOriginalHeight) 

static bool js_spine_RegionAttachment_setRegionOriginalHeight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RegionAttachment_setRegionOriginalHeight,2,SWIGTYPE_float"); 
    (arg1)->setRegionOriginalHeight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_setRegionOriginalHeight) 

static bool js_spine_RegionAttachment_getOffset(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    spine::Vector< float > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< float > *) &(arg1)->getOffset();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RegionAttachment_getOffset, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getOffset) 

static bool js_spine_RegionAttachment_getUVs(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RegionAttachment *arg1 = (spine::RegionAttachment *) NULL ;
    spine::Vector< float > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RegionAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< float > *) &(arg1)->getUVs();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RegionAttachment_getUVs, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RegionAttachment_getUVs) 

static bool js_delete_spine_RegionAttachment(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_RegionAttachment) 

bool js_register_spine_RegionAttachment(se::Object* obj) {
    auto* cls = se::Class::create("RegionAttachment", obj, __jsb_spine_Attachment_proto, nullptr); 
    
    
    cls->defineFunction("updateOffset", _SE(js_spine_RegionAttachment_updateOffset)); 
    cls->defineFunction("setUVs", _SE(js_spine_RegionAttachment_setUVs)); 
    cls->defineFunction("getX", _SE(js_spine_RegionAttachment_getX)); 
    cls->defineFunction("setX", _SE(js_spine_RegionAttachment_setX)); 
    cls->defineFunction("getY", _SE(js_spine_RegionAttachment_getY)); 
    cls->defineFunction("setY", _SE(js_spine_RegionAttachment_setY)); 
    cls->defineFunction("getRotation", _SE(js_spine_RegionAttachment_getRotation)); 
    cls->defineFunction("setRotation", _SE(js_spine_RegionAttachment_setRotation)); 
    cls->defineFunction("getScaleX", _SE(js_spine_RegionAttachment_getScaleX)); 
    cls->defineFunction("setScaleX", _SE(js_spine_RegionAttachment_setScaleX)); 
    cls->defineFunction("getScaleY", _SE(js_spine_RegionAttachment_getScaleY)); 
    cls->defineFunction("setScaleY", _SE(js_spine_RegionAttachment_setScaleY)); 
    cls->defineFunction("getWidth", _SE(js_spine_RegionAttachment_getWidth)); 
    cls->defineFunction("setWidth", _SE(js_spine_RegionAttachment_setWidth)); 
    cls->defineFunction("getHeight", _SE(js_spine_RegionAttachment_getHeight)); 
    cls->defineFunction("setHeight", _SE(js_spine_RegionAttachment_setHeight)); 
    cls->defineFunction("getColor", _SE(js_spine_RegionAttachment_getColor)); 
    cls->defineFunction("getPath", _SE(js_spine_RegionAttachment_getPath)); 
    cls->defineFunction("setPath", _SE(js_spine_RegionAttachment_setPath)); 
    cls->defineFunction("getRegionOffsetX", _SE(js_spine_RegionAttachment_getRegionOffsetX)); 
    cls->defineFunction("setRegionOffsetX", _SE(js_spine_RegionAttachment_setRegionOffsetX)); 
    cls->defineFunction("getRegionOffsetY", _SE(js_spine_RegionAttachment_getRegionOffsetY)); 
    cls->defineFunction("setRegionOffsetY", _SE(js_spine_RegionAttachment_setRegionOffsetY)); 
    cls->defineFunction("getRegionWidth", _SE(js_spine_RegionAttachment_getRegionWidth)); 
    cls->defineFunction("setRegionWidth", _SE(js_spine_RegionAttachment_setRegionWidth)); 
    cls->defineFunction("getRegionHeight", _SE(js_spine_RegionAttachment_getRegionHeight)); 
    cls->defineFunction("setRegionHeight", _SE(js_spine_RegionAttachment_setRegionHeight)); 
    cls->defineFunction("getRegionOriginalWidth", _SE(js_spine_RegionAttachment_getRegionOriginalWidth)); 
    cls->defineFunction("setRegionOriginalWidth", _SE(js_spine_RegionAttachment_setRegionOriginalWidth)); 
    cls->defineFunction("getRegionOriginalHeight", _SE(js_spine_RegionAttachment_getRegionOriginalHeight)); 
    cls->defineFunction("setRegionOriginalHeight", _SE(js_spine_RegionAttachment_setRegionOriginalHeight)); 
    cls->defineFunction("getOffset", _SE(js_spine_RegionAttachment_getOffset)); 
    cls->defineFunction("getUVs", _SE(js_spine_RegionAttachment_getUVs)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_RegionAttachment));
    
    
    cls->install();
    JSBClassType::registerClass<spine::RegionAttachment>(cls);
    
    __jsb_spine_RegionAttachment_proto = cls->getProto();
    __jsb_spine_RegionAttachment_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_RotateTimeline_class = nullptr;
se::Object* __jsb_spine_RotateTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_RotateTimeline) 

static bool js_spine_RotateTimeline_setFrame(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RotateTimeline *arg1 = (spine::RotateTimeline *) NULL ;
    int arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RotateTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RotateTimeline_setFrame,2,SWIGTYPE_int"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "RotateTimeline_setFrame,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "RotateTimeline_setFrame,4,SWIGTYPE_float"); 
    (arg1)->setFrame(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RotateTimeline_setFrame) 

static bool js_spine_RotateTimeline_getBoneIndex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RotateTimeline *arg1 = (spine::RotateTimeline *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RotateTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)(arg1)->getBoneIndex();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RotateTimeline_getBoneIndex) 

static bool js_spine_RotateTimeline_setBoneIndex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RotateTimeline *arg1 = (spine::RotateTimeline *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RotateTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RotateTimeline_setBoneIndex,2,SWIGTYPE_int"); 
    (arg1)->setBoneIndex(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RotateTimeline_setBoneIndex) 

static bool js_spine_RotateTimeline_getFrames(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::RotateTimeline *arg1 = (spine::RotateTimeline *) NULL ;
    spine::Vector< float > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::RotateTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< float > *) &(arg1)->getFrames();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RotateTimeline_getFrames, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_RotateTimeline_getFrames) 

static bool js_delete_spine_RotateTimeline(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_RotateTimeline) 

bool js_register_spine_RotateTimeline(se::Object* obj) {
    auto* cls = se::Class::create("RotateTimeline", obj, __jsb_spine_CurveTimeline_proto, nullptr); 
    
    
    cls->defineFunction("setFrame", _SE(js_spine_RotateTimeline_setFrame)); 
    cls->defineFunction("getBoneIndex", _SE(js_spine_RotateTimeline_getBoneIndex)); 
    cls->defineFunction("setBoneIndex", _SE(js_spine_RotateTimeline_setBoneIndex)); 
    cls->defineFunction("getFrames", _SE(js_spine_RotateTimeline_getFrames)); 
    
    cls->defineStaticProperty("ENTRIES", nullptr, nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_RotateTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::RotateTimeline>(cls);
    
    __jsb_spine_RotateTimeline_proto = cls->getProto();
    __jsb_spine_RotateTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_ScaleTimeline_class = nullptr;
se::Object* __jsb_spine_ScaleTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_ScaleTimeline) 

static bool js_spine_ScaleTimeline_getPropertyId(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ScaleTimeline *arg1 = (spine::ScaleTimeline *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ScaleTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)(arg1)->getPropertyId();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ScaleTimeline_getPropertyId) 

static bool js_delete_spine_ScaleTimeline(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_ScaleTimeline) 

bool js_register_spine_ScaleTimeline(se::Object* obj) {
    auto* cls = se::Class::create("ScaleTimeline", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("getPropertyId", _SE(js_spine_ScaleTimeline_getPropertyId)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_ScaleTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::ScaleTimeline>(cls);
    
    __jsb_spine_ScaleTimeline_proto = cls->getProto();
    __jsb_spine_ScaleTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_ShearTimeline_class = nullptr;
se::Object* __jsb_spine_ShearTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_ShearTimeline) 

static bool js_spine_ShearTimeline_getPropertyId(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ShearTimeline *arg1 = (spine::ShearTimeline *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ShearTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)(arg1)->getPropertyId();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ShearTimeline_getPropertyId) 

static bool js_delete_spine_ShearTimeline(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_ShearTimeline) 

bool js_register_spine_ShearTimeline(se::Object* obj) {
    auto* cls = se::Class::create("ShearTimeline", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("getPropertyId", _SE(js_spine_ShearTimeline_getPropertyId)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_ShearTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::ShearTimeline>(cls);
    
    __jsb_spine_ShearTimeline_proto = cls->getProto();
    __jsb_spine_ShearTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_Skeleton_class = nullptr;
se::Object* __jsb_spine_Skeleton_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_Skeleton) 

static bool js_delete_spine_Skeleton(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_Skeleton) 

static bool js_spine_Skeleton_updateCache(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->updateCache();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_updateCache) 

static bool js_spine_Skeleton_printUpdateCache(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->printUpdateCache();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_printUpdateCache) 

static bool js_spine_Skeleton_updateWorldTransform(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->updateWorldTransform();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_updateWorldTransform) 

static bool js_spine_Skeleton_setToSetupPose(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->setToSetupPose();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_setToSetupPose) 

static bool js_spine_Skeleton_setBonesToSetupPose(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->setBonesToSetupPose();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_setBonesToSetupPose) 

static bool js_spine_Skeleton_setSlotsToSetupPose(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->setSlotsToSetupPose();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_setSlotsToSetupPose) 

static bool js_spine_Skeleton_findBone(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    spine::Bone *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skeleton_findBone,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    result = (spine::Bone *)(arg1)->findBone((spine::String const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skeleton_findBone, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_findBone) 

static bool js_spine_Skeleton_findBoneIndex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    int result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skeleton_findBoneIndex,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    result = (int)(arg1)->findBoneIndex((spine::String const &)*arg2);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_findBoneIndex) 

static bool js_spine_Skeleton_findSlot(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    spine::Slot *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skeleton_findSlot,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    result = (spine::Slot *)(arg1)->findSlot((spine::String const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skeleton_findSlot, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_findSlot) 

static bool js_spine_Skeleton_findSlotIndex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    int result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skeleton_findSlotIndex,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    result = (int)(arg1)->findSlotIndex((spine::String const &)*arg2);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_findSlotIndex) 

static bool js_spine_Skeleton_setSkin__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skeleton_setSkin,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    (arg1)->setSkin((spine::String const &)*arg2);
    
    
    return true;
}

static bool js_spine_Skeleton_setSkin__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::Skin *arg2 = (spine::Skin *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skeleton_setSkin,2,SWIGTYPE_p_spine__Skin"); 
    (arg1)->setSkin(arg2);
    
    
    return true;
}

static bool js_spine_Skeleton_setSkin(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_spine_Skeleton_setSkin__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_spine_Skeleton_setSkin__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_Skeleton_setSkin) 

static bool js_spine_Skeleton_getAttachment__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String *arg3 = 0 ;
    spine::String temp2 ;
    spine::String temp3 ;
    spine::Attachment *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skeleton_getAttachment,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skeleton_getAttachment,3,SWIGTYPE_p_spine__String");
    arg3 = &temp3;
    
    result = (spine::Attachment *)(arg1)->getAttachment((spine::String const &)*arg2,(spine::String const &)*arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skeleton_getAttachment, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_Skeleton_getAttachment__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    int arg2 ;
    spine::String *arg3 = 0 ;
    spine::String temp3 ;
    spine::Attachment *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Skeleton_getAttachment,2,SWIGTYPE_int"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skeleton_getAttachment,3,SWIGTYPE_p_spine__String");
    arg3 = &temp3;
    
    result = (spine::Attachment *)(arg1)->getAttachment(arg2,(spine::String const &)*arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skeleton_getAttachment, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_Skeleton_getAttachment(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_spine_Skeleton_getAttachment__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_spine_Skeleton_getAttachment__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_Skeleton_getAttachment) 

static bool js_spine_Skeleton_setAttachment(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String *arg3 = 0 ;
    spine::String temp2 ;
    spine::String temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skeleton_setAttachment,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skeleton_setAttachment,3,SWIGTYPE_p_spine__String");
    arg3 = &temp3;
    
    (arg1)->setAttachment((spine::String const &)*arg2,(spine::String const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_setAttachment) 

static bool js_spine_Skeleton_findIkConstraint(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    spine::IkConstraint *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skeleton_findIkConstraint,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    result = (spine::IkConstraint *)(arg1)->findIkConstraint((spine::String const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skeleton_findIkConstraint, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_findIkConstraint) 

static bool js_spine_Skeleton_findTransformConstraint(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    spine::TransformConstraint *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skeleton_findTransformConstraint,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    result = (spine::TransformConstraint *)(arg1)->findTransformConstraint((spine::String const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skeleton_findTransformConstraint, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_findTransformConstraint) 

static bool js_spine_Skeleton_findPathConstraint(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    spine::PathConstraint *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skeleton_findPathConstraint,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    result = (spine::PathConstraint *)(arg1)->findPathConstraint((spine::String const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skeleton_findPathConstraint, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_findPathConstraint) 

static bool js_spine_Skeleton_update(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Skeleton_update,2,SWIGTYPE_float"); 
    (arg1)->update(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_update) 

static bool js_spine_Skeleton_getRootBone(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::Bone *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Bone *)(arg1)->getRootBone();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skeleton_getRootBone, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getRootBone) 

static bool js_spine_Skeleton_getData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::SkeletonData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::SkeletonData *)(arg1)->getData();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skeleton_getData, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getData) 

static bool js_spine_Skeleton_getBones(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::Vector< spine::Bone * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::Bone * > *) &(arg1)->getBones();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skeleton_getBones, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getBones) 

static bool js_spine_Skeleton_getUpdateCacheList(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::Vector< spine::Updatable * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::Updatable * > *) &(arg1)->getUpdateCacheList();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skeleton_getUpdateCacheList, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getUpdateCacheList) 

static bool js_spine_Skeleton_getSlots(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::Vector< spine::Slot * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::Slot * > *) &(arg1)->getSlots();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skeleton_getSlots, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getSlots) 

static bool js_spine_Skeleton_getDrawOrder(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::Vector< spine::Slot * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::Slot * > *) &(arg1)->getDrawOrder();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skeleton_getDrawOrder, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getDrawOrder) 

static bool js_spine_Skeleton_getIkConstraints(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::Vector< spine::IkConstraint * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::IkConstraint * > *) &(arg1)->getIkConstraints();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skeleton_getIkConstraints, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getIkConstraints) 

static bool js_spine_Skeleton_getPathConstraints(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::Vector< spine::PathConstraint * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::PathConstraint * > *) &(arg1)->getPathConstraints();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skeleton_getPathConstraints, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getPathConstraints) 

static bool js_spine_Skeleton_getTransformConstraints(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::Vector< spine::TransformConstraint * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::TransformConstraint * > *) &(arg1)->getTransformConstraints();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skeleton_getTransformConstraints, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getTransformConstraints) 

static bool js_spine_Skeleton_getSkin(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::Skin *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Skin *)(arg1)->getSkin();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skeleton_getSkin, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getSkin) 

static bool js_spine_Skeleton_getColor(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::Color *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Color *) &(arg1)->getColor();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skeleton_getColor, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getColor) 

static bool js_spine_Skeleton_getTime(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getTime();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getTime) 

static bool js_spine_Skeleton_setTime(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Skeleton_setTime,2,SWIGTYPE_float"); 
    (arg1)->setTime(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_setTime) 

static bool js_spine_Skeleton_setPosition(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    float arg2 ;
    float arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Skeleton_setPosition,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Skeleton_setPosition,3,SWIGTYPE_float"); 
    (arg1)->setPosition(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_setPosition) 

static bool js_spine_Skeleton_getX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getX();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getX) 

static bool js_spine_Skeleton_setX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Skeleton_setX,2,SWIGTYPE_float"); 
    (arg1)->setX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_setX) 

static bool js_spine_Skeleton_getY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getY) 

static bool js_spine_Skeleton_setY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Skeleton_setY,2,SWIGTYPE_float"); 
    (arg1)->setY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_setY) 

static bool js_spine_Skeleton_getScaleX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getScaleX();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getScaleX) 

static bool js_spine_Skeleton_setScaleX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Skeleton_setScaleX,2,SWIGTYPE_float"); 
    (arg1)->setScaleX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_setScaleX) 

static bool js_spine_Skeleton_getScaleY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getScaleY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_getScaleY) 

static bool js_spine_Skeleton_setScaleY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Skeleton_setScaleY,2,SWIGTYPE_float"); 
    (arg1)->setScaleY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skeleton_setScaleY) 

bool js_register_spine_Skeleton(se::Object* obj) {
    auto* cls = se::Class::create("Skeleton", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("updateCache", _SE(js_spine_Skeleton_updateCache)); 
    cls->defineFunction("printUpdateCache", _SE(js_spine_Skeleton_printUpdateCache)); 
    cls->defineFunction("updateWorldTransform", _SE(js_spine_Skeleton_updateWorldTransform)); 
    cls->defineFunction("setToSetupPose", _SE(js_spine_Skeleton_setToSetupPose)); 
    cls->defineFunction("setBonesToSetupPose", _SE(js_spine_Skeleton_setBonesToSetupPose)); 
    cls->defineFunction("setSlotsToSetupPose", _SE(js_spine_Skeleton_setSlotsToSetupPose)); 
    cls->defineFunction("findBone", _SE(js_spine_Skeleton_findBone)); 
    cls->defineFunction("findBoneIndex", _SE(js_spine_Skeleton_findBoneIndex)); 
    cls->defineFunction("findSlot", _SE(js_spine_Skeleton_findSlot)); 
    cls->defineFunction("findSlotIndex", _SE(js_spine_Skeleton_findSlotIndex)); 
    cls->defineFunction("setSkin", _SE(js_spine_Skeleton_setSkin)); 
    cls->defineFunction("getAttachment", _SE(js_spine_Skeleton_getAttachment)); 
    cls->defineFunction("setAttachment", _SE(js_spine_Skeleton_setAttachment)); 
    cls->defineFunction("findIkConstraint", _SE(js_spine_Skeleton_findIkConstraint)); 
    cls->defineFunction("findTransformConstraint", _SE(js_spine_Skeleton_findTransformConstraint)); 
    cls->defineFunction("findPathConstraint", _SE(js_spine_Skeleton_findPathConstraint)); 
    cls->defineFunction("update", _SE(js_spine_Skeleton_update)); 
    cls->defineFunction("getRootBone", _SE(js_spine_Skeleton_getRootBone)); 
    cls->defineFunction("getData", _SE(js_spine_Skeleton_getData)); 
    cls->defineFunction("getBones", _SE(js_spine_Skeleton_getBones)); 
    cls->defineFunction("getUpdateCacheList", _SE(js_spine_Skeleton_getUpdateCacheList)); 
    cls->defineFunction("getSlots", _SE(js_spine_Skeleton_getSlots)); 
    cls->defineFunction("getDrawOrder", _SE(js_spine_Skeleton_getDrawOrder)); 
    cls->defineFunction("getIkConstraints", _SE(js_spine_Skeleton_getIkConstraints)); 
    cls->defineFunction("getPathConstraints", _SE(js_spine_Skeleton_getPathConstraints)); 
    cls->defineFunction("getTransformConstraints", _SE(js_spine_Skeleton_getTransformConstraints)); 
    cls->defineFunction("getSkin", _SE(js_spine_Skeleton_getSkin)); 
    cls->defineFunction("getColor", _SE(js_spine_Skeleton_getColor)); 
    cls->defineFunction("getTime", _SE(js_spine_Skeleton_getTime)); 
    cls->defineFunction("setTime", _SE(js_spine_Skeleton_setTime)); 
    cls->defineFunction("setPosition", _SE(js_spine_Skeleton_setPosition)); 
    cls->defineFunction("getX", _SE(js_spine_Skeleton_getX)); 
    cls->defineFunction("setX", _SE(js_spine_Skeleton_setX)); 
    cls->defineFunction("getY", _SE(js_spine_Skeleton_getY)); 
    cls->defineFunction("setY", _SE(js_spine_Skeleton_setY)); 
    cls->defineFunction("getScaleX", _SE(js_spine_Skeleton_getScaleX)); 
    cls->defineFunction("setScaleX", _SE(js_spine_Skeleton_setScaleX)); 
    cls->defineFunction("getScaleY", _SE(js_spine_Skeleton_getScaleY)); 
    cls->defineFunction("setScaleY", _SE(js_spine_Skeleton_setScaleY)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_Skeleton));
    
    
    cls->install();
    JSBClassType::registerClass<spine::Skeleton>(cls);
    
    __jsb_spine_Skeleton_proto = cls->getProto();
    __jsb_spine_Skeleton_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_Slot_class = nullptr;
se::Object* __jsb_spine_Slot_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_Slot) 

static bool js_spine_Slot_setToSetupPose(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Slot *arg1 = (spine::Slot *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->setToSetupPose();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Slot_setToSetupPose) 

static bool js_spine_Slot_getData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Slot *arg1 = (spine::Slot *) NULL ;
    spine::SlotData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::SlotData *) &(arg1)->getData();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Slot_getData, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Slot_getData) 

static bool js_spine_Slot_getBone(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Slot *arg1 = (spine::Slot *) NULL ;
    spine::Bone *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Bone *) &(arg1)->getBone();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Slot_getBone, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Slot_getBone) 

static bool js_spine_Slot_getSkeleton(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Slot *arg1 = (spine::Slot *) NULL ;
    spine::Skeleton *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Skeleton *) &(arg1)->getSkeleton();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Slot_getSkeleton, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Slot_getSkeleton) 

static bool js_spine_Slot_getColor(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Slot *arg1 = (spine::Slot *) NULL ;
    spine::Color *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Color *) &(arg1)->getColor();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Slot_getColor, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Slot_getColor) 

static bool js_spine_Slot_getDarkColor(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Slot *arg1 = (spine::Slot *) NULL ;
    spine::Color *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Color *) &(arg1)->getDarkColor();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Slot_getDarkColor, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Slot_getDarkColor) 

static bool js_spine_Slot_hasDarkColor(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Slot *arg1 = (spine::Slot *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->hasDarkColor();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Slot_hasDarkColor) 

static bool js_spine_Slot_getAttachment(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Slot *arg1 = (spine::Slot *) NULL ;
    spine::Attachment *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Attachment *)(arg1)->getAttachment();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Slot_getAttachment, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Slot_getAttachment) 

static bool js_spine_Slot_setAttachment(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Slot *arg1 = (spine::Slot *) NULL ;
    spine::Attachment *arg2 = (spine::Attachment *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Slot_setAttachment,2,SWIGTYPE_p_spine__Attachment"); 
    (arg1)->setAttachment(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Slot_setAttachment) 

static bool js_spine_Slot_getAttachmentTime(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Slot *arg1 = (spine::Slot *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getAttachmentTime();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Slot_getAttachmentTime) 

static bool js_spine_Slot_setAttachmentTime(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Slot *arg1 = (spine::Slot *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Slot_setAttachmentTime,2,SWIGTYPE_float"); 
    (arg1)->setAttachmentTime(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Slot_setAttachmentTime) 

static bool js_spine_Slot_getDeform(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Slot *arg1 = (spine::Slot *) NULL ;
    spine::Vector< float > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Slot>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< float > *) &(arg1)->getDeform();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Slot_getDeform, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Slot_getDeform) 

static bool js_delete_spine_Slot(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_Slot) 

bool js_register_spine_Slot(se::Object* obj) {
    auto* cls = se::Class::create("Slot", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("setToSetupPose", _SE(js_spine_Slot_setToSetupPose)); 
    cls->defineFunction("getData", _SE(js_spine_Slot_getData)); 
    cls->defineFunction("getBone", _SE(js_spine_Slot_getBone)); 
    cls->defineFunction("getSkeleton", _SE(js_spine_Slot_getSkeleton)); 
    cls->defineFunction("getColor", _SE(js_spine_Slot_getColor)); 
    cls->defineFunction("getDarkColor", _SE(js_spine_Slot_getDarkColor)); 
    cls->defineFunction("hasDarkColor", _SE(js_spine_Slot_hasDarkColor)); 
    cls->defineFunction("getAttachment", _SE(js_spine_Slot_getAttachment)); 
    cls->defineFunction("setAttachment", _SE(js_spine_Slot_setAttachment)); 
    cls->defineFunction("getAttachmentTime", _SE(js_spine_Slot_getAttachmentTime)); 
    cls->defineFunction("setAttachmentTime", _SE(js_spine_Slot_setAttachmentTime)); 
    cls->defineFunction("getDeform", _SE(js_spine_Slot_getDeform)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_Slot));
    
    
    cls->install();
    JSBClassType::registerClass<spine::Slot>(cls);
    
    __jsb_spine_Slot_proto = cls->getProto();
    __jsb_spine_Slot_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_Skin_class = nullptr;
se::Object* __jsb_spine_Skin_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_Skin) 

static bool js_delete_spine_Skin(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_Skin) 

static bool js_spine_Skin_setAttachment(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skin *arg1 = (spine::Skin *) NULL ;
    size_t arg2 ;
    spine::String *arg3 = 0 ;
    spine::Attachment *arg4 = (spine::Attachment *) NULL ;
    spine::String temp3 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skin>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Skin_setAttachment,2,SWIGTYPE_size_t");
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skin_setAttachment,3,SWIGTYPE_p_spine__String");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skin_setAttachment,4,SWIGTYPE_p_spine__Attachment"); 
    (arg1)->setAttachment(arg2,(spine::String const &)*arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skin_setAttachment) 

static bool js_spine_Skin_getAttachment(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skin *arg1 = (spine::Skin *) NULL ;
    size_t arg2 ;
    spine::String *arg3 = 0 ;
    spine::String temp3 ;
    spine::Attachment *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skin>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Skin_getAttachment,2,SWIGTYPE_size_t");
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skin_getAttachment,3,SWIGTYPE_p_spine__String");
    arg3 = &temp3;
    
    result = (spine::Attachment *)(arg1)->getAttachment(arg2,(spine::String const &)*arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skin_getAttachment, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skin_getAttachment) 

static bool js_spine_Skin_removeAttachment(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skin *arg1 = (spine::Skin *) NULL ;
    size_t arg2 ;
    spine::String *arg3 = 0 ;
    spine::String temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skin>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Skin_removeAttachment,2,SWIGTYPE_size_t");
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skin_removeAttachment,3,SWIGTYPE_p_spine__String");
    arg3 = &temp3;
    
    (arg1)->removeAttachment(arg2,(spine::String const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skin_removeAttachment) 

static bool js_spine_Skin_getName(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skin *arg1 = (spine::Skin *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skin>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::String *) &(arg1)->getName();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skin_getName, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skin_getName) 

static bool js_spine_Skin_addSkin(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skin *arg1 = (spine::Skin *) NULL ;
    spine::Skin *arg2 = (spine::Skin *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skin>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skin_addSkin,2,SWIGTYPE_p_spine__Skin"); 
    (arg1)->addSkin(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skin_addSkin) 

static bool js_spine_Skin_copySkin(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skin *arg1 = (spine::Skin *) NULL ;
    spine::Skin *arg2 = (spine::Skin *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skin>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skin_copySkin,2,SWIGTYPE_p_spine__Skin"); 
    (arg1)->copySkin(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skin_copySkin) 

static bool js_spine_Skin_getBones(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skin *arg1 = (spine::Skin *) NULL ;
    spine::Vector< spine::BoneData * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skin>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::BoneData * > *) &(arg1)->getBones();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skin_getBones, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skin_getBones) 

static bool js_spine_Skin_getConstraints(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Skin *arg1 = (spine::Skin *) NULL ;
    spine::Vector< spine::ConstraintData * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::Skin>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::ConstraintData * > *) &(arg1)->getConstraints();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skin_getConstraints, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_Skin_getConstraints) 

bool js_register_spine_Skin(se::Object* obj) {
    auto* cls = se::Class::create("Skin", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("setAttachment", _SE(js_spine_Skin_setAttachment)); 
    cls->defineFunction("getAttachment", _SE(js_spine_Skin_getAttachment)); 
    cls->defineFunction("removeAttachment", _SE(js_spine_Skin_removeAttachment)); 
    cls->defineFunction("getName", _SE(js_spine_Skin_getName)); 
    cls->defineFunction("addSkin", _SE(js_spine_Skin_addSkin)); 
    cls->defineFunction("copySkin", _SE(js_spine_Skin_copySkin)); 
    cls->defineFunction("getBones", _SE(js_spine_Skin_getBones)); 
    cls->defineFunction("getConstraints", _SE(js_spine_Skin_getConstraints)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_Skin));
    
    
    cls->install();
    JSBClassType::registerClass<spine::Skin>(cls);
    
    __jsb_spine_Skin_proto = cls->getProto();
    __jsb_spine_Skin_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_SkeletonBounds_class = nullptr;
se::Object* __jsb_spine_SkeletonBounds_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_SkeletonBounds) 

static bool js_spine_SkeletonBounds_aabbcontainsPoint(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonBounds *arg1 = (spine::SkeletonBounds *) NULL ;
    float arg2 ;
    float arg3 ;
    bool result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonBounds>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonBounds_aabbcontainsPoint,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonBounds_aabbcontainsPoint,3,SWIGTYPE_float"); 
    result = (bool)(arg1)->aabbcontainsPoint(arg2,arg3);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonBounds_aabbcontainsPoint) 

static bool js_spine_SkeletonBounds_aabbintersectsSegment(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonBounds *arg1 = (spine::SkeletonBounds *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    bool result;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonBounds>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonBounds_aabbintersectsSegment,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonBounds_aabbintersectsSegment,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonBounds_aabbintersectsSegment,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonBounds_aabbintersectsSegment,5,SWIGTYPE_float"); 
    result = (bool)(arg1)->aabbintersectsSegment(arg2,arg3,arg4,arg5);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonBounds_aabbintersectsSegment) 

static bool js_spine_SkeletonBounds_containsPoint__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonBounds *arg1 = (spine::SkeletonBounds *) NULL ;
    spine::Polygon *arg2 = (spine::Polygon *) NULL ;
    float arg3 ;
    float arg4 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonBounds>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonBounds_containsPoint,2,SWIGTYPE_p_spine__Polygon"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonBounds_containsPoint,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonBounds_containsPoint,4,SWIGTYPE_float"); 
    result = (bool)(arg1)->containsPoint(arg2,arg3,arg4);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_spine_SkeletonBounds_containsPoint__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonBounds *arg1 = (spine::SkeletonBounds *) NULL ;
    float arg2 ;
    float arg3 ;
    spine::BoundingBoxAttachment *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonBounds>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonBounds_containsPoint,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonBounds_containsPoint,3,SWIGTYPE_float"); 
    result = (spine::BoundingBoxAttachment *)(arg1)->containsPoint(arg2,arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonBounds_containsPoint, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonBounds_containsPoint(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_spine_SkeletonBounds_containsPoint__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_spine_SkeletonBounds_containsPoint__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonBounds_containsPoint) 

static bool js_spine_SkeletonBounds_intersectsSegment__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonBounds *arg1 = (spine::SkeletonBounds *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    spine::BoundingBoxAttachment *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonBounds>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonBounds_intersectsSegment,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonBounds_intersectsSegment,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonBounds_intersectsSegment,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonBounds_intersectsSegment,5,SWIGTYPE_float"); 
    result = (spine::BoundingBoxAttachment *)(arg1)->intersectsSegment(arg2,arg3,arg4,arg5);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonBounds_intersectsSegment, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonBounds_intersectsSegment__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonBounds *arg1 = (spine::SkeletonBounds *) NULL ;
    spine::Polygon *arg2 = (spine::Polygon *) NULL ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonBounds>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonBounds_intersectsSegment,2,SWIGTYPE_p_spine__Polygon"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonBounds_intersectsSegment,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonBounds_intersectsSegment,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonBounds_intersectsSegment,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonBounds_intersectsSegment,6,SWIGTYPE_float"); 
    result = (bool)(arg1)->intersectsSegment(arg2,arg3,arg4,arg5,arg6);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_spine_SkeletonBounds_intersectsSegment(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 4) {
        ok = js_spine_SkeletonBounds_intersectsSegment__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_spine_SkeletonBounds_intersectsSegment__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonBounds_intersectsSegment) 

static bool js_spine_SkeletonBounds_getPolygon(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonBounds *arg1 = (spine::SkeletonBounds *) NULL ;
    spine::BoundingBoxAttachment *arg2 = (spine::BoundingBoxAttachment *) NULL ;
    spine::Polygon *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonBounds>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonBounds_getPolygon,2,SWIGTYPE_p_spine__BoundingBoxAttachment"); 
    result = (spine::Polygon *)(arg1)->getPolygon(arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonBounds_getPolygon, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonBounds_getPolygon) 

static bool js_spine_SkeletonBounds_getWidth(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonBounds *arg1 = (spine::SkeletonBounds *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonBounds>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getWidth();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonBounds_getWidth) 

static bool js_spine_SkeletonBounds_getHeight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonBounds *arg1 = (spine::SkeletonBounds *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonBounds>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getHeight();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonBounds_getHeight) 

static bool js_delete_spine_SkeletonBounds(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_SkeletonBounds) 

bool js_register_spine_SkeletonBounds(se::Object* obj) {
    auto* cls = se::Class::create("SkeletonBounds", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("aabbcontainsPoint", _SE(js_spine_SkeletonBounds_aabbcontainsPoint)); 
    cls->defineFunction("aabbintersectsSegment", _SE(js_spine_SkeletonBounds_aabbintersectsSegment)); 
    cls->defineFunction("containsPoint", _SE(js_spine_SkeletonBounds_containsPoint)); 
    cls->defineFunction("intersectsSegment", _SE(js_spine_SkeletonBounds_intersectsSegment)); 
    cls->defineFunction("getPolygon", _SE(js_spine_SkeletonBounds_getPolygon)); 
    cls->defineFunction("getWidth", _SE(js_spine_SkeletonBounds_getWidth)); 
    cls->defineFunction("getHeight", _SE(js_spine_SkeletonBounds_getHeight)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_SkeletonBounds));
    
    
    cls->install();
    JSBClassType::registerClass<spine::SkeletonBounds>(cls);
    
    __jsb_spine_SkeletonBounds_proto = cls->getProto();
    __jsb_spine_SkeletonBounds_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_Polygon_class = nullptr;
se::Object* __jsb_spine_Polygon_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_Polygon) 

static bool js_spine_Polygon__count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::Polygon *arg1 = (spine::Polygon *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::Polygon>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->_count, nullptr);
    SE_PRECONDITION2(ok, false, "Polygon__count_set,2,SWIGTYPE_int"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_spine_Polygon__count_set) 

static bool js_spine_Polygon__count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    spine::Polygon *arg1 = (spine::Polygon *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::Polygon>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->_count, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_Polygon__count_get) 

static bool js_delete_spine_Polygon(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_Polygon) 

bool js_register_spine_Polygon(se::Object* obj) {
    auto* cls = se::Class::create("Polygon", obj, nullptr, nullptr); 
    
    cls->defineProperty("_count", _SE(js_spine_Polygon__count_get), _SE(js_spine_Polygon__count_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_Polygon));
    
    
    cls->install();
    JSBClassType::registerClass<spine::Polygon>(cls);
    
    __jsb_spine_Polygon_proto = cls->getProto();
    __jsb_spine_Polygon_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_SkeletonData_class = nullptr;
se::Object* __jsb_spine_SkeletonData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_SkeletonData) 

static bool js_delete_spine_SkeletonData(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_SkeletonData) 

static bool js_spine_SkeletonData_findBone(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    spine::BoneData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonData_findBone,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    result = (spine::BoneData *)(arg1)->findBone((spine::String const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonData_findBone, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_findBone) 

static bool js_spine_SkeletonData_findBoneIndex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    int result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonData_findBoneIndex,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    result = (int)(arg1)->findBoneIndex((spine::String const &)*arg2);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_findBoneIndex) 

static bool js_spine_SkeletonData_findSlot(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    spine::SlotData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonData_findSlot,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    result = (spine::SlotData *)(arg1)->findSlot((spine::String const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonData_findSlot, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_findSlot) 

static bool js_spine_SkeletonData_findSlotIndex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    int result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonData_findSlotIndex,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    result = (int)(arg1)->findSlotIndex((spine::String const &)*arg2);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_findSlotIndex) 

static bool js_spine_SkeletonData_findSkin(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    spine::Skin *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonData_findSkin,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    result = (spine::Skin *)(arg1)->findSkin((spine::String const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonData_findSkin, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_findSkin) 

static bool js_spine_SkeletonData_findEvent(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    spine::EventData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonData_findEvent,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    result = (spine::EventData *)(arg1)->findEvent((spine::String const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonData_findEvent, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_findEvent) 

static bool js_spine_SkeletonData_findAnimation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    spine::Animation *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonData_findAnimation,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    result = (spine::Animation *)(arg1)->findAnimation((spine::String const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonData_findAnimation, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_findAnimation) 

static bool js_spine_SkeletonData_findIkConstraint(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    spine::IkConstraintData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonData_findIkConstraint,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    result = (spine::IkConstraintData *)(arg1)->findIkConstraint((spine::String const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonData_findIkConstraint, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_findIkConstraint) 

static bool js_spine_SkeletonData_findTransformConstraint(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    spine::TransformConstraintData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonData_findTransformConstraint,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    result = (spine::TransformConstraintData *)(arg1)->findTransformConstraint((spine::String const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonData_findTransformConstraint, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_findTransformConstraint) 

static bool js_spine_SkeletonData_findPathConstraint(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    spine::PathConstraintData *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonData_findPathConstraint,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    result = (spine::PathConstraintData *)(arg1)->findPathConstraint((spine::String const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonData_findPathConstraint, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_findPathConstraint) 

static bool js_spine_SkeletonData_findPathConstraintIndex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    int result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonData_findPathConstraintIndex,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    result = (int)(arg1)->findPathConstraintIndex((spine::String const &)*arg2);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_findPathConstraintIndex) 

static bool js_spine_SkeletonData_getName(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::String *) &(arg1)->getName();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonData_getName, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getName) 

static bool js_spine_SkeletonData_setName(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonData_setName,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    (arg1)->setName((spine::String const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_setName) 

static bool js_spine_SkeletonData_getBones(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::Vector< spine::BoneData * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::BoneData * > *) &(arg1)->getBones();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonData_getBones, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getBones) 

static bool js_spine_SkeletonData_getSlots(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::Vector< spine::SlotData * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::SlotData * > *) &(arg1)->getSlots();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonData_getSlots, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getSlots) 

static bool js_spine_SkeletonData_getSkins(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::Vector< spine::Skin * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::Skin * > *) &(arg1)->getSkins();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonData_getSkins, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getSkins) 

static bool js_spine_SkeletonData_getDefaultSkin(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::Skin *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Skin *)(arg1)->getDefaultSkin();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonData_getDefaultSkin, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getDefaultSkin) 

static bool js_spine_SkeletonData_setDefaultSkin(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::Skin *arg2 = (spine::Skin *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonData_setDefaultSkin,2,SWIGTYPE_p_spine__Skin"); 
    (arg1)->setDefaultSkin(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_setDefaultSkin) 

static bool js_spine_SkeletonData_getEvents(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::Vector< spine::EventData * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::EventData * > *) &(arg1)->getEvents();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonData_getEvents, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getEvents) 

static bool js_spine_SkeletonData_getAnimations(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::Vector< spine::Animation * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::Animation * > *) &(arg1)->getAnimations();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonData_getAnimations, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getAnimations) 

static bool js_spine_SkeletonData_getIkConstraints(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::Vector< spine::IkConstraintData * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::IkConstraintData * > *) &(arg1)->getIkConstraints();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonData_getIkConstraints, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getIkConstraints) 

static bool js_spine_SkeletonData_getTransformConstraints(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::Vector< spine::TransformConstraintData * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::TransformConstraintData * > *) &(arg1)->getTransformConstraints();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonData_getTransformConstraints, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getTransformConstraints) 

static bool js_spine_SkeletonData_getPathConstraints(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::Vector< spine::PathConstraintData * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::PathConstraintData * > *) &(arg1)->getPathConstraints();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonData_getPathConstraints, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getPathConstraints) 

static bool js_spine_SkeletonData_getX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getX();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getX) 

static bool js_spine_SkeletonData_setX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonData_setX,2,SWIGTYPE_float"); 
    (arg1)->setX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_setX) 

static bool js_spine_SkeletonData_getY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getY) 

static bool js_spine_SkeletonData_setY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonData_setY,2,SWIGTYPE_float"); 
    (arg1)->setY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_setY) 

static bool js_spine_SkeletonData_getWidth(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getWidth();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getWidth) 

static bool js_spine_SkeletonData_setWidth(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonData_setWidth,2,SWIGTYPE_float"); 
    (arg1)->setWidth(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_setWidth) 

static bool js_spine_SkeletonData_getHeight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getHeight();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getHeight) 

static bool js_spine_SkeletonData_setHeight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonData_setHeight,2,SWIGTYPE_float"); 
    (arg1)->setHeight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_setHeight) 

static bool js_spine_SkeletonData_getVersion(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::String *) &(arg1)->getVersion();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonData_getVersion, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getVersion) 

static bool js_spine_SkeletonData_setVersion(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonData_setVersion,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    (arg1)->setVersion((spine::String const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_setVersion) 

static bool js_spine_SkeletonData_getHash(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::String *) &(arg1)->getHash();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonData_getHash, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getHash) 

static bool js_spine_SkeletonData_setHash(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonData_setHash,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    (arg1)->setHash((spine::String const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_setHash) 

static bool js_spine_SkeletonData_getImagesPath(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::String *) &(arg1)->getImagesPath();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonData_getImagesPath, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getImagesPath) 

static bool js_spine_SkeletonData_setImagesPath(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonData_setImagesPath,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    (arg1)->setImagesPath((spine::String const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_setImagesPath) 

static bool js_spine_SkeletonData_getAudioPath(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::String *) &(arg1)->getAudioPath();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonData_getAudioPath, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getAudioPath) 

static bool js_spine_SkeletonData_setAudioPath(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonData_setAudioPath,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    (arg1)->setAudioPath((spine::String const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_setAudioPath) 

static bool js_spine_SkeletonData_getFps(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getFps();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_getFps) 

static bool js_spine_SkeletonData_setFps(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonData_setFps,2,SWIGTYPE_float"); 
    (arg1)->setFps(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonData_setFps) 

bool js_register_spine_SkeletonData(se::Object* obj) {
    auto* cls = se::Class::create("SkeletonData", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("findBone", _SE(js_spine_SkeletonData_findBone)); 
    cls->defineFunction("findBoneIndex", _SE(js_spine_SkeletonData_findBoneIndex)); 
    cls->defineFunction("findSlot", _SE(js_spine_SkeletonData_findSlot)); 
    cls->defineFunction("findSlotIndex", _SE(js_spine_SkeletonData_findSlotIndex)); 
    cls->defineFunction("findSkin", _SE(js_spine_SkeletonData_findSkin)); 
    cls->defineFunction("findEvent", _SE(js_spine_SkeletonData_findEvent)); 
    cls->defineFunction("findAnimation", _SE(js_spine_SkeletonData_findAnimation)); 
    cls->defineFunction("findIkConstraint", _SE(js_spine_SkeletonData_findIkConstraint)); 
    cls->defineFunction("findTransformConstraint", _SE(js_spine_SkeletonData_findTransformConstraint)); 
    cls->defineFunction("findPathConstraint", _SE(js_spine_SkeletonData_findPathConstraint)); 
    cls->defineFunction("findPathConstraintIndex", _SE(js_spine_SkeletonData_findPathConstraintIndex)); 
    cls->defineFunction("getName", _SE(js_spine_SkeletonData_getName)); 
    cls->defineFunction("setName", _SE(js_spine_SkeletonData_setName)); 
    cls->defineFunction("getBones", _SE(js_spine_SkeletonData_getBones)); 
    cls->defineFunction("getSlots", _SE(js_spine_SkeletonData_getSlots)); 
    cls->defineFunction("getSkins", _SE(js_spine_SkeletonData_getSkins)); 
    cls->defineFunction("getDefaultSkin", _SE(js_spine_SkeletonData_getDefaultSkin)); 
    cls->defineFunction("setDefaultSkin", _SE(js_spine_SkeletonData_setDefaultSkin)); 
    cls->defineFunction("getEvents", _SE(js_spine_SkeletonData_getEvents)); 
    cls->defineFunction("getAnimations", _SE(js_spine_SkeletonData_getAnimations)); 
    cls->defineFunction("getIkConstraints", _SE(js_spine_SkeletonData_getIkConstraints)); 
    cls->defineFunction("getTransformConstraints", _SE(js_spine_SkeletonData_getTransformConstraints)); 
    cls->defineFunction("getPathConstraints", _SE(js_spine_SkeletonData_getPathConstraints)); 
    cls->defineFunction("getX", _SE(js_spine_SkeletonData_getX)); 
    cls->defineFunction("setX", _SE(js_spine_SkeletonData_setX)); 
    cls->defineFunction("getY", _SE(js_spine_SkeletonData_getY)); 
    cls->defineFunction("setY", _SE(js_spine_SkeletonData_setY)); 
    cls->defineFunction("getWidth", _SE(js_spine_SkeletonData_getWidth)); 
    cls->defineFunction("setWidth", _SE(js_spine_SkeletonData_setWidth)); 
    cls->defineFunction("getHeight", _SE(js_spine_SkeletonData_getHeight)); 
    cls->defineFunction("setHeight", _SE(js_spine_SkeletonData_setHeight)); 
    cls->defineFunction("getVersion", _SE(js_spine_SkeletonData_getVersion)); 
    cls->defineFunction("setVersion", _SE(js_spine_SkeletonData_setVersion)); 
    cls->defineFunction("getHash", _SE(js_spine_SkeletonData_getHash)); 
    cls->defineFunction("setHash", _SE(js_spine_SkeletonData_setHash)); 
    cls->defineFunction("getImagesPath", _SE(js_spine_SkeletonData_getImagesPath)); 
    cls->defineFunction("setImagesPath", _SE(js_spine_SkeletonData_setImagesPath)); 
    cls->defineFunction("getAudioPath", _SE(js_spine_SkeletonData_getAudioPath)); 
    cls->defineFunction("setAudioPath", _SE(js_spine_SkeletonData_setAudioPath)); 
    cls->defineFunction("getFps", _SE(js_spine_SkeletonData_getFps)); 
    cls->defineFunction("setFps", _SE(js_spine_SkeletonData_setFps)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_SkeletonData));
    
    
    cls->install();
    JSBClassType::registerClass<spine::SkeletonData>(cls);
    
    __jsb_spine_SkeletonData_proto = cls->getProto();
    __jsb_spine_SkeletonData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_SlotData_class = nullptr;
se::Object* __jsb_spine_SlotData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_SlotData) 

static bool js_spine_SlotData_getIndex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SlotData *arg1 = (spine::SlotData *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SlotData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)(arg1)->getIndex();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SlotData_getIndex) 

static bool js_spine_SlotData_getName(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SlotData *arg1 = (spine::SlotData *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SlotData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::String *) &(arg1)->getName();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SlotData_getName, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SlotData_getName) 

static bool js_spine_SlotData_getBoneData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SlotData *arg1 = (spine::SlotData *) NULL ;
    spine::BoneData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SlotData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::BoneData *) &(arg1)->getBoneData();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SlotData_getBoneData, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SlotData_getBoneData) 

static bool js_spine_SlotData_getColor(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SlotData *arg1 = (spine::SlotData *) NULL ;
    spine::Color *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SlotData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Color *) &(arg1)->getColor();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SlotData_getColor, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SlotData_getColor) 

static bool js_spine_SlotData_getDarkColor(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SlotData *arg1 = (spine::SlotData *) NULL ;
    spine::Color *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SlotData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Color *) &(arg1)->getDarkColor();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SlotData_getDarkColor, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SlotData_getDarkColor) 

static bool js_spine_SlotData_hasDarkColor(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SlotData *arg1 = (spine::SlotData *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SlotData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->hasDarkColor();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SlotData_hasDarkColor) 

static bool js_spine_SlotData_setHasDarkColor(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SlotData *arg1 = (spine::SlotData *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SlotData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "SlotData_setHasDarkColor,2,SWIGTYPE_bool"); 
    (arg1)->setHasDarkColor(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SlotData_setHasDarkColor) 

static bool js_spine_SlotData_getAttachmentName(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SlotData *arg1 = (spine::SlotData *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SlotData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::String *) &(arg1)->getAttachmentName();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SlotData_getAttachmentName, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SlotData_getAttachmentName) 

static bool js_spine_SlotData_setAttachmentName(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SlotData *arg1 = (spine::SlotData *) NULL ;
    spine::String *arg2 = 0 ;
    spine::String temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SlotData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SlotData_setAttachmentName,2,SWIGTYPE_p_spine__String");
    arg2 = &temp2;
    
    (arg1)->setAttachmentName((spine::String const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SlotData_setAttachmentName) 

static bool js_spine_SlotData_getBlendMode(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SlotData *arg1 = (spine::SlotData *) NULL ;
    spine::BlendMode result;
    int32_t temp ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SlotData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::BlendMode)(arg1)->getBlendMode();
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SlotData_getBlendMode) 

static bool js_spine_SlotData_setBlendMode(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SlotData *arg1 = (spine::SlotData *) NULL ;
    spine::BlendMode arg2 ;
    int32_t temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SlotData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "SlotData_setBlendMode,2,SWIGTYPE_spine__BlendMode");
    arg2 = (spine::BlendMode)temp2;
    (arg1)->setBlendMode(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SlotData_setBlendMode) 

static bool js_delete_spine_SlotData(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_SlotData) 

bool js_register_spine_SlotData(se::Object* obj) {
    auto* cls = se::Class::create("SlotData", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("getIndex", _SE(js_spine_SlotData_getIndex)); 
    cls->defineFunction("getName", _SE(js_spine_SlotData_getName)); 
    cls->defineFunction("getBoneData", _SE(js_spine_SlotData_getBoneData)); 
    cls->defineFunction("getColor", _SE(js_spine_SlotData_getColor)); 
    cls->defineFunction("getDarkColor", _SE(js_spine_SlotData_getDarkColor)); 
    cls->defineFunction("hasDarkColor", _SE(js_spine_SlotData_hasDarkColor)); 
    cls->defineFunction("setHasDarkColor", _SE(js_spine_SlotData_setHasDarkColor)); 
    cls->defineFunction("getAttachmentName", _SE(js_spine_SlotData_getAttachmentName)); 
    cls->defineFunction("setAttachmentName", _SE(js_spine_SlotData_setAttachmentName)); 
    cls->defineFunction("getBlendMode", _SE(js_spine_SlotData_getBlendMode)); 
    cls->defineFunction("setBlendMode", _SE(js_spine_SlotData_setBlendMode)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_SlotData));
    
    
    cls->install();
    JSBClassType::registerClass<spine::SlotData>(cls);
    
    __jsb_spine_SlotData_proto = cls->getProto();
    __jsb_spine_SlotData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_TransformConstraint_class = nullptr;
se::Object* __jsb_spine_TransformConstraint_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_TransformConstraint) 

static bool js_spine_TransformConstraint_apply(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->apply();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_apply) 

static bool js_spine_TransformConstraint_update(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->update();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_update) 

static bool js_spine_TransformConstraint_getOrder(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)(arg1)->getOrder();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_getOrder) 

static bool js_spine_TransformConstraint_getData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    spine::TransformConstraintData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::TransformConstraintData *) &(arg1)->getData();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TransformConstraint_getData, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_getData) 

static bool js_spine_TransformConstraint_getBones(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    spine::Vector< spine::Bone * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::Bone * > *) &(arg1)->getBones();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TransformConstraint_getBones, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_getBones) 

static bool js_spine_TransformConstraint_getTarget(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    spine::Bone *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Bone *)(arg1)->getTarget();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TransformConstraint_getTarget, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_getTarget) 

static bool js_spine_TransformConstraint_setTarget(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    spine::Bone *arg2 = (spine::Bone *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TransformConstraint_setTarget,2,SWIGTYPE_p_spine__Bone"); 
    (arg1)->setTarget(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_setTarget) 

static bool js_spine_TransformConstraint_getRotateMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getRotateMix();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_getRotateMix) 

static bool js_spine_TransformConstraint_setRotateMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "TransformConstraint_setRotateMix,2,SWIGTYPE_float"); 
    (arg1)->setRotateMix(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_setRotateMix) 

static bool js_spine_TransformConstraint_getTranslateMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getTranslateMix();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_getTranslateMix) 

static bool js_spine_TransformConstraint_setTranslateMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "TransformConstraint_setTranslateMix,2,SWIGTYPE_float"); 
    (arg1)->setTranslateMix(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_setTranslateMix) 

static bool js_spine_TransformConstraint_getScaleMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getScaleMix();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_getScaleMix) 

static bool js_spine_TransformConstraint_setScaleMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "TransformConstraint_setScaleMix,2,SWIGTYPE_float"); 
    (arg1)->setScaleMix(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_setScaleMix) 

static bool js_spine_TransformConstraint_getShearMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getShearMix();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_getShearMix) 

static bool js_spine_TransformConstraint_setShearMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "TransformConstraint_setShearMix,2,SWIGTYPE_float"); 
    (arg1)->setShearMix(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_setShearMix) 

static bool js_spine_TransformConstraint_isActive(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->isActive();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_isActive) 

static bool js_spine_TransformConstraint_setActive(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraint *arg1 = (spine::TransformConstraint *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraint>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "TransformConstraint_setActive,2,SWIGTYPE_bool"); 
    (arg1)->setActive(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraint_setActive) 

static bool js_delete_spine_TransformConstraint(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_TransformConstraint) 

bool js_register_spine_TransformConstraint(se::Object* obj) {
    auto* cls = se::Class::create("TransformConstraint", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("apply", _SE(js_spine_TransformConstraint_apply)); 
    cls->defineFunction("update", _SE(js_spine_TransformConstraint_update)); 
    cls->defineFunction("getOrder", _SE(js_spine_TransformConstraint_getOrder)); 
    cls->defineFunction("getData", _SE(js_spine_TransformConstraint_getData)); 
    cls->defineFunction("getBones", _SE(js_spine_TransformConstraint_getBones)); 
    cls->defineFunction("getTarget", _SE(js_spine_TransformConstraint_getTarget)); 
    cls->defineFunction("setTarget", _SE(js_spine_TransformConstraint_setTarget)); 
    cls->defineFunction("getRotateMix", _SE(js_spine_TransformConstraint_getRotateMix)); 
    cls->defineFunction("setRotateMix", _SE(js_spine_TransformConstraint_setRotateMix)); 
    cls->defineFunction("getTranslateMix", _SE(js_spine_TransformConstraint_getTranslateMix)); 
    cls->defineFunction("setTranslateMix", _SE(js_spine_TransformConstraint_setTranslateMix)); 
    cls->defineFunction("getScaleMix", _SE(js_spine_TransformConstraint_getScaleMix)); 
    cls->defineFunction("setScaleMix", _SE(js_spine_TransformConstraint_setScaleMix)); 
    cls->defineFunction("getShearMix", _SE(js_spine_TransformConstraint_getShearMix)); 
    cls->defineFunction("setShearMix", _SE(js_spine_TransformConstraint_setShearMix)); 
    cls->defineFunction("isActive", _SE(js_spine_TransformConstraint_isActive)); 
    cls->defineFunction("setActive", _SE(js_spine_TransformConstraint_setActive)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_TransformConstraint));
    
    
    cls->install();
    JSBClassType::registerClass<spine::TransformConstraint>(cls);
    
    __jsb_spine_TransformConstraint_proto = cls->getProto();
    __jsb_spine_TransformConstraint_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_TransformConstraintData_class = nullptr;
se::Object* __jsb_spine_TransformConstraintData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_TransformConstraintData) 

static bool js_spine_TransformConstraintData_getBones(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    spine::Vector< spine::BoneData * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< spine::BoneData * > *) &(arg1)->getBones();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TransformConstraintData_getBones, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_getBones) 

static bool js_spine_TransformConstraintData_getTarget(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    spine::BoneData *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::BoneData *)(arg1)->getTarget();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TransformConstraintData_getTarget, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_getTarget) 

static bool js_spine_TransformConstraintData_getRotateMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getRotateMix();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_getRotateMix) 

static bool js_spine_TransformConstraintData_getTranslateMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getTranslateMix();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_getTranslateMix) 

static bool js_spine_TransformConstraintData_getScaleMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getScaleMix();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_getScaleMix) 

static bool js_spine_TransformConstraintData_getShearMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getShearMix();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_getShearMix) 

static bool js_spine_TransformConstraintData_getOffsetRotation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getOffsetRotation();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_getOffsetRotation) 

static bool js_spine_TransformConstraintData_getOffsetX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getOffsetX();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_getOffsetX) 

static bool js_spine_TransformConstraintData_getOffsetY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getOffsetY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_getOffsetY) 

static bool js_spine_TransformConstraintData_getOffsetScaleX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getOffsetScaleX();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_getOffsetScaleX) 

static bool js_spine_TransformConstraintData_getOffsetScaleY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getOffsetScaleY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_getOffsetScaleY) 

static bool js_spine_TransformConstraintData_getOffsetShearY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getOffsetShearY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_getOffsetShearY) 

static bool js_spine_TransformConstraintData_isRelative(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->isRelative();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_isRelative) 

static bool js_spine_TransformConstraintData_isLocal(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintData *arg1 = (spine::TransformConstraintData *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->isLocal();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintData_isLocal) 

static bool js_delete_spine_TransformConstraintData(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_TransformConstraintData) 

bool js_register_spine_TransformConstraintData(se::Object* obj) {
    auto* cls = se::Class::create("TransformConstraintData", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("getBones", _SE(js_spine_TransformConstraintData_getBones)); 
    cls->defineFunction("getTarget", _SE(js_spine_TransformConstraintData_getTarget)); 
    cls->defineFunction("getRotateMix", _SE(js_spine_TransformConstraintData_getRotateMix)); 
    cls->defineFunction("getTranslateMix", _SE(js_spine_TransformConstraintData_getTranslateMix)); 
    cls->defineFunction("getScaleMix", _SE(js_spine_TransformConstraintData_getScaleMix)); 
    cls->defineFunction("getShearMix", _SE(js_spine_TransformConstraintData_getShearMix)); 
    cls->defineFunction("getOffsetRotation", _SE(js_spine_TransformConstraintData_getOffsetRotation)); 
    cls->defineFunction("getOffsetX", _SE(js_spine_TransformConstraintData_getOffsetX)); 
    cls->defineFunction("getOffsetY", _SE(js_spine_TransformConstraintData_getOffsetY)); 
    cls->defineFunction("getOffsetScaleX", _SE(js_spine_TransformConstraintData_getOffsetScaleX)); 
    cls->defineFunction("getOffsetScaleY", _SE(js_spine_TransformConstraintData_getOffsetScaleY)); 
    cls->defineFunction("getOffsetShearY", _SE(js_spine_TransformConstraintData_getOffsetShearY)); 
    cls->defineFunction("isRelative", _SE(js_spine_TransformConstraintData_isRelative)); 
    cls->defineFunction("isLocal", _SE(js_spine_TransformConstraintData_isLocal)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_TransformConstraintData));
    
    
    cls->install();
    JSBClassType::registerClass<spine::TransformConstraintData>(cls);
    
    __jsb_spine_TransformConstraintData_proto = cls->getProto();
    __jsb_spine_TransformConstraintData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_TransformConstraintTimeline_class = nullptr;
se::Object* __jsb_spine_TransformConstraintTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_TransformConstraintTimeline) 

static bool js_spine_TransformConstraintTimeline_ENTRIES_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    int result;
    
    result = (int)(int)spine::TransformConstraintTimeline::ENTRIES;
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_TransformConstraintTimeline_ENTRIES_get) 

static bool js_spine_TransformConstraintTimeline_setFrame(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TransformConstraintTimeline *arg1 = (spine::TransformConstraintTimeline *) NULL ;
    size_t arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TransformConstraintTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "TransformConstraintTimeline_setFrame,2,SWIGTYPE_size_t");
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "TransformConstraintTimeline_setFrame,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "TransformConstraintTimeline_setFrame,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "TransformConstraintTimeline_setFrame,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "TransformConstraintTimeline_setFrame,6,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg7, nullptr);
    SE_PRECONDITION2(ok, false, "TransformConstraintTimeline_setFrame,7,SWIGTYPE_float"); 
    (arg1)->setFrame(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TransformConstraintTimeline_setFrame) 

static bool js_delete_spine_TransformConstraintTimeline(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_TransformConstraintTimeline) 

bool js_register_spine_TransformConstraintTimeline(se::Object* obj) {
    auto* cls = se::Class::create("TransformConstraintTimeline", obj, __jsb_spine_CurveTimeline_proto, nullptr); 
    
    
    cls->defineFunction("setFrame", _SE(js_spine_TransformConstraintTimeline_setFrame)); 
    
    cls->defineStaticProperty("ENTRIES", _SE(js_spine_TransformConstraintTimeline_ENTRIES_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_TransformConstraintTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::TransformConstraintTimeline>(cls);
    
    __jsb_spine_TransformConstraintTimeline_proto = cls->getProto();
    __jsb_spine_TransformConstraintTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_TranslateTimeline_class = nullptr;
se::Object* __jsb_spine_TranslateTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_TranslateTimeline) 

static bool js_spine_TranslateTimeline_ENTRIES_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    int result;
    
    result = (int)(int)spine::TranslateTimeline::ENTRIES;
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_TranslateTimeline_ENTRIES_get) 

static bool js_delete_spine_TranslateTimeline(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_TranslateTimeline) 

static bool js_spine_TranslateTimeline_setFrame(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TranslateTimeline *arg1 = (spine::TranslateTimeline *) NULL ;
    int arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TranslateTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "TranslateTimeline_setFrame,2,SWIGTYPE_int"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "TranslateTimeline_setFrame,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "TranslateTimeline_setFrame,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "TranslateTimeline_setFrame,5,SWIGTYPE_float"); 
    (arg1)->setFrame(arg2,arg3,arg4,arg5);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TranslateTimeline_setFrame) 

bool js_register_spine_TranslateTimeline(se::Object* obj) {
    auto* cls = se::Class::create("TranslateTimeline", obj, __jsb_spine_CurveTimeline_proto, nullptr); 
    
    
    cls->defineFunction("setFrame", _SE(js_spine_TranslateTimeline_setFrame)); 
    
    cls->defineStaticProperty("ENTRIES", _SE(js_spine_TranslateTimeline_ENTRIES_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_TranslateTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::TranslateTimeline>(cls);
    
    __jsb_spine_TranslateTimeline_proto = cls->getProto();
    __jsb_spine_TranslateTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_TwoColorTimeline_class = nullptr;
se::Object* __jsb_spine_TwoColorTimeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_TwoColorTimeline) 

static bool js_spine_TwoColorTimeline_ENTRIES_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    int result;
    
    result = (int)(int)spine::TwoColorTimeline::ENTRIES;
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_TwoColorTimeline_ENTRIES_get) 

static bool js_spine_TwoColorTimeline_setFrame(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TwoColorTimeline *arg1 = (spine::TwoColorTimeline *) NULL ;
    int arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    float arg8 ;
    float arg9 ;
    float arg10 ;
    
    if(argc != 9) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 9);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TwoColorTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "TwoColorTimeline_setFrame,2,SWIGTYPE_int"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "TwoColorTimeline_setFrame,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "TwoColorTimeline_setFrame,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "TwoColorTimeline_setFrame,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "TwoColorTimeline_setFrame,6,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg7, nullptr);
    SE_PRECONDITION2(ok, false, "TwoColorTimeline_setFrame,7,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[6], &arg8, nullptr);
    SE_PRECONDITION2(ok, false, "TwoColorTimeline_setFrame,8,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[7], &arg9, nullptr);
    SE_PRECONDITION2(ok, false, "TwoColorTimeline_setFrame,9,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[8], &arg10, nullptr);
    SE_PRECONDITION2(ok, false, "TwoColorTimeline_setFrame,10,SWIGTYPE_float"); 
    (arg1)->setFrame(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TwoColorTimeline_setFrame) 

static bool js_spine_TwoColorTimeline_getSlotIndex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TwoColorTimeline *arg1 = (spine::TwoColorTimeline *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TwoColorTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)(arg1)->getSlotIndex();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TwoColorTimeline_getSlotIndex) 

static bool js_spine_TwoColorTimeline_setSlotIndex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::TwoColorTimeline *arg1 = (spine::TwoColorTimeline *) NULL ;
    int arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::TwoColorTimeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "TwoColorTimeline_setSlotIndex,2,SWIGTYPE_int"); 
    (arg1)->setSlotIndex(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_TwoColorTimeline_setSlotIndex) 

static bool js_delete_spine_TwoColorTimeline(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_TwoColorTimeline) 

bool js_register_spine_TwoColorTimeline(se::Object* obj) {
    auto* cls = se::Class::create("TwoColorTimeline", obj, __jsb_spine_CurveTimeline_proto, nullptr); 
    
    
    cls->defineFunction("setFrame", _SE(js_spine_TwoColorTimeline_setFrame)); 
    cls->defineFunction("getSlotIndex", _SE(js_spine_TwoColorTimeline_getSlotIndex)); 
    cls->defineFunction("setSlotIndex", _SE(js_spine_TwoColorTimeline_setSlotIndex)); 
    
    cls->defineStaticProperty("ENTRIES", _SE(js_spine_TwoColorTimeline_ENTRIES_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_TwoColorTimeline));
    
    
    cls->install();
    JSBClassType::registerClass<spine::TwoColorTimeline>(cls);
    
    __jsb_spine_TwoColorTimeline_proto = cls->getProto();
    __jsb_spine_TwoColorTimeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_VertexAttachment_class = nullptr;
se::Object* __jsb_spine_VertexAttachment_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_VertexAttachment) 

static bool js_delete_spine_VertexAttachment(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_VertexAttachment) 

static bool js_spine_VertexAttachment_getId(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexAttachment *arg1 = (spine::VertexAttachment *) NULL ;
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)(arg1)->getId();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexAttachment_getId) 

static bool js_spine_VertexAttachment_getVertices(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexAttachment *arg1 = (spine::VertexAttachment *) NULL ;
    spine::Vector< float > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Vector< float > *) &(arg1)->getVertices();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "VertexAttachment_getVertices, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexAttachment_getVertices) 

static bool js_spine_VertexAttachment_getWorldVerticesLength(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexAttachment *arg1 = (spine::VertexAttachment *) NULL ;
    size_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getWorldVerticesLength();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexAttachment_getWorldVerticesLength) 

static bool js_spine_VertexAttachment_setWorldVerticesLength(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexAttachment *arg1 = (spine::VertexAttachment *) NULL ;
    size_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "VertexAttachment_setWorldVerticesLength,2,SWIGTYPE_size_t");
    
    (arg1)->setWorldVerticesLength(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexAttachment_setWorldVerticesLength) 

static bool js_spine_VertexAttachment_getDeformAttachment(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexAttachment *arg1 = (spine::VertexAttachment *) NULL ;
    spine::VertexAttachment *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::VertexAttachment *)(arg1)->getDeformAttachment();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "VertexAttachment_getDeformAttachment, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexAttachment_getDeformAttachment) 

static bool js_spine_VertexAttachment_setDeformAttachment(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexAttachment *arg1 = (spine::VertexAttachment *) NULL ;
    spine::VertexAttachment *arg2 = (spine::VertexAttachment *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "VertexAttachment_setDeformAttachment,2,SWIGTYPE_p_spine__VertexAttachment"); 
    (arg1)->setDeformAttachment(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexAttachment_setDeformAttachment) 

static bool js_spine_VertexAttachment_copyTo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexAttachment *arg1 = (spine::VertexAttachment *) NULL ;
    spine::VertexAttachment *arg2 = (spine::VertexAttachment *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "VertexAttachment_copyTo,2,SWIGTYPE_p_spine__VertexAttachment"); 
    (arg1)->copyTo(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexAttachment_copyTo) 

bool js_register_spine_VertexAttachment(se::Object* obj) {
    auto* cls = se::Class::create("VertexAttachment", obj, __jsb_spine_Attachment_proto, nullptr); 
    
    
    cls->defineFunction("getId", _SE(js_spine_VertexAttachment_getId)); 
    cls->defineFunction("getVertices", _SE(js_spine_VertexAttachment_getVertices)); 
    cls->defineFunction("getWorldVerticesLength", _SE(js_spine_VertexAttachment_getWorldVerticesLength)); 
    cls->defineFunction("setWorldVerticesLength", _SE(js_spine_VertexAttachment_setWorldVerticesLength)); 
    cls->defineFunction("getDeformAttachment", _SE(js_spine_VertexAttachment_getDeformAttachment)); 
    cls->defineFunction("setDeformAttachment", _SE(js_spine_VertexAttachment_setDeformAttachment)); 
    cls->defineFunction("copyTo", _SE(js_spine_VertexAttachment_copyTo)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_VertexAttachment));
    
    
    cls->install();
    JSBClassType::registerClass<spine::VertexAttachment>(cls);
    
    __jsb_spine_VertexAttachment_proto = cls->getProto();
    __jsb_spine_VertexAttachment_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_VertexEffect_class = nullptr;
se::Object* __jsb_spine_VertexEffect_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_VertexEffect) 

static bool js_delete_spine_VertexEffect(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_VertexEffect) 

bool js_register_spine_VertexEffect(se::Object* obj) {
    auto* cls = se::Class::create("VertexEffect", obj, nullptr, nullptr); 
    
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_VertexEffect));
    
    
    cls->install();
    JSBClassType::registerClass<spine::VertexEffect>(cls);
    
    __jsb_spine_VertexEffect_proto = cls->getProto();
    __jsb_spine_VertexEffect_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_JitterVertexEffect_class = nullptr;
se::Object* __jsb_spine_JitterVertexEffect_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_JitterVertexEffect) 

static bool js_spine_JitterVertexEffect_setJitterX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::JitterVertexEffect *arg1 = (spine::JitterVertexEffect *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::JitterVertexEffect>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "JitterVertexEffect_setJitterX,2,SWIGTYPE_float"); 
    (arg1)->setJitterX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_JitterVertexEffect_setJitterX) 

static bool js_spine_JitterVertexEffect_getJitterX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::JitterVertexEffect *arg1 = (spine::JitterVertexEffect *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::JitterVertexEffect>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getJitterX();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_JitterVertexEffect_getJitterX) 

static bool js_spine_JitterVertexEffect_setJitterY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::JitterVertexEffect *arg1 = (spine::JitterVertexEffect *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::JitterVertexEffect>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "JitterVertexEffect_setJitterY,2,SWIGTYPE_float"); 
    (arg1)->setJitterY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_JitterVertexEffect_setJitterY) 

static bool js_spine_JitterVertexEffect_getJitterY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::JitterVertexEffect *arg1 = (spine::JitterVertexEffect *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::JitterVertexEffect>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getJitterY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_JitterVertexEffect_getJitterY) 

static bool js_delete_spine_JitterVertexEffect(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_JitterVertexEffect) 

bool js_register_spine_JitterVertexEffect(se::Object* obj) {
    auto* cls = se::Class::create("JitterVertexEffect", obj, __jsb_spine_VertexEffect_proto, nullptr); 
    
    
    cls->defineFunction("setJitterX", _SE(js_spine_JitterVertexEffect_setJitterX)); 
    cls->defineFunction("getJitterX", _SE(js_spine_JitterVertexEffect_getJitterX)); 
    cls->defineFunction("setJitterY", _SE(js_spine_JitterVertexEffect_setJitterY)); 
    cls->defineFunction("getJitterY", _SE(js_spine_JitterVertexEffect_getJitterY)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_JitterVertexEffect));
    
    
    cls->install();
    JSBClassType::registerClass<spine::JitterVertexEffect>(cls);
    
    __jsb_spine_JitterVertexEffect_proto = cls->getProto();
    __jsb_spine_JitterVertexEffect_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_SwirlVertexEffect_class = nullptr;
se::Object* __jsb_spine_SwirlVertexEffect_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_SwirlVertexEffect) 

static bool js_spine_SwirlVertexEffect_setCenterX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SwirlVertexEffect *arg1 = (spine::SwirlVertexEffect *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SwirlVertexEffect>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SwirlVertexEffect_setCenterX,2,SWIGTYPE_float"); 
    (arg1)->setCenterX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SwirlVertexEffect_setCenterX) 

static bool js_spine_SwirlVertexEffect_getCenterX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SwirlVertexEffect *arg1 = (spine::SwirlVertexEffect *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SwirlVertexEffect>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getCenterX();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SwirlVertexEffect_getCenterX) 

static bool js_spine_SwirlVertexEffect_setCenterY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SwirlVertexEffect *arg1 = (spine::SwirlVertexEffect *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SwirlVertexEffect>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SwirlVertexEffect_setCenterY,2,SWIGTYPE_float"); 
    (arg1)->setCenterY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SwirlVertexEffect_setCenterY) 

static bool js_spine_SwirlVertexEffect_getCenterY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SwirlVertexEffect *arg1 = (spine::SwirlVertexEffect *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SwirlVertexEffect>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getCenterY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SwirlVertexEffect_getCenterY) 

static bool js_spine_SwirlVertexEffect_setRadius(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SwirlVertexEffect *arg1 = (spine::SwirlVertexEffect *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SwirlVertexEffect>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SwirlVertexEffect_setRadius,2,SWIGTYPE_float"); 
    (arg1)->setRadius(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SwirlVertexEffect_setRadius) 

static bool js_spine_SwirlVertexEffect_getRadius(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SwirlVertexEffect *arg1 = (spine::SwirlVertexEffect *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SwirlVertexEffect>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getRadius();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SwirlVertexEffect_getRadius) 

static bool js_spine_SwirlVertexEffect_setAngle(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SwirlVertexEffect *arg1 = (spine::SwirlVertexEffect *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SwirlVertexEffect>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SwirlVertexEffect_setAngle,2,SWIGTYPE_float"); 
    (arg1)->setAngle(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SwirlVertexEffect_setAngle) 

static bool js_spine_SwirlVertexEffect_getAngle(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SwirlVertexEffect *arg1 = (spine::SwirlVertexEffect *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SwirlVertexEffect>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getAngle();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SwirlVertexEffect_getAngle) 

static bool js_spine_SwirlVertexEffect_setWorldX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SwirlVertexEffect *arg1 = (spine::SwirlVertexEffect *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SwirlVertexEffect>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SwirlVertexEffect_setWorldX,2,SWIGTYPE_float"); 
    (arg1)->setWorldX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SwirlVertexEffect_setWorldX) 

static bool js_spine_SwirlVertexEffect_getWorldX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SwirlVertexEffect *arg1 = (spine::SwirlVertexEffect *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SwirlVertexEffect>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getWorldX();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SwirlVertexEffect_getWorldX) 

static bool js_spine_SwirlVertexEffect_setWorldY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SwirlVertexEffect *arg1 = (spine::SwirlVertexEffect *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SwirlVertexEffect>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SwirlVertexEffect_setWorldY,2,SWIGTYPE_float"); 
    (arg1)->setWorldY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SwirlVertexEffect_setWorldY) 

static bool js_spine_SwirlVertexEffect_getWorldY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SwirlVertexEffect *arg1 = (spine::SwirlVertexEffect *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SwirlVertexEffect>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)(arg1)->getWorldY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SwirlVertexEffect_getWorldY) 

static bool js_delete_spine_SwirlVertexEffect(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_SwirlVertexEffect) 

bool js_register_spine_SwirlVertexEffect(se::Object* obj) {
    auto* cls = se::Class::create("SwirlVertexEffect", obj, __jsb_spine_VertexEffect_proto, nullptr); 
    
    
    cls->defineFunction("setCenterX", _SE(js_spine_SwirlVertexEffect_setCenterX)); 
    cls->defineFunction("getCenterX", _SE(js_spine_SwirlVertexEffect_getCenterX)); 
    cls->defineFunction("setCenterY", _SE(js_spine_SwirlVertexEffect_setCenterY)); 
    cls->defineFunction("getCenterY", _SE(js_spine_SwirlVertexEffect_getCenterY)); 
    cls->defineFunction("setRadius", _SE(js_spine_SwirlVertexEffect_setRadius)); 
    cls->defineFunction("getRadius", _SE(js_spine_SwirlVertexEffect_getRadius)); 
    cls->defineFunction("setAngle", _SE(js_spine_SwirlVertexEffect_setAngle)); 
    cls->defineFunction("getAngle", _SE(js_spine_SwirlVertexEffect_getAngle)); 
    cls->defineFunction("setWorldX", _SE(js_spine_SwirlVertexEffect_setWorldX)); 
    cls->defineFunction("getWorldX", _SE(js_spine_SwirlVertexEffect_getWorldX)); 
    cls->defineFunction("setWorldY", _SE(js_spine_SwirlVertexEffect_setWorldY)); 
    cls->defineFunction("getWorldY", _SE(js_spine_SwirlVertexEffect_getWorldY)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_SwirlVertexEffect));
    
    
    cls->install();
    JSBClassType::registerClass<spine::SwirlVertexEffect>(cls);
    
    __jsb_spine_SwirlVertexEffect_proto = cls->getProto();
    __jsb_spine_SwirlVertexEffect_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_ConstraintData_class = nullptr;
se::Object* __jsb_spine_ConstraintData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_ConstraintData) 

static bool js_delete_spine_ConstraintData(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_ConstraintData) 

static bool js_spine_ConstraintData_getName(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ConstraintData *arg1 = (spine::ConstraintData *) NULL ;
    spine::String *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::String *) &(arg1)->getName();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ConstraintData_getName, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ConstraintData_getName) 

static bool js_spine_ConstraintData_getOrder(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ConstraintData *arg1 = (spine::ConstraintData *) NULL ;
    size_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->getOrder();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ConstraintData_getOrder) 

static bool js_spine_ConstraintData_setOrder(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ConstraintData *arg1 = (spine::ConstraintData *) NULL ;
    size_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ConstraintData_setOrder,2,SWIGTYPE_size_t");
    
    (arg1)->setOrder(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ConstraintData_setOrder) 

static bool js_spine_ConstraintData_isSkinRequired(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ConstraintData *arg1 = (spine::ConstraintData *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->isSkinRequired();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ConstraintData_isSkinRequired) 

static bool js_spine_ConstraintData_setSkinRequired(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::ConstraintData *arg1 = (spine::ConstraintData *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::ConstraintData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "ConstraintData_setSkinRequired,2,SWIGTYPE_bool"); 
    (arg1)->setSkinRequired(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_ConstraintData_setSkinRequired) 

bool js_register_spine_ConstraintData(se::Object* obj) {
    auto* cls = se::Class::create("ConstraintData", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("getName", _SE(js_spine_ConstraintData_getName)); 
    cls->defineFunction("getOrder", _SE(js_spine_ConstraintData_getOrder)); 
    cls->defineFunction("setOrder", _SE(js_spine_ConstraintData_setOrder)); 
    cls->defineFunction("isSkinRequired", _SE(js_spine_ConstraintData_isSkinRequired)); 
    cls->defineFunction("setSkinRequired", _SE(js_spine_ConstraintData_setSkinRequired)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_ConstraintData));
    
    
    cls->install();
    JSBClassType::registerClass<spine::ConstraintData>(cls);
    
    __jsb_spine_ConstraintData_proto = cls->getProto();
    __jsb_spine_ConstraintData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_VertexEffectDelegate_class = nullptr;
se::Object* __jsb_spine_VertexEffectDelegate_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_VertexEffectDelegate) 

// js_ctor
static bool js_new_spine_VertexEffectDelegate(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    spine::VertexEffectDelegate *result;
    result = (spine::VertexEffectDelegate *)new spine::VertexEffectDelegate();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_spine_VertexEffectDelegate, __jsb_spine_VertexEffectDelegate_class, js_delete_spine_VertexEffectDelegate)

static bool js_delete_spine_VertexEffectDelegate(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_VertexEffectDelegate) 

static bool js_spine_VertexEffectDelegate_initJitter(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexEffectDelegate *arg1 = (spine::VertexEffectDelegate *) NULL ;
    float arg2 ;
    float arg3 ;
    spine::JitterVertexEffect *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexEffectDelegate>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "VertexEffectDelegate_initJitter,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "VertexEffectDelegate_initJitter,3,SWIGTYPE_float"); 
    result = (spine::JitterVertexEffect *)(arg1)->initJitter(arg2,arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "VertexEffectDelegate_initJitter, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexEffectDelegate_initJitter) 

static bool js_spine_VertexEffectDelegate_initSwirlWithPow(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexEffectDelegate *arg1 = (spine::VertexEffectDelegate *) NULL ;
    float arg2 ;
    int arg3 ;
    spine::SwirlVertexEffect *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexEffectDelegate>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "VertexEffectDelegate_initSwirlWithPow,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "VertexEffectDelegate_initSwirlWithPow,3,SWIGTYPE_int"); 
    result = (spine::SwirlVertexEffect *)(arg1)->initSwirlWithPow(arg2,arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "VertexEffectDelegate_initSwirlWithPow, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexEffectDelegate_initSwirlWithPow) 

static bool js_spine_VertexEffectDelegate_initSwirlWithPowOut(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexEffectDelegate *arg1 = (spine::VertexEffectDelegate *) NULL ;
    float arg2 ;
    int arg3 ;
    spine::SwirlVertexEffect *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexEffectDelegate>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "VertexEffectDelegate_initSwirlWithPowOut,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "VertexEffectDelegate_initSwirlWithPowOut,3,SWIGTYPE_int"); 
    result = (spine::SwirlVertexEffect *)(arg1)->initSwirlWithPowOut(arg2,arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "VertexEffectDelegate_initSwirlWithPowOut, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexEffectDelegate_initSwirlWithPowOut) 

static bool js_spine_VertexEffectDelegate_getVertexEffect(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexEffectDelegate *arg1 = (spine::VertexEffectDelegate *) NULL ;
    spine::VertexEffect *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexEffectDelegate>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::VertexEffect *)(arg1)->getVertexEffect();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "VertexEffectDelegate_getVertexEffect, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexEffectDelegate_getVertexEffect) 

static bool js_spine_VertexEffectDelegate_getJitterVertexEffect(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexEffectDelegate *arg1 = (spine::VertexEffectDelegate *) NULL ;
    spine::JitterVertexEffect *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexEffectDelegate>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::JitterVertexEffect *)(arg1)->getJitterVertexEffect();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "VertexEffectDelegate_getJitterVertexEffect, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexEffectDelegate_getJitterVertexEffect) 

static bool js_spine_VertexEffectDelegate_getSwirlVertexEffect(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexEffectDelegate *arg1 = (spine::VertexEffectDelegate *) NULL ;
    spine::SwirlVertexEffect *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexEffectDelegate>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::SwirlVertexEffect *)(arg1)->getSwirlVertexEffect();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "VertexEffectDelegate_getSwirlVertexEffect, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexEffectDelegate_getSwirlVertexEffect) 

static bool js_spine_VertexEffectDelegate_getEffectType(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexEffectDelegate *arg1 = (spine::VertexEffectDelegate *) NULL ;
    std::string *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexEffectDelegate>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (std::string *) &((spine::VertexEffectDelegate const *)arg1)->getEffectType();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "VertexEffectDelegate_getEffectType, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexEffectDelegate_getEffectType) 

static bool js_spine_VertexEffectDelegate_clear(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::VertexEffectDelegate *arg1 = (spine::VertexEffectDelegate *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::VertexEffectDelegate>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->clear();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_VertexEffectDelegate_clear) 

bool js_register_spine_VertexEffectDelegate(se::Object* obj) {
    auto* cls = se::Class::create("VertexEffectDelegate", obj, nullptr, _SE(js_new_spine_VertexEffectDelegate)); 
    
    
    cls->defineFunction("initJitter", _SE(js_spine_VertexEffectDelegate_initJitter)); 
    cls->defineFunction("initSwirlWithPow", _SE(js_spine_VertexEffectDelegate_initSwirlWithPow)); 
    cls->defineFunction("initSwirlWithPowOut", _SE(js_spine_VertexEffectDelegate_initSwirlWithPowOut)); 
    cls->defineFunction("getVertexEffect", _SE(js_spine_VertexEffectDelegate_getVertexEffect)); 
    cls->defineFunction("getJitterVertexEffect", _SE(js_spine_VertexEffectDelegate_getJitterVertexEffect)); 
    cls->defineFunction("getSwirlVertexEffect", _SE(js_spine_VertexEffectDelegate_getSwirlVertexEffect)); 
    cls->defineFunction("getEffectType", _SE(js_spine_VertexEffectDelegate_getEffectType)); 
    cls->defineFunction("clear", _SE(js_spine_VertexEffectDelegate_clear)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_VertexEffectDelegate));
    
    
    cls->install();
    JSBClassType::registerClass<spine::VertexEffectDelegate>(cls);
    
    __jsb_spine_VertexEffectDelegate_proto = cls->getProto();
    __jsb_spine_VertexEffectDelegate_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_SkeletonRenderer_class = nullptr;
se::Object* __jsb_spine_SkeletonRenderer_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_SkeletonRenderer) 

static bool js_spine_SkeletonRenderer_create_static__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    std::string *arg1 = 0 ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp1 ;
    std::string temp2 ;
    spine::SkeletonRenderer *result = 0 ;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_create,1,SWIGTYPE_p_std__string");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_create,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_create,3,SWIGTYPE_float"); 
    result = (spine::SkeletonRenderer *)spine::SkeletonRenderer::createWithFile((std::string const &)*arg1,(std::string const &)*arg2,arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonRenderer_create_static__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    std::string *arg1 = 0 ;
    std::string *arg2 = 0 ;
    std::string temp1 ;
    std::string temp2 ;
    spine::SkeletonRenderer *result = 0 ;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_create,1,SWIGTYPE_p_std__string");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_create,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (spine::SkeletonRenderer *)spine::SkeletonRenderer::createWithFile((std::string const &)*arg1,(std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonRenderer_create_static(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_spine_SkeletonRenderer_create_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_spine_SkeletonRenderer_create_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_create_static) 

static bool js_spine_SkeletonRenderer_update(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_update,2,SWIGTYPE_float"); 
    (arg1)->update(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_update) 

static bool js_spine_SkeletonRenderer_render(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_render,2,SWIGTYPE_float"); 
    (arg1)->render(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_render) 

static bool js_spine_SkeletonRenderer_getBoundingBox(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    cc::Rect result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((spine::SkeletonRenderer const *)arg1)->getBoundingBox();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_getBoundingBox, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_getBoundingBox) 

static bool js_spine_SkeletonRenderer_getSkeleton(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    spine::Skeleton *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Skeleton *)((spine::SkeletonRenderer const *)arg1)->getSkeleton();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_getSkeleton, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_getSkeleton) 

static bool js_spine_SkeletonRenderer_setTimeScale(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_setTimeScale,2,SWIGTYPE_float"); 
    (arg1)->setTimeScale(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setTimeScale) 

static bool js_spine_SkeletonRenderer_getTimeScale(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)((spine::SkeletonRenderer const *)arg1)->getTimeScale();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_getTimeScale) 

static bool js_spine_SkeletonRenderer_updateWorldTransform(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->updateWorldTransform();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_updateWorldTransform) 

static bool js_spine_SkeletonRenderer_setToSetupPose(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->setToSetupPose();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setToSetupPose) 

static bool js_spine_SkeletonRenderer_setBonesToSetupPose(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->setBonesToSetupPose();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setBonesToSetupPose) 

static bool js_spine_SkeletonRenderer_setSlotsToSetupPose(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->setSlotsToSetupPose();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setSlotsToSetupPose) 

static bool js_spine_SkeletonRenderer_paused(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_paused,2,SWIGTYPE_bool"); 
    (arg1)->paused(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_paused) 

static bool js_spine_SkeletonRenderer_findBone(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    spine::Bone *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_findBone,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (spine::Bone *)((spine::SkeletonRenderer const *)arg1)->findBone((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_findBone, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_findBone) 

static bool js_spine_SkeletonRenderer_findSlot(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    spine::Slot *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_findSlot,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (spine::Slot *)((spine::SkeletonRenderer const *)arg1)->findSlot((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_findSlot, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_findSlot) 

static bool js_spine_SkeletonRenderer_setSkin__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_setSkin,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    (arg1)->setSkin((std::string const &)*arg2);
    
    
    return true;
}

static bool js_spine_SkeletonRenderer_setSkin__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    char *arg2 = (char *) NULL ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_setSkin,2,SWIGTYPE_p_char");
    arg2 = (char *) temp2.c_str(); 
    (arg1)->setSkin((char const *)arg2);
    
    
    return true;
}

static bool js_spine_SkeletonRenderer_setSkin(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_spine_SkeletonRenderer_setSkin__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_spine_SkeletonRenderer_setSkin__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setSkin) 

static bool js_spine_SkeletonRenderer_getAttachment(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    spine::Attachment *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_getAttachment,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_getAttachment,3,SWIGTYPE_p_std__string");
    arg3 = &temp3;
    
    result = (spine::Attachment *)((spine::SkeletonRenderer const *)arg1)->getAttachment((std::string const &)*arg2,(std::string const &)*arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_getAttachment, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_getAttachment) 

static bool js_spine_SkeletonRenderer_setAttachment__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_setAttachment,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_setAttachment,3,SWIGTYPE_p_std__string");
    arg3 = &temp3;
    
    result = (bool)(arg1)->setAttachment((std::string const &)*arg2,(std::string const &)*arg3);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_spine_SkeletonRenderer_setAttachment__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    std::string *arg2 = 0 ;
    char *arg3 = (char *) NULL ;
    std::string temp2 ;
    ccstd::string temp3 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_setAttachment,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_setAttachment,3,SWIGTYPE_p_char");
    arg3 = (char *) temp3.c_str(); 
    result = (bool)(arg1)->setAttachment((std::string const &)*arg2,(char const *)arg3);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_spine_SkeletonRenderer_setAttachment(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_spine_SkeletonRenderer_setAttachment__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_spine_SkeletonRenderer_setAttachment__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setAttachment) 

static bool js_spine_SkeletonRenderer_setUseTint(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_setUseTint,2,SWIGTYPE_bool"); 
    (arg1)->setUseTint(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setUseTint) 

static bool js_spine_SkeletonRenderer_setVertexEffectDelegate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    spine::VertexEffectDelegate *arg2 = (spine::VertexEffectDelegate *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_setVertexEffectDelegate,2,SWIGTYPE_p_spine__VertexEffectDelegate"); 
    (arg1)->setVertexEffectDelegate(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setVertexEffectDelegate) 

static bool js_spine_SkeletonRenderer_setSlotsRange(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    int arg2 ;
    int arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_setSlotsRange,2,SWIGTYPE_int"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_setSlotsRange,3,SWIGTYPE_int"); 
    (arg1)->setSlotsRange(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setSlotsRange) 

static bool js_spine_SkeletonRenderer_getDebugData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    se_object_ptr result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((spine::SkeletonRenderer const *)arg1)->getDebugData();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_getDebugData, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_getDebugData) 

static bool js_spine_SkeletonRenderer_getSharedBufferOffset(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    se_object_ptr result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((spine::SkeletonRenderer const *)arg1)->getSharedBufferOffset();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_getSharedBufferOffset, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_getSharedBufferOffset) 

static bool js_spine_SkeletonRenderer_getParamsBuffer(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    se_object_ptr result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((spine::SkeletonRenderer const *)arg1)->getParamsBuffer();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_getParamsBuffer, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_getParamsBuffer) 

static bool js_spine_SkeletonRenderer_setColor(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_setColor,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_setColor,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_setColor,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_setColor,5,SWIGTYPE_float"); 
    (arg1)->setColor(arg2,arg3,arg4,arg5);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setColor) 

static bool js_spine_SkeletonRenderer_setBatchEnabled(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_setBatchEnabled,2,SWIGTYPE_bool"); 
    (arg1)->setBatchEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setBatchEnabled) 

static bool js_spine_SkeletonRenderer_setDebugBonesEnabled(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_setDebugBonesEnabled,2,SWIGTYPE_bool"); 
    (arg1)->setDebugBonesEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setDebugBonesEnabled) 

static bool js_spine_SkeletonRenderer_setDebugSlotsEnabled(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_setDebugSlotsEnabled,2,SWIGTYPE_bool"); 
    (arg1)->setDebugSlotsEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setDebugSlotsEnabled) 

static bool js_spine_SkeletonRenderer_setDebugMeshEnabled(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_setDebugMeshEnabled,2,SWIGTYPE_bool"); 
    (arg1)->setDebugMeshEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setDebugMeshEnabled) 

static bool js_spine_SkeletonRenderer_setAttachEnabled(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_setAttachEnabled,2,SWIGTYPE_bool"); 
    (arg1)->setAttachEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setAttachEnabled) 

static bool js_spine_SkeletonRenderer_setOpacityModifyRGB(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_setOpacityModifyRGB,2,SWIGTYPE_bool"); 
    (arg1)->setOpacityModifyRGB(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_setOpacityModifyRGB) 

static bool js_spine_SkeletonRenderer_isOpacityModifyRGB(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((spine::SkeletonRenderer const *)arg1)->isOpacityModifyRGB();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_isOpacityModifyRGB) 

static bool js_spine_SkeletonRenderer_beginSchedule(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->beginSchedule();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_beginSchedule) 

static bool js_spine_SkeletonRenderer_stopSchedule(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->stopSchedule();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_stopSchedule) 

static bool js_spine_SkeletonRenderer_onEnable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_onEnable) 

static bool js_spine_SkeletonRenderer_onDisable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_onDisable) 

static bool js_new_spine_SkeletonRenderer__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    spine::SkeletonRenderer *result;
    result = (spine::SkeletonRenderer *)new spine::SkeletonRenderer();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_spine_SkeletonRenderer__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    bool arg2 ;
    bool arg3 ;
    bool arg4 ;
    spine::SkeletonRenderer *result;
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_SkeletonRenderer,1,SWIGTYPE_p_spine__Skeleton"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[1], &arg2);
    SE_PRECONDITION2(ok, false, "new_SkeletonRenderer,2,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[2], &arg3);
    SE_PRECONDITION2(ok, false, "new_SkeletonRenderer,3,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[3], &arg4);
    SE_PRECONDITION2(ok, false, "new_SkeletonRenderer,4,SWIGTYPE_bool"); 
    result = (spine::SkeletonRenderer *)new spine::SkeletonRenderer(arg1,arg2,arg3,arg4);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_spine_SkeletonRenderer__SWIG_2(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    bool arg2 ;
    bool arg3 ;
    spine::SkeletonRenderer *result;
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_SkeletonRenderer,1,SWIGTYPE_p_spine__Skeleton"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[1], &arg2);
    SE_PRECONDITION2(ok, false, "new_SkeletonRenderer,2,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[2], &arg3);
    SE_PRECONDITION2(ok, false, "new_SkeletonRenderer,3,SWIGTYPE_bool"); 
    result = (spine::SkeletonRenderer *)new spine::SkeletonRenderer(arg1,arg2,arg3);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_spine_SkeletonRenderer__SWIG_3(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    bool arg2 ;
    spine::SkeletonRenderer *result;
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_SkeletonRenderer,1,SWIGTYPE_p_spine__Skeleton"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[1], &arg2);
    SE_PRECONDITION2(ok, false, "new_SkeletonRenderer,2,SWIGTYPE_bool"); 
    result = (spine::SkeletonRenderer *)new spine::SkeletonRenderer(arg1,arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_spine_SkeletonRenderer__SWIG_4(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    spine::Skeleton *arg1 = (spine::Skeleton *) NULL ;
    spine::SkeletonRenderer *result;
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_SkeletonRenderer,1,SWIGTYPE_p_spine__Skeleton"); 
    result = (spine::SkeletonRenderer *)new spine::SkeletonRenderer(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_spine_SkeletonRenderer__SWIG_5(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    bool arg2 ;
    spine::SkeletonRenderer *result;
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_SkeletonRenderer,1,SWIGTYPE_p_spine__SkeletonData"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[1], &arg2);
    SE_PRECONDITION2(ok, false, "new_SkeletonRenderer,2,SWIGTYPE_bool"); 
    result = (spine::SkeletonRenderer *)new spine::SkeletonRenderer(arg1,arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_spine_SkeletonRenderer__SWIG_6(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    spine::SkeletonData *arg1 = (spine::SkeletonData *) NULL ;
    spine::SkeletonRenderer *result;
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_SkeletonRenderer,1,SWIGTYPE_p_spine__SkeletonData"); 
    result = (spine::SkeletonRenderer *)new spine::SkeletonRenderer(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_spine_SkeletonRenderer__SWIG_7(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    std::string *arg1 = 0 ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp1 ;
    std::string temp2 ;
    spine::SkeletonRenderer *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_SkeletonRenderer,1,SWIGTYPE_p_std__string");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_SkeletonRenderer,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "new_SkeletonRenderer,3,SWIGTYPE_float"); 
    result = (spine::SkeletonRenderer *)new spine::SkeletonRenderer((std::string const &)*arg1,(std::string const &)*arg2,arg3);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_spine_SkeletonRenderer__SWIG_8(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    std::string *arg1 = 0 ;
    std::string *arg2 = 0 ;
    std::string temp1 ;
    std::string temp2 ;
    spine::SkeletonRenderer *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_SkeletonRenderer,1,SWIGTYPE_p_std__string");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_SkeletonRenderer,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (spine::SkeletonRenderer *)new spine::SkeletonRenderer((std::string const &)*arg1,(std::string const &)*arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_SkeletonRenderer(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_ctor_dispatcher
    size_t argc = s.args().size();
    bool ret = false;
    
    // switch all cases by means of series of if-returns.
    
    // js_ctor_dispatch_case
    if(argc == 0) {
        ret = js_new_spine_SkeletonRenderer__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 4) {
        ret = js_new_spine_SkeletonRenderer__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 3) {
        ret = js_new_spine_SkeletonRenderer__SWIG_2(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 2) {
        ret = js_new_spine_SkeletonRenderer__SWIG_3(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_spine_SkeletonRenderer__SWIG_4(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 2) {
        ret = js_new_spine_SkeletonRenderer__SWIG_5(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_spine_SkeletonRenderer__SWIG_6(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 3) {
        ret = js_new_spine_SkeletonRenderer__SWIG_7(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 2) {
        ret = js_new_spine_SkeletonRenderer__SWIG_8(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    
    // default:
    SE_REPORT_ERROR("Illegal arguments for construction of SkeletonRenderer");
    return false;
}
SE_BIND_CTOR(js_new_SkeletonRenderer, __jsb_spine_SkeletonRenderer_class, js_delete_spine_SkeletonRenderer)

static bool js_delete_spine_SkeletonRenderer(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_SkeletonRenderer) 

static bool js_spine_SkeletonRenderer_initWithUUID(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_initWithUUID,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    (arg1)->initWithUUID((std::string const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_initWithUUID) 

static bool js_spine_SkeletonRenderer_initWithSkeleton__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    spine::Skeleton *arg2 = (spine::Skeleton *) NULL ;
    bool arg3 ;
    bool arg4 ;
    bool arg5 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_initWithSkeleton,2,SWIGTYPE_p_spine__Skeleton"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_initWithSkeleton,3,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_initWithSkeleton,4,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_initWithSkeleton,5,SWIGTYPE_bool"); 
    (arg1)->initWithSkeleton(arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_spine_SkeletonRenderer_initWithSkeleton__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    spine::Skeleton *arg2 = (spine::Skeleton *) NULL ;
    bool arg3 ;
    bool arg4 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_initWithSkeleton,2,SWIGTYPE_p_spine__Skeleton"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_initWithSkeleton,3,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_initWithSkeleton,4,SWIGTYPE_bool"); 
    (arg1)->initWithSkeleton(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_spine_SkeletonRenderer_initWithSkeleton__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    spine::Skeleton *arg2 = (spine::Skeleton *) NULL ;
    bool arg3 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_initWithSkeleton,2,SWIGTYPE_p_spine__Skeleton"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_initWithSkeleton,3,SWIGTYPE_bool"); 
    (arg1)->initWithSkeleton(arg2,arg3);
    
    
    return true;
}

static bool js_spine_SkeletonRenderer_initWithSkeleton__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    spine::Skeleton *arg2 = (spine::Skeleton *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonRenderer_initWithSkeleton,2,SWIGTYPE_p_spine__Skeleton"); 
    (arg1)->initWithSkeleton(arg2);
    
    
    return true;
}

static bool js_spine_SkeletonRenderer_initWithSkeleton(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 4) {
        ok = js_spine_SkeletonRenderer_initWithSkeleton__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_spine_SkeletonRenderer_initWithSkeleton__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_spine_SkeletonRenderer_initWithSkeleton__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_spine_SkeletonRenderer_initWithSkeleton__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_initWithSkeleton) 

static bool js_spine_SkeletonRenderer_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonRenderer *arg1 = (spine::SkeletonRenderer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->initialize();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonRenderer_initialize) 

bool js_register_spine_SkeletonRenderer(se::Object* obj) {
    auto* cls = se::Class::create("SkeletonRenderer", obj, nullptr, _SE(js_new_SkeletonRenderer)); 
    
    
    cls->defineFunction("update", _SE(js_spine_SkeletonRenderer_update)); 
    cls->defineFunction("render", _SE(js_spine_SkeletonRenderer_render)); 
    cls->defineFunction("getBoundingBox", _SE(js_spine_SkeletonRenderer_getBoundingBox)); 
    cls->defineFunction("getSkeleton", _SE(js_spine_SkeletonRenderer_getSkeleton)); 
    cls->defineFunction("setTimeScale", _SE(js_spine_SkeletonRenderer_setTimeScale)); 
    cls->defineFunction("getTimeScale", _SE(js_spine_SkeletonRenderer_getTimeScale)); 
    cls->defineFunction("updateWorldTransform", _SE(js_spine_SkeletonRenderer_updateWorldTransform)); 
    cls->defineFunction("setToSetupPose", _SE(js_spine_SkeletonRenderer_setToSetupPose)); 
    cls->defineFunction("setBonesToSetupPose", _SE(js_spine_SkeletonRenderer_setBonesToSetupPose)); 
    cls->defineFunction("setSlotsToSetupPose", _SE(js_spine_SkeletonRenderer_setSlotsToSetupPose)); 
    cls->defineFunction("paused", _SE(js_spine_SkeletonRenderer_paused)); 
    cls->defineFunction("findBone", _SE(js_spine_SkeletonRenderer_findBone)); 
    cls->defineFunction("findSlot", _SE(js_spine_SkeletonRenderer_findSlot)); 
    cls->defineFunction("setSkin", _SE(js_spine_SkeletonRenderer_setSkin)); 
    cls->defineFunction("getAttachment", _SE(js_spine_SkeletonRenderer_getAttachment)); 
    cls->defineFunction("setAttachment", _SE(js_spine_SkeletonRenderer_setAttachment)); 
    cls->defineFunction("setUseTint", _SE(js_spine_SkeletonRenderer_setUseTint)); 
    cls->defineFunction("setVertexEffectDelegate", _SE(js_spine_SkeletonRenderer_setVertexEffectDelegate)); 
    cls->defineFunction("setSlotsRange", _SE(js_spine_SkeletonRenderer_setSlotsRange)); 
    cls->defineFunction("getDebugData", _SE(js_spine_SkeletonRenderer_getDebugData)); 
    cls->defineFunction("getSharedBufferOffset", _SE(js_spine_SkeletonRenderer_getSharedBufferOffset)); 
    cls->defineFunction("getParamsBuffer", _SE(js_spine_SkeletonRenderer_getParamsBuffer)); 
    cls->defineFunction("setColor", _SE(js_spine_SkeletonRenderer_setColor)); 
    cls->defineFunction("setBatchEnabled", _SE(js_spine_SkeletonRenderer_setBatchEnabled)); 
    cls->defineFunction("setDebugBonesEnabled", _SE(js_spine_SkeletonRenderer_setDebugBonesEnabled)); 
    cls->defineFunction("setDebugSlotsEnabled", _SE(js_spine_SkeletonRenderer_setDebugSlotsEnabled)); 
    cls->defineFunction("setDebugMeshEnabled", _SE(js_spine_SkeletonRenderer_setDebugMeshEnabled)); 
    cls->defineFunction("setAttachEnabled", _SE(js_spine_SkeletonRenderer_setAttachEnabled)); 
    cls->defineFunction("setOpacityModifyRGB", _SE(js_spine_SkeletonRenderer_setOpacityModifyRGB)); 
    cls->defineFunction("isOpacityModifyRGB", _SE(js_spine_SkeletonRenderer_isOpacityModifyRGB)); 
    cls->defineFunction("beginSchedule", _SE(js_spine_SkeletonRenderer_beginSchedule)); 
    cls->defineFunction("stopSchedule", _SE(js_spine_SkeletonRenderer_stopSchedule)); 
    cls->defineFunction("onEnable", _SE(js_spine_SkeletonRenderer_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_spine_SkeletonRenderer_onDisable)); 
    cls->defineFunction("initWithUUID", _SE(js_spine_SkeletonRenderer_initWithUUID)); 
    cls->defineFunction("initWithSkeleton", _SE(js_spine_SkeletonRenderer_initWithSkeleton)); 
    cls->defineFunction("initialize", _SE(js_spine_SkeletonRenderer_initialize)); 
    
    
    cls->defineStaticFunction("create", _SE(js_spine_SkeletonRenderer_create_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_SkeletonRenderer));
    
    
    cls->install();
    JSBClassType::registerClass<spine::SkeletonRenderer>(cls);
    
    __jsb_spine_SkeletonRenderer_proto = cls->getProto();
    __jsb_spine_SkeletonRenderer_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_SkeletonAnimation_class = nullptr;
se::Object* __jsb_spine_SkeletonAnimation_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_SkeletonAnimation) 

static bool js_spine_SkeletonAnimation_createWithJsonFile_static__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    std::string *arg1 = 0 ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp1 ;
    std::string temp2 ;
    spine::SkeletonAnimation *result = 0 ;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_createWithJsonFile,1,SWIGTYPE_p_std__string");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_createWithJsonFile,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_createWithJsonFile,3,SWIGTYPE_float"); 
    result = (spine::SkeletonAnimation *)spine::SkeletonAnimation::createWithJsonFile((std::string const &)*arg1,(std::string const &)*arg2,arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_createWithJsonFile, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonAnimation_createWithJsonFile_static__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    std::string *arg1 = 0 ;
    std::string *arg2 = 0 ;
    std::string temp1 ;
    std::string temp2 ;
    spine::SkeletonAnimation *result = 0 ;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_createWithJsonFile,1,SWIGTYPE_p_std__string");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_createWithJsonFile,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (spine::SkeletonAnimation *)spine::SkeletonAnimation::createWithJsonFile((std::string const &)*arg1,(std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_createWithJsonFile, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonAnimation_createWithJsonFile_static(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_spine_SkeletonAnimation_createWithJsonFile_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_spine_SkeletonAnimation_createWithJsonFile_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_createWithJsonFile_static) 

static bool js_spine_SkeletonAnimation_createWithBinaryFile_static__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    std::string *arg1 = 0 ;
    std::string *arg2 = 0 ;
    float arg3 ;
    std::string temp1 ;
    std::string temp2 ;
    spine::SkeletonAnimation *result = 0 ;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_createWithBinaryFile,1,SWIGTYPE_p_std__string");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_createWithBinaryFile,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_createWithBinaryFile,3,SWIGTYPE_float"); 
    result = (spine::SkeletonAnimation *)spine::SkeletonAnimation::createWithBinaryFile((std::string const &)*arg1,(std::string const &)*arg2,arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_createWithBinaryFile, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonAnimation_createWithBinaryFile_static__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    std::string *arg1 = 0 ;
    std::string *arg2 = 0 ;
    std::string temp1 ;
    std::string temp2 ;
    spine::SkeletonAnimation *result = 0 ;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_createWithBinaryFile,1,SWIGTYPE_p_std__string");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_createWithBinaryFile,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (spine::SkeletonAnimation *)spine::SkeletonAnimation::createWithBinaryFile((std::string const &)*arg1,(std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_createWithBinaryFile, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonAnimation_createWithBinaryFile_static(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_spine_SkeletonAnimation_createWithBinaryFile_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_spine_SkeletonAnimation_createWithBinaryFile_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_createWithBinaryFile_static) 

static bool js_spine_SkeletonAnimation_setGlobalTimeScale_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float arg1 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setGlobalTimeScale,1,SWIGTYPE_float"); 
    spine::SkeletonAnimation::setGlobalTimeScale(arg1);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setGlobalTimeScale_static) 

static bool js_spine_SkeletonAnimation_update(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_update,2,SWIGTYPE_float"); 
    (arg1)->update(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_update) 

static bool js_spine_SkeletonAnimation_setAnimationStateData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::AnimationStateData *arg2 = (spine::AnimationStateData *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setAnimationStateData,2,SWIGTYPE_p_spine__AnimationStateData"); 
    (arg1)->setAnimationStateData(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setAnimationStateData) 

static bool js_spine_SkeletonAnimation_setMix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    float arg4 ;
    std::string temp2 ;
    std::string temp3 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setMix,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setMix,3,SWIGTYPE_p_std__string");
    arg3 = &temp3;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setMix,4,SWIGTYPE_float"); 
    (arg1)->setMix((std::string const &)*arg2,(std::string const &)*arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setMix) 

static bool js_spine_SkeletonAnimation_setAnimation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    int arg2 ;
    std::string *arg3 = 0 ;
    bool arg4 ;
    std::string temp3 ;
    spine::TrackEntry *result = 0 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setAnimation,2,SWIGTYPE_int"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setAnimation,3,SWIGTYPE_p_std__string");
    arg3 = &temp3;
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setAnimation,4,SWIGTYPE_bool"); 
    result = (spine::TrackEntry *)(arg1)->setAnimation(arg2,(std::string const &)*arg3,arg4);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setAnimation, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setAnimation) 

static bool js_spine_SkeletonAnimation_addAnimation__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    int arg2 ;
    std::string *arg3 = 0 ;
    bool arg4 ;
    float arg5 ;
    std::string temp3 ;
    spine::TrackEntry *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_addAnimation,2,SWIGTYPE_int"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_addAnimation,3,SWIGTYPE_p_std__string");
    arg3 = &temp3;
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_addAnimation,4,SWIGTYPE_bool"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_addAnimation,5,SWIGTYPE_float"); 
    result = (spine::TrackEntry *)(arg1)->addAnimation(arg2,(std::string const &)*arg3,arg4,arg5);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_addAnimation, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonAnimation_addAnimation__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    int arg2 ;
    std::string *arg3 = 0 ;
    bool arg4 ;
    std::string temp3 ;
    spine::TrackEntry *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_addAnimation,2,SWIGTYPE_int"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_addAnimation,3,SWIGTYPE_p_std__string");
    arg3 = &temp3;
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_addAnimation,4,SWIGTYPE_bool"); 
    result = (spine::TrackEntry *)(arg1)->addAnimation(arg2,(std::string const &)*arg3,arg4);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_addAnimation, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonAnimation_addAnimation(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 4) {
        ok = js_spine_SkeletonAnimation_addAnimation__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_spine_SkeletonAnimation_addAnimation__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_addAnimation) 

static bool js_spine_SkeletonAnimation_setEmptyAnimation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    int arg2 ;
    float arg3 ;
    spine::TrackEntry *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setEmptyAnimation,2,SWIGTYPE_int"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setEmptyAnimation,3,SWIGTYPE_float"); 
    result = (spine::TrackEntry *)(arg1)->setEmptyAnimation(arg2,arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setEmptyAnimation, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setEmptyAnimation) 

static bool js_spine_SkeletonAnimation_setEmptyAnimations(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setEmptyAnimations,2,SWIGTYPE_float"); 
    (arg1)->setEmptyAnimations(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setEmptyAnimations) 

static bool js_spine_SkeletonAnimation_addEmptyAnimation__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    int arg2 ;
    float arg3 ;
    float arg4 ;
    spine::TrackEntry *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_addEmptyAnimation,2,SWIGTYPE_int"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_addEmptyAnimation,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_addEmptyAnimation,4,SWIGTYPE_float"); 
    result = (spine::TrackEntry *)(arg1)->addEmptyAnimation(arg2,arg3,arg4);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_addEmptyAnimation, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonAnimation_addEmptyAnimation__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    int arg2 ;
    float arg3 ;
    spine::TrackEntry *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_addEmptyAnimation,2,SWIGTYPE_int"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_addEmptyAnimation,3,SWIGTYPE_float"); 
    result = (spine::TrackEntry *)(arg1)->addEmptyAnimation(arg2,arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_addEmptyAnimation, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonAnimation_addEmptyAnimation(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_spine_SkeletonAnimation_addEmptyAnimation__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_spine_SkeletonAnimation_addEmptyAnimation__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_addEmptyAnimation) 

static bool js_spine_SkeletonAnimation_findAnimation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    spine::Animation *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_findAnimation,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (spine::Animation *)((spine::SkeletonAnimation const *)arg1)->findAnimation((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_findAnimation, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_findAnimation) 

static bool js_spine_SkeletonAnimation_getCurrent__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    int arg2 ;
    spine::TrackEntry *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_getCurrent,2,SWIGTYPE_int"); 
    result = (spine::TrackEntry *)(arg1)->getCurrent(arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_getCurrent, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonAnimation_getCurrent__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::TrackEntry *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::TrackEntry *)(arg1)->getCurrent();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_getCurrent, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_spine_SkeletonAnimation_getCurrent(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_spine_SkeletonAnimation_getCurrent__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 0) {
        ok = js_spine_SkeletonAnimation_getCurrent__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_getCurrent) 

static bool js_spine_SkeletonAnimation_clearTracks(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->clearTracks();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_clearTracks) 

static bool js_spine_SkeletonAnimation_clearTrack__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    int arg2 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_clearTrack,2,SWIGTYPE_int"); 
    (arg1)->clearTrack(arg2);
    
    
    return true;
}

static bool js_spine_SkeletonAnimation_clearTrack__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->clearTrack();
    
    
    return true;
}

static bool js_spine_SkeletonAnimation_clearTrack(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_spine_SkeletonAnimation_clearTrack__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 0) {
        ok = js_spine_SkeletonAnimation_clearTrack__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_clearTrack) 

static bool js_spine_SkeletonAnimation_setStartListener(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::StartListener *arg2 = 0 ;
    spine::StartListener temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setStartListener,2,SWIGTYPE_p_std__functionT_void_fspine__TrackEntry_pF_t");
    arg2 = &temp2;
    
    (arg1)->setStartListener((spine::StartListener const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setStartListener) 

static bool js_spine_SkeletonAnimation_setInterruptListener(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::InterruptListener *arg2 = 0 ;
    spine::InterruptListener temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setInterruptListener,2,SWIGTYPE_p_std__functionT_void_fspine__TrackEntry_pF_t");
    arg2 = &temp2;
    
    (arg1)->setInterruptListener((spine::InterruptListener const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setInterruptListener) 

static bool js_spine_SkeletonAnimation_setEndListener(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::EndListener *arg2 = 0 ;
    spine::EndListener temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setEndListener,2,SWIGTYPE_p_std__functionT_void_fspine__TrackEntry_pF_t");
    arg2 = &temp2;
    
    (arg1)->setEndListener((spine::EndListener const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setEndListener) 

static bool js_spine_SkeletonAnimation_setDisposeListener(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::DisposeListener *arg2 = 0 ;
    spine::DisposeListener temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setDisposeListener,2,SWIGTYPE_p_std__functionT_void_fspine__TrackEntry_pF_t");
    arg2 = &temp2;
    
    (arg1)->setDisposeListener((spine::DisposeListener const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setDisposeListener) 

static bool js_spine_SkeletonAnimation_setCompleteListenerNative(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::CompleteListener *arg2 = 0 ;
    spine::CompleteListener temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setCompleteListenerNative,2,SWIGTYPE_p_std__functionT_void_fspine__TrackEntry_pF_t");
    arg2 = &temp2;
    
    (arg1)->setCompleteListener((spine::CompleteListener const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setCompleteListenerNative) 

static bool js_spine_SkeletonAnimation_setEventListener(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::EventListener *arg2 = 0 ;
    spine::EventListener temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setEventListener,2,SWIGTYPE_p_std__functionT_void_fspine__TrackEntry_p_spine__Event_pF_t");
    arg2 = &temp2;
    
    (arg1)->setEventListener((spine::EventListener const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setEventListener) 

static bool js_spine_SkeletonAnimation_setTrackStartListener(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::TrackEntry *arg2 = (spine::TrackEntry *) NULL ;
    spine::StartListener *arg3 = 0 ;
    spine::StartListener temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setTrackStartListener,2,SWIGTYPE_p_spine__TrackEntry"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setTrackStartListener,3,SWIGTYPE_p_std__functionT_void_fspine__TrackEntry_pF_t");
    arg3 = &temp3;
    
    (arg1)->setTrackStartListener(arg2,(spine::StartListener const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setTrackStartListener) 

static bool js_spine_SkeletonAnimation_setTrackInterruptListener(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::TrackEntry *arg2 = (spine::TrackEntry *) NULL ;
    spine::InterruptListener *arg3 = 0 ;
    spine::InterruptListener temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setTrackInterruptListener,2,SWIGTYPE_p_spine__TrackEntry"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setTrackInterruptListener,3,SWIGTYPE_p_std__functionT_void_fspine__TrackEntry_pF_t");
    arg3 = &temp3;
    
    (arg1)->setTrackInterruptListener(arg2,(spine::InterruptListener const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setTrackInterruptListener) 

static bool js_spine_SkeletonAnimation_setTrackEndListener(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::TrackEntry *arg2 = (spine::TrackEntry *) NULL ;
    spine::EndListener *arg3 = 0 ;
    spine::EndListener temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setTrackEndListener,2,SWIGTYPE_p_spine__TrackEntry"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setTrackEndListener,3,SWIGTYPE_p_std__functionT_void_fspine__TrackEntry_pF_t");
    arg3 = &temp3;
    
    (arg1)->setTrackEndListener(arg2,(spine::EndListener const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setTrackEndListener) 

static bool js_spine_SkeletonAnimation_setTrackDisposeListener(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::TrackEntry *arg2 = (spine::TrackEntry *) NULL ;
    spine::DisposeListener *arg3 = 0 ;
    spine::DisposeListener temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setTrackDisposeListener,2,SWIGTYPE_p_spine__TrackEntry"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setTrackDisposeListener,3,SWIGTYPE_p_std__functionT_void_fspine__TrackEntry_pF_t");
    arg3 = &temp3;
    
    (arg1)->setTrackDisposeListener(arg2,(spine::DisposeListener const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setTrackDisposeListener) 

static bool js_spine_SkeletonAnimation_setTrackCompleteListenerNative(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::TrackEntry *arg2 = (spine::TrackEntry *) NULL ;
    spine::CompleteListener *arg3 = 0 ;
    spine::CompleteListener temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setTrackCompleteListenerNative,2,SWIGTYPE_p_spine__TrackEntry"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setTrackCompleteListenerNative,3,SWIGTYPE_p_std__functionT_void_fspine__TrackEntry_pF_t");
    arg3 = &temp3;
    
    (arg1)->setTrackCompleteListener(arg2,(spine::CompleteListener const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setTrackCompleteListenerNative) 

static bool js_spine_SkeletonAnimation_setTrackEventListener(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::TrackEntry *arg2 = (spine::TrackEntry *) NULL ;
    spine::EventListener *arg3 = 0 ;
    spine::EventListener temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setTrackEventListener,2,SWIGTYPE_p_spine__TrackEntry"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_setTrackEventListener,3,SWIGTYPE_p_std__functionT_void_fspine__TrackEntry_p_spine__Event_pF_t");
    arg3 = &temp3;
    
    (arg1)->setTrackEventListener(arg2,(spine::EventListener const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_setTrackEventListener) 

static bool js_spine_SkeletonAnimation_getState(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonAnimation *arg1 = (spine::SkeletonAnimation *) NULL ;
    spine::AnimationState *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::AnimationState *)((spine::SkeletonAnimation const *)arg1)->getState();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_getState, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonAnimation_getState) 

// js_ctor
static bool js_new_spine_SkeletonAnimation(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    spine::SkeletonAnimation *result;
    result = (spine::SkeletonAnimation *)new spine::SkeletonAnimation();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_spine_SkeletonAnimation, __jsb_spine_SkeletonAnimation_class, js_delete_spine_SkeletonAnimation)

static bool js_delete_spine_SkeletonAnimation(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_SkeletonAnimation) 

static bool js_spine_SkeletonAnimation_GlobalTimeScale_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float arg1 ;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonAnimation_GlobalTimeScale_set,1,SWIGTYPE_float"); 
    spine::SkeletonAnimation::GlobalTimeScale = arg1;
    
    
    return true;
}
SE_BIND_PROP_SET(js_spine_SkeletonAnimation_GlobalTimeScale_set) 

static bool js_spine_SkeletonAnimation_GlobalTimeScale_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    float result;
    
    result = (float)spine::SkeletonAnimation::GlobalTimeScale;
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_spine_SkeletonAnimation_GlobalTimeScale_get) 

bool js_register_spine_SkeletonAnimation(se::Object* obj) {
    auto* cls = se::Class::create("SkeletonAnimation", obj, __jsb_spine_SkeletonRenderer_proto, _SE(js_new_spine_SkeletonAnimation)); 
    
    
    cls->defineFunction("update", _SE(js_spine_SkeletonAnimation_update)); 
    cls->defineFunction("setAnimationStateData", _SE(js_spine_SkeletonAnimation_setAnimationStateData)); 
    cls->defineFunction("setMix", _SE(js_spine_SkeletonAnimation_setMix)); 
    cls->defineFunction("setAnimation", _SE(js_spine_SkeletonAnimation_setAnimation)); 
    cls->defineFunction("addAnimation", _SE(js_spine_SkeletonAnimation_addAnimation)); 
    cls->defineFunction("setEmptyAnimation", _SE(js_spine_SkeletonAnimation_setEmptyAnimation)); 
    cls->defineFunction("setEmptyAnimations", _SE(js_spine_SkeletonAnimation_setEmptyAnimations)); 
    cls->defineFunction("addEmptyAnimation", _SE(js_spine_SkeletonAnimation_addEmptyAnimation)); 
    cls->defineFunction("findAnimation", _SE(js_spine_SkeletonAnimation_findAnimation)); 
    cls->defineFunction("getCurrent", _SE(js_spine_SkeletonAnimation_getCurrent)); 
    cls->defineFunction("clearTracks", _SE(js_spine_SkeletonAnimation_clearTracks)); 
    cls->defineFunction("clearTrack", _SE(js_spine_SkeletonAnimation_clearTrack)); 
    cls->defineFunction("setStartListener", _SE(js_spine_SkeletonAnimation_setStartListener)); 
    cls->defineFunction("setInterruptListener", _SE(js_spine_SkeletonAnimation_setInterruptListener)); 
    cls->defineFunction("setEndListener", _SE(js_spine_SkeletonAnimation_setEndListener)); 
    cls->defineFunction("setDisposeListener", _SE(js_spine_SkeletonAnimation_setDisposeListener)); 
    cls->defineFunction("setCompleteListenerNative", _SE(js_spine_SkeletonAnimation_setCompleteListenerNative)); 
    cls->defineFunction("setEventListener", _SE(js_spine_SkeletonAnimation_setEventListener)); 
    cls->defineFunction("setTrackStartListener", _SE(js_spine_SkeletonAnimation_setTrackStartListener)); 
    cls->defineFunction("setTrackInterruptListener", _SE(js_spine_SkeletonAnimation_setTrackInterruptListener)); 
    cls->defineFunction("setTrackEndListener", _SE(js_spine_SkeletonAnimation_setTrackEndListener)); 
    cls->defineFunction("setTrackDisposeListener", _SE(js_spine_SkeletonAnimation_setTrackDisposeListener)); 
    cls->defineFunction("setTrackCompleteListenerNative", _SE(js_spine_SkeletonAnimation_setTrackCompleteListenerNative)); 
    cls->defineFunction("setTrackEventListener", _SE(js_spine_SkeletonAnimation_setTrackEventListener)); 
    cls->defineFunction("getState", _SE(js_spine_SkeletonAnimation_getState)); 
    
    cls->defineStaticProperty("GlobalTimeScale", _SE(js_spine_SkeletonAnimation_GlobalTimeScale_get), _SE(js_spine_SkeletonAnimation_GlobalTimeScale_set)); 
    
    cls->defineStaticFunction("createWithJsonFile", _SE(js_spine_SkeletonAnimation_createWithJsonFile_static)); 
    cls->defineStaticFunction("createWithBinaryFile", _SE(js_spine_SkeletonAnimation_createWithBinaryFile_static)); 
    cls->defineStaticFunction("setGlobalTimeScale", _SE(js_spine_SkeletonAnimation_setGlobalTimeScale_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_SkeletonAnimation));
    
    
    cls->install();
    JSBClassType::registerClass<spine::SkeletonAnimation>(cls);
    
    __jsb_spine_SkeletonAnimation_proto = cls->getProto();
    __jsb_spine_SkeletonAnimation_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_SkeletonDataMgr_class = nullptr;
se::Object* __jsb_spine_SkeletonDataMgr_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_SkeletonDataMgr) 

static bool js_spine_SkeletonDataMgr_getInstance_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonDataMgr *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (spine::SkeletonDataMgr *)spine::SkeletonDataMgr::getInstance();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonDataMgr_getInstance, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonDataMgr_getInstance_static) 

// js_ctor
static bool js_new_spine_SkeletonDataMgr(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    spine::SkeletonDataMgr *result;
    result = (spine::SkeletonDataMgr *)new spine::SkeletonDataMgr();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_spine_SkeletonDataMgr, __jsb_spine_SkeletonDataMgr_class, js_delete_spine_SkeletonDataMgr)

static bool js_delete_spine_SkeletonDataMgr(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_SkeletonDataMgr) 

static bool js_spine_SkeletonDataMgr_setDestroyCallback(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonDataMgr *arg1 = (spine::SkeletonDataMgr *) NULL ;
    spine::SkeletonDataMgr::destroyCallback arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonDataMgr>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonDataMgr_setDestroyCallback,2,SWIGTYPE_std__functionT_void_fintF_t"); 
    
    (arg1)->setDestroyCallback(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonDataMgr_setDestroyCallback) 

bool js_register_spine_SkeletonDataMgr(se::Object* obj) {
    auto* cls = se::Class::create("SkeletonDataMgr", obj, nullptr, _SE(js_new_spine_SkeletonDataMgr)); 
    
    
    cls->defineFunction("setDestroyCallback", _SE(js_spine_SkeletonDataMgr_setDestroyCallback)); 
    
    
    cls->defineStaticFunction("getInstance", _SE(js_spine_SkeletonDataMgr_getInstance_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_SkeletonDataMgr));
    
    
    cls->install();
    JSBClassType::registerClass<spine::SkeletonDataMgr>(cls);
    
    __jsb_spine_SkeletonDataMgr_proto = cls->getProto();
    __jsb_spine_SkeletonDataMgr_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_SkeletonCacheAnimation_class = nullptr;
se::Object* __jsb_spine_SkeletonCacheAnimation_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_SkeletonCacheAnimation) 

// js_ctor
static bool js_new_spine_SkeletonCacheAnimation(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 2) {
        SE_REPORT_ERROR("js_new_spine_SkeletonCacheAnimation: wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    
    std::string *arg1 = 0 ;
    bool arg2 ;
    std::string temp1 ;
    spine::SkeletonCacheAnimation *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_SkeletonCacheAnimation,1,SWIGTYPE_p_std__string");
    arg1 = &temp1;
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[1], &arg2);
    SE_PRECONDITION2(ok, false, "new_SkeletonCacheAnimation,2,SWIGTYPE_bool"); 
    result = (spine::SkeletonCacheAnimation *)new spine::SkeletonCacheAnimation((std::string const &)*arg1,arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_spine_SkeletonCacheAnimation, __jsb_spine_SkeletonCacheAnimation_class, js_delete_spine_SkeletonCacheAnimation)

static bool js_delete_spine_SkeletonCacheAnimation(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_SkeletonCacheAnimation) 

static bool js_spine_SkeletonCacheAnimation_update(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_update,2,SWIGTYPE_float"); 
    (arg1)->update(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_update) 

static bool js_spine_SkeletonCacheAnimation_getSkeleton(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    spine::Skeleton *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (spine::Skeleton *)((spine::SkeletonCacheAnimation const *)arg1)->getSkeleton();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_getSkeleton, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_getSkeleton) 

static bool js_spine_SkeletonCacheAnimation_setTimeScale(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_setTimeScale,2,SWIGTYPE_float"); 
    (arg1)->setTimeScale(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setTimeScale) 

static bool js_spine_SkeletonCacheAnimation_getTimeScale(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)((spine::SkeletonCacheAnimation const *)arg1)->getTimeScale();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_getTimeScale) 

static bool js_spine_SkeletonCacheAnimation_paused(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_paused,2,SWIGTYPE_bool"); 
    (arg1)->paused(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_paused) 

static bool js_spine_SkeletonCacheAnimation_findBone(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    spine::Bone *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_findBone,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (spine::Bone *)((spine::SkeletonCacheAnimation const *)arg1)->findBone((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_findBone, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_findBone) 

static bool js_spine_SkeletonCacheAnimation_findSlot(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    spine::Slot *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_findSlot,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (spine::Slot *)((spine::SkeletonCacheAnimation const *)arg1)->findSlot((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_findSlot, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_findSlot) 

static bool js_spine_SkeletonCacheAnimation_setSkin__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_setSkin,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    (arg1)->setSkin((std::string const &)*arg2);
    
    
    return true;
}

static bool js_spine_SkeletonCacheAnimation_setSkin__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    char *arg2 = (char *) NULL ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_setSkin,2,SWIGTYPE_p_char");
    arg2 = (char *) temp2.c_str(); 
    (arg1)->setSkin((char const *)arg2);
    
    
    return true;
}

static bool js_spine_SkeletonCacheAnimation_setSkin(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_spine_SkeletonCacheAnimation_setSkin__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_spine_SkeletonCacheAnimation_setSkin__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setSkin) 

static bool js_spine_SkeletonCacheAnimation_getAttachment(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    spine::Attachment *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_getAttachment,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_getAttachment,3,SWIGTYPE_p_std__string");
    arg3 = &temp3;
    
    result = (spine::Attachment *)((spine::SkeletonCacheAnimation const *)arg1)->getAttachment((std::string const &)*arg2,(std::string const &)*arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_getAttachment, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_getAttachment) 

static bool js_spine_SkeletonCacheAnimation_setAttachment__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string temp2 ;
    std::string temp3 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_setAttachment,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_setAttachment,3,SWIGTYPE_p_std__string");
    arg3 = &temp3;
    
    result = (bool)(arg1)->setAttachment((std::string const &)*arg2,(std::string const &)*arg3);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_spine_SkeletonCacheAnimation_setAttachment__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    std::string *arg2 = 0 ;
    char *arg3 = (char *) NULL ;
    std::string temp2 ;
    ccstd::string temp3 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_setAttachment,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3);
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_setAttachment,3,SWIGTYPE_p_char");
    arg3 = (char *) temp3.c_str(); 
    result = (bool)(arg1)->setAttachment((std::string const &)*arg2,(char const *)arg3);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_spine_SkeletonCacheAnimation_setAttachment(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_spine_SkeletonCacheAnimation_setAttachment__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_spine_SkeletonCacheAnimation_setAttachment__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setAttachment) 

static bool js_spine_SkeletonCacheAnimation_setColor(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_setColor,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_setColor,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_setColor,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_setColor,5,SWIGTYPE_float"); 
    (arg1)->setColor(arg2,arg3,arg4,arg5);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setColor) 

static bool js_spine_SkeletonCacheAnimation_setBatchEnabled(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_setBatchEnabled,2,SWIGTYPE_bool"); 
    (arg1)->setBatchEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setBatchEnabled) 

static bool js_spine_SkeletonCacheAnimation_setAttachEnabled(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_setAttachEnabled,2,SWIGTYPE_bool"); 
    (arg1)->setAttachEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setAttachEnabled) 

static bool js_spine_SkeletonCacheAnimation_setOpacityModifyRGB(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_setOpacityModifyRGB,2,SWIGTYPE_bool"); 
    (arg1)->setOpacityModifyRGB(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setOpacityModifyRGB) 

static bool js_spine_SkeletonCacheAnimation_isOpacityModifyRGB(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((spine::SkeletonCacheAnimation const *)arg1)->isOpacityModifyRGB();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_isOpacityModifyRGB) 

static bool js_spine_SkeletonCacheAnimation_beginSchedule(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->beginSchedule();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_beginSchedule) 

static bool js_spine_SkeletonCacheAnimation_stopSchedule(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->stopSchedule();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_stopSchedule) 

static bool js_spine_SkeletonCacheAnimation_onEnable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onEnable();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_onEnable) 

static bool js_spine_SkeletonCacheAnimation_onDisable(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onDisable();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_onDisable) 

static bool js_spine_SkeletonCacheAnimation_setUseTint(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_setUseTint,2,SWIGTYPE_bool"); 
    (arg1)->setUseTint(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setUseTint) 

static bool js_spine_SkeletonCacheAnimation_setAnimation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    std::string *arg2 = 0 ;
    bool arg3 ;
    std::string temp2 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_setAnimation,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_setAnimation,3,SWIGTYPE_bool"); 
    (arg1)->setAnimation((std::string const &)*arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setAnimation) 

static bool js_spine_SkeletonCacheAnimation_addAnimation__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    std::string *arg2 = 0 ;
    bool arg3 ;
    float arg4 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_addAnimation,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_addAnimation,3,SWIGTYPE_bool"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_addAnimation,4,SWIGTYPE_float"); 
    (arg1)->addAnimation((std::string const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_spine_SkeletonCacheAnimation_addAnimation__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    std::string *arg2 = 0 ;
    bool arg3 ;
    std::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_addAnimation,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_addAnimation,3,SWIGTYPE_bool"); 
    (arg1)->addAnimation((std::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_spine_SkeletonCacheAnimation_addAnimation(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_spine_SkeletonCacheAnimation_addAnimation__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_spine_SkeletonCacheAnimation_addAnimation__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_addAnimation) 

static bool js_spine_SkeletonCacheAnimation_findAnimation(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    spine::Animation *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_findAnimation,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (spine::Animation *)((spine::SkeletonCacheAnimation const *)arg1)->findAnimation((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_findAnimation, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_findAnimation) 

static bool js_spine_SkeletonCacheAnimation_setStartListener(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    spine::SkeletonCacheAnimation::CacheFrameEvent *arg2 = 0 ;
    spine::SkeletonCacheAnimation::CacheFrameEvent temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_setStartListener,2,SWIGTYPE_p_std__functionT_void_fstd__stringF_t");
    arg2 = &temp2;
    
    (arg1)->setStartListener((spine::SkeletonCacheAnimation::CacheFrameEvent const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setStartListener) 

static bool js_spine_SkeletonCacheAnimation_setEndListener(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    spine::SkeletonCacheAnimation::CacheFrameEvent *arg2 = 0 ;
    spine::SkeletonCacheAnimation::CacheFrameEvent temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_setEndListener,2,SWIGTYPE_p_std__functionT_void_fstd__stringF_t");
    arg2 = &temp2;
    
    (arg1)->setEndListener((spine::SkeletonCacheAnimation::CacheFrameEvent const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setEndListener) 

static bool js_spine_SkeletonCacheAnimation_setCompleteListener(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    spine::SkeletonCacheAnimation::CacheFrameEvent *arg2 = 0 ;
    spine::SkeletonCacheAnimation::CacheFrameEvent temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_setCompleteListener,2,SWIGTYPE_p_std__functionT_void_fstd__stringF_t");
    arg2 = &temp2;
    
    (arg1)->setCompleteListener((spine::SkeletonCacheAnimation::CacheFrameEvent const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setCompleteListener) 

static bool js_spine_SkeletonCacheAnimation_updateAnimationCache(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_updateAnimationCache,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    (arg1)->updateAnimationCache((std::string const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_updateAnimationCache) 

static bool js_spine_SkeletonCacheAnimation_updateAllAnimationCache(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->updateAllAnimationCache();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_updateAllAnimationCache) 

static bool js_spine_SkeletonCacheAnimation_setToSetupPose(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->setToSetupPose();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setToSetupPose) 

static bool js_spine_SkeletonCacheAnimation_setBonesToSetupPose(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->setBonesToSetupPose();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setBonesToSetupPose) 

static bool js_spine_SkeletonCacheAnimation_setSlotsToSetupPose(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->setSlotsToSetupPose();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_setSlotsToSetupPose) 

static bool js_spine_SkeletonCacheAnimation_getSharedBufferOffset(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    se_object_ptr result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((spine::SkeletonCacheAnimation const *)arg1)->getSharedBufferOffset();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_getSharedBufferOffset, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_getSharedBufferOffset) 

static bool js_spine_SkeletonCacheAnimation_getParamsBuffer(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheAnimation *arg1 = (spine::SkeletonCacheAnimation *) NULL ;
    se_object_ptr result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheAnimation>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((spine::SkeletonCacheAnimation const *)arg1)->getParamsBuffer();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonCacheAnimation_getParamsBuffer, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheAnimation_getParamsBuffer) 

bool js_register_spine_SkeletonCacheAnimation(se::Object* obj) {
    auto* cls = se::Class::create("SkeletonCacheAnimation", obj, nullptr, _SE(js_new_spine_SkeletonCacheAnimation)); 
    
    
    cls->defineFunction("update", _SE(js_spine_SkeletonCacheAnimation_update)); 
    cls->defineFunction("getSkeleton", _SE(js_spine_SkeletonCacheAnimation_getSkeleton)); 
    cls->defineFunction("setTimeScale", _SE(js_spine_SkeletonCacheAnimation_setTimeScale)); 
    cls->defineFunction("getTimeScale", _SE(js_spine_SkeletonCacheAnimation_getTimeScale)); 
    cls->defineFunction("paused", _SE(js_spine_SkeletonCacheAnimation_paused)); 
    cls->defineFunction("findBone", _SE(js_spine_SkeletonCacheAnimation_findBone)); 
    cls->defineFunction("findSlot", _SE(js_spine_SkeletonCacheAnimation_findSlot)); 
    cls->defineFunction("setSkin", _SE(js_spine_SkeletonCacheAnimation_setSkin)); 
    cls->defineFunction("getAttachment", _SE(js_spine_SkeletonCacheAnimation_getAttachment)); 
    cls->defineFunction("setAttachment", _SE(js_spine_SkeletonCacheAnimation_setAttachment)); 
    cls->defineFunction("setColor", _SE(js_spine_SkeletonCacheAnimation_setColor)); 
    cls->defineFunction("setBatchEnabled", _SE(js_spine_SkeletonCacheAnimation_setBatchEnabled)); 
    cls->defineFunction("setAttachEnabled", _SE(js_spine_SkeletonCacheAnimation_setAttachEnabled)); 
    cls->defineFunction("setOpacityModifyRGB", _SE(js_spine_SkeletonCacheAnimation_setOpacityModifyRGB)); 
    cls->defineFunction("isOpacityModifyRGB", _SE(js_spine_SkeletonCacheAnimation_isOpacityModifyRGB)); 
    cls->defineFunction("beginSchedule", _SE(js_spine_SkeletonCacheAnimation_beginSchedule)); 
    cls->defineFunction("stopSchedule", _SE(js_spine_SkeletonCacheAnimation_stopSchedule)); 
    cls->defineFunction("onEnable", _SE(js_spine_SkeletonCacheAnimation_onEnable)); 
    cls->defineFunction("onDisable", _SE(js_spine_SkeletonCacheAnimation_onDisable)); 
    cls->defineFunction("setUseTint", _SE(js_spine_SkeletonCacheAnimation_setUseTint)); 
    cls->defineFunction("setAnimation", _SE(js_spine_SkeletonCacheAnimation_setAnimation)); 
    cls->defineFunction("addAnimation", _SE(js_spine_SkeletonCacheAnimation_addAnimation)); 
    cls->defineFunction("findAnimation", _SE(js_spine_SkeletonCacheAnimation_findAnimation)); 
    cls->defineFunction("setStartListener", _SE(js_spine_SkeletonCacheAnimation_setStartListener)); 
    cls->defineFunction("setEndListener", _SE(js_spine_SkeletonCacheAnimation_setEndListener)); 
    cls->defineFunction("setCompleteListener", _SE(js_spine_SkeletonCacheAnimation_setCompleteListener)); 
    cls->defineFunction("updateAnimationCache", _SE(js_spine_SkeletonCacheAnimation_updateAnimationCache)); 
    cls->defineFunction("updateAllAnimationCache", _SE(js_spine_SkeletonCacheAnimation_updateAllAnimationCache)); 
    cls->defineFunction("setToSetupPose", _SE(js_spine_SkeletonCacheAnimation_setToSetupPose)); 
    cls->defineFunction("setBonesToSetupPose", _SE(js_spine_SkeletonCacheAnimation_setBonesToSetupPose)); 
    cls->defineFunction("setSlotsToSetupPose", _SE(js_spine_SkeletonCacheAnimation_setSlotsToSetupPose)); 
    cls->defineFunction("getSharedBufferOffset", _SE(js_spine_SkeletonCacheAnimation_getSharedBufferOffset)); 
    cls->defineFunction("getParamsBuffer", _SE(js_spine_SkeletonCacheAnimation_getParamsBuffer)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_SkeletonCacheAnimation));
    
    
    cls->install();
    JSBClassType::registerClass<spine::SkeletonCacheAnimation>(cls);
    
    __jsb_spine_SkeletonCacheAnimation_proto = cls->getProto();
    __jsb_spine_SkeletonCacheAnimation_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_spine_SkeletonCacheMgr_class = nullptr;
se::Object* __jsb_spine_SkeletonCacheMgr_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_spine_SkeletonCacheMgr) 

static bool js_spine_SkeletonCacheMgr_getInstance_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheMgr *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (spine::SkeletonCacheMgr *)spine::SkeletonCacheMgr::getInstance();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonCacheMgr_getInstance, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheMgr_getInstance_static) 

static bool js_spine_SkeletonCacheMgr_destroyInstance_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    spine::SkeletonCacheMgr::destroyInstance();
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheMgr_destroyInstance_static) 

static bool js_spine_SkeletonCacheMgr_removeSkeletonCache(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheMgr *arg1 = (spine::SkeletonCacheMgr *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheMgr>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonCacheMgr_removeSkeletonCache,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    (arg1)->removeSkeletonCache((std::string const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheMgr_removeSkeletonCache) 

static bool js_spine_SkeletonCacheMgr_buildSkeletonCache(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    spine::SkeletonCacheMgr *arg1 = (spine::SkeletonCacheMgr *) NULL ;
    std::string *arg2 = 0 ;
    std::string temp2 ;
    SkeletonCache *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<spine::SkeletonCacheMgr>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkeletonCacheMgr_buildSkeletonCache,2,SWIGTYPE_p_std__string");
    arg2 = &temp2;
    
    result = (SkeletonCache *)(arg1)->buildSkeletonCache((std::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkeletonCacheMgr_buildSkeletonCache, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_spine_SkeletonCacheMgr_buildSkeletonCache) 

// js_ctor
static bool js_new_spine_SkeletonCacheMgr(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    spine::SkeletonCacheMgr *result;
    result = (spine::SkeletonCacheMgr *)new spine::SkeletonCacheMgr();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_spine_SkeletonCacheMgr, __jsb_spine_SkeletonCacheMgr_class, js_delete_spine_SkeletonCacheMgr)

static bool js_delete_spine_SkeletonCacheMgr(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_spine_SkeletonCacheMgr) 

bool js_register_spine_SkeletonCacheMgr(se::Object* obj) {
    auto* cls = se::Class::create("SkeletonCacheMgr", obj, nullptr, _SE(js_new_spine_SkeletonCacheMgr)); 
    
    
    cls->defineFunction("removeSkeletonCache", _SE(js_spine_SkeletonCacheMgr_removeSkeletonCache)); 
    cls->defineFunction("buildSkeletonCache", _SE(js_spine_SkeletonCacheMgr_buildSkeletonCache)); 
    
    
    cls->defineStaticFunction("getInstance", _SE(js_spine_SkeletonCacheMgr_getInstance_static)); 
    cls->defineStaticFunction("destroyInstance", _SE(js_spine_SkeletonCacheMgr_destroyInstance_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_spine_SkeletonCacheMgr));
    
    
    cls->install();
    JSBClassType::registerClass<spine::SkeletonCacheMgr>(cls);
    
    __jsb_spine_SkeletonCacheMgr_proto = cls->getProto();
    __jsb_spine_SkeletonCacheMgr_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}




bool register_all_spine(se::Object* obj) {
    // Get the ns
    se::Value nsVal;
    if (!obj->getProperty("spine", &nsVal, true))
    {
        se::HandleObject jsobj(se::Object::createPlainObject());
        nsVal.setObject(jsobj);
        obj->setProperty("spine", nsVal);
    }
    se::Object* ns = nsVal.toObject();
    /* Register classes */
    js_register_spine_Timeline(ns); 
    js_register_spine_Animation(ns); 
    js_register_spine_AnimationStateListenerObject(ns); 
    js_register_spine_TrackEntry(ns); 
    js_register_spine_EventQueueEntry(ns); 
    js_register_spine_EventQueue(ns); 
    js_register_spine_AnimationState(ns); 
    js_register_spine_AnimationStateData(ns); 
    js_register_spine_Attachment(ns); 
    js_register_spine_AttachmentTimeline(ns); 
    js_register_spine_BoundingBoxAttachment(ns); 
    js_register_spine_Bone(ns); 
    js_register_spine_BoneData(ns); 
    js_register_spine_ClippingAttachment(ns); 
    js_register_spine_Color(ns); 
    js_register_spine_ColorTimeline(ns); 
    js_register_spine_CurveTimeline(ns); 
    js_register_spine_DeformTimeline(ns); 
    js_register_spine_DrawOrderTimeline(ns); 
    js_register_spine_Event(ns); 
    js_register_spine_EventData(ns); 
    js_register_spine_EventTimeline(ns); 
    js_register_spine_IkConstraint(ns); 
    js_register_spine_IkConstraintData(ns); 
    js_register_spine_IkConstraintTimeline(ns); 
    js_register_spine_MeshAttachment(ns); 
    js_register_spine_PathAttachment(ns); 
    js_register_spine_PathConstraint(ns); 
    js_register_spine_PathConstraintData(ns); 
    js_register_spine_PathConstraintMixTimeline(ns); 
    js_register_spine_PathConstraintPositionTimeline(ns); 
    js_register_spine_PathConstraintSpacingTimeline(ns); 
    js_register_spine_PointAttachment(ns); 
    js_register_spine_RegionAttachment(ns); 
    js_register_spine_RotateTimeline(ns); 
    js_register_spine_ScaleTimeline(ns); 
    js_register_spine_ShearTimeline(ns); 
    js_register_spine_Skeleton(ns); 
    js_register_spine_Slot(ns); 
    js_register_spine_Skin(ns); 
    js_register_spine_SkeletonBounds(ns); 
    js_register_spine_Polygon(ns); 
    js_register_spine_SkeletonData(ns); 
    js_register_spine_SlotData(ns); 
    js_register_spine_TransformConstraint(ns); 
    js_register_spine_TransformConstraintData(ns); 
    js_register_spine_TransformConstraintTimeline(ns); 
    js_register_spine_TranslateTimeline(ns); 
    js_register_spine_TwoColorTimeline(ns); 
    js_register_spine_VertexAttachment(ns); 
    js_register_spine_VertexEffect(ns); 
    js_register_spine_JitterVertexEffect(ns); 
    js_register_spine_SwirlVertexEffect(ns); 
    js_register_spine_ConstraintData(ns); 
    js_register_spine_VertexEffectDelegate(ns); 
    js_register_spine_SkeletonRenderer(ns); 
    js_register_spine_SkeletonAnimation(ns); 
    js_register_spine_SkeletonDataMgr(ns); 
    js_register_spine_SkeletonCacheAnimation(ns); 
    js_register_spine_SkeletonCacheMgr(ns); 
    
    /* Register global variables & global functions */
    
    
    
    return true;
}

// clang-format on
