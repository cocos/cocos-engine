// clang-format off

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.1.0
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

/****************************************************************************
 Copyright (c) 2022 Xiamen Yaji Software Co., Ltd.

 http://www.cocos.com

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated engine source code (the "Software"), a limited,
 worldwide, royalty-free, non-assignable, revocable and non-exclusive license
 to use Cocos Creator solely to develop games on your target platforms. You shall
 not use Cocos Creator software for developing other software or tools that's
 used for developing games. You are not granted to publish, distribute,
 sublicense, and/or sell copies of Cocos Creator.

 The software or tools in this License Agreement are licensed, not sold.
 Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
****************************************************************************/

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static 
#endif



#include <stdio.h>


#include "bindings/jswrapper/SeApi.h"
#include "bindings/manual/jsb_conversions.h"
#include "bindings/manual/jsb_global.h"


#include "bindings/auto/jsb_assets_auto.h"
#include "bindings/auto/jsb_cocos_auto.h"
#include "bindings/auto/jsb_gfx_auto.h"
#include "bindings/auto/jsb_scene_auto.h"
#include "renderer/core/PassUtils.h"
#include "renderer/gfx-base/GFXDef-common.h"
#include "renderer/pipeline/Define.h"
#include "renderer/pipeline/RenderStage.h"
#include "scene/Pass.h"
#include "scene/RenderWindow.h"
#include "core/scene-graph/Scene.h"


#define cc_Asset__uuid_get(self_) self_->getUuid()
#define cc_Asset__uuid_set(self_, val_) self_->setUuid(val_)
  

#define cc_Asset_nativeUrl_get(self_) self_->getNativeUrl()
  

#define cc_Asset__nativeDep_get(self_) self_->getNativeDep()
  

#define cc_Asset_isDefault_get(self_) self_->isDefault()
  

#define cc_ImageAsset_format_get(self_) self_->getFormat()
#define cc_ImageAsset_format_set(self_, val_) self_->setFormat(val_)
  

#define cc_ImageAsset_url_get(self_) self_->getUrl()
#define cc_ImageAsset_url_set(self_, val_) self_->setUrl(val_)
  

#define cc_BufferAsset__nativeAsset_get(self_) self_->getNativeAssetForJS()
#define cc_BufferAsset__nativeAsset_set(self_, val_) self_->setNativeAssetForJS(val_)
  

#define cc_TextureBase_isCompressed_get(self_) self_->isCompressed()
  

#define cc_TextureBase__width_get(self_) self_->getWidth()
#define cc_TextureBase__width_set(self_, val_) self_->setWidth(val_)
  

#define cc_TextureBase_width_get(self_) self_->getWidth()
#define cc_TextureBase_width_set(self_, val_) self_->setWidth(val_)
  

#define cc_TextureBase__height_get(self_) self_->getHeight()
#define cc_TextureBase__height_set(self_, val_) self_->setHeight(val_)
  

#define cc_TextureBase_height_get(self_) self_->getHeight()
#define cc_TextureBase_height_set(self_, val_) self_->setHeight(val_)
  

#define cc_SimpleTexture_mipmapLevel_get(self_) self_->mipmapLevel()
  

#define cc_RenderTexture_window_get(self_) self_->getWindow()
  

#define cc_Mesh__hash_get(self_) self_->getHash()
  

#define cc_Mesh_hash_get(self_) self_->getHash()
  

#define cc_Mesh_data_get(self_) self_->getData()
  

#define cc_Mesh__data_get(self_) self_->getData()
  

#define cc_Mesh_jointBufferIndices_get(self_) self_->getJointBufferIndices()
  

#define cc_Mesh_maxPosition_get(self_) self_->getMaxPosition()
  

#define cc_Mesh_minPosition_get(self_) self_->getMinPosition()
  

#define cc_Mesh_renderingSubMeshes_get(self_) self_->getRenderingSubMeshes()
  

#define cc_Mesh_subMeshCount_get(self_) self_->getSubMeshCount()
  

#define cc_Mesh__nativeAsset_get(self_) self_->getAssetData()
#define cc_Mesh__nativeAsset_set(self_, val_) self_->setAssetData(val_)
  

#define cc_Mesh__allowDataAccess_get(self_) self_->isAllowDataAccess()
#define cc_Mesh__allowDataAccess_set(self_, val_) self_->setAllowDataAccess(val_)
  

#define cc_Mesh_allowDataAccess_get(self_) self_->isAllowDataAccess()
#define cc_Mesh_allowDataAccess_set(self_, val_) self_->setAllowDataAccess(val_)
  

#define cc_Material_effectAsset_get(self_) self_->getEffectAsset()
#define cc_Material_effectAsset_set(self_, val_) self_->setEffectAsset(val_)
  

#define cc_Material_effectName_get(self_) self_->getEffectName()
  

#define cc_Material_technique_get(self_) self_->getTechniqueIndex()
  

#define cc_Material_hash_get(self_) self_->getHash()
  

#define cc_Material_parent_get(self_) self_->getParent()
  

#define cc_RenderingSubMesh_mesh_get(self_) self_->getMesh()
#define cc_RenderingSubMesh_mesh_set(self_, val_) self_->setMesh(val_)
  

#define cc_RenderingSubMesh_subMeshIdx_get(self_) self_->getSubMeshIdx()
#define cc_RenderingSubMesh_subMeshIdx_set(self_, val_) self_->setSubMeshIdx(val_)
  

#define cc_RenderingSubMesh_flatBuffers_get(self_) self_->getFlatBuffers()
#define cc_RenderingSubMesh_flatBuffers_set(self_, val_) self_->setFlatBuffers(val_)
  

#define cc_RenderingSubMesh__flatBuffers_get(self_) self_->getFlatBuffers()
#define cc_RenderingSubMesh__flatBuffers_set(self_, val_) self_->setFlatBuffers(val_)
  

#define cc_RenderingSubMesh_jointMappedBuffers_get(self_) self_->getJointMappedBuffers()
  

#define cc_RenderingSubMesh_iaInfo_get(self_) self_->getIaInfo()
  

#define cc_RenderingSubMesh__iaInfo_get(self_) self_->getIaInfo()
  

#define cc_RenderingSubMesh_primitiveMode_get(self_) self_->getPrimitiveMode()
  

#define cc_Skeleton_joints_get(self_) self_->getJoints()
#define cc_Skeleton_joints_set(self_, val_) self_->setJoints(val_)
  

#define cc_Skeleton__joints_get(self_) self_->getJoints()
#define cc_Skeleton__joints_set(self_, val_) self_->setJoints(val_)
  

#define cc_Skeleton_hash_get(self_) self_->getHash()
#define cc_Skeleton_hash_set(self_, val_) self_->setHash(val_)
  

#define cc_Skeleton__hash_get(self_) self_->getHash()
#define cc_Skeleton__hash_set(self_, val_) self_->setHash(val_)
  

#define cc_Skeleton__invBindposes_get(self_) self_->getInverseBindposes()
  

#define cc_Skeleton_inverseBindposes_get(self_) self_->getInverseBindposes()
  

#define cc_EffectAsset_techniques_get(self_) self_->getTechniques()
#define cc_EffectAsset_techniques_set(self_, val_) self_->setTechniques(val_)
  

#define cc_EffectAsset_shaders_get(self_) self_->getShaders()
#define cc_EffectAsset_shaders_set(self_, val_) self_->setShaders(val_)
  

#define cc_EffectAsset_combinations_get(self_) self_->getCombinations()
#define cc_EffectAsset_combinations_set(self_, val_) self_->setCombinations(val_)
  


se::Class* __jsb_cc_Error_class = nullptr;
se::Object* __jsb_cc_Error_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Error) 

static bool js_cc_Error_msg_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Error *arg1 = (cc::Error *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Error>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->msg, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error_msg_set,2,SWIGTYPE_ccstd__optionalT_ccstd__string_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Error_msg_set) 

static bool js_cc_Error_msg_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Error *arg1 = (cc::Error *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Error>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->msg, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error_msg_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->msg, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Error_msg_get) 

// js_ctor
static bool js_new_cc_Error(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::Error *result;
    result = (cc::Error *)new cc::Error();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Error, __jsb_cc_Error_class, js_delete_cc_Error)

static bool js_delete_cc_Error(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Error) 

template<>
bool sevalue_to_native(const se::Value &from, cc::Error * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::Error*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("msg", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->msg), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_Error(se::Object* obj) {
    auto* cls = se::Class::create("Error", obj, nullptr, _SE(js_new_cc_Error)); 
    
    cls->defineProperty("msg", _SE(js_cc_Error_msg_get), _SE(js_cc_Error_msg_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Error));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Error>(cls);
    
    __jsb_cc_Error_proto = cls->getProto();
    __jsb_cc_Error_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_BoundingBox_class = nullptr;
se::Object* __jsb_cc_BoundingBox_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_BoundingBox) 

static bool js_cc_BoundingBox_min_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BoundingBox *arg1 = (cc::BoundingBox *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BoundingBox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->min, s.thisObject());
    SE_PRECONDITION2(ok, false, "BoundingBox_min_set,2,SWIGTYPE_Vec3"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BoundingBox_min_set) 

static bool js_cc_BoundingBox_min_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BoundingBox *arg1 = (cc::BoundingBox *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BoundingBox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->min, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BoundingBox_min_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->min, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BoundingBox_min_get) 

static bool js_cc_BoundingBox_max_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BoundingBox *arg1 = (cc::BoundingBox *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BoundingBox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->max, s.thisObject());
    SE_PRECONDITION2(ok, false, "BoundingBox_max_set,2,SWIGTYPE_Vec3"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BoundingBox_max_set) 

static bool js_cc_BoundingBox_max_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BoundingBox *arg1 = (cc::BoundingBox *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BoundingBox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->max, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BoundingBox_max_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->max, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BoundingBox_max_get) 

// js_ctor
static bool js_new_cc_BoundingBox(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::BoundingBox *result;
    result = (cc::BoundingBox *)new cc::BoundingBox();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_BoundingBox, __jsb_cc_BoundingBox_class, js_delete_cc_BoundingBox)

static bool js_delete_cc_BoundingBox(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_BoundingBox) 

template<>
bool sevalue_to_native(const se::Value &from, cc::BoundingBox * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::BoundingBox*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("min", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->min), ctx);
    }
    
    
    json->getProperty("max", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->max), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_BoundingBox(se::Object* obj) {
    auto* cls = se::Class::create("BoundingBox", obj, nullptr, _SE(js_new_cc_BoundingBox)); 
    
    cls->defineProperty("min", _SE(js_cc_BoundingBox_min_get), _SE(js_cc_BoundingBox_min_set)); 
    cls->defineProperty("max", _SE(js_cc_BoundingBox_max_get), _SE(js_cc_BoundingBox_max_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_BoundingBox));
    
    
    cls->install();
    JSBClassType::registerClass<cc::BoundingBox>(cls);
    
    __jsb_cc_BoundingBox_proto = cls->getProto();
    __jsb_cc_BoundingBox_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_VertexIdChannel_class = nullptr;
se::Object* __jsb_cc_VertexIdChannel_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_VertexIdChannel) 

static bool js_cc_VertexIdChannel_stream_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::VertexIdChannel *arg1 = (cc::VertexIdChannel *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::VertexIdChannel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stream, s.thisObject());
    SE_PRECONDITION2(ok, false, "VertexIdChannel_stream_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_VertexIdChannel_stream_set) 

static bool js_cc_VertexIdChannel_stream_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::VertexIdChannel *arg1 = (cc::VertexIdChannel *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::VertexIdChannel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stream, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "VertexIdChannel_stream_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stream, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_VertexIdChannel_stream_get) 

static bool js_cc_VertexIdChannel_index_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::VertexIdChannel *arg1 = (cc::VertexIdChannel *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::VertexIdChannel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->index, s.thisObject());
    SE_PRECONDITION2(ok, false, "VertexIdChannel_index_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_VertexIdChannel_index_set) 

static bool js_cc_VertexIdChannel_index_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::VertexIdChannel *arg1 = (cc::VertexIdChannel *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::VertexIdChannel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->index, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "VertexIdChannel_index_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->index, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_VertexIdChannel_index_get) 

// js_ctor
static bool js_new_cc_VertexIdChannel(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::VertexIdChannel *result;
    result = (cc::VertexIdChannel *)new cc::VertexIdChannel();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_VertexIdChannel, __jsb_cc_VertexIdChannel_class, js_delete_cc_VertexIdChannel)

static bool js_delete_cc_VertexIdChannel(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_VertexIdChannel) 

template<>
bool sevalue_to_native(const se::Value &from, cc::VertexIdChannel * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::VertexIdChannel*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("stream", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stream), ctx);
    }
    
    
    json->getProperty("index", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->index), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_VertexIdChannel(se::Object* obj) {
    auto* cls = se::Class::create("VertexIdChannel", obj, nullptr, _SE(js_new_cc_VertexIdChannel)); 
    
    cls->defineProperty("stream", _SE(js_cc_VertexIdChannel_stream_get), _SE(js_cc_VertexIdChannel_stream_set)); 
    cls->defineProperty("index", _SE(js_cc_VertexIdChannel_index_get), _SE(js_cc_VertexIdChannel_index_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_VertexIdChannel));
    
    
    cls->install();
    JSBClassType::registerClass<cc::VertexIdChannel>(cls);
    
    __jsb_cc_VertexIdChannel_proto = cls->getProto();
    __jsb_cc_VertexIdChannel_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_NativeDep_class = nullptr;
se::Object* __jsb_cc_NativeDep_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_NativeDep) 

static bool js_cc_NativeDep_uuid_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::NativeDep *arg1 = (cc::NativeDep *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::NativeDep>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->uuid, s.thisObject());
    SE_PRECONDITION2(ok, false, "NativeDep_uuid_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_NativeDep_uuid_set) 

static bool js_cc_NativeDep_uuid_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::NativeDep *arg1 = (cc::NativeDep *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::NativeDep>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->uuid, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "NativeDep_uuid_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->uuid, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_NativeDep_uuid_get) 

static bool js_cc_NativeDep_ext_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::NativeDep *arg1 = (cc::NativeDep *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::NativeDep>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->ext, s.thisObject());
    SE_PRECONDITION2(ok, false, "NativeDep_ext_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_NativeDep_ext_set) 

static bool js_cc_NativeDep_ext_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::NativeDep *arg1 = (cc::NativeDep *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::NativeDep>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->ext, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "NativeDep_ext_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->ext, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_NativeDep_ext_get) 

static bool js_cc_NativeDep___isNative___set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::NativeDep *arg1 = (cc::NativeDep *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::NativeDep>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->__isNative__);
    SE_PRECONDITION2(ok, false, "NativeDep___isNative___set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_NativeDep___isNative___set) 

static bool js_cc_NativeDep___isNative___get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::NativeDep *arg1 = (cc::NativeDep *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::NativeDep>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->__isNative__, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_NativeDep___isNative___get) 

static bool js_new_cc_NativeDep__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::NativeDep *result;
    result = (cc::NativeDep *)new cc::NativeDep();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_NativeDep__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    bool arg1 ;
    ccstd::string arg2 ;
    ccstd::string arg3 ;
    cc::NativeDep *result;
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1);
    SE_PRECONDITION2(ok, false, "new_NativeDep,1,SWIGTYPE_bool"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_NativeDep,2,SWIGTYPE_ccstd__string"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_NativeDep,3,SWIGTYPE_ccstd__string"); 
    
    result = (cc::NativeDep *)new cc::NativeDep(arg1,arg2,arg3);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_NativeDep(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_ctor_dispatcher
    size_t argc = s.args().size();
    bool ret = false;
    
    // switch all cases by means of series of if-returns.
    
    // js_ctor_dispatch_case
    if(argc == 0) {
        ret = js_new_cc_NativeDep__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 3) {
        ret = js_new_cc_NativeDep__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    
    // default:
    SE_REPORT_ERROR("Illegal arguments for construction of NativeDep");
    return false;
}
SE_BIND_CTOR(js_new_NativeDep, __jsb_cc_NativeDep_class, js_delete_cc_NativeDep)

static bool js_cc_NativeDep_isValid(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::NativeDep *arg1 = (cc::NativeDep *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::NativeDep>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((cc::NativeDep const *)arg1)->isValid();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_NativeDep_isValid) 

static bool js_delete_cc_NativeDep(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_NativeDep) 

template<>
bool sevalue_to_native(const se::Value &from, cc::NativeDep * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::NativeDep*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("uuid", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->uuid), ctx);
    }
    
    
    json->getProperty("ext", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->ext), ctx);
    }
    
    
    json->getProperty("__isNative__", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->__isNative__), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_NativeDep(se::Object* obj) {
    auto* cls = se::Class::create("NativeDep", obj, nullptr, _SE(js_new_NativeDep)); 
    
    cls->defineProperty("uuid", _SE(js_cc_NativeDep_uuid_get), _SE(js_cc_NativeDep_uuid_set)); 
    cls->defineProperty("ext", _SE(js_cc_NativeDep_ext_get), _SE(js_cc_NativeDep_ext_set)); 
    cls->defineProperty("__isNative__", _SE(js_cc_NativeDep___isNative___get), _SE(js_cc_NativeDep___isNative___set)); 
    
    cls->defineFunction("isValid", _SE(js_cc_NativeDep_isValid)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_NativeDep));
    
    
    cls->install();
    JSBClassType::registerClass<cc::NativeDep>(cls);
    
    __jsb_cc_NativeDep_proto = cls->getProto();
    __jsb_cc_NativeDep_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IGeometryOptions_class = nullptr;
se::Object* __jsb_cc_IGeometryOptions_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IGeometryOptions) 

static bool js_cc_IGeometryOptions_includeNormal_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometryOptions *arg1 = (cc::IGeometryOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometryOptions>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->includeNormal);
    SE_PRECONDITION2(ok, false, "IGeometryOptions_includeNormal_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometryOptions_includeNormal_set) 

static bool js_cc_IGeometryOptions_includeNormal_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometryOptions *arg1 = (cc::IGeometryOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometryOptions>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->includeNormal, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometryOptions_includeNormal_get) 

static bool js_cc_IGeometryOptions_includeUV_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometryOptions *arg1 = (cc::IGeometryOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometryOptions>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->includeUV);
    SE_PRECONDITION2(ok, false, "IGeometryOptions_includeUV_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometryOptions_includeUV_set) 

static bool js_cc_IGeometryOptions_includeUV_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometryOptions *arg1 = (cc::IGeometryOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometryOptions>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->includeUV, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometryOptions_includeUV_get) 

// js_ctor
static bool js_new_cc_IGeometryOptions(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IGeometryOptions *result;
    result = (cc::IGeometryOptions *)new cc::IGeometryOptions();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IGeometryOptions, __jsb_cc_IGeometryOptions_class, js_delete_cc_IGeometryOptions)

static bool js_delete_cc_IGeometryOptions(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IGeometryOptions) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IGeometryOptions * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IGeometryOptions*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("includeNormal", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->includeNormal), ctx);
    }
    
    
    json->getProperty("includeUV", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->includeUV), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IGeometryOptions(se::Object* obj) {
    auto* cls = se::Class::create("IGeometryOptions", obj, nullptr, _SE(js_new_cc_IGeometryOptions)); 
    
    cls->defineProperty("includeNormal", _SE(js_cc_IGeometryOptions_includeNormal_get), _SE(js_cc_IGeometryOptions_includeNormal_set)); 
    cls->defineProperty("includeUV", _SE(js_cc_IGeometryOptions_includeUV_get), _SE(js_cc_IGeometryOptions_includeUV_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IGeometryOptions));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IGeometryOptions>(cls);
    
    __jsb_cc_IGeometryOptions_proto = cls->getProto();
    __jsb_cc_IGeometryOptions_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_CustomAttribute_class = nullptr;
se::Object* __jsb_cc_CustomAttribute_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_CustomAttribute) 

static bool js_cc_CustomAttribute_attr_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::CustomAttribute *arg1 = (cc::CustomAttribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CustomAttribute>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->attr, s.thisObject());
    SE_PRECONDITION2(ok, false, "CustomAttribute_attr_set,2,SWIGTYPE_cc__gfx__Attribute"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_CustomAttribute_attr_set) 

static bool js_cc_CustomAttribute_attr_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::CustomAttribute *arg1 = (cc::CustomAttribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CustomAttribute>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->attr, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CustomAttribute_attr_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->attr, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_CustomAttribute_attr_get) 

static bool js_cc_CustomAttribute_values_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::CustomAttribute *arg1 = (cc::CustomAttribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CustomAttribute>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->values, s.thisObject());
    SE_PRECONDITION2(ok, false, "CustomAttribute_values_set,2,SWIGTYPE_ccstd__vectorT_float_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_CustomAttribute_values_set) 

static bool js_cc_CustomAttribute_values_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::CustomAttribute *arg1 = (cc::CustomAttribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CustomAttribute>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->values, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CustomAttribute_values_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->values, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_CustomAttribute_values_get) 

// js_ctor
static bool js_new_cc_CustomAttribute(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::CustomAttribute *result;
    result = (cc::CustomAttribute *)new cc::CustomAttribute();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_CustomAttribute, __jsb_cc_CustomAttribute_class, js_delete_cc_CustomAttribute)

static bool js_delete_cc_CustomAttribute(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_CustomAttribute) 

template<>
bool sevalue_to_native(const se::Value &from, cc::CustomAttribute * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::CustomAttribute*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("attr", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->attr), ctx);
    }
    
    
    json->getProperty("values", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->values), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_CustomAttribute(se::Object* obj) {
    auto* cls = se::Class::create("CustomAttribute", obj, nullptr, _SE(js_new_cc_CustomAttribute)); 
    
    cls->defineProperty("attr", _SE(js_cc_CustomAttribute_attr_get), _SE(js_cc_CustomAttribute_attr_set)); 
    cls->defineProperty("values", _SE(js_cc_CustomAttribute_values_get), _SE(js_cc_CustomAttribute_values_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_CustomAttribute));
    
    
    cls->install();
    JSBClassType::registerClass<cc::CustomAttribute>(cls);
    
    __jsb_cc_CustomAttribute_proto = cls->getProto();
    __jsb_cc_CustomAttribute_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IGeometry_class = nullptr;
se::Object* __jsb_cc_IGeometry_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IGeometry) 

static bool js_cc_IGeometry_positions_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->positions, s.thisObject());
    SE_PRECONDITION2(ok, false, "IGeometry_positions_set,2,SWIGTYPE_ccstd__vectorT_float_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometry_positions_set) 

static bool js_cc_IGeometry_positions_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->positions, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IGeometry_positions_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->positions, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometry_positions_get) 

static bool js_cc_IGeometry_normals_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->normals, s.thisObject());
    SE_PRECONDITION2(ok, false, "IGeometry_normals_set,2,SWIGTYPE_ccstd__optionalT_ccstd__vectorT_float_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometry_normals_set) 

static bool js_cc_IGeometry_normals_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->normals, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IGeometry_normals_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->normals, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometry_normals_get) 

static bool js_cc_IGeometry_uvs_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->uvs, s.thisObject());
    SE_PRECONDITION2(ok, false, "IGeometry_uvs_set,2,SWIGTYPE_ccstd__optionalT_ccstd__vectorT_float_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometry_uvs_set) 

static bool js_cc_IGeometry_uvs_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->uvs, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IGeometry_uvs_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->uvs, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometry_uvs_get) 

static bool js_cc_IGeometry_tangents_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->tangents, s.thisObject());
    SE_PRECONDITION2(ok, false, "IGeometry_tangents_set,2,SWIGTYPE_ccstd__optionalT_ccstd__vectorT_float_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometry_tangents_set) 

static bool js_cc_IGeometry_tangents_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->tangents, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IGeometry_tangents_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->tangents, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometry_tangents_get) 

static bool js_cc_IGeometry_colors_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->colors, s.thisObject());
    SE_PRECONDITION2(ok, false, "IGeometry_colors_set,2,SWIGTYPE_ccstd__optionalT_ccstd__vectorT_float_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometry_colors_set) 

static bool js_cc_IGeometry_colors_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->colors, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IGeometry_colors_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->colors, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometry_colors_get) 

static bool js_cc_IGeometry_attributes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->attributes, s.thisObject());
    SE_PRECONDITION2(ok, false, "IGeometry_attributes_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__AttributeList_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometry_attributes_set) 

static bool js_cc_IGeometry_attributes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->attributes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IGeometry_attributes_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->attributes, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometry_attributes_get) 

static bool js_cc_IGeometry_customAttributes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->customAttributes, s.thisObject());
    SE_PRECONDITION2(ok, false, "IGeometry_customAttributes_set,2,SWIGTYPE_ccstd__optionalT_ccstd__vectorT_cc__CustomAttribute_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometry_customAttributes_set) 

static bool js_cc_IGeometry_customAttributes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->customAttributes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IGeometry_customAttributes_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->customAttributes, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometry_customAttributes_get) 

static bool js_cc_IGeometry_boundingRadius_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->boundingRadius, s.thisObject());
    SE_PRECONDITION2(ok, false, "IGeometry_boundingRadius_set,2,SWIGTYPE_ccstd__optionalT_float_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometry_boundingRadius_set) 

static bool js_cc_IGeometry_boundingRadius_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->boundingRadius, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IGeometry_boundingRadius_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->boundingRadius, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometry_boundingRadius_get) 

static bool js_cc_IGeometry_minPos_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->minPos, s.thisObject());
    SE_PRECONDITION2(ok, false, "IGeometry_minPos_set,2,SWIGTYPE_ccstd__optionalT_cc__Vec3_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometry_minPos_set) 

static bool js_cc_IGeometry_minPos_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->minPos, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IGeometry_minPos_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->minPos, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometry_minPos_get) 

static bool js_cc_IGeometry_maxPos_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxPos, s.thisObject());
    SE_PRECONDITION2(ok, false, "IGeometry_maxPos_set,2,SWIGTYPE_ccstd__optionalT_cc__Vec3_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometry_maxPos_set) 

static bool js_cc_IGeometry_maxPos_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxPos, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IGeometry_maxPos_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxPos, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometry_maxPos_get) 

static bool js_cc_IGeometry_indices_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->indices, s.thisObject());
    SE_PRECONDITION2(ok, false, "IGeometry_indices_set,2,SWIGTYPE_ccstd__optionalT_ccstd__vectorT_uint32_t_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometry_indices_set) 

static bool js_cc_IGeometry_indices_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->indices, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IGeometry_indices_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->indices, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometry_indices_get) 

static bool js_cc_IGeometry_primitiveMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->primitiveMode, s.thisObject());
    SE_PRECONDITION2(ok, false, "IGeometry_primitiveMode_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__PrimitiveMode_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometry_primitiveMode_set) 

static bool js_cc_IGeometry_primitiveMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->primitiveMode, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IGeometry_primitiveMode_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->primitiveMode, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometry_primitiveMode_get) 

static bool js_cc_IGeometry_doubleSided_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->doubleSided, s.thisObject());
    SE_PRECONDITION2(ok, false, "IGeometry_doubleSided_set,2,SWIGTYPE_ccstd__optionalT_bool_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometry_doubleSided_set) 

static bool js_cc_IGeometry_doubleSided_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->doubleSided, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IGeometry_doubleSided_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->doubleSided, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometry_doubleSided_get) 

// js_ctor
static bool js_new_cc_IGeometry(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IGeometry *result;
    result = (cc::IGeometry *)new cc::IGeometry();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IGeometry, __jsb_cc_IGeometry_class, js_delete_cc_IGeometry)

static bool js_delete_cc_IGeometry(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IGeometry) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IGeometry * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IGeometry*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("positions", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->positions), ctx);
    }
    
    
    json->getProperty("normals", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->normals), ctx);
    }
    
    
    json->getProperty("uvs", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->uvs), ctx);
    }
    
    
    json->getProperty("tangents", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->tangents), ctx);
    }
    
    
    json->getProperty("colors", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->colors), ctx);
    }
    
    
    json->getProperty("attributes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->attributes), ctx);
    }
    
    
    json->getProperty("customAttributes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->customAttributes), ctx);
    }
    
    
    json->getProperty("boundingRadius", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->boundingRadius), ctx);
    }
    
    
    json->getProperty("minPos", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->minPos), ctx);
    }
    
    
    json->getProperty("maxPos", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxPos), ctx);
    }
    
    
    json->getProperty("indices", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->indices), ctx);
    }
    
    
    json->getProperty("primitiveMode", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->primitiveMode), ctx);
    }
    
    
    json->getProperty("doubleSided", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->doubleSided), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IGeometry(se::Object* obj) {
    auto* cls = se::Class::create("IGeometry", obj, nullptr, _SE(js_new_cc_IGeometry)); 
    
    cls->defineProperty("positions", _SE(js_cc_IGeometry_positions_get), _SE(js_cc_IGeometry_positions_set)); 
    cls->defineProperty("normals", _SE(js_cc_IGeometry_normals_get), _SE(js_cc_IGeometry_normals_set)); 
    cls->defineProperty("uvs", _SE(js_cc_IGeometry_uvs_get), _SE(js_cc_IGeometry_uvs_set)); 
    cls->defineProperty("tangents", _SE(js_cc_IGeometry_tangents_get), _SE(js_cc_IGeometry_tangents_set)); 
    cls->defineProperty("colors", _SE(js_cc_IGeometry_colors_get), _SE(js_cc_IGeometry_colors_set)); 
    cls->defineProperty("attributes", _SE(js_cc_IGeometry_attributes_get), _SE(js_cc_IGeometry_attributes_set)); 
    cls->defineProperty("customAttributes", _SE(js_cc_IGeometry_customAttributes_get), _SE(js_cc_IGeometry_customAttributes_set)); 
    cls->defineProperty("boundingRadius", _SE(js_cc_IGeometry_boundingRadius_get), _SE(js_cc_IGeometry_boundingRadius_set)); 
    cls->defineProperty("minPos", _SE(js_cc_IGeometry_minPos_get), _SE(js_cc_IGeometry_minPos_set)); 
    cls->defineProperty("maxPos", _SE(js_cc_IGeometry_maxPos_get), _SE(js_cc_IGeometry_maxPos_set)); 
    cls->defineProperty("indices", _SE(js_cc_IGeometry_indices_get), _SE(js_cc_IGeometry_indices_set)); 
    cls->defineProperty("primitiveMode", _SE(js_cc_IGeometry_primitiveMode_get), _SE(js_cc_IGeometry_primitiveMode_set)); 
    cls->defineProperty("doubleSided", _SE(js_cc_IGeometry_doubleSided_get), _SE(js_cc_IGeometry_doubleSided_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IGeometry));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IGeometry>(cls);
    
    __jsb_cc_IGeometry_proto = cls->getProto();
    __jsb_cc_IGeometry_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_DynamicCustomAttribute_class = nullptr;
se::Object* __jsb_cc_DynamicCustomAttribute_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_DynamicCustomAttribute) 

static bool js_cc_DynamicCustomAttribute_attr_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DynamicCustomAttribute *arg1 = (cc::DynamicCustomAttribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DynamicCustomAttribute>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->attr, s.thisObject());
    SE_PRECONDITION2(ok, false, "DynamicCustomAttribute_attr_set,2,SWIGTYPE_cc__gfx__Attribute"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DynamicCustomAttribute_attr_set) 

static bool js_cc_DynamicCustomAttribute_attr_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DynamicCustomAttribute *arg1 = (cc::DynamicCustomAttribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DynamicCustomAttribute>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->attr, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DynamicCustomAttribute_attr_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->attr, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DynamicCustomAttribute_attr_get) 

static bool js_cc_DynamicCustomAttribute_values_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DynamicCustomAttribute *arg1 = (cc::DynamicCustomAttribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DynamicCustomAttribute>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->values, s.thisObject());
    SE_PRECONDITION2(ok, false, "DynamicCustomAttribute_values_set,2,SWIGTYPE_cc__TypedArrayTempT_float_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DynamicCustomAttribute_values_set) 

static bool js_cc_DynamicCustomAttribute_values_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DynamicCustomAttribute *arg1 = (cc::DynamicCustomAttribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DynamicCustomAttribute>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(out) cc::Float32Array
    ok &= nativevalue_to_se(arg1->values, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DynamicCustomAttribute_values_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->values, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DynamicCustomAttribute_values_get) 

// js_ctor
static bool js_new_cc_DynamicCustomAttribute(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::DynamicCustomAttribute *result;
    result = (cc::DynamicCustomAttribute *)new cc::DynamicCustomAttribute();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_DynamicCustomAttribute, __jsb_cc_DynamicCustomAttribute_class, js_delete_cc_DynamicCustomAttribute)

static bool js_delete_cc_DynamicCustomAttribute(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_DynamicCustomAttribute) 

template<>
bool sevalue_to_native(const se::Value &from, cc::DynamicCustomAttribute * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::DynamicCustomAttribute*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("attr", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->attr), ctx);
    }
    
    
    json->getProperty("values", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->values), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_DynamicCustomAttribute(se::Object* obj) {
    auto* cls = se::Class::create("DynamicCustomAttribute", obj, nullptr, _SE(js_new_cc_DynamicCustomAttribute)); 
    
    cls->defineProperty("attr", _SE(js_cc_DynamicCustomAttribute_attr_get), _SE(js_cc_DynamicCustomAttribute_attr_set)); 
    cls->defineProperty("values", _SE(js_cc_DynamicCustomAttribute_values_get), _SE(js_cc_DynamicCustomAttribute_values_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_DynamicCustomAttribute));
    
    
    cls->install();
    JSBClassType::registerClass<cc::DynamicCustomAttribute>(cls);
    
    __jsb_cc_DynamicCustomAttribute_proto = cls->getProto();
    __jsb_cc_DynamicCustomAttribute_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IDynamicGeometry_class = nullptr;
se::Object* __jsb_cc_IDynamicGeometry_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IDynamicGeometry) 

static bool js_cc_IDynamicGeometry_positions_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->positions, s.thisObject());
    SE_PRECONDITION2(ok, false, "IDynamicGeometry_positions_set,2,SWIGTYPE_cc__TypedArrayTempT_float_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDynamicGeometry_positions_set) 

static bool js_cc_IDynamicGeometry_positions_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(out) cc::Float32Array
    ok &= nativevalue_to_se(arg1->positions, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IDynamicGeometry_positions_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->positions, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDynamicGeometry_positions_get) 

static bool js_cc_IDynamicGeometry_normals_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->normals, s.thisObject());
    SE_PRECONDITION2(ok, false, "IDynamicGeometry_normals_set,2,SWIGTYPE_ccstd__optionalT_cc__Float32Array_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDynamicGeometry_normals_set) 

static bool js_cc_IDynamicGeometry_normals_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->normals, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IDynamicGeometry_normals_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->normals, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDynamicGeometry_normals_get) 

static bool js_cc_IDynamicGeometry_uvs_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->uvs, s.thisObject());
    SE_PRECONDITION2(ok, false, "IDynamicGeometry_uvs_set,2,SWIGTYPE_ccstd__optionalT_cc__Float32Array_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDynamicGeometry_uvs_set) 

static bool js_cc_IDynamicGeometry_uvs_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->uvs, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IDynamicGeometry_uvs_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->uvs, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDynamicGeometry_uvs_get) 

static bool js_cc_IDynamicGeometry_tangents_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->tangents, s.thisObject());
    SE_PRECONDITION2(ok, false, "IDynamicGeometry_tangents_set,2,SWIGTYPE_ccstd__optionalT_cc__Float32Array_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDynamicGeometry_tangents_set) 

static bool js_cc_IDynamicGeometry_tangents_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->tangents, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IDynamicGeometry_tangents_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->tangents, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDynamicGeometry_tangents_get) 

static bool js_cc_IDynamicGeometry_colors_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->colors, s.thisObject());
    SE_PRECONDITION2(ok, false, "IDynamicGeometry_colors_set,2,SWIGTYPE_ccstd__optionalT_cc__Float32Array_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDynamicGeometry_colors_set) 

static bool js_cc_IDynamicGeometry_colors_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->colors, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IDynamicGeometry_colors_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->colors, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDynamicGeometry_colors_get) 

static bool js_cc_IDynamicGeometry_customAttributes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->customAttributes, s.thisObject());
    SE_PRECONDITION2(ok, false, "IDynamicGeometry_customAttributes_set,2,SWIGTYPE_ccstd__optionalT_ccstd__vectorT_cc__DynamicCustomAttribute_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDynamicGeometry_customAttributes_set) 

static bool js_cc_IDynamicGeometry_customAttributes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->customAttributes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IDynamicGeometry_customAttributes_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->customAttributes, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDynamicGeometry_customAttributes_get) 

static bool js_cc_IDynamicGeometry_minPos_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->minPos, s.thisObject());
    SE_PRECONDITION2(ok, false, "IDynamicGeometry_minPos_set,2,SWIGTYPE_ccstd__optionalT_cc__Vec3_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDynamicGeometry_minPos_set) 

static bool js_cc_IDynamicGeometry_minPos_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->minPos, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IDynamicGeometry_minPos_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->minPos, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDynamicGeometry_minPos_get) 

static bool js_cc_IDynamicGeometry_maxPos_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxPos, s.thisObject());
    SE_PRECONDITION2(ok, false, "IDynamicGeometry_maxPos_set,2,SWIGTYPE_ccstd__optionalT_cc__Vec3_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDynamicGeometry_maxPos_set) 

static bool js_cc_IDynamicGeometry_maxPos_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxPos, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IDynamicGeometry_maxPos_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxPos, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDynamicGeometry_maxPos_get) 

static bool js_cc_IDynamicGeometry_indices16_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->indices16, s.thisObject());
    SE_PRECONDITION2(ok, false, "IDynamicGeometry_indices16_set,2,SWIGTYPE_ccstd__optionalT_cc__Uint16Array_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDynamicGeometry_indices16_set) 

static bool js_cc_IDynamicGeometry_indices16_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->indices16, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IDynamicGeometry_indices16_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->indices16, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDynamicGeometry_indices16_get) 

static bool js_cc_IDynamicGeometry_indices32_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->indices32, s.thisObject());
    SE_PRECONDITION2(ok, false, "IDynamicGeometry_indices32_set,2,SWIGTYPE_ccstd__optionalT_cc__Uint32Array_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDynamicGeometry_indices32_set) 

static bool js_cc_IDynamicGeometry_indices32_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->indices32, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IDynamicGeometry_indices32_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->indices32, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDynamicGeometry_indices32_get) 

static bool js_cc_IDynamicGeometry_primitiveMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->primitiveMode, s.thisObject());
    SE_PRECONDITION2(ok, false, "IDynamicGeometry_primitiveMode_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__PrimitiveMode_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDynamicGeometry_primitiveMode_set) 

static bool js_cc_IDynamicGeometry_primitiveMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->primitiveMode, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IDynamicGeometry_primitiveMode_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->primitiveMode, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDynamicGeometry_primitiveMode_get) 

static bool js_cc_IDynamicGeometry_doubleSided_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->doubleSided, s.thisObject());
    SE_PRECONDITION2(ok, false, "IDynamicGeometry_doubleSided_set,2,SWIGTYPE_ccstd__optionalT_bool_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDynamicGeometry_doubleSided_set) 

static bool js_cc_IDynamicGeometry_doubleSided_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->doubleSided, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IDynamicGeometry_doubleSided_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->doubleSided, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDynamicGeometry_doubleSided_get) 

// js_ctor
static bool js_new_cc_IDynamicGeometry(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IDynamicGeometry *result;
    result = (cc::IDynamicGeometry *)new cc::IDynamicGeometry();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IDynamicGeometry, __jsb_cc_IDynamicGeometry_class, js_delete_cc_IDynamicGeometry)

static bool js_delete_cc_IDynamicGeometry(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IDynamicGeometry) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IDynamicGeometry * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IDynamicGeometry*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("positions", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->positions), ctx);
    }
    
    
    json->getProperty("normals", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->normals), ctx);
    }
    
    
    json->getProperty("uvs", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->uvs), ctx);
    }
    
    
    json->getProperty("tangents", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->tangents), ctx);
    }
    
    
    json->getProperty("colors", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->colors), ctx);
    }
    
    
    json->getProperty("customAttributes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->customAttributes), ctx);
    }
    
    
    json->getProperty("minPos", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->minPos), ctx);
    }
    
    
    json->getProperty("maxPos", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxPos), ctx);
    }
    
    
    json->getProperty("indices16", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->indices16), ctx);
    }
    
    
    json->getProperty("indices32", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->indices32), ctx);
    }
    
    
    json->getProperty("primitiveMode", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->primitiveMode), ctx);
    }
    
    
    json->getProperty("doubleSided", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->doubleSided), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IDynamicGeometry(se::Object* obj) {
    auto* cls = se::Class::create("IDynamicGeometry", obj, nullptr, _SE(js_new_cc_IDynamicGeometry)); 
    
    cls->defineProperty("positions", _SE(js_cc_IDynamicGeometry_positions_get), _SE(js_cc_IDynamicGeometry_positions_set)); 
    cls->defineProperty("normals", _SE(js_cc_IDynamicGeometry_normals_get), _SE(js_cc_IDynamicGeometry_normals_set)); 
    cls->defineProperty("uvs", _SE(js_cc_IDynamicGeometry_uvs_get), _SE(js_cc_IDynamicGeometry_uvs_set)); 
    cls->defineProperty("tangents", _SE(js_cc_IDynamicGeometry_tangents_get), _SE(js_cc_IDynamicGeometry_tangents_set)); 
    cls->defineProperty("colors", _SE(js_cc_IDynamicGeometry_colors_get), _SE(js_cc_IDynamicGeometry_colors_set)); 
    cls->defineProperty("customAttributes", _SE(js_cc_IDynamicGeometry_customAttributes_get), _SE(js_cc_IDynamicGeometry_customAttributes_set)); 
    cls->defineProperty("minPos", _SE(js_cc_IDynamicGeometry_minPos_get), _SE(js_cc_IDynamicGeometry_minPos_set)); 
    cls->defineProperty("maxPos", _SE(js_cc_IDynamicGeometry_maxPos_get), _SE(js_cc_IDynamicGeometry_maxPos_set)); 
    cls->defineProperty("indices16", _SE(js_cc_IDynamicGeometry_indices16_get), _SE(js_cc_IDynamicGeometry_indices16_set)); 
    cls->defineProperty("indices32", _SE(js_cc_IDynamicGeometry_indices32_get), _SE(js_cc_IDynamicGeometry_indices32_set)); 
    cls->defineProperty("primitiveMode", _SE(js_cc_IDynamicGeometry_primitiveMode_get), _SE(js_cc_IDynamicGeometry_primitiveMode_set)); 
    cls->defineProperty("doubleSided", _SE(js_cc_IDynamicGeometry_doubleSided_get), _SE(js_cc_IDynamicGeometry_doubleSided_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IDynamicGeometry));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IDynamicGeometry>(cls);
    
    __jsb_cc_IDynamicGeometry_proto = cls->getProto();
    __jsb_cc_IDynamicGeometry_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Asset_class = nullptr;
se::Object* __jsb_cc_Asset_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Asset) 

// js_ctor
static bool js_new_cc_Asset(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::Asset *result;
    result = (cc::Asset *)new cc::Asset();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Asset, __jsb_cc_Asset_class, js_delete_cc_Asset)

static bool js_delete_cc_Asset(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Asset) 

static bool js_cc_Asset_getNativeAsset(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    ccstd::any result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::Asset const *)arg1)->getNativeAsset();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Asset_getNativeAsset, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Asset_getNativeAsset) 

static bool js_cc_Asset_setNativeAsset(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    ccstd::any *arg2 = 0 ;
    ccstd::any temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Asset_setNativeAsset,2,SWIGTYPE_p_ccstd__any");
    arg2 = &temp2;
    
    (arg1)->setNativeAsset((ccstd::any const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Asset_setNativeAsset) 

static bool js_cc_Asset_addAssetRef(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->addAssetRef();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Asset_addAssetRef) 

static bool js_cc_Asset_decAssetRef__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Asset_decAssetRef,2,SWIGTYPE_bool"); 
    (arg1)->decAssetRef(arg2);
    
    
    return true;
}

static bool js_cc_Asset_decAssetRef__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->decAssetRef();
    
    
    return true;
}

static bool js_cc_Asset_decAssetRef(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Asset_decAssetRef__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 0) {
        ok = js_cc_Asset_decAssetRef__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Asset_decAssetRef) 

static bool js_cc_Asset_getAssetRefCount(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::Asset const *)arg1)->getAssetRefCount();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Asset_getAssetRefCount, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Asset_getAssetRefCount) 

static bool js_cc_Asset_onLoaded(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onLoaded();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Asset_onLoaded) 

static bool js_cc_Asset_initDefault__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->initDefault();
    
    
    return true;
}

static bool js_cc_Asset_initDefault__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    ccstd::optional< ccstd::string > *arg2 = 0 ;
    ccstd::optional< ccstd::string > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Asset_initDefault,2,SWIGTYPE_p_ccstd__optionalT_ccstd__string_t");
    arg2 = &temp2;
    
    (arg1)->initDefault((ccstd::optional< ccstd::string > const &)*arg2);
    
    
    return true;
}

static bool js_cc_Asset_initDefault(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 0) {
        ok = js_cc_Asset_initDefault__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Asset_initDefault__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Asset_initDefault) 

static bool js_cc_Asset_validate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((cc::Asset const *)arg1)->validate();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Asset_validate) 

static bool js_cc_Asset_serialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    ccstd::any *arg2 = 0 ;
    ccstd::any temp2 ;
    ccstd::any result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Asset_serialize,2,SWIGTYPE_p_ccstd__any");
    arg2 = &temp2;
    
    result = (arg1)->serialize((ccstd::any const &)*arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Asset_serialize, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Asset_serialize) 

static bool js_cc_Asset_deserialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    ccstd::any *arg2 = 0 ;
    ccstd::any *arg3 = 0 ;
    ccstd::any temp2 ;
    ccstd::any temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Asset_deserialize,2,SWIGTYPE_p_ccstd__any");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Asset_deserialize,3,SWIGTYPE_p_ccstd__any");
    arg3 = &temp3;
    
    (arg1)->deserialize((ccstd::any const &)*arg2,(ccstd::any const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Asset_deserialize) 

static bool js_cc_Asset__native_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_native, s.thisObject());
    SE_PRECONDITION2(ok, false, "Asset__native_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Asset__native_set) 

static bool js_cc_Asset__native_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_native, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Asset__native_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_native, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Asset__native_get) 

static bool js_cc_Asset__nativeUrl_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_nativeUrl, s.thisObject());
    SE_PRECONDITION2(ok, false, "Asset__nativeUrl_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Asset__nativeUrl_set) 

static bool js_cc_Asset__nativeUrl_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_nativeUrl, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Asset__nativeUrl_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_nativeUrl, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Asset__nativeUrl_get) 

static bool js_cc_Asset__uuid_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Asset__uuid_set,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    cc_Asset__uuid_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Asset__uuid_set) 

static bool js_cc_Asset__uuid_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    ccstd::string *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::string *) &cc_Asset__uuid_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Asset__uuid_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Asset__uuid_get) 

static bool js_cc_Asset_nativeUrl_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    ccstd::string result;
    
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_Asset_nativeUrl_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Asset_nativeUrl_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Asset_nativeUrl_get) 

static bool js_cc_Asset__nativeDep_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    cc::NativeDep result;
    
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_Asset__nativeDep_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Asset__nativeDep_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Asset__nativeDep_get) 

static bool js_cc_Asset_isDefault_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_Asset_isDefault_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Asset_isDefault_get) 

bool js_register_cc_Asset(se::Object* obj) {
    auto* cls = se::Class::create("Asset", obj, __jsb_cc_CCObject_proto, _SE(js_new_cc_Asset)); 
    
    cls->defineProperty("_native", _SE(js_cc_Asset__native_get), _SE(js_cc_Asset__native_set)); 
    cls->defineProperty("_nativeUrl", _SE(js_cc_Asset__nativeUrl_get), _SE(js_cc_Asset__nativeUrl_set)); 
    cls->defineProperty("_uuid", _SE(js_cc_Asset__uuid_get), _SE(js_cc_Asset__uuid_set)); 
    cls->defineProperty("nativeUrl", _SE(js_cc_Asset_nativeUrl_get), nullptr); 
    cls->defineProperty("_nativeDep", _SE(js_cc_Asset__nativeDep_get), nullptr); 
    cls->defineProperty("isDefault", _SE(js_cc_Asset_isDefault_get), nullptr); 
    
    cls->defineFunction("getNativeAsset", _SE(js_cc_Asset_getNativeAsset)); 
    cls->defineFunction("setNativeAsset", _SE(js_cc_Asset_setNativeAsset)); 
    cls->defineFunction("addAssetRef", _SE(js_cc_Asset_addAssetRef)); 
    cls->defineFunction("decAssetRef", _SE(js_cc_Asset_decAssetRef)); 
    cls->defineFunction("getAssetRefCount", _SE(js_cc_Asset_getAssetRefCount)); 
    cls->defineFunction("onLoaded", _SE(js_cc_Asset_onLoaded)); 
    cls->defineFunction("initDefault", _SE(js_cc_Asset_initDefault)); 
    cls->defineFunction("validate", _SE(js_cc_Asset_validate)); 
    cls->defineFunction("serialize", _SE(js_cc_Asset_serialize)); 
    cls->defineFunction("deserialize", _SE(js_cc_Asset_deserialize)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Asset));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Asset>(cls);
    
    __jsb_cc_Asset_proto = cls->getProto();
    __jsb_cc_Asset_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_TextureBase_class = nullptr;
se::Object* __jsb_cc_TextureBase_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_TextureBase) 

// js_ctor
static bool js_new_cc_TextureBase(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::TextureBase *result;
    result = (cc::TextureBase *)new cc::TextureBase();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_TextureBase, __jsb_cc_TextureBase_class, js_delete_cc_TextureBase)

static bool js_delete_cc_TextureBase(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_TextureBase) 

static bool js_cc_TextureBase_getId(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    ccstd::string *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::string *) &((cc::TextureBase const *)arg1)->getId();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBase_getId, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureBase_getId) 

static bool js_cc_TextureBase_getPixelFormat(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    cc::TextureBase::PixelFormat result;
    int32_t temp ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::TextureBase::PixelFormat)((cc::TextureBase const *)arg1)->getPixelFormat();
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureBase_getPixelFormat) 

static bool js_cc_TextureBase_getAnisotropy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::TextureBase const *)arg1)->getAnisotropy();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBase_getAnisotropy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureBase_getAnisotropy) 

static bool js_cc_TextureBase_setWrapMode__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    cc::TextureBase::WrapMode arg2 ;
    cc::TextureBase::WrapMode arg3 ;
    cc::TextureBase::WrapMode arg4 ;
    int32_t temp2 ;
    int32_t temp3 ;
    int32_t temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TextureBase_setWrapMode,2,SWIGTYPE_cc__WrapMode");
    arg2 = (cc::TextureBase::WrapMode)temp2;
    // %typemap(in) enum SWIGTYPE (int32_t temp3)
    ok &= sevalue_to_native(args[1], &temp3);
    SE_PRECONDITION2(ok, false, "TextureBase_setWrapMode,3,SWIGTYPE_cc__WrapMode");
    arg3 = (cc::TextureBase::WrapMode)temp3;
    // %typemap(in) enum SWIGTYPE (int32_t temp4)
    ok &= sevalue_to_native(args[2], &temp4);
    SE_PRECONDITION2(ok, false, "TextureBase_setWrapMode,4,SWIGTYPE_cc__WrapMode");
    arg4 = (cc::TextureBase::WrapMode)temp4;
    (arg1)->setWrapMode(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_TextureBase_setWrapMode__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    cc::TextureBase::WrapMode arg2 ;
    cc::TextureBase::WrapMode arg3 ;
    int32_t temp2 ;
    int32_t temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TextureBase_setWrapMode,2,SWIGTYPE_cc__WrapMode");
    arg2 = (cc::TextureBase::WrapMode)temp2;
    // %typemap(in) enum SWIGTYPE (int32_t temp3)
    ok &= sevalue_to_native(args[1], &temp3);
    SE_PRECONDITION2(ok, false, "TextureBase_setWrapMode,3,SWIGTYPE_cc__WrapMode");
    arg3 = (cc::TextureBase::WrapMode)temp3;
    (arg1)->setWrapMode(arg2,arg3);
    
    
    return true;
}

static bool js_cc_TextureBase_setWrapMode(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_TextureBase_setWrapMode__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_TextureBase_setWrapMode__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_TextureBase_setWrapMode) 

static bool js_cc_TextureBase_setFilters(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    cc::TextureBase::Filter arg2 ;
    cc::TextureBase::Filter arg3 ;
    int32_t temp2 ;
    int32_t temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TextureBase_setFilters,2,SWIGTYPE_cc__Filter");
    arg2 = (cc::TextureBase::Filter)temp2;
    // %typemap(in) enum SWIGTYPE (int32_t temp3)
    ok &= sevalue_to_native(args[1], &temp3);
    SE_PRECONDITION2(ok, false, "TextureBase_setFilters,3,SWIGTYPE_cc__Filter");
    arg3 = (cc::TextureBase::Filter)temp3;
    (arg1)->setFilters(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureBase_setFilters) 

static bool js_cc_TextureBase_setMipFilter(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    cc::TextureBase::Filter arg2 ;
    int32_t temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TextureBase_setMipFilter,2,SWIGTYPE_cc__Filter");
    arg2 = (cc::TextureBase::Filter)temp2;
    (arg1)->setMipFilter(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureBase_setMipFilter) 

static bool js_cc_TextureBase_setAnisotropy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureBase_setAnisotropy,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setAnisotropy(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureBase_setAnisotropy) 

static bool js_cc_TextureBase_getHash(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    ccstd::hash_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::TextureBase const *)arg1)->getHash();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBase_getHash, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureBase_getHash) 

static bool js_cc_TextureBase_getGFXTexture(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    cc::gfx::Texture *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Texture *)((cc::TextureBase const *)arg1)->getGFXTexture();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBase_getGFXTexture, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureBase_getGFXTexture) 

static bool js_cc_TextureBase_getSamplerInfo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    cc::gfx::SamplerInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::SamplerInfo *) &((cc::TextureBase const *)arg1)->getSamplerInfo();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBase_getSamplerInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureBase_getSamplerInfo) 

static bool js_cc_TextureBase_getGFXSampler(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    cc::gfx::Sampler *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Sampler *)((cc::TextureBase const *)arg1)->getGFXSampler();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBase_getGFXSampler, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureBase_getGFXSampler) 

static bool js_cc_TextureBase__format_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TextureBase__format_set,2,SWIGTYPE_cc__PixelFormat");
    arg1->_format = (cc::TextureBase::PixelFormat)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureBase__format_set) 

static bool js_cc_TextureBase__format_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->_format));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureBase__format_get) 

static bool js_cc_TextureBase__minFilter_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TextureBase__minFilter_set,2,SWIGTYPE_cc__Filter");
    arg1->_minFilter = (cc::TextureBase::Filter)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureBase__minFilter_set) 

static bool js_cc_TextureBase__minFilter_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->_minFilter));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureBase__minFilter_get) 

static bool js_cc_TextureBase__magFilter_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TextureBase__magFilter_set,2,SWIGTYPE_cc__Filter");
    arg1->_magFilter = (cc::TextureBase::Filter)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureBase__magFilter_set) 

static bool js_cc_TextureBase__magFilter_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->_magFilter));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureBase__magFilter_get) 

static bool js_cc_TextureBase__mipFilter_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TextureBase__mipFilter_set,2,SWIGTYPE_cc__Filter");
    arg1->_mipFilter = (cc::TextureBase::Filter)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureBase__mipFilter_set) 

static bool js_cc_TextureBase__mipFilter_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->_mipFilter));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureBase__mipFilter_get) 

static bool js_cc_TextureBase__wrapS_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TextureBase__wrapS_set,2,SWIGTYPE_cc__WrapMode");
    arg1->_wrapS = (cc::TextureBase::WrapMode)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureBase__wrapS_set) 

static bool js_cc_TextureBase__wrapS_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->_wrapS));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureBase__wrapS_get) 

static bool js_cc_TextureBase__wrapT_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TextureBase__wrapT_set,2,SWIGTYPE_cc__WrapMode");
    arg1->_wrapT = (cc::TextureBase::WrapMode)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureBase__wrapT_set) 

static bool js_cc_TextureBase__wrapT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->_wrapT));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureBase__wrapT_get) 

static bool js_cc_TextureBase__wrapR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TextureBase__wrapR_set,2,SWIGTYPE_cc__WrapMode");
    arg1->_wrapR = (cc::TextureBase::WrapMode)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureBase__wrapR_set) 

static bool js_cc_TextureBase__wrapR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->_wrapR));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureBase__wrapR_get) 

static bool js_cc_TextureBase__anisotropy_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_anisotropy, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureBase__anisotropy_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureBase__anisotropy_set) 

static bool js_cc_TextureBase__anisotropy_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_anisotropy, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBase__anisotropy_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_anisotropy, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureBase__anisotropy_get) 

static bool js_cc_TextureBase_isCompressed_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_TextureBase_isCompressed_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureBase_isCompressed_get) 

static bool js_cc_TextureBase__width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureBase__width_set,2,SWIGTYPE_uint32_t"); 
    
    cc_TextureBase__width_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureBase__width_set) 

static bool js_cc_TextureBase__width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_TextureBase__width_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBase__width_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureBase__width_get) 

static bool js_cc_TextureBase_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureBase_width_set,2,SWIGTYPE_uint32_t"); 
    
    cc_TextureBase_width_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureBase_width_set) 

static bool js_cc_TextureBase_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_TextureBase_width_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBase_width_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureBase_width_get) 

static bool js_cc_TextureBase__height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureBase__height_set,2,SWIGTYPE_uint32_t"); 
    
    cc_TextureBase__height_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureBase__height_set) 

static bool js_cc_TextureBase__height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_TextureBase__height_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBase__height_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureBase__height_get) 

static bool js_cc_TextureBase_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureBase_height_set,2,SWIGTYPE_uint32_t"); 
    
    cc_TextureBase_height_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureBase_height_set) 

static bool js_cc_TextureBase_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_TextureBase_height_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBase_height_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureBase_height_get) 

bool js_register_cc_TextureBase(se::Object* obj) {
    auto* cls = se::Class::create("TextureBase", obj, __jsb_cc_Asset_proto, _SE(js_new_cc_TextureBase)); 
    
    cls->defineProperty("_format", _SE(js_cc_TextureBase__format_get), _SE(js_cc_TextureBase__format_set)); 
    cls->defineProperty("_minFilter", _SE(js_cc_TextureBase__minFilter_get), _SE(js_cc_TextureBase__minFilter_set)); 
    cls->defineProperty("_magFilter", _SE(js_cc_TextureBase__magFilter_get), _SE(js_cc_TextureBase__magFilter_set)); 
    cls->defineProperty("_mipFilter", _SE(js_cc_TextureBase__mipFilter_get), _SE(js_cc_TextureBase__mipFilter_set)); 
    cls->defineProperty("_wrapS", _SE(js_cc_TextureBase__wrapS_get), _SE(js_cc_TextureBase__wrapS_set)); 
    cls->defineProperty("_wrapT", _SE(js_cc_TextureBase__wrapT_get), _SE(js_cc_TextureBase__wrapT_set)); 
    cls->defineProperty("_wrapR", _SE(js_cc_TextureBase__wrapR_get), _SE(js_cc_TextureBase__wrapR_set)); 
    cls->defineProperty("_anisotropy", _SE(js_cc_TextureBase__anisotropy_get), _SE(js_cc_TextureBase__anisotropy_set)); 
    cls->defineProperty("isCompressed", _SE(js_cc_TextureBase_isCompressed_get), nullptr); 
    cls->defineProperty("_width", _SE(js_cc_TextureBase__width_get), _SE(js_cc_TextureBase__width_set)); 
    cls->defineProperty("width", _SE(js_cc_TextureBase_width_get), _SE(js_cc_TextureBase_width_set)); 
    cls->defineProperty("_height", _SE(js_cc_TextureBase__height_get), _SE(js_cc_TextureBase__height_set)); 
    cls->defineProperty("height", _SE(js_cc_TextureBase_height_get), _SE(js_cc_TextureBase_height_set)); 
    
    cls->defineFunction("getId", _SE(js_cc_TextureBase_getId)); 
    cls->defineFunction("getPixelFormat", _SE(js_cc_TextureBase_getPixelFormat)); 
    cls->defineFunction("getAnisotropy", _SE(js_cc_TextureBase_getAnisotropy)); 
    cls->defineFunction("setWrapMode", _SE(js_cc_TextureBase_setWrapMode)); 
    cls->defineFunction("setFilters", _SE(js_cc_TextureBase_setFilters)); 
    cls->defineFunction("setMipFilter", _SE(js_cc_TextureBase_setMipFilter)); 
    cls->defineFunction("setAnisotropy", _SE(js_cc_TextureBase_setAnisotropy)); 
    cls->defineFunction("getHash", _SE(js_cc_TextureBase_getHash)); 
    cls->defineFunction("getGFXTexture", _SE(js_cc_TextureBase_getGFXTexture)); 
    cls->defineFunction("getSamplerInfo", _SE(js_cc_TextureBase_getSamplerInfo)); 
    cls->defineFunction("getGFXSampler", _SE(js_cc_TextureBase_getGFXSampler)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_TextureBase));
    
    
    cls->install();
    JSBClassType::registerClass<cc::TextureBase>(cls);
    
    __jsb_cc_TextureBase_proto = cls->getProto();
    __jsb_cc_TextureBase_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_SimpleTexture_class = nullptr;
se::Object* __jsb_cc_SimpleTexture_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_SimpleTexture) 

static bool js_delete_cc_SimpleTexture(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_SimpleTexture) 

static bool js_cc_SimpleTexture_updateImage(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SimpleTexture *arg1 = (cc::SimpleTexture *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SimpleTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->updateImage();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SimpleTexture_updateImage) 

static bool js_cc_SimpleTexture_updateMipmaps(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SimpleTexture *arg1 = (cc::SimpleTexture *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SimpleTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SimpleTexture_updateMipmaps,2,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "SimpleTexture_updateMipmaps,3,SWIGTYPE_uint32_t"); 
    
    (arg1)->updateMipmaps(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SimpleTexture_updateMipmaps) 

static bool js_cc_SimpleTexture_uploadData__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::SimpleTexture *arg1 = (cc::SimpleTexture *) NULL ;
    uint8_t *arg2 = (uint8_t *) NULL ;
    uint32_t arg3 ;
    uint32_t arg4 ;
    
    arg1 = SE_THIS_OBJECT<cc::SimpleTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SimpleTexture_uploadData,2,SWIGTYPE_p_uint8_t"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "SimpleTexture_uploadData,3,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "SimpleTexture_uploadData,4,SWIGTYPE_uint32_t"); 
    
    (arg1)->uploadData((uint8_t const *)arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_SimpleTexture_uploadData__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::SimpleTexture *arg1 = (cc::SimpleTexture *) NULL ;
    uint8_t *arg2 = (uint8_t *) NULL ;
    uint32_t arg3 ;
    
    arg1 = SE_THIS_OBJECT<cc::SimpleTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SimpleTexture_uploadData,2,SWIGTYPE_p_uint8_t"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "SimpleTexture_uploadData,3,SWIGTYPE_uint32_t"); 
    
    (arg1)->uploadData((uint8_t const *)arg2,arg3);
    
    
    return true;
}

static bool js_cc_SimpleTexture_uploadData__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::SimpleTexture *arg1 = (cc::SimpleTexture *) NULL ;
    uint8_t *arg2 = (uint8_t *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::SimpleTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SimpleTexture_uploadData,2,SWIGTYPE_p_uint8_t"); 
    (arg1)->uploadData((uint8_t const *)arg2);
    
    
    return true;
}

static bool js_cc_SimpleTexture_uploadData(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_SimpleTexture_uploadData__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_SimpleTexture_uploadData__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_SimpleTexture_uploadData__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_SimpleTexture_uploadData) 

static bool js_cc_SimpleTexture_assignImage__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::SimpleTexture *arg1 = (cc::SimpleTexture *) NULL ;
    cc::ImageAsset *arg2 = (cc::ImageAsset *) NULL ;
    uint32_t arg3 ;
    uint32_t arg4 ;
    
    arg1 = SE_THIS_OBJECT<cc::SimpleTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SimpleTexture_assignImage,2,SWIGTYPE_p_cc__ImageAsset"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "SimpleTexture_assignImage,3,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "SimpleTexture_assignImage,4,SWIGTYPE_uint32_t"); 
    
    (arg1)->assignImage(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_SimpleTexture_assignImage__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::SimpleTexture *arg1 = (cc::SimpleTexture *) NULL ;
    cc::ImageAsset *arg2 = (cc::ImageAsset *) NULL ;
    uint32_t arg3 ;
    
    arg1 = SE_THIS_OBJECT<cc::SimpleTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SimpleTexture_assignImage,2,SWIGTYPE_p_cc__ImageAsset"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "SimpleTexture_assignImage,3,SWIGTYPE_uint32_t"); 
    
    (arg1)->assignImage(arg2,arg3);
    
    
    return true;
}

static bool js_cc_SimpleTexture_assignImage(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_SimpleTexture_assignImage__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_SimpleTexture_assignImage__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_SimpleTexture_assignImage) 

static bool js_cc_SimpleTexture_checkTextureLoaded(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SimpleTexture *arg1 = (cc::SimpleTexture *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SimpleTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->checkTextureLoaded();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SimpleTexture_checkTextureLoaded) 

static bool js_cc_SimpleTexture_setMipmapLevel(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SimpleTexture *arg1 = (cc::SimpleTexture *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SimpleTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SimpleTexture_setMipmapLevel,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setMipmapLevel(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SimpleTexture_setMipmapLevel) 

static bool js_cc_SimpleTexture_setMipRange(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SimpleTexture *arg1 = (cc::SimpleTexture *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SimpleTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SimpleTexture_setMipRange,2,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "SimpleTexture_setMipRange,3,SWIGTYPE_uint32_t"); 
    
    (arg1)->setMipRange(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SimpleTexture_setMipRange) 

static bool js_cc_SimpleTexture_isUsingOfflineMipmaps(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SimpleTexture *arg1 = (cc::SimpleTexture *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SimpleTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->isUsingOfflineMipmaps();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SimpleTexture_isUsingOfflineMipmaps) 

static bool js_cc_SimpleTexture_mipmapLevel_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::SimpleTexture *arg1 = (cc::SimpleTexture *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::SimpleTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_SimpleTexture_mipmapLevel_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SimpleTexture_mipmapLevel_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_SimpleTexture_mipmapLevel_get) 

bool js_register_cc_SimpleTexture(se::Object* obj) {
    auto* cls = se::Class::create("SimpleTexture", obj, __jsb_cc_TextureBase_proto, nullptr); 
    
    cls->defineProperty("mipmapLevel", _SE(js_cc_SimpleTexture_mipmapLevel_get), nullptr); 
    
    cls->defineFunction("updateImage", _SE(js_cc_SimpleTexture_updateImage)); 
    cls->defineFunction("updateMipmaps", _SE(js_cc_SimpleTexture_updateMipmaps)); 
    cls->defineFunction("uploadData", _SE(js_cc_SimpleTexture_uploadData)); 
    cls->defineFunction("assignImage", _SE(js_cc_SimpleTexture_assignImage)); 
    cls->defineFunction("checkTextureLoaded", _SE(js_cc_SimpleTexture_checkTextureLoaded)); 
    cls->defineFunction("setMipmapLevel", _SE(js_cc_SimpleTexture_setMipmapLevel)); 
    cls->defineFunction("setMipRange", _SE(js_cc_SimpleTexture_setMipRange)); 
    cls->defineFunction("isUsingOfflineMipmaps", _SE(js_cc_SimpleTexture_isUsingOfflineMipmaps)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_SimpleTexture));
    
    
    cls->install();
    JSBClassType::registerClass<cc::SimpleTexture>(cls);
    
    __jsb_cc_SimpleTexture_proto = cls->getProto();
    __jsb_cc_SimpleTexture_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_ITexture2DSerializeData_class = nullptr;
se::Object* __jsb_cc_ITexture2DSerializeData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_ITexture2DSerializeData) 

static bool js_cc_ITexture2DSerializeData_base_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITexture2DSerializeData *arg1 = (cc::ITexture2DSerializeData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DSerializeData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->base, s.thisObject());
    SE_PRECONDITION2(ok, false, "ITexture2DSerializeData_base_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITexture2DSerializeData_base_set) 

static bool js_cc_ITexture2DSerializeData_base_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITexture2DSerializeData *arg1 = (cc::ITexture2DSerializeData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DSerializeData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->base, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ITexture2DSerializeData_base_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->base, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITexture2DSerializeData_base_get) 

static bool js_cc_ITexture2DSerializeData_mipmaps_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITexture2DSerializeData *arg1 = (cc::ITexture2DSerializeData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DSerializeData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->mipmaps, s.thisObject());
    SE_PRECONDITION2(ok, false, "ITexture2DSerializeData_mipmaps_set,2,SWIGTYPE_ccstd__vectorT_ccstd__string_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITexture2DSerializeData_mipmaps_set) 

static bool js_cc_ITexture2DSerializeData_mipmaps_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITexture2DSerializeData *arg1 = (cc::ITexture2DSerializeData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DSerializeData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->mipmaps, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ITexture2DSerializeData_mipmaps_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->mipmaps, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITexture2DSerializeData_mipmaps_get) 

// js_ctor
static bool js_new_cc_ITexture2DSerializeData(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::ITexture2DSerializeData *result;
    result = (cc::ITexture2DSerializeData *)new cc::ITexture2DSerializeData();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_ITexture2DSerializeData, __jsb_cc_ITexture2DSerializeData_class, js_delete_cc_ITexture2DSerializeData)

static bool js_delete_cc_ITexture2DSerializeData(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_ITexture2DSerializeData) 

template<>
bool sevalue_to_native(const se::Value &from, cc::ITexture2DSerializeData * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::ITexture2DSerializeData*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("base", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->base), ctx);
    }
    
    
    json->getProperty("mipmaps", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->mipmaps), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_ITexture2DSerializeData(se::Object* obj) {
    auto* cls = se::Class::create("ITexture2DSerializeData", obj, nullptr, _SE(js_new_cc_ITexture2DSerializeData)); 
    
    cls->defineProperty("base", _SE(js_cc_ITexture2DSerializeData_base_get), _SE(js_cc_ITexture2DSerializeData_base_set)); 
    cls->defineProperty("mipmaps", _SE(js_cc_ITexture2DSerializeData_mipmaps_get), _SE(js_cc_ITexture2DSerializeData_mipmaps_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_ITexture2DSerializeData));
    
    
    cls->install();
    JSBClassType::registerClass<cc::ITexture2DSerializeData>(cls);
    
    __jsb_cc_ITexture2DSerializeData_proto = cls->getProto();
    __jsb_cc_ITexture2DSerializeData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_ITexture2DCreateInfo_class = nullptr;
se::Object* __jsb_cc_ITexture2DCreateInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_ITexture2DCreateInfo) 

static bool js_cc_ITexture2DCreateInfo_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITexture2DCreateInfo *arg1 = (cc::ITexture2DCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DCreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->width, s.thisObject());
    SE_PRECONDITION2(ok, false, "ITexture2DCreateInfo_width_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITexture2DCreateInfo_width_set) 

static bool js_cc_ITexture2DCreateInfo_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITexture2DCreateInfo *arg1 = (cc::ITexture2DCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DCreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->width, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ITexture2DCreateInfo_width_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->width, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITexture2DCreateInfo_width_get) 

static bool js_cc_ITexture2DCreateInfo_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITexture2DCreateInfo *arg1 = (cc::ITexture2DCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DCreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->height, s.thisObject());
    SE_PRECONDITION2(ok, false, "ITexture2DCreateInfo_height_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITexture2DCreateInfo_height_set) 

static bool js_cc_ITexture2DCreateInfo_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITexture2DCreateInfo *arg1 = (cc::ITexture2DCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DCreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->height, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ITexture2DCreateInfo_height_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->height, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITexture2DCreateInfo_height_get) 

static bool js_cc_ITexture2DCreateInfo_format_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITexture2DCreateInfo *arg1 = (cc::ITexture2DCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DCreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->format, s.thisObject());
    SE_PRECONDITION2(ok, false, "ITexture2DCreateInfo_format_set,2,SWIGTYPE_ccstd__optionalT_cc__PixelFormat_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITexture2DCreateInfo_format_set) 

static bool js_cc_ITexture2DCreateInfo_format_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITexture2DCreateInfo *arg1 = (cc::ITexture2DCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DCreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->format, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ITexture2DCreateInfo_format_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->format, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITexture2DCreateInfo_format_get) 

static bool js_cc_ITexture2DCreateInfo_mipmapLevel_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITexture2DCreateInfo *arg1 = (cc::ITexture2DCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DCreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->mipmapLevel, s.thisObject());
    SE_PRECONDITION2(ok, false, "ITexture2DCreateInfo_mipmapLevel_set,2,SWIGTYPE_ccstd__optionalT_uint32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITexture2DCreateInfo_mipmapLevel_set) 

static bool js_cc_ITexture2DCreateInfo_mipmapLevel_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITexture2DCreateInfo *arg1 = (cc::ITexture2DCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DCreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->mipmapLevel, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ITexture2DCreateInfo_mipmapLevel_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->mipmapLevel, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITexture2DCreateInfo_mipmapLevel_get) 

static bool js_cc_ITexture2DCreateInfo_baseLevel_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITexture2DCreateInfo *arg1 = (cc::ITexture2DCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DCreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->baseLevel, s.thisObject());
    SE_PRECONDITION2(ok, false, "ITexture2DCreateInfo_baseLevel_set,2,SWIGTYPE_ccstd__optionalT_uint32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITexture2DCreateInfo_baseLevel_set) 

static bool js_cc_ITexture2DCreateInfo_baseLevel_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITexture2DCreateInfo *arg1 = (cc::ITexture2DCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DCreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->baseLevel, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ITexture2DCreateInfo_baseLevel_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->baseLevel, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITexture2DCreateInfo_baseLevel_get) 

static bool js_cc_ITexture2DCreateInfo_maxLevel_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITexture2DCreateInfo *arg1 = (cc::ITexture2DCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DCreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxLevel, s.thisObject());
    SE_PRECONDITION2(ok, false, "ITexture2DCreateInfo_maxLevel_set,2,SWIGTYPE_ccstd__optionalT_uint32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITexture2DCreateInfo_maxLevel_set) 

static bool js_cc_ITexture2DCreateInfo_maxLevel_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITexture2DCreateInfo *arg1 = (cc::ITexture2DCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DCreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxLevel, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ITexture2DCreateInfo_maxLevel_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxLevel, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITexture2DCreateInfo_maxLevel_get) 

// js_ctor
static bool js_new_cc_ITexture2DCreateInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::ITexture2DCreateInfo *result;
    result = (cc::ITexture2DCreateInfo *)new cc::ITexture2DCreateInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_ITexture2DCreateInfo, __jsb_cc_ITexture2DCreateInfo_class, js_delete_cc_ITexture2DCreateInfo)

static bool js_delete_cc_ITexture2DCreateInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_ITexture2DCreateInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::ITexture2DCreateInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::ITexture2DCreateInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("width", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->width), ctx);
    }
    
    
    json->getProperty("height", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->height), ctx);
    }
    
    
    json->getProperty("format", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->format), ctx);
    }
    
    
    json->getProperty("mipmapLevel", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->mipmapLevel), ctx);
    }
    
    
    json->getProperty("baseLevel", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->baseLevel), ctx);
    }
    
    
    json->getProperty("maxLevel", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxLevel), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_ITexture2DCreateInfo(se::Object* obj) {
    auto* cls = se::Class::create("ITexture2DCreateInfo", obj, nullptr, _SE(js_new_cc_ITexture2DCreateInfo)); 
    
    cls->defineProperty("width", _SE(js_cc_ITexture2DCreateInfo_width_get), _SE(js_cc_ITexture2DCreateInfo_width_set)); 
    cls->defineProperty("height", _SE(js_cc_ITexture2DCreateInfo_height_get), _SE(js_cc_ITexture2DCreateInfo_height_set)); 
    cls->defineProperty("format", _SE(js_cc_ITexture2DCreateInfo_format_get), _SE(js_cc_ITexture2DCreateInfo_format_set)); 
    cls->defineProperty("mipmapLevel", _SE(js_cc_ITexture2DCreateInfo_mipmapLevel_get), _SE(js_cc_ITexture2DCreateInfo_mipmapLevel_set)); 
    cls->defineProperty("baseLevel", _SE(js_cc_ITexture2DCreateInfo_baseLevel_get), _SE(js_cc_ITexture2DCreateInfo_baseLevel_set)); 
    cls->defineProperty("maxLevel", _SE(js_cc_ITexture2DCreateInfo_maxLevel_get), _SE(js_cc_ITexture2DCreateInfo_maxLevel_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_ITexture2DCreateInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::ITexture2DCreateInfo>(cls);
    
    __jsb_cc_ITexture2DCreateInfo_proto = cls->getProto();
    __jsb_cc_ITexture2DCreateInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Texture2D_class = nullptr;
se::Object* __jsb_cc_Texture2D_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Texture2D) 

// js_ctor
static bool js_new_cc_Texture2D(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::Texture2D *result;
    result = (cc::Texture2D *)new cc::Texture2D();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Texture2D, __jsb_cc_Texture2D_class, js_delete_cc_Texture2D)

static bool js_delete_cc_Texture2D(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Texture2D) 

static bool js_cc_Texture2D_getMipmaps(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::ImageAsset > > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::IntrusivePtr< cc::ImageAsset > > *) &((cc::Texture2D const *)arg1)->getMipmaps();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Texture2D_getMipmaps, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Texture2D_getMipmaps) 

static bool js_cc_Texture2D_getMipmapsUuids(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    ccstd::vector< ccstd::string > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< ccstd::string > *) &((cc::Texture2D const *)arg1)->getMipmapsUuids();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Texture2D_getMipmapsUuids, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Texture2D_getMipmapsUuids) 

static bool js_cc_Texture2D_syncMipmapsForJS(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::ImageAsset > > *arg2 = 0 ;
    ccstd::vector< cc::IntrusivePtr< cc::ImageAsset > > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture2D_syncMipmapsForJS,2,SWIGTYPE_p_ccstd__vectorT_cc__IntrusivePtrT_cc__ImageAsset_t_t");
    arg2 = &temp2;
    
    (arg1)->syncMipmapsForJS((ccstd::vector< cc::IntrusivePtr< cc::ImageAsset > > const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Texture2D_syncMipmapsForJS) 

static bool js_cc_Texture2D_setMipmaps(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::ImageAsset > > *arg2 = 0 ;
    ccstd::vector< cc::IntrusivePtr< cc::ImageAsset > > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture2D_setMipmaps,2,SWIGTYPE_p_ccstd__vectorT_cc__IntrusivePtrT_cc__ImageAsset_t_t");
    arg2 = &temp2;
    
    (arg1)->setMipmaps((ccstd::vector< cc::IntrusivePtr< cc::ImageAsset > > const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Texture2D_setMipmaps) 

static bool js_cc_Texture2D_getImage(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    cc::ImageAsset *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::ImageAsset *)((cc::Texture2D const *)arg1)->getImage();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Texture2D_getImage, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Texture2D_getImage) 

static bool js_cc_Texture2D_setImage(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    cc::ImageAsset *arg2 = (cc::ImageAsset *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture2D_setImage,2,SWIGTYPE_p_cc__ImageAsset"); 
    (arg1)->setImage(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Texture2D_setImage) 

static bool js_cc_Texture2D_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->initialize();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Texture2D_initialize) 

static bool js_cc_Texture2D_reset(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    cc::ITexture2DCreateInfo *arg2 = 0 ;
    cc::ITexture2DCreateInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture2D_reset,2,SWIGTYPE_p_cc__ITexture2DCreateInfo");
    arg2 = &temp2;
    
    (arg1)->reset((cc::ITexture2DCreateInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Texture2D_reset) 

static bool js_cc_Texture2D_create__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    cc::TextureBase::PixelFormat arg4 ;
    uint32_t arg5 ;
    uint32_t arg6 ;
    uint32_t arg7 ;
    int32_t temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture2D_create,2,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture2D_create,3,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) enum SWIGTYPE (int32_t temp4)
    ok &= sevalue_to_native(args[2], &temp4);
    SE_PRECONDITION2(ok, false, "Texture2D_create,4,SWIGTYPE_cc__PixelFormat");
    arg4 = (cc::TextureBase::PixelFormat)temp4;
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture2D_create,5,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture2D_create,6,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture2D_create,7,SWIGTYPE_uint32_t"); 
    
    (arg1)->create(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_Texture2D_create__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    cc::TextureBase::PixelFormat arg4 ;
    uint32_t arg5 ;
    uint32_t arg6 ;
    int32_t temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture2D_create,2,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture2D_create,3,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) enum SWIGTYPE (int32_t temp4)
    ok &= sevalue_to_native(args[2], &temp4);
    SE_PRECONDITION2(ok, false, "Texture2D_create,4,SWIGTYPE_cc__PixelFormat");
    arg4 = (cc::TextureBase::PixelFormat)temp4;
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture2D_create,5,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture2D_create,6,SWIGTYPE_uint32_t"); 
    
    (arg1)->create(arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_Texture2D_create__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    cc::TextureBase::PixelFormat arg4 ;
    uint32_t arg5 ;
    int32_t temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture2D_create,2,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture2D_create,3,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) enum SWIGTYPE (int32_t temp4)
    ok &= sevalue_to_native(args[2], &temp4);
    SE_PRECONDITION2(ok, false, "Texture2D_create,4,SWIGTYPE_cc__PixelFormat");
    arg4 = (cc::TextureBase::PixelFormat)temp4;
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture2D_create,5,SWIGTYPE_uint32_t"); 
    
    (arg1)->create(arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_Texture2D_create__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    cc::TextureBase::PixelFormat arg4 ;
    int32_t temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture2D_create,2,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture2D_create,3,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) enum SWIGTYPE (int32_t temp4)
    ok &= sevalue_to_native(args[2], &temp4);
    SE_PRECONDITION2(ok, false, "Texture2D_create,4,SWIGTYPE_cc__PixelFormat");
    arg4 = (cc::TextureBase::PixelFormat)temp4;
    (arg1)->create(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_Texture2D_create__SWIG_4(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture2D_create,2,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture2D_create,3,SWIGTYPE_uint32_t"); 
    
    (arg1)->create(arg2,arg3);
    
    
    return true;
}

static bool js_cc_Texture2D_create(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 6) {
        ok = js_cc_Texture2D_create__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_cc_Texture2D_create__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_Texture2D_create__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Texture2D_create__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Texture2D_create__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Texture2D_create) 

static bool js_cc_Texture2D_description(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    ccstd::string result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::Texture2D const *)arg1)->description();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Texture2D_description, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Texture2D_description) 

static bool js_cc_Texture2D_releaseTexture(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->releaseTexture();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Texture2D_releaseTexture) 

static bool js_cc_Texture2D_getGfxTextureCreateInfo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    cc::gfx::TextureUsageBit arg2 ;
    cc::gfx::Format arg3 ;
    uint32_t arg4 ;
    cc::gfx::TextureFlagBit arg5 ;
    int32_t temp2 ;
    int32_t temp3 ;
    int32_t temp5 ;
    cc::gfx::TextureInfo result;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "Texture2D_getGfxTextureCreateInfo,2,SWIGTYPE_cc__gfx__TextureUsageBit");
    arg2 = (cc::gfx::TextureUsageBit)temp2;
    // %typemap(in) enum SWIGTYPE (int32_t temp3)
    ok &= sevalue_to_native(args[1], &temp3);
    SE_PRECONDITION2(ok, false, "Texture2D_getGfxTextureCreateInfo,3,SWIGTYPE_cc__gfx__Format");
    arg3 = (cc::gfx::Format)temp3;
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture2D_getGfxTextureCreateInfo,4,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) enum SWIGTYPE (int32_t temp5)
    ok &= sevalue_to_native(args[3], &temp5);
    SE_PRECONDITION2(ok, false, "Texture2D_getGfxTextureCreateInfo,5,SWIGTYPE_cc__gfx__TextureFlagBit");
    arg5 = (cc::gfx::TextureFlagBit)temp5;
    result = (arg1)->getGfxTextureCreateInfo(arg2,arg3,arg4,arg5);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Texture2D_getGfxTextureCreateInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Texture2D_getGfxTextureCreateInfo) 

static bool js_cc_Texture2D_getGfxTextureViewCreateInfo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    cc::gfx::Texture *arg2 = (cc::gfx::Texture *) NULL ;
    cc::gfx::Format arg3 ;
    uint32_t arg4 ;
    uint32_t arg5 ;
    int32_t temp3 ;
    cc::gfx::TextureViewInfo result;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture2D_getGfxTextureViewCreateInfo,2,SWIGTYPE_p_cc__gfx__Texture"); 
    // %typemap(in) enum SWIGTYPE (int32_t temp3)
    ok &= sevalue_to_native(args[1], &temp3);
    SE_PRECONDITION2(ok, false, "Texture2D_getGfxTextureViewCreateInfo,3,SWIGTYPE_cc__gfx__Format");
    arg3 = (cc::gfx::Format)temp3;
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture2D_getGfxTextureViewCreateInfo,4,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture2D_getGfxTextureViewCreateInfo,5,SWIGTYPE_uint32_t"); 
    
    result = (arg1)->getGfxTextureViewCreateInfo(arg2,arg3,arg4,arg5);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Texture2D_getGfxTextureViewCreateInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Texture2D_getGfxTextureViewCreateInfo) 

bool js_register_cc_Texture2D(se::Object* obj) {
    auto* cls = se::Class::create("Texture2D", obj, __jsb_cc_SimpleTexture_proto, _SE(js_new_cc_Texture2D)); 
    
    
    cls->defineFunction("getMipmaps", _SE(js_cc_Texture2D_getMipmaps)); 
    cls->defineFunction("getMipmapsUuids", _SE(js_cc_Texture2D_getMipmapsUuids)); 
    cls->defineFunction("syncMipmapsForJS", _SE(js_cc_Texture2D_syncMipmapsForJS)); 
    cls->defineFunction("setMipmaps", _SE(js_cc_Texture2D_setMipmaps)); 
    cls->defineFunction("getImage", _SE(js_cc_Texture2D_getImage)); 
    cls->defineFunction("setImage", _SE(js_cc_Texture2D_setImage)); 
    cls->defineFunction("initialize", _SE(js_cc_Texture2D_initialize)); 
    cls->defineFunction("reset", _SE(js_cc_Texture2D_reset)); 
    cls->defineFunction("create", _SE(js_cc_Texture2D_create)); 
    cls->defineFunction("description", _SE(js_cc_Texture2D_description)); 
    cls->defineFunction("releaseTexture", _SE(js_cc_Texture2D_releaseTexture)); 
    cls->defineFunction("getGfxTextureCreateInfo", _SE(js_cc_Texture2D_getGfxTextureCreateInfo)); 
    cls->defineFunction("getGfxTextureViewCreateInfo", _SE(js_cc_Texture2D_getGfxTextureViewCreateInfo)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Texture2D));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Texture2D>(cls);
    
    __jsb_cc_Texture2D_proto = cls->getProto();
    __jsb_cc_Texture2D_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_ITextureCubeMipmap_class = nullptr;
se::Object* __jsb_cc_ITextureCubeMipmap_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_ITextureCubeMipmap) 

static bool js_cc_ITextureCubeMipmap_front_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureCubeMipmap *arg1 = (cc::ITextureCubeMipmap *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeMipmap>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->front, s.thisObject());
    SE_PRECONDITION2(ok, false, "ITextureCubeMipmap_front_set,2,SWIGTYPE_cc__IntrusivePtrT_cc__ImageAsset_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureCubeMipmap_front_set) 

static bool js_cc_ITextureCubeMipmap_front_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureCubeMipmap *arg1 = (cc::ITextureCubeMipmap *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeMipmap>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->front, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ITextureCubeMipmap_front_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->front, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureCubeMipmap_front_get) 

static bool js_cc_ITextureCubeMipmap_back_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureCubeMipmap *arg1 = (cc::ITextureCubeMipmap *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeMipmap>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->back, s.thisObject());
    SE_PRECONDITION2(ok, false, "ITextureCubeMipmap_back_set,2,SWIGTYPE_cc__IntrusivePtrT_cc__ImageAsset_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureCubeMipmap_back_set) 

static bool js_cc_ITextureCubeMipmap_back_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureCubeMipmap *arg1 = (cc::ITextureCubeMipmap *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeMipmap>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->back, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ITextureCubeMipmap_back_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->back, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureCubeMipmap_back_get) 

static bool js_cc_ITextureCubeMipmap_left_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureCubeMipmap *arg1 = (cc::ITextureCubeMipmap *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeMipmap>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->left, s.thisObject());
    SE_PRECONDITION2(ok, false, "ITextureCubeMipmap_left_set,2,SWIGTYPE_cc__IntrusivePtrT_cc__ImageAsset_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureCubeMipmap_left_set) 

static bool js_cc_ITextureCubeMipmap_left_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureCubeMipmap *arg1 = (cc::ITextureCubeMipmap *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeMipmap>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->left, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ITextureCubeMipmap_left_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->left, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureCubeMipmap_left_get) 

static bool js_cc_ITextureCubeMipmap_right_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureCubeMipmap *arg1 = (cc::ITextureCubeMipmap *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeMipmap>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->right, s.thisObject());
    SE_PRECONDITION2(ok, false, "ITextureCubeMipmap_right_set,2,SWIGTYPE_cc__IntrusivePtrT_cc__ImageAsset_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureCubeMipmap_right_set) 

static bool js_cc_ITextureCubeMipmap_right_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureCubeMipmap *arg1 = (cc::ITextureCubeMipmap *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeMipmap>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->right, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ITextureCubeMipmap_right_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->right, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureCubeMipmap_right_get) 

static bool js_cc_ITextureCubeMipmap_top_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureCubeMipmap *arg1 = (cc::ITextureCubeMipmap *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeMipmap>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->top, s.thisObject());
    SE_PRECONDITION2(ok, false, "ITextureCubeMipmap_top_set,2,SWIGTYPE_cc__IntrusivePtrT_cc__ImageAsset_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureCubeMipmap_top_set) 

static bool js_cc_ITextureCubeMipmap_top_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureCubeMipmap *arg1 = (cc::ITextureCubeMipmap *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeMipmap>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->top, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ITextureCubeMipmap_top_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->top, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureCubeMipmap_top_get) 

static bool js_cc_ITextureCubeMipmap_bottom_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureCubeMipmap *arg1 = (cc::ITextureCubeMipmap *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeMipmap>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->bottom, s.thisObject());
    SE_PRECONDITION2(ok, false, "ITextureCubeMipmap_bottom_set,2,SWIGTYPE_cc__IntrusivePtrT_cc__ImageAsset_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureCubeMipmap_bottom_set) 

static bool js_cc_ITextureCubeMipmap_bottom_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureCubeMipmap *arg1 = (cc::ITextureCubeMipmap *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeMipmap>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->bottom, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ITextureCubeMipmap_bottom_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->bottom, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureCubeMipmap_bottom_get) 

// js_ctor
static bool js_new_cc_ITextureCubeMipmap(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::ITextureCubeMipmap *result;
    result = (cc::ITextureCubeMipmap *)new cc::ITextureCubeMipmap();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_ITextureCubeMipmap, __jsb_cc_ITextureCubeMipmap_class, js_delete_cc_ITextureCubeMipmap)

static bool js_delete_cc_ITextureCubeMipmap(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_ITextureCubeMipmap) 

template<>
bool sevalue_to_native(const se::Value &from, cc::ITextureCubeMipmap * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::ITextureCubeMipmap*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("front", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->front), ctx);
    }
    
    
    json->getProperty("back", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->back), ctx);
    }
    
    
    json->getProperty("left", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->left), ctx);
    }
    
    
    json->getProperty("right", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->right), ctx);
    }
    
    
    json->getProperty("top", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->top), ctx);
    }
    
    
    json->getProperty("bottom", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->bottom), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_ITextureCubeMipmap(se::Object* obj) {
    auto* cls = se::Class::create("ITextureCubeMipmap", obj, nullptr, _SE(js_new_cc_ITextureCubeMipmap)); 
    
    cls->defineProperty("front", _SE(js_cc_ITextureCubeMipmap_front_get), _SE(js_cc_ITextureCubeMipmap_front_set)); 
    cls->defineProperty("back", _SE(js_cc_ITextureCubeMipmap_back_get), _SE(js_cc_ITextureCubeMipmap_back_set)); 
    cls->defineProperty("left", _SE(js_cc_ITextureCubeMipmap_left_get), _SE(js_cc_ITextureCubeMipmap_left_set)); 
    cls->defineProperty("right", _SE(js_cc_ITextureCubeMipmap_right_get), _SE(js_cc_ITextureCubeMipmap_right_set)); 
    cls->defineProperty("top", _SE(js_cc_ITextureCubeMipmap_top_get), _SE(js_cc_ITextureCubeMipmap_top_set)); 
    cls->defineProperty("bottom", _SE(js_cc_ITextureCubeMipmap_bottom_get), _SE(js_cc_ITextureCubeMipmap_bottom_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_ITextureCubeMipmap));
    
    
    cls->install();
    JSBClassType::registerClass<cc::ITextureCubeMipmap>(cls);
    
    __jsb_cc_ITextureCubeMipmap_proto = cls->getProto();
    __jsb_cc_ITextureCubeMipmap_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_ITextureCubeSerializeMipmapData_class = nullptr;
se::Object* __jsb_cc_ITextureCubeSerializeMipmapData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_ITextureCubeSerializeMipmapData) 

static bool js_cc_ITextureCubeSerializeMipmapData_front_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureCubeSerializeMipmapData *arg1 = (cc::ITextureCubeSerializeMipmapData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeSerializeMipmapData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->front, s.thisObject());
    SE_PRECONDITION2(ok, false, "ITextureCubeSerializeMipmapData_front_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureCubeSerializeMipmapData_front_set) 

static bool js_cc_ITextureCubeSerializeMipmapData_front_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureCubeSerializeMipmapData *arg1 = (cc::ITextureCubeSerializeMipmapData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeSerializeMipmapData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->front, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ITextureCubeSerializeMipmapData_front_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->front, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureCubeSerializeMipmapData_front_get) 

static bool js_cc_ITextureCubeSerializeMipmapData_back_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureCubeSerializeMipmapData *arg1 = (cc::ITextureCubeSerializeMipmapData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeSerializeMipmapData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->back, s.thisObject());
    SE_PRECONDITION2(ok, false, "ITextureCubeSerializeMipmapData_back_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureCubeSerializeMipmapData_back_set) 

static bool js_cc_ITextureCubeSerializeMipmapData_back_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureCubeSerializeMipmapData *arg1 = (cc::ITextureCubeSerializeMipmapData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeSerializeMipmapData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->back, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ITextureCubeSerializeMipmapData_back_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->back, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureCubeSerializeMipmapData_back_get) 

static bool js_cc_ITextureCubeSerializeMipmapData_left_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureCubeSerializeMipmapData *arg1 = (cc::ITextureCubeSerializeMipmapData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeSerializeMipmapData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->left, s.thisObject());
    SE_PRECONDITION2(ok, false, "ITextureCubeSerializeMipmapData_left_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureCubeSerializeMipmapData_left_set) 

static bool js_cc_ITextureCubeSerializeMipmapData_left_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureCubeSerializeMipmapData *arg1 = (cc::ITextureCubeSerializeMipmapData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeSerializeMipmapData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->left, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ITextureCubeSerializeMipmapData_left_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->left, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureCubeSerializeMipmapData_left_get) 

static bool js_cc_ITextureCubeSerializeMipmapData_right_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureCubeSerializeMipmapData *arg1 = (cc::ITextureCubeSerializeMipmapData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeSerializeMipmapData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->right, s.thisObject());
    SE_PRECONDITION2(ok, false, "ITextureCubeSerializeMipmapData_right_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureCubeSerializeMipmapData_right_set) 

static bool js_cc_ITextureCubeSerializeMipmapData_right_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureCubeSerializeMipmapData *arg1 = (cc::ITextureCubeSerializeMipmapData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeSerializeMipmapData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->right, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ITextureCubeSerializeMipmapData_right_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->right, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureCubeSerializeMipmapData_right_get) 

static bool js_cc_ITextureCubeSerializeMipmapData_top_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureCubeSerializeMipmapData *arg1 = (cc::ITextureCubeSerializeMipmapData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeSerializeMipmapData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->top, s.thisObject());
    SE_PRECONDITION2(ok, false, "ITextureCubeSerializeMipmapData_top_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureCubeSerializeMipmapData_top_set) 

static bool js_cc_ITextureCubeSerializeMipmapData_top_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureCubeSerializeMipmapData *arg1 = (cc::ITextureCubeSerializeMipmapData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeSerializeMipmapData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->top, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ITextureCubeSerializeMipmapData_top_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->top, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureCubeSerializeMipmapData_top_get) 

static bool js_cc_ITextureCubeSerializeMipmapData_bottom_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureCubeSerializeMipmapData *arg1 = (cc::ITextureCubeSerializeMipmapData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeSerializeMipmapData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->bottom, s.thisObject());
    SE_PRECONDITION2(ok, false, "ITextureCubeSerializeMipmapData_bottom_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureCubeSerializeMipmapData_bottom_set) 

static bool js_cc_ITextureCubeSerializeMipmapData_bottom_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureCubeSerializeMipmapData *arg1 = (cc::ITextureCubeSerializeMipmapData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeSerializeMipmapData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->bottom, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ITextureCubeSerializeMipmapData_bottom_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->bottom, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureCubeSerializeMipmapData_bottom_get) 

// js_ctor
static bool js_new_cc_ITextureCubeSerializeMipmapData(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::ITextureCubeSerializeMipmapData *result;
    result = (cc::ITextureCubeSerializeMipmapData *)new cc::ITextureCubeSerializeMipmapData();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_ITextureCubeSerializeMipmapData, __jsb_cc_ITextureCubeSerializeMipmapData_class, js_delete_cc_ITextureCubeSerializeMipmapData)

static bool js_delete_cc_ITextureCubeSerializeMipmapData(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_ITextureCubeSerializeMipmapData) 

template<>
bool sevalue_to_native(const se::Value &from, cc::ITextureCubeSerializeMipmapData * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::ITextureCubeSerializeMipmapData*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("front", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->front), ctx);
    }
    
    
    json->getProperty("back", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->back), ctx);
    }
    
    
    json->getProperty("left", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->left), ctx);
    }
    
    
    json->getProperty("right", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->right), ctx);
    }
    
    
    json->getProperty("top", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->top), ctx);
    }
    
    
    json->getProperty("bottom", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->bottom), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_ITextureCubeSerializeMipmapData(se::Object* obj) {
    auto* cls = se::Class::create("ITextureCubeSerializeMipmapData", obj, nullptr, _SE(js_new_cc_ITextureCubeSerializeMipmapData)); 
    
    cls->defineProperty("front", _SE(js_cc_ITextureCubeSerializeMipmapData_front_get), _SE(js_cc_ITextureCubeSerializeMipmapData_front_set)); 
    cls->defineProperty("back", _SE(js_cc_ITextureCubeSerializeMipmapData_back_get), _SE(js_cc_ITextureCubeSerializeMipmapData_back_set)); 
    cls->defineProperty("left", _SE(js_cc_ITextureCubeSerializeMipmapData_left_get), _SE(js_cc_ITextureCubeSerializeMipmapData_left_set)); 
    cls->defineProperty("right", _SE(js_cc_ITextureCubeSerializeMipmapData_right_get), _SE(js_cc_ITextureCubeSerializeMipmapData_right_set)); 
    cls->defineProperty("top", _SE(js_cc_ITextureCubeSerializeMipmapData_top_get), _SE(js_cc_ITextureCubeSerializeMipmapData_top_set)); 
    cls->defineProperty("bottom", _SE(js_cc_ITextureCubeSerializeMipmapData_bottom_get), _SE(js_cc_ITextureCubeSerializeMipmapData_bottom_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_ITextureCubeSerializeMipmapData));
    
    
    cls->install();
    JSBClassType::registerClass<cc::ITextureCubeSerializeMipmapData>(cls);
    
    __jsb_cc_ITextureCubeSerializeMipmapData_proto = cls->getProto();
    __jsb_cc_ITextureCubeSerializeMipmapData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_MipmapAtlasLayoutInfo_class = nullptr;
se::Object* __jsb_cc_MipmapAtlasLayoutInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_MipmapAtlasLayoutInfo) 

static bool js_cc_MipmapAtlasLayoutInfo_left_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MipmapAtlasLayoutInfo *arg1 = (cc::MipmapAtlasLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MipmapAtlasLayoutInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->left, s.thisObject());
    SE_PRECONDITION2(ok, false, "MipmapAtlasLayoutInfo_left_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_MipmapAtlasLayoutInfo_left_set) 

static bool js_cc_MipmapAtlasLayoutInfo_left_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::MipmapAtlasLayoutInfo *arg1 = (cc::MipmapAtlasLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MipmapAtlasLayoutInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->left, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MipmapAtlasLayoutInfo_left_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->left, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_MipmapAtlasLayoutInfo_left_get) 

static bool js_cc_MipmapAtlasLayoutInfo_top_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MipmapAtlasLayoutInfo *arg1 = (cc::MipmapAtlasLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MipmapAtlasLayoutInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->top, s.thisObject());
    SE_PRECONDITION2(ok, false, "MipmapAtlasLayoutInfo_top_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_MipmapAtlasLayoutInfo_top_set) 

static bool js_cc_MipmapAtlasLayoutInfo_top_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::MipmapAtlasLayoutInfo *arg1 = (cc::MipmapAtlasLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MipmapAtlasLayoutInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->top, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MipmapAtlasLayoutInfo_top_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->top, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_MipmapAtlasLayoutInfo_top_get) 

static bool js_cc_MipmapAtlasLayoutInfo_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MipmapAtlasLayoutInfo *arg1 = (cc::MipmapAtlasLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MipmapAtlasLayoutInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->width, s.thisObject());
    SE_PRECONDITION2(ok, false, "MipmapAtlasLayoutInfo_width_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_MipmapAtlasLayoutInfo_width_set) 

static bool js_cc_MipmapAtlasLayoutInfo_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::MipmapAtlasLayoutInfo *arg1 = (cc::MipmapAtlasLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MipmapAtlasLayoutInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->width, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MipmapAtlasLayoutInfo_width_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->width, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_MipmapAtlasLayoutInfo_width_get) 

static bool js_cc_MipmapAtlasLayoutInfo_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MipmapAtlasLayoutInfo *arg1 = (cc::MipmapAtlasLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MipmapAtlasLayoutInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->height, s.thisObject());
    SE_PRECONDITION2(ok, false, "MipmapAtlasLayoutInfo_height_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_MipmapAtlasLayoutInfo_height_set) 

static bool js_cc_MipmapAtlasLayoutInfo_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::MipmapAtlasLayoutInfo *arg1 = (cc::MipmapAtlasLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MipmapAtlasLayoutInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->height, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MipmapAtlasLayoutInfo_height_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->height, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_MipmapAtlasLayoutInfo_height_get) 

static bool js_cc_MipmapAtlasLayoutInfo_level_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MipmapAtlasLayoutInfo *arg1 = (cc::MipmapAtlasLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MipmapAtlasLayoutInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->level, s.thisObject());
    SE_PRECONDITION2(ok, false, "MipmapAtlasLayoutInfo_level_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_MipmapAtlasLayoutInfo_level_set) 

static bool js_cc_MipmapAtlasLayoutInfo_level_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::MipmapAtlasLayoutInfo *arg1 = (cc::MipmapAtlasLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MipmapAtlasLayoutInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->level, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MipmapAtlasLayoutInfo_level_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->level, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_MipmapAtlasLayoutInfo_level_get) 

// js_ctor
static bool js_new_cc_MipmapAtlasLayoutInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::MipmapAtlasLayoutInfo *result;
    result = (cc::MipmapAtlasLayoutInfo *)new cc::MipmapAtlasLayoutInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_MipmapAtlasLayoutInfo, __jsb_cc_MipmapAtlasLayoutInfo_class, js_delete_cc_MipmapAtlasLayoutInfo)

static bool js_delete_cc_MipmapAtlasLayoutInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_MipmapAtlasLayoutInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::MipmapAtlasLayoutInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::MipmapAtlasLayoutInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("left", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->left), ctx);
    }
    
    
    json->getProperty("top", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->top), ctx);
    }
    
    
    json->getProperty("width", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->width), ctx);
    }
    
    
    json->getProperty("height", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->height), ctx);
    }
    
    
    json->getProperty("level", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->level), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_MipmapAtlasLayoutInfo(se::Object* obj) {
    auto* cls = se::Class::create("MipmapAtlasLayoutInfo", obj, nullptr, _SE(js_new_cc_MipmapAtlasLayoutInfo)); 
    
    cls->defineProperty("left", _SE(js_cc_MipmapAtlasLayoutInfo_left_get), _SE(js_cc_MipmapAtlasLayoutInfo_left_set)); 
    cls->defineProperty("top", _SE(js_cc_MipmapAtlasLayoutInfo_top_get), _SE(js_cc_MipmapAtlasLayoutInfo_top_set)); 
    cls->defineProperty("width", _SE(js_cc_MipmapAtlasLayoutInfo_width_get), _SE(js_cc_MipmapAtlasLayoutInfo_width_set)); 
    cls->defineProperty("height", _SE(js_cc_MipmapAtlasLayoutInfo_height_get), _SE(js_cc_MipmapAtlasLayoutInfo_height_set)); 
    cls->defineProperty("level", _SE(js_cc_MipmapAtlasLayoutInfo_level_get), _SE(js_cc_MipmapAtlasLayoutInfo_level_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_MipmapAtlasLayoutInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::MipmapAtlasLayoutInfo>(cls);
    
    __jsb_cc_MipmapAtlasLayoutInfo_proto = cls->getProto();
    __jsb_cc_MipmapAtlasLayoutInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_TextureCubeMipmapAtlasInfo_class = nullptr;
se::Object* __jsb_cc_TextureCubeMipmapAtlasInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_TextureCubeMipmapAtlasInfo) 

static bool js_cc_TextureCubeMipmapAtlasInfo_atlas_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCubeMipmapAtlasInfo *arg1 = (cc::TextureCubeMipmapAtlasInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeMipmapAtlasInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->atlas, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureCubeMipmapAtlasInfo_atlas_set,2,SWIGTYPE_cc__ITextureCubeMipmap"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureCubeMipmapAtlasInfo_atlas_set) 

static bool js_cc_TextureCubeMipmapAtlasInfo_atlas_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureCubeMipmapAtlasInfo *arg1 = (cc::TextureCubeMipmapAtlasInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeMipmapAtlasInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->atlas, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureCubeMipmapAtlasInfo_atlas_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->atlas, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureCubeMipmapAtlasInfo_atlas_get) 

static bool js_cc_TextureCubeMipmapAtlasInfo_layout_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCubeMipmapAtlasInfo *arg1 = (cc::TextureCubeMipmapAtlasInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeMipmapAtlasInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->layout, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureCubeMipmapAtlasInfo_layout_set,2,SWIGTYPE_ccstd__vectorT_cc__MipmapAtlasLayoutInfo_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureCubeMipmapAtlasInfo_layout_set) 

static bool js_cc_TextureCubeMipmapAtlasInfo_layout_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureCubeMipmapAtlasInfo *arg1 = (cc::TextureCubeMipmapAtlasInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeMipmapAtlasInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->layout, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureCubeMipmapAtlasInfo_layout_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->layout, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureCubeMipmapAtlasInfo_layout_get) 

// js_ctor
static bool js_new_cc_TextureCubeMipmapAtlasInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::TextureCubeMipmapAtlasInfo *result;
    result = (cc::TextureCubeMipmapAtlasInfo *)new cc::TextureCubeMipmapAtlasInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_TextureCubeMipmapAtlasInfo, __jsb_cc_TextureCubeMipmapAtlasInfo_class, js_delete_cc_TextureCubeMipmapAtlasInfo)

static bool js_delete_cc_TextureCubeMipmapAtlasInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_TextureCubeMipmapAtlasInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::TextureCubeMipmapAtlasInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::TextureCubeMipmapAtlasInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("atlas", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->atlas), ctx);
    }
    
    
    json->getProperty("layout", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->layout), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_TextureCubeMipmapAtlasInfo(se::Object* obj) {
    auto* cls = se::Class::create("TextureCubeMipmapAtlasInfo", obj, nullptr, _SE(js_new_cc_TextureCubeMipmapAtlasInfo)); 
    
    cls->defineProperty("atlas", _SE(js_cc_TextureCubeMipmapAtlasInfo_atlas_get), _SE(js_cc_TextureCubeMipmapAtlasInfo_atlas_set)); 
    cls->defineProperty("layout", _SE(js_cc_TextureCubeMipmapAtlasInfo_layout_get), _SE(js_cc_TextureCubeMipmapAtlasInfo_layout_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_TextureCubeMipmapAtlasInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::TextureCubeMipmapAtlasInfo>(cls);
    
    __jsb_cc_TextureCubeMipmapAtlasInfo_proto = cls->getProto();
    __jsb_cc_TextureCubeMipmapAtlasInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_TextureCubeSerializeData_class = nullptr;
se::Object* __jsb_cc_TextureCubeSerializeData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_TextureCubeSerializeData) 

static bool js_cc_TextureCubeSerializeData_base_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCubeSerializeData *arg1 = (cc::TextureCubeSerializeData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeSerializeData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->base, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureCubeSerializeData_base_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureCubeSerializeData_base_set) 

static bool js_cc_TextureCubeSerializeData_base_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureCubeSerializeData *arg1 = (cc::TextureCubeSerializeData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeSerializeData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->base, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureCubeSerializeData_base_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->base, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureCubeSerializeData_base_get) 

static bool js_cc_TextureCubeSerializeData_rgbe_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCubeSerializeData *arg1 = (cc::TextureCubeSerializeData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeSerializeData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->rgbe);
    SE_PRECONDITION2(ok, false, "TextureCubeSerializeData_rgbe_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureCubeSerializeData_rgbe_set) 

static bool js_cc_TextureCubeSerializeData_rgbe_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureCubeSerializeData *arg1 = (cc::TextureCubeSerializeData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeSerializeData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->rgbe, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureCubeSerializeData_rgbe_get) 

static bool js_cc_TextureCubeSerializeData_mipmapMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCubeSerializeData *arg1 = (cc::TextureCubeSerializeData *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeSerializeData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TextureCubeSerializeData_mipmapMode_set,2,SWIGTYPE_cc__MipmapMode");
    arg1->mipmapMode = (cc::MipmapMode)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureCubeSerializeData_mipmapMode_set) 

static bool js_cc_TextureCubeSerializeData_mipmapMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureCubeSerializeData *arg1 = (cc::TextureCubeSerializeData *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeSerializeData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->mipmapMode));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureCubeSerializeData_mipmapMode_get) 

static bool js_cc_TextureCubeSerializeData_mipmaps_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCubeSerializeData *arg1 = (cc::TextureCubeSerializeData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeSerializeData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->mipmaps, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureCubeSerializeData_mipmaps_set,2,SWIGTYPE_ccstd__vectorT_cc__ITextureCubeSerializeMipmapData_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureCubeSerializeData_mipmaps_set) 

static bool js_cc_TextureCubeSerializeData_mipmaps_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureCubeSerializeData *arg1 = (cc::TextureCubeSerializeData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeSerializeData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->mipmaps, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureCubeSerializeData_mipmaps_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->mipmaps, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureCubeSerializeData_mipmaps_get) 

static bool js_cc_TextureCubeSerializeData_mipmapAtlas_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCubeSerializeData *arg1 = (cc::TextureCubeSerializeData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeSerializeData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->mipmapAtlas, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureCubeSerializeData_mipmapAtlas_set,2,SWIGTYPE_cc__TextureCubeMipmapAtlasInfo"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureCubeSerializeData_mipmapAtlas_set) 

static bool js_cc_TextureCubeSerializeData_mipmapAtlas_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureCubeSerializeData *arg1 = (cc::TextureCubeSerializeData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeSerializeData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->mipmapAtlas, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureCubeSerializeData_mipmapAtlas_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->mipmapAtlas, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureCubeSerializeData_mipmapAtlas_get) 

// js_ctor
static bool js_new_cc_TextureCubeSerializeData(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::TextureCubeSerializeData *result;
    result = (cc::TextureCubeSerializeData *)new cc::TextureCubeSerializeData();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_TextureCubeSerializeData, __jsb_cc_TextureCubeSerializeData_class, js_delete_cc_TextureCubeSerializeData)

static bool js_delete_cc_TextureCubeSerializeData(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_TextureCubeSerializeData) 

template<>
bool sevalue_to_native(const se::Value &from, cc::TextureCubeSerializeData * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::TextureCubeSerializeData*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("base", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->base), ctx);
    }
    
    
    json->getProperty("rgbe", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->rgbe), ctx);
    }
    
    
    json->getProperty("mipmapMode", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->mipmapMode), ctx);
    }
    
    
    json->getProperty("mipmaps", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->mipmaps), ctx);
    }
    
    
    json->getProperty("mipmapAtlas", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->mipmapAtlas), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_TextureCubeSerializeData(se::Object* obj) {
    auto* cls = se::Class::create("TextureCubeSerializeData", obj, nullptr, _SE(js_new_cc_TextureCubeSerializeData)); 
    
    cls->defineProperty("base", _SE(js_cc_TextureCubeSerializeData_base_get), _SE(js_cc_TextureCubeSerializeData_base_set)); 
    cls->defineProperty("rgbe", _SE(js_cc_TextureCubeSerializeData_rgbe_get), _SE(js_cc_TextureCubeSerializeData_rgbe_set)); 
    cls->defineProperty("mipmapMode", _SE(js_cc_TextureCubeSerializeData_mipmapMode_get), _SE(js_cc_TextureCubeSerializeData_mipmapMode_set)); 
    cls->defineProperty("mipmaps", _SE(js_cc_TextureCubeSerializeData_mipmaps_get), _SE(js_cc_TextureCubeSerializeData_mipmaps_set)); 
    cls->defineProperty("mipmapAtlas", _SE(js_cc_TextureCubeSerializeData_mipmapAtlas_get), _SE(js_cc_TextureCubeSerializeData_mipmapAtlas_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_TextureCubeSerializeData));
    
    
    cls->install();
    JSBClassType::registerClass<cc::TextureCubeSerializeData>(cls);
    
    __jsb_cc_TextureCubeSerializeData_proto = cls->getProto();
    __jsb_cc_TextureCubeSerializeData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_TextureCube_class = nullptr;
se::Object* __jsb_cc_TextureCube_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_TextureCube) 

// js_ctor
static bool js_new_cc_TextureCube(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::TextureCube *result;
    result = (cc::TextureCube *)new cc::TextureCube();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_TextureCube, __jsb_cc_TextureCube_class, js_delete_cc_TextureCube)

static bool js_delete_cc_TextureCube(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_TextureCube) 

static bool js_cc_TextureCube_fromTexture2DArray_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    ccstd::vector< cc::Texture2D * > *arg1 = 0 ;
    ccstd::vector< cc::Texture2D * > temp1 ;
    cc::TextureCube *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureCube_fromTexture2DArray,1,SWIGTYPE_p_ccstd__vectorT_cc__Texture2D_p_t");
    arg1 = &temp1;
    
    result = (cc::TextureCube *)cc::TextureCube::fromTexture2DArray((ccstd::vector< cc::Texture2D * > const &)*arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureCube_fromTexture2DArray, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_fromTexture2DArray_static) 

static bool js_cc_TextureCube_getMipmaps(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    ccstd::vector< cc::ITextureCubeMipmap > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::ITextureCubeMipmap > *) &((cc::TextureCube const *)arg1)->getMipmaps();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureCube_getMipmaps, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_getMipmaps) 

static bool js_cc_TextureCube_getMipmapAtlas(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    cc::TextureCubeMipmapAtlasInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::TextureCubeMipmapAtlasInfo *) &((cc::TextureCube const *)arg1)->getMipmapAtlas();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureCube_getMipmapAtlas, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_getMipmapAtlas) 

static bool js_cc_TextureCube_setMipmaps(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    ccstd::vector< cc::ITextureCubeMipmap > *arg2 = 0 ;
    ccstd::vector< cc::ITextureCubeMipmap > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureCube_setMipmaps,2,SWIGTYPE_p_ccstd__vectorT_cc__ITextureCubeMipmap_t");
    arg2 = &temp2;
    
    (arg1)->setMipmaps((ccstd::vector< cc::ITextureCubeMipmap > const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_setMipmaps) 

static bool js_cc_TextureCube_setMipmapsForJS(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    ccstd::vector< cc::ITextureCubeMipmap > *arg2 = 0 ;
    ccstd::vector< cc::ITextureCubeMipmap > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureCube_setMipmapsForJS,2,SWIGTYPE_p_ccstd__vectorT_cc__ITextureCubeMipmap_t");
    arg2 = &temp2;
    
    (arg1)->setMipmapsForJS((ccstd::vector< cc::ITextureCubeMipmap > const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_setMipmapsForJS) 

static bool js_cc_TextureCube_setMipmapAtlasForJS(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    cc::TextureCubeMipmapAtlasInfo *arg2 = 0 ;
    cc::TextureCubeMipmapAtlasInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureCube_setMipmapAtlasForJS,2,SWIGTYPE_p_cc__TextureCubeMipmapAtlasInfo");
    arg2 = &temp2;
    
    (arg1)->setMipmapAtlasForJS((cc::TextureCubeMipmapAtlasInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_setMipmapAtlasForJS) 

static bool js_cc_TextureCube_setMipmapAtlas(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    cc::TextureCubeMipmapAtlasInfo *arg2 = 0 ;
    cc::TextureCubeMipmapAtlasInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureCube_setMipmapAtlas,2,SWIGTYPE_p_cc__TextureCubeMipmapAtlasInfo");
    arg2 = &temp2;
    
    (arg1)->setMipmapAtlas((cc::TextureCubeMipmapAtlasInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_setMipmapAtlas) 

static bool js_cc_TextureCube_getImage(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    cc::ITextureCubeMipmap *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::ITextureCubeMipmap *)((cc::TextureCube const *)arg1)->getImage();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureCube_getImage, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_getImage) 

static bool js_cc_TextureCube_setImage(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    cc::ITextureCubeMipmap *arg2 = (cc::ITextureCubeMipmap *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureCube_setImage,2,SWIGTYPE_p_cc__ITextureCubeMipmap"); 
    (arg1)->setImage((cc::ITextureCubeMipmap const *)arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_setImage) 

static bool js_cc_TextureCube_reset(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    cc::ITextureCubeCreateInfo *arg2 = 0 ;
    cc::ITextureCubeCreateInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureCube_reset,2,SWIGTYPE_p_cc__ITexture2DCreateInfo");
    arg2 = &temp2;
    
    (arg1)->reset((cc::ITextureCubeCreateInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_reset) 

static bool js_cc_TextureCube_releaseTexture(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->releaseTexture();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_releaseTexture) 

static bool js_cc_TextureCube_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->initialize();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_initialize) 

static bool js_cc_TextureCube_getGfxTextureCreateInfo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    cc::gfx::TextureUsageBit arg2 ;
    cc::gfx::Format arg3 ;
    uint32_t arg4 ;
    cc::gfx::TextureFlagBit arg5 ;
    int32_t temp2 ;
    int32_t temp3 ;
    int32_t temp5 ;
    cc::gfx::TextureInfo result;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TextureCube_getGfxTextureCreateInfo,2,SWIGTYPE_cc__gfx__TextureUsageBit");
    arg2 = (cc::gfx::TextureUsageBit)temp2;
    // %typemap(in) enum SWIGTYPE (int32_t temp3)
    ok &= sevalue_to_native(args[1], &temp3);
    SE_PRECONDITION2(ok, false, "TextureCube_getGfxTextureCreateInfo,3,SWIGTYPE_cc__gfx__Format");
    arg3 = (cc::gfx::Format)temp3;
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureCube_getGfxTextureCreateInfo,4,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) enum SWIGTYPE (int32_t temp5)
    ok &= sevalue_to_native(args[3], &temp5);
    SE_PRECONDITION2(ok, false, "TextureCube_getGfxTextureCreateInfo,5,SWIGTYPE_cc__gfx__TextureFlagBit");
    arg5 = (cc::gfx::TextureFlagBit)temp5;
    result = (arg1)->getGfxTextureCreateInfo(arg2,arg3,arg4,arg5);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureCube_getGfxTextureCreateInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_getGfxTextureCreateInfo) 

static bool js_cc_TextureCube_getGfxTextureViewCreateInfo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    cc::gfx::Texture *arg2 = (cc::gfx::Texture *) NULL ;
    cc::gfx::Format arg3 ;
    uint32_t arg4 ;
    uint32_t arg5 ;
    int32_t temp3 ;
    cc::gfx::TextureViewInfo result;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureCube_getGfxTextureViewCreateInfo,2,SWIGTYPE_p_cc__gfx__Texture"); 
    // %typemap(in) enum SWIGTYPE (int32_t temp3)
    ok &= sevalue_to_native(args[1], &temp3);
    SE_PRECONDITION2(ok, false, "TextureCube_getGfxTextureViewCreateInfo,3,SWIGTYPE_cc__gfx__Format");
    arg3 = (cc::gfx::Format)temp3;
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureCube_getGfxTextureViewCreateInfo,4,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureCube_getGfxTextureViewCreateInfo,5,SWIGTYPE_uint32_t"); 
    
    result = (arg1)->getGfxTextureViewCreateInfo(arg2,arg3,arg4,arg5);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureCube_getGfxTextureViewCreateInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_getGfxTextureViewCreateInfo) 

static bool js_cc_TextureCube__mipmapMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TextureCube__mipmapMode_set,2,SWIGTYPE_cc__MipmapMode");
    arg1->_mipmapMode = (cc::MipmapMode)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureCube__mipmapMode_set) 

static bool js_cc_TextureCube__mipmapMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->_mipmapMode));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureCube__mipmapMode_get) 

static bool js_cc_TextureCube_isRGBE_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->isRGBE);
    SE_PRECONDITION2(ok, false, "TextureCube_isRGBE_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureCube_isRGBE_set) 

static bool js_cc_TextureCube_isRGBE_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->isRGBE, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureCube_isRGBE_get) 

bool js_register_cc_TextureCube(se::Object* obj) {
    auto* cls = se::Class::create("TextureCube", obj, __jsb_cc_SimpleTexture_proto, _SE(js_new_cc_TextureCube)); 
    
    cls->defineProperty("_mipmapMode", _SE(js_cc_TextureCube__mipmapMode_get), _SE(js_cc_TextureCube__mipmapMode_set)); 
    cls->defineProperty("isRGBE", _SE(js_cc_TextureCube_isRGBE_get), _SE(js_cc_TextureCube_isRGBE_set)); 
    
    cls->defineFunction("getMipmaps", _SE(js_cc_TextureCube_getMipmaps)); 
    cls->defineFunction("getMipmapAtlas", _SE(js_cc_TextureCube_getMipmapAtlas)); 
    cls->defineFunction("setMipmaps", _SE(js_cc_TextureCube_setMipmaps)); 
    cls->defineFunction("setMipmapsForJS", _SE(js_cc_TextureCube_setMipmapsForJS)); 
    cls->defineFunction("setMipmapAtlasForJS", _SE(js_cc_TextureCube_setMipmapAtlasForJS)); 
    cls->defineFunction("setMipmapAtlas", _SE(js_cc_TextureCube_setMipmapAtlas)); 
    cls->defineFunction("getImage", _SE(js_cc_TextureCube_getImage)); 
    cls->defineFunction("setImage", _SE(js_cc_TextureCube_setImage)); 
    cls->defineFunction("reset", _SE(js_cc_TextureCube_reset)); 
    cls->defineFunction("releaseTexture", _SE(js_cc_TextureCube_releaseTexture)); 
    cls->defineFunction("initialize", _SE(js_cc_TextureCube_initialize)); 
    cls->defineFunction("getGfxTextureCreateInfo", _SE(js_cc_TextureCube_getGfxTextureCreateInfo)); 
    cls->defineFunction("getGfxTextureViewCreateInfo", _SE(js_cc_TextureCube_getGfxTextureViewCreateInfo)); 
    
    
    cls->defineStaticFunction("fromTexture2DArray", _SE(js_cc_TextureCube_fromTexture2DArray_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_TextureCube));
    
    
    cls->install();
    JSBClassType::registerClass<cc::TextureCube>(cls);
    
    __jsb_cc_TextureCube_proto = cls->getProto();
    __jsb_cc_TextureCube_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IRenderTextureCreateInfo_class = nullptr;
se::Object* __jsb_cc_IRenderTextureCreateInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IRenderTextureCreateInfo) 

static bool js_cc_IRenderTextureCreateInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IRenderTextureCreateInfo *arg1 = (cc::IRenderTextureCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IRenderTextureCreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "IRenderTextureCreateInfo_name_set,2,SWIGTYPE_ccstd__optionalT_ccstd__string_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IRenderTextureCreateInfo_name_set) 

static bool js_cc_IRenderTextureCreateInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IRenderTextureCreateInfo *arg1 = (cc::IRenderTextureCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IRenderTextureCreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IRenderTextureCreateInfo_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IRenderTextureCreateInfo_name_get) 

static bool js_cc_IRenderTextureCreateInfo_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IRenderTextureCreateInfo *arg1 = (cc::IRenderTextureCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IRenderTextureCreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->width, s.thisObject());
    SE_PRECONDITION2(ok, false, "IRenderTextureCreateInfo_width_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IRenderTextureCreateInfo_width_set) 

static bool js_cc_IRenderTextureCreateInfo_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IRenderTextureCreateInfo *arg1 = (cc::IRenderTextureCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IRenderTextureCreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->width, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IRenderTextureCreateInfo_width_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->width, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IRenderTextureCreateInfo_width_get) 

static bool js_cc_IRenderTextureCreateInfo_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IRenderTextureCreateInfo *arg1 = (cc::IRenderTextureCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IRenderTextureCreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->height, s.thisObject());
    SE_PRECONDITION2(ok, false, "IRenderTextureCreateInfo_height_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IRenderTextureCreateInfo_height_set) 

static bool js_cc_IRenderTextureCreateInfo_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IRenderTextureCreateInfo *arg1 = (cc::IRenderTextureCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IRenderTextureCreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->height, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IRenderTextureCreateInfo_height_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->height, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IRenderTextureCreateInfo_height_get) 

static bool js_cc_IRenderTextureCreateInfo_passInfo_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IRenderTextureCreateInfo *arg1 = (cc::IRenderTextureCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IRenderTextureCreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->passInfo, s.thisObject());
    SE_PRECONDITION2(ok, false, "IRenderTextureCreateInfo_passInfo_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__RenderPassInfo_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IRenderTextureCreateInfo_passInfo_set) 

static bool js_cc_IRenderTextureCreateInfo_passInfo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IRenderTextureCreateInfo *arg1 = (cc::IRenderTextureCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IRenderTextureCreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->passInfo, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IRenderTextureCreateInfo_passInfo_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->passInfo, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IRenderTextureCreateInfo_passInfo_get) 

// js_ctor
static bool js_new_cc_IRenderTextureCreateInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IRenderTextureCreateInfo *result;
    result = (cc::IRenderTextureCreateInfo *)new cc::IRenderTextureCreateInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IRenderTextureCreateInfo, __jsb_cc_IRenderTextureCreateInfo_class, js_delete_cc_IRenderTextureCreateInfo)

static bool js_delete_cc_IRenderTextureCreateInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IRenderTextureCreateInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IRenderTextureCreateInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IRenderTextureCreateInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("width", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->width), ctx);
    }
    
    
    json->getProperty("height", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->height), ctx);
    }
    
    
    json->getProperty("passInfo", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->passInfo), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IRenderTextureCreateInfo(se::Object* obj) {
    auto* cls = se::Class::create("IRenderTextureCreateInfo", obj, nullptr, _SE(js_new_cc_IRenderTextureCreateInfo)); 
    
    cls->defineProperty("name", _SE(js_cc_IRenderTextureCreateInfo_name_get), _SE(js_cc_IRenderTextureCreateInfo_name_set)); 
    cls->defineProperty("width", _SE(js_cc_IRenderTextureCreateInfo_width_get), _SE(js_cc_IRenderTextureCreateInfo_width_set)); 
    cls->defineProperty("height", _SE(js_cc_IRenderTextureCreateInfo_height_get), _SE(js_cc_IRenderTextureCreateInfo_height_set)); 
    cls->defineProperty("passInfo", _SE(js_cc_IRenderTextureCreateInfo_passInfo_get), _SE(js_cc_IRenderTextureCreateInfo_passInfo_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IRenderTextureCreateInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IRenderTextureCreateInfo>(cls);
    
    __jsb_cc_IRenderTextureCreateInfo_proto = cls->getProto();
    __jsb_cc_IRenderTextureCreateInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_RenderTexture_class = nullptr;
se::Object* __jsb_cc_RenderTexture_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_RenderTexture) 

// js_ctor
static bool js_new_cc_RenderTexture(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::RenderTexture *result;
    result = (cc::RenderTexture *)new cc::RenderTexture();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_RenderTexture, __jsb_cc_RenderTexture_class, js_delete_cc_RenderTexture)

static bool js_delete_cc_RenderTexture(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_RenderTexture) 

static bool js_cc_RenderTexture_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderTexture *arg1 = (cc::RenderTexture *) NULL ;
    cc::IRenderTextureCreateInfo *arg2 = 0 ;
    cc::IRenderTextureCreateInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderTexture_initialize,2,SWIGTYPE_p_cc__IRenderTextureCreateInfo");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::IRenderTextureCreateInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderTexture_initialize) 

static bool js_cc_RenderTexture_reset(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderTexture *arg1 = (cc::RenderTexture *) NULL ;
    cc::IRenderTextureCreateInfo *arg2 = 0 ;
    cc::IRenderTextureCreateInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderTexture_reset,2,SWIGTYPE_p_cc__IRenderTextureCreateInfo");
    arg2 = &temp2;
    
    (arg1)->reset((cc::IRenderTextureCreateInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderTexture_reset) 

static bool js_cc_RenderTexture_resize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderTexture *arg1 = (cc::RenderTexture *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderTexture_resize,2,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderTexture_resize,3,SWIGTYPE_uint32_t"); 
    
    (arg1)->resize(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderTexture_resize) 

static bool js_cc_RenderTexture_initWindow__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::RenderTexture *arg1 = (cc::RenderTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->initWindow();
    
    
    return true;
}

static bool js_cc_RenderTexture_initWindow__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::RenderTexture *arg1 = (cc::RenderTexture *) NULL ;
    cc::IRenderTextureCreateInfo *arg2 = 0 ;
    cc::IRenderTextureCreateInfo temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderTexture_initWindow,2,SWIGTYPE_p_cc__IRenderTextureCreateInfo");
    arg2 = &temp2;
    
    (arg1)->initWindow((cc::IRenderTextureCreateInfo const &)*arg2);
    
    
    return true;
}

static bool js_cc_RenderTexture_initWindow(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 0) {
        ok = js_cc_RenderTexture_initWindow__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_RenderTexture_initWindow__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_RenderTexture_initWindow) 

static bool js_cc_RenderTexture_readPixels(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderTexture *arg1 = (cc::RenderTexture *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    uint32_t arg4 ;
    uint32_t arg5 ;
    ccstd::vector< uint8_t > result;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderTexture_readPixels,2,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderTexture_readPixels,3,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderTexture_readPixels,4,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderTexture_readPixels,5,SWIGTYPE_uint32_t"); 
    
    result = ((cc::RenderTexture const *)arg1)->readPixels(arg2,arg3,arg4,arg5);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderTexture_readPixels, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderTexture_readPixels) 

static bool js_cc_RenderTexture_window_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderTexture *arg1 = (cc::RenderTexture *) NULL ;
    cc::scene::RenderWindow *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::RenderWindow *)cc_RenderTexture_window_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderTexture_window_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderTexture_window_get) 

bool js_register_cc_RenderTexture(se::Object* obj) {
    auto* cls = se::Class::create("RenderTexture", obj, __jsb_cc_TextureBase_proto, _SE(js_new_cc_RenderTexture)); 
    
    cls->defineProperty("window", _SE(js_cc_RenderTexture_window_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_RenderTexture_initialize)); 
    cls->defineFunction("reset", _SE(js_cc_RenderTexture_reset)); 
    cls->defineFunction("resize", _SE(js_cc_RenderTexture_resize)); 
    cls->defineFunction("initWindow", _SE(js_cc_RenderTexture_initWindow)); 
    cls->defineFunction("readPixels", _SE(js_cc_RenderTexture_readPixels)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_RenderTexture));
    
    
    cls->install();
    JSBClassType::registerClass<cc::RenderTexture>(cls);
    
    __jsb_cc_RenderTexture_proto = cls->getProto();
    __jsb_cc_RenderTexture_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_BufferAsset_class = nullptr;
se::Object* __jsb_cc_BufferAsset_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_BufferAsset) 

// js_ctor
static bool js_new_cc_BufferAsset(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::BufferAsset *result;
    result = (cc::BufferAsset *)new cc::BufferAsset();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_BufferAsset, __jsb_cc_BufferAsset_class, js_delete_cc_BufferAsset)

static bool js_delete_cc_BufferAsset(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_BufferAsset) 

static bool js_cc_BufferAsset_buffer(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BufferAsset *arg1 = (cc::BufferAsset *) NULL ;
    cc::ArrayBuffer *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BufferAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::ArrayBuffer *)((cc::BufferAsset const *)arg1)->getBuffer();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BufferAsset_buffer, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BufferAsset_buffer) 

static bool js_cc_BufferAsset__nativeAsset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BufferAsset *arg1 = (cc::BufferAsset *) NULL ;
    cc::ArrayBuffer *arg2 = (cc::ArrayBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BufferAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BufferAsset__nativeAsset_set,2,SWIGTYPE_p_cc__ArrayBuffer"); 
    cc_BufferAsset__nativeAsset_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BufferAsset__nativeAsset_set) 

static bool js_cc_BufferAsset__nativeAsset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BufferAsset *arg1 = (cc::BufferAsset *) NULL ;
    cc::ArrayBuffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::BufferAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::ArrayBuffer *)cc_BufferAsset__nativeAsset_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BufferAsset__nativeAsset_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BufferAsset__nativeAsset_get) 

bool js_register_cc_BufferAsset(se::Object* obj) {
    auto* cls = se::Class::create("BufferAsset", obj, __jsb_cc_Asset_proto, _SE(js_new_cc_BufferAsset)); 
    
    cls->defineProperty("_nativeAsset", _SE(js_cc_BufferAsset__nativeAsset_get), _SE(js_cc_BufferAsset__nativeAsset_set)); 
    
    cls->defineFunction("buffer", _SE(js_cc_BufferAsset_buffer)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_BufferAsset));
    
    
    cls->install();
    JSBClassType::registerClass<cc::BufferAsset>(cls);
    
    __jsb_cc_BufferAsset_proto = cls->getProto();
    __jsb_cc_BufferAsset_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IPropertyInfo_class = nullptr;
se::Object* __jsb_cc_IPropertyInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IPropertyInfo) 

static bool js_cc_IPropertyInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPropertyInfo *arg1 = (cc::IPropertyInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPropertyInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->type, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPropertyInfo_type_set,2,SWIGTYPE_int32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPropertyInfo_type_set) 

static bool js_cc_IPropertyInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPropertyInfo *arg1 = (cc::IPropertyInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPropertyInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->type, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPropertyInfo_type_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->type, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPropertyInfo_type_get) 

static bool js_cc_IPropertyInfo_handleInfo_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPropertyInfo *arg1 = (cc::IPropertyInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPropertyInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->handleInfo, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPropertyInfo_handleInfo_set,2,SWIGTYPE_ccstd__optionalT_cc__IPropertyHandleInfo_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPropertyInfo_handleInfo_set) 

static bool js_cc_IPropertyInfo_handleInfo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPropertyInfo *arg1 = (cc::IPropertyInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPropertyInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->handleInfo, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPropertyInfo_handleInfo_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->handleInfo, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPropertyInfo_handleInfo_get) 

static bool js_cc_IPropertyInfo_samplerHash_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPropertyInfo *arg1 = (cc::IPropertyInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPropertyInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->samplerHash, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPropertyInfo_samplerHash_set,2,SWIGTYPE_ccstd__optionalT_ccstd__hash_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPropertyInfo_samplerHash_set) 

static bool js_cc_IPropertyInfo_samplerHash_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPropertyInfo *arg1 = (cc::IPropertyInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPropertyInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->samplerHash, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPropertyInfo_samplerHash_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->samplerHash, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPropertyInfo_samplerHash_get) 

static bool js_cc_IPropertyInfo_value_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPropertyInfo *arg1 = (cc::IPropertyInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPropertyInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->value, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPropertyInfo_value_set,2,SWIGTYPE_ccstd__optionalT_ccstd__variantT_ccstd__vectorT_float_t_ccstd__string_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPropertyInfo_value_set) 

static bool js_cc_IPropertyInfo_value_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPropertyInfo *arg1 = (cc::IPropertyInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPropertyInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->value, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPropertyInfo_value_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->value, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPropertyInfo_value_get) 

static bool js_cc_IPropertyInfo_linear_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPropertyInfo *arg1 = (cc::IPropertyInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPropertyInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->linear, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPropertyInfo_linear_set,2,SWIGTYPE_ccstd__optionalT_bool_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPropertyInfo_linear_set) 

static bool js_cc_IPropertyInfo_linear_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPropertyInfo *arg1 = (cc::IPropertyInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPropertyInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->linear, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPropertyInfo_linear_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->linear, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPropertyInfo_linear_get) 

// js_ctor
static bool js_new_cc_IPropertyInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IPropertyInfo *result;
    result = (cc::IPropertyInfo *)new cc::IPropertyInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IPropertyInfo, __jsb_cc_IPropertyInfo_class, js_delete_cc_IPropertyInfo)

static bool js_delete_cc_IPropertyInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IPropertyInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IPropertyInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IPropertyInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("handleInfo", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->handleInfo), ctx);
    }
    
    
    json->getProperty("samplerHash", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->samplerHash), ctx);
    }
    
    
    json->getProperty("value", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->value), ctx);
    }
    
    
    json->getProperty("linear", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->linear), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IPropertyInfo(se::Object* obj) {
    auto* cls = se::Class::create("IPropertyInfo", obj, nullptr, _SE(js_new_cc_IPropertyInfo)); 
    
    cls->defineProperty("type", _SE(js_cc_IPropertyInfo_type_get), _SE(js_cc_IPropertyInfo_type_set)); 
    cls->defineProperty("handleInfo", _SE(js_cc_IPropertyInfo_handleInfo_get), _SE(js_cc_IPropertyInfo_handleInfo_set)); 
    cls->defineProperty("samplerHash", _SE(js_cc_IPropertyInfo_samplerHash_get), _SE(js_cc_IPropertyInfo_samplerHash_set)); 
    cls->defineProperty("value", _SE(js_cc_IPropertyInfo_value_get), _SE(js_cc_IPropertyInfo_value_set)); 
    cls->defineProperty("linear", _SE(js_cc_IPropertyInfo_linear_get), _SE(js_cc_IPropertyInfo_linear_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IPropertyInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IPropertyInfo>(cls);
    
    __jsb_cc_IPropertyInfo_proto = cls->getProto();
    __jsb_cc_IPropertyInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_RasterizerStateInfo_class = nullptr;
se::Object* __jsb_cc_RasterizerStateInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_RasterizerStateInfo) 

static bool js_cc_RasterizerStateInfo_isDiscard_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->isDiscard, s.thisObject());
    SE_PRECONDITION2(ok, false, "RasterizerStateInfo_isDiscard_set,2,SWIGTYPE_ccstd__optionalT_bool_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RasterizerStateInfo_isDiscard_set) 

static bool js_cc_RasterizerStateInfo_isDiscard_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->isDiscard, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RasterizerStateInfo_isDiscard_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->isDiscard, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RasterizerStateInfo_isDiscard_get) 

static bool js_cc_RasterizerStateInfo_isFrontFaceCCW_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->isFrontFaceCCW, s.thisObject());
    SE_PRECONDITION2(ok, false, "RasterizerStateInfo_isFrontFaceCCW_set,2,SWIGTYPE_ccstd__optionalT_bool_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RasterizerStateInfo_isFrontFaceCCW_set) 

static bool js_cc_RasterizerStateInfo_isFrontFaceCCW_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->isFrontFaceCCW, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RasterizerStateInfo_isFrontFaceCCW_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->isFrontFaceCCW, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RasterizerStateInfo_isFrontFaceCCW_get) 

static bool js_cc_RasterizerStateInfo_depthBiasEnabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->depthBiasEnabled, s.thisObject());
    SE_PRECONDITION2(ok, false, "RasterizerStateInfo_depthBiasEnabled_set,2,SWIGTYPE_ccstd__optionalT_bool_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RasterizerStateInfo_depthBiasEnabled_set) 

static bool js_cc_RasterizerStateInfo_depthBiasEnabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->depthBiasEnabled, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RasterizerStateInfo_depthBiasEnabled_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthBiasEnabled, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RasterizerStateInfo_depthBiasEnabled_get) 

static bool js_cc_RasterizerStateInfo_isDepthClip_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->isDepthClip, s.thisObject());
    SE_PRECONDITION2(ok, false, "RasterizerStateInfo_isDepthClip_set,2,SWIGTYPE_ccstd__optionalT_bool_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RasterizerStateInfo_isDepthClip_set) 

static bool js_cc_RasterizerStateInfo_isDepthClip_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->isDepthClip, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RasterizerStateInfo_isDepthClip_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->isDepthClip, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RasterizerStateInfo_isDepthClip_get) 

static bool js_cc_RasterizerStateInfo_isMultisample_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->isMultisample, s.thisObject());
    SE_PRECONDITION2(ok, false, "RasterizerStateInfo_isMultisample_set,2,SWIGTYPE_ccstd__optionalT_bool_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RasterizerStateInfo_isMultisample_set) 

static bool js_cc_RasterizerStateInfo_isMultisample_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->isMultisample, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RasterizerStateInfo_isMultisample_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->isMultisample, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RasterizerStateInfo_isMultisample_get) 

static bool js_cc_RasterizerStateInfo_polygonMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->polygonMode, s.thisObject());
    SE_PRECONDITION2(ok, false, "RasterizerStateInfo_polygonMode_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__PolygonMode_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RasterizerStateInfo_polygonMode_set) 

static bool js_cc_RasterizerStateInfo_polygonMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->polygonMode, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RasterizerStateInfo_polygonMode_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->polygonMode, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RasterizerStateInfo_polygonMode_get) 

static bool js_cc_RasterizerStateInfo_shadeModel_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->shadeModel, s.thisObject());
    SE_PRECONDITION2(ok, false, "RasterizerStateInfo_shadeModel_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__ShadeModel_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RasterizerStateInfo_shadeModel_set) 

static bool js_cc_RasterizerStateInfo_shadeModel_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->shadeModel, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RasterizerStateInfo_shadeModel_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->shadeModel, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RasterizerStateInfo_shadeModel_get) 

static bool js_cc_RasterizerStateInfo_cullMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->cullMode, s.thisObject());
    SE_PRECONDITION2(ok, false, "RasterizerStateInfo_cullMode_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__CullMode_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RasterizerStateInfo_cullMode_set) 

static bool js_cc_RasterizerStateInfo_cullMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->cullMode, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RasterizerStateInfo_cullMode_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->cullMode, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RasterizerStateInfo_cullMode_get) 

static bool js_cc_RasterizerStateInfo_depthBias_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->depthBias, s.thisObject());
    SE_PRECONDITION2(ok, false, "RasterizerStateInfo_depthBias_set,2,SWIGTYPE_ccstd__optionalT_float_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RasterizerStateInfo_depthBias_set) 

static bool js_cc_RasterizerStateInfo_depthBias_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->depthBias, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RasterizerStateInfo_depthBias_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthBias, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RasterizerStateInfo_depthBias_get) 

static bool js_cc_RasterizerStateInfo_depthBiasClamp_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->depthBiasClamp, s.thisObject());
    SE_PRECONDITION2(ok, false, "RasterizerStateInfo_depthBiasClamp_set,2,SWIGTYPE_ccstd__optionalT_float_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RasterizerStateInfo_depthBiasClamp_set) 

static bool js_cc_RasterizerStateInfo_depthBiasClamp_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->depthBiasClamp, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RasterizerStateInfo_depthBiasClamp_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthBiasClamp, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RasterizerStateInfo_depthBiasClamp_get) 

static bool js_cc_RasterizerStateInfo_depthBiasSlop_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->depthBiasSlop, s.thisObject());
    SE_PRECONDITION2(ok, false, "RasterizerStateInfo_depthBiasSlop_set,2,SWIGTYPE_ccstd__optionalT_float_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RasterizerStateInfo_depthBiasSlop_set) 

static bool js_cc_RasterizerStateInfo_depthBiasSlop_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->depthBiasSlop, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RasterizerStateInfo_depthBiasSlop_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthBiasSlop, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RasterizerStateInfo_depthBiasSlop_get) 

static bool js_cc_RasterizerStateInfo_lineWidth_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->lineWidth, s.thisObject());
    SE_PRECONDITION2(ok, false, "RasterizerStateInfo_lineWidth_set,2,SWIGTYPE_ccstd__optionalT_float_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RasterizerStateInfo_lineWidth_set) 

static bool js_cc_RasterizerStateInfo_lineWidth_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->lineWidth, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RasterizerStateInfo_lineWidth_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->lineWidth, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RasterizerStateInfo_lineWidth_get) 

static bool js_cc_RasterizerStateInfo_fromGFXRasterizerState(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    cc::gfx::RasterizerState *arg2 = 0 ;
    cc::gfx::RasterizerState temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RasterizerStateInfo_fromGFXRasterizerState,2,SWIGTYPE_p_cc__gfx__RasterizerState");
    arg2 = &temp2;
    
    (arg1)->fromGFXRasterizerState((cc::gfx::RasterizerState const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RasterizerStateInfo_fromGFXRasterizerState) 

static bool js_cc_RasterizerStateInfo_assignToGFXRasterizerState(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    cc::gfx::RasterizerState *arg2 = 0 ;
    cc::gfx::RasterizerState temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RasterizerStateInfo_assignToGFXRasterizerState,2,SWIGTYPE_p_cc__gfx__RasterizerState");
    arg2 = &temp2;
    
    ((cc::RasterizerStateInfo const *)arg1)->assignToGFXRasterizerState(*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RasterizerStateInfo_assignToGFXRasterizerState) 

// js_ctor
static bool js_new_cc_RasterizerStateInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::RasterizerStateInfo *result;
    result = (cc::RasterizerStateInfo *)new cc::RasterizerStateInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_RasterizerStateInfo, __jsb_cc_RasterizerStateInfo_class, js_delete_cc_RasterizerStateInfo)

static bool js_delete_cc_RasterizerStateInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_RasterizerStateInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::RasterizerStateInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::RasterizerStateInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("isDiscard", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isDiscard), ctx);
    }
    
    
    json->getProperty("isFrontFaceCCW", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isFrontFaceCCW), ctx);
    }
    
    
    json->getProperty("depthBiasEnabled", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthBiasEnabled), ctx);
    }
    
    
    json->getProperty("isDepthClip", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isDepthClip), ctx);
    }
    
    
    json->getProperty("isMultisample", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isMultisample), ctx);
    }
    
    
    json->getProperty("polygonMode", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->polygonMode), ctx);
    }
    
    
    json->getProperty("shadeModel", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->shadeModel), ctx);
    }
    
    
    json->getProperty("cullMode", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->cullMode), ctx);
    }
    
    
    json->getProperty("depthBias", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthBias), ctx);
    }
    
    
    json->getProperty("depthBiasClamp", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthBiasClamp), ctx);
    }
    
    
    json->getProperty("depthBiasSlop", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthBiasSlop), ctx);
    }
    
    
    json->getProperty("lineWidth", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->lineWidth), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_RasterizerStateInfo(se::Object* obj) {
    auto* cls = se::Class::create("RasterizerStateInfo", obj, nullptr, _SE(js_new_cc_RasterizerStateInfo)); 
    
    cls->defineProperty("isDiscard", _SE(js_cc_RasterizerStateInfo_isDiscard_get), _SE(js_cc_RasterizerStateInfo_isDiscard_set)); 
    cls->defineProperty("isFrontFaceCCW", _SE(js_cc_RasterizerStateInfo_isFrontFaceCCW_get), _SE(js_cc_RasterizerStateInfo_isFrontFaceCCW_set)); 
    cls->defineProperty("depthBiasEnabled", _SE(js_cc_RasterizerStateInfo_depthBiasEnabled_get), _SE(js_cc_RasterizerStateInfo_depthBiasEnabled_set)); 
    cls->defineProperty("isDepthClip", _SE(js_cc_RasterizerStateInfo_isDepthClip_get), _SE(js_cc_RasterizerStateInfo_isDepthClip_set)); 
    cls->defineProperty("isMultisample", _SE(js_cc_RasterizerStateInfo_isMultisample_get), _SE(js_cc_RasterizerStateInfo_isMultisample_set)); 
    cls->defineProperty("polygonMode", _SE(js_cc_RasterizerStateInfo_polygonMode_get), _SE(js_cc_RasterizerStateInfo_polygonMode_set)); 
    cls->defineProperty("shadeModel", _SE(js_cc_RasterizerStateInfo_shadeModel_get), _SE(js_cc_RasterizerStateInfo_shadeModel_set)); 
    cls->defineProperty("cullMode", _SE(js_cc_RasterizerStateInfo_cullMode_get), _SE(js_cc_RasterizerStateInfo_cullMode_set)); 
    cls->defineProperty("depthBias", _SE(js_cc_RasterizerStateInfo_depthBias_get), _SE(js_cc_RasterizerStateInfo_depthBias_set)); 
    cls->defineProperty("depthBiasClamp", _SE(js_cc_RasterizerStateInfo_depthBiasClamp_get), _SE(js_cc_RasterizerStateInfo_depthBiasClamp_set)); 
    cls->defineProperty("depthBiasSlop", _SE(js_cc_RasterizerStateInfo_depthBiasSlop_get), _SE(js_cc_RasterizerStateInfo_depthBiasSlop_set)); 
    cls->defineProperty("lineWidth", _SE(js_cc_RasterizerStateInfo_lineWidth_get), _SE(js_cc_RasterizerStateInfo_lineWidth_set)); 
    
    cls->defineFunction("fromGFXRasterizerState", _SE(js_cc_RasterizerStateInfo_fromGFXRasterizerState)); 
    cls->defineFunction("assignToGFXRasterizerState", _SE(js_cc_RasterizerStateInfo_assignToGFXRasterizerState)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_RasterizerStateInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::RasterizerStateInfo>(cls);
    
    __jsb_cc_RasterizerStateInfo_proto = cls->getProto();
    __jsb_cc_RasterizerStateInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_DepthStencilStateInfo_class = nullptr;
se::Object* __jsb_cc_DepthStencilStateInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_DepthStencilStateInfo) 

static bool js_cc_DepthStencilStateInfo_depthTest_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->depthTest, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_depthTest_set,2,SWIGTYPE_ccstd__optionalT_bool_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_depthTest_set) 

static bool js_cc_DepthStencilStateInfo_depthTest_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->depthTest, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_depthTest_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthTest, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_depthTest_get) 

static bool js_cc_DepthStencilStateInfo_depthWrite_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->depthWrite, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_depthWrite_set,2,SWIGTYPE_ccstd__optionalT_bool_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_depthWrite_set) 

static bool js_cc_DepthStencilStateInfo_depthWrite_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->depthWrite, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_depthWrite_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthWrite, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_depthWrite_get) 

static bool js_cc_DepthStencilStateInfo_stencilTestFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stencilTestFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilTestFront_set,2,SWIGTYPE_ccstd__optionalT_bool_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilTestFront_set) 

static bool js_cc_DepthStencilStateInfo_stencilTestFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stencilTestFront, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilTestFront_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilTestFront, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilTestFront_get) 

static bool js_cc_DepthStencilStateInfo_stencilTestBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stencilTestBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilTestBack_set,2,SWIGTYPE_ccstd__optionalT_bool_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilTestBack_set) 

static bool js_cc_DepthStencilStateInfo_stencilTestBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stencilTestBack, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilTestBack_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilTestBack, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilTestBack_get) 

static bool js_cc_DepthStencilStateInfo_depthFunc_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->depthFunc, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_depthFunc_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__ComparisonFunc_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_depthFunc_set) 

static bool js_cc_DepthStencilStateInfo_depthFunc_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->depthFunc, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_depthFunc_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthFunc, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_depthFunc_get) 

static bool js_cc_DepthStencilStateInfo_stencilFuncFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stencilFuncFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilFuncFront_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__ComparisonFunc_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilFuncFront_set) 

static bool js_cc_DepthStencilStateInfo_stencilFuncFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stencilFuncFront, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilFuncFront_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilFuncFront, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilFuncFront_get) 

static bool js_cc_DepthStencilStateInfo_stencilReadMaskFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stencilReadMaskFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilReadMaskFront_set,2,SWIGTYPE_ccstd__optionalT_uint32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilReadMaskFront_set) 

static bool js_cc_DepthStencilStateInfo_stencilReadMaskFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stencilReadMaskFront, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilReadMaskFront_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilReadMaskFront, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilReadMaskFront_get) 

static bool js_cc_DepthStencilStateInfo_stencilWriteMaskFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stencilWriteMaskFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilWriteMaskFront_set,2,SWIGTYPE_ccstd__optionalT_uint32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilWriteMaskFront_set) 

static bool js_cc_DepthStencilStateInfo_stencilWriteMaskFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stencilWriteMaskFront, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilWriteMaskFront_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilWriteMaskFront, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilWriteMaskFront_get) 

static bool js_cc_DepthStencilStateInfo_stencilFailOpFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stencilFailOpFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilFailOpFront_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__StencilOp_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilFailOpFront_set) 

static bool js_cc_DepthStencilStateInfo_stencilFailOpFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stencilFailOpFront, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilFailOpFront_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilFailOpFront, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilFailOpFront_get) 

static bool js_cc_DepthStencilStateInfo_stencilZFailOpFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stencilZFailOpFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilZFailOpFront_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__StencilOp_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilZFailOpFront_set) 

static bool js_cc_DepthStencilStateInfo_stencilZFailOpFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stencilZFailOpFront, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilZFailOpFront_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilZFailOpFront, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilZFailOpFront_get) 

static bool js_cc_DepthStencilStateInfo_stencilPassOpFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stencilPassOpFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilPassOpFront_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__StencilOp_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilPassOpFront_set) 

static bool js_cc_DepthStencilStateInfo_stencilPassOpFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stencilPassOpFront, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilPassOpFront_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilPassOpFront, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilPassOpFront_get) 

static bool js_cc_DepthStencilStateInfo_stencilRefFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stencilRefFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilRefFront_set,2,SWIGTYPE_ccstd__optionalT_uint32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilRefFront_set) 

static bool js_cc_DepthStencilStateInfo_stencilRefFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stencilRefFront, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilRefFront_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilRefFront, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilRefFront_get) 

static bool js_cc_DepthStencilStateInfo_stencilFuncBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stencilFuncBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilFuncBack_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__ComparisonFunc_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilFuncBack_set) 

static bool js_cc_DepthStencilStateInfo_stencilFuncBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stencilFuncBack, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilFuncBack_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilFuncBack, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilFuncBack_get) 

static bool js_cc_DepthStencilStateInfo_stencilReadMaskBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stencilReadMaskBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilReadMaskBack_set,2,SWIGTYPE_ccstd__optionalT_uint32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilReadMaskBack_set) 

static bool js_cc_DepthStencilStateInfo_stencilReadMaskBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stencilReadMaskBack, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilReadMaskBack_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilReadMaskBack, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilReadMaskBack_get) 

static bool js_cc_DepthStencilStateInfo_stencilWriteMaskBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stencilWriteMaskBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilWriteMaskBack_set,2,SWIGTYPE_ccstd__optionalT_uint32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilWriteMaskBack_set) 

static bool js_cc_DepthStencilStateInfo_stencilWriteMaskBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stencilWriteMaskBack, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilWriteMaskBack_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilWriteMaskBack, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilWriteMaskBack_get) 

static bool js_cc_DepthStencilStateInfo_stencilFailOpBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stencilFailOpBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilFailOpBack_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__StencilOp_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilFailOpBack_set) 

static bool js_cc_DepthStencilStateInfo_stencilFailOpBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stencilFailOpBack, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilFailOpBack_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilFailOpBack, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilFailOpBack_get) 

static bool js_cc_DepthStencilStateInfo_stencilZFailOpBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stencilZFailOpBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilZFailOpBack_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__StencilOp_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilZFailOpBack_set) 

static bool js_cc_DepthStencilStateInfo_stencilZFailOpBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stencilZFailOpBack, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilZFailOpBack_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilZFailOpBack, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilZFailOpBack_get) 

static bool js_cc_DepthStencilStateInfo_stencilPassOpBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stencilPassOpBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilPassOpBack_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__StencilOp_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilPassOpBack_set) 

static bool js_cc_DepthStencilStateInfo_stencilPassOpBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stencilPassOpBack, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilPassOpBack_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilPassOpBack, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilPassOpBack_get) 

static bool js_cc_DepthStencilStateInfo_stencilRefBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stencilRefBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilRefBack_set,2,SWIGTYPE_ccstd__optionalT_uint32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilRefBack_set) 

static bool js_cc_DepthStencilStateInfo_stencilRefBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stencilRefBack, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_stencilRefBack_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilRefBack, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilRefBack_get) 

static bool js_cc_DepthStencilStateInfo_fromGFXDepthStencilState(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    cc::gfx::DepthStencilState *arg2 = 0 ;
    cc::gfx::DepthStencilState temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_fromGFXDepthStencilState,2,SWIGTYPE_p_cc__gfx__DepthStencilState");
    arg2 = &temp2;
    
    (arg1)->fromGFXDepthStencilState((cc::gfx::DepthStencilState const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_DepthStencilStateInfo_fromGFXDepthStencilState) 

static bool js_cc_DepthStencilStateInfo_assignToGFXDepthStencilState(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    cc::gfx::DepthStencilState *arg2 = 0 ;
    cc::gfx::DepthStencilState temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilStateInfo_assignToGFXDepthStencilState,2,SWIGTYPE_p_cc__gfx__DepthStencilState");
    arg2 = &temp2;
    
    ((cc::DepthStencilStateInfo const *)arg1)->assignToGFXDepthStencilState(*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_DepthStencilStateInfo_assignToGFXDepthStencilState) 

// js_ctor
static bool js_new_cc_DepthStencilStateInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::DepthStencilStateInfo *result;
    result = (cc::DepthStencilStateInfo *)new cc::DepthStencilStateInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_DepthStencilStateInfo, __jsb_cc_DepthStencilStateInfo_class, js_delete_cc_DepthStencilStateInfo)

static bool js_delete_cc_DepthStencilStateInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_DepthStencilStateInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::DepthStencilStateInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::DepthStencilStateInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("depthTest", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthTest), ctx);
    }
    
    
    json->getProperty("depthWrite", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthWrite), ctx);
    }
    
    
    json->getProperty("stencilTestFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilTestFront), ctx);
    }
    
    
    json->getProperty("stencilTestBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilTestBack), ctx);
    }
    
    
    json->getProperty("depthFunc", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthFunc), ctx);
    }
    
    
    json->getProperty("stencilFuncFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilFuncFront), ctx);
    }
    
    
    json->getProperty("stencilReadMaskFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilReadMaskFront), ctx);
    }
    
    
    json->getProperty("stencilWriteMaskFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilWriteMaskFront), ctx);
    }
    
    
    json->getProperty("stencilFailOpFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilFailOpFront), ctx);
    }
    
    
    json->getProperty("stencilZFailOpFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilZFailOpFront), ctx);
    }
    
    
    json->getProperty("stencilPassOpFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilPassOpFront), ctx);
    }
    
    
    json->getProperty("stencilRefFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilRefFront), ctx);
    }
    
    
    json->getProperty("stencilFuncBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilFuncBack), ctx);
    }
    
    
    json->getProperty("stencilReadMaskBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilReadMaskBack), ctx);
    }
    
    
    json->getProperty("stencilWriteMaskBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilWriteMaskBack), ctx);
    }
    
    
    json->getProperty("stencilFailOpBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilFailOpBack), ctx);
    }
    
    
    json->getProperty("stencilZFailOpBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilZFailOpBack), ctx);
    }
    
    
    json->getProperty("stencilPassOpBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilPassOpBack), ctx);
    }
    
    
    json->getProperty("stencilRefBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilRefBack), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_DepthStencilStateInfo(se::Object* obj) {
    auto* cls = se::Class::create("DepthStencilStateInfo", obj, nullptr, _SE(js_new_cc_DepthStencilStateInfo)); 
    
    cls->defineProperty("depthTest", _SE(js_cc_DepthStencilStateInfo_depthTest_get), _SE(js_cc_DepthStencilStateInfo_depthTest_set)); 
    cls->defineProperty("depthWrite", _SE(js_cc_DepthStencilStateInfo_depthWrite_get), _SE(js_cc_DepthStencilStateInfo_depthWrite_set)); 
    cls->defineProperty("stencilTestFront", _SE(js_cc_DepthStencilStateInfo_stencilTestFront_get), _SE(js_cc_DepthStencilStateInfo_stencilTestFront_set)); 
    cls->defineProperty("stencilTestBack", _SE(js_cc_DepthStencilStateInfo_stencilTestBack_get), _SE(js_cc_DepthStencilStateInfo_stencilTestBack_set)); 
    cls->defineProperty("depthFunc", _SE(js_cc_DepthStencilStateInfo_depthFunc_get), _SE(js_cc_DepthStencilStateInfo_depthFunc_set)); 
    cls->defineProperty("stencilFuncFront", _SE(js_cc_DepthStencilStateInfo_stencilFuncFront_get), _SE(js_cc_DepthStencilStateInfo_stencilFuncFront_set)); 
    cls->defineProperty("stencilReadMaskFront", _SE(js_cc_DepthStencilStateInfo_stencilReadMaskFront_get), _SE(js_cc_DepthStencilStateInfo_stencilReadMaskFront_set)); 
    cls->defineProperty("stencilWriteMaskFront", _SE(js_cc_DepthStencilStateInfo_stencilWriteMaskFront_get), _SE(js_cc_DepthStencilStateInfo_stencilWriteMaskFront_set)); 
    cls->defineProperty("stencilFailOpFront", _SE(js_cc_DepthStencilStateInfo_stencilFailOpFront_get), _SE(js_cc_DepthStencilStateInfo_stencilFailOpFront_set)); 
    cls->defineProperty("stencilZFailOpFront", _SE(js_cc_DepthStencilStateInfo_stencilZFailOpFront_get), _SE(js_cc_DepthStencilStateInfo_stencilZFailOpFront_set)); 
    cls->defineProperty("stencilPassOpFront", _SE(js_cc_DepthStencilStateInfo_stencilPassOpFront_get), _SE(js_cc_DepthStencilStateInfo_stencilPassOpFront_set)); 
    cls->defineProperty("stencilRefFront", _SE(js_cc_DepthStencilStateInfo_stencilRefFront_get), _SE(js_cc_DepthStencilStateInfo_stencilRefFront_set)); 
    cls->defineProperty("stencilFuncBack", _SE(js_cc_DepthStencilStateInfo_stencilFuncBack_get), _SE(js_cc_DepthStencilStateInfo_stencilFuncBack_set)); 
    cls->defineProperty("stencilReadMaskBack", _SE(js_cc_DepthStencilStateInfo_stencilReadMaskBack_get), _SE(js_cc_DepthStencilStateInfo_stencilReadMaskBack_set)); 
    cls->defineProperty("stencilWriteMaskBack", _SE(js_cc_DepthStencilStateInfo_stencilWriteMaskBack_get), _SE(js_cc_DepthStencilStateInfo_stencilWriteMaskBack_set)); 
    cls->defineProperty("stencilFailOpBack", _SE(js_cc_DepthStencilStateInfo_stencilFailOpBack_get), _SE(js_cc_DepthStencilStateInfo_stencilFailOpBack_set)); 
    cls->defineProperty("stencilZFailOpBack", _SE(js_cc_DepthStencilStateInfo_stencilZFailOpBack_get), _SE(js_cc_DepthStencilStateInfo_stencilZFailOpBack_set)); 
    cls->defineProperty("stencilPassOpBack", _SE(js_cc_DepthStencilStateInfo_stencilPassOpBack_get), _SE(js_cc_DepthStencilStateInfo_stencilPassOpBack_set)); 
    cls->defineProperty("stencilRefBack", _SE(js_cc_DepthStencilStateInfo_stencilRefBack_get), _SE(js_cc_DepthStencilStateInfo_stencilRefBack_set)); 
    
    cls->defineFunction("fromGFXDepthStencilState", _SE(js_cc_DepthStencilStateInfo_fromGFXDepthStencilState)); 
    cls->defineFunction("assignToGFXDepthStencilState", _SE(js_cc_DepthStencilStateInfo_assignToGFXDepthStencilState)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_DepthStencilStateInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::DepthStencilStateInfo>(cls);
    
    __jsb_cc_DepthStencilStateInfo_proto = cls->getProto();
    __jsb_cc_DepthStencilStateInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_BlendTargetInfo_class = nullptr;
se::Object* __jsb_cc_BlendTargetInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_BlendTargetInfo) 

static bool js_cc_BlendTargetInfo_blend_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->blend, s.thisObject());
    SE_PRECONDITION2(ok, false, "BlendTargetInfo_blend_set,2,SWIGTYPE_ccstd__optionalT_bool_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BlendTargetInfo_blend_set) 

static bool js_cc_BlendTargetInfo_blend_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->blend, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BlendTargetInfo_blend_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blend, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BlendTargetInfo_blend_get) 

static bool js_cc_BlendTargetInfo_blendSrc_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->blendSrc, s.thisObject());
    SE_PRECONDITION2(ok, false, "BlendTargetInfo_blendSrc_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__BlendFactor_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BlendTargetInfo_blendSrc_set) 

static bool js_cc_BlendTargetInfo_blendSrc_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->blendSrc, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BlendTargetInfo_blendSrc_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendSrc, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BlendTargetInfo_blendSrc_get) 

static bool js_cc_BlendTargetInfo_blendDst_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->blendDst, s.thisObject());
    SE_PRECONDITION2(ok, false, "BlendTargetInfo_blendDst_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__BlendFactor_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BlendTargetInfo_blendDst_set) 

static bool js_cc_BlendTargetInfo_blendDst_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->blendDst, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BlendTargetInfo_blendDst_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendDst, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BlendTargetInfo_blendDst_get) 

static bool js_cc_BlendTargetInfo_blendEq_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->blendEq, s.thisObject());
    SE_PRECONDITION2(ok, false, "BlendTargetInfo_blendEq_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__BlendOp_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BlendTargetInfo_blendEq_set) 

static bool js_cc_BlendTargetInfo_blendEq_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->blendEq, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BlendTargetInfo_blendEq_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendEq, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BlendTargetInfo_blendEq_get) 

static bool js_cc_BlendTargetInfo_blendSrcAlpha_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->blendSrcAlpha, s.thisObject());
    SE_PRECONDITION2(ok, false, "BlendTargetInfo_blendSrcAlpha_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__BlendFactor_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BlendTargetInfo_blendSrcAlpha_set) 

static bool js_cc_BlendTargetInfo_blendSrcAlpha_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->blendSrcAlpha, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BlendTargetInfo_blendSrcAlpha_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendSrcAlpha, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BlendTargetInfo_blendSrcAlpha_get) 

static bool js_cc_BlendTargetInfo_blendDstAlpha_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->blendDstAlpha, s.thisObject());
    SE_PRECONDITION2(ok, false, "BlendTargetInfo_blendDstAlpha_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__BlendFactor_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BlendTargetInfo_blendDstAlpha_set) 

static bool js_cc_BlendTargetInfo_blendDstAlpha_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->blendDstAlpha, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BlendTargetInfo_blendDstAlpha_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendDstAlpha, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BlendTargetInfo_blendDstAlpha_get) 

static bool js_cc_BlendTargetInfo_blendAlphaEq_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->blendAlphaEq, s.thisObject());
    SE_PRECONDITION2(ok, false, "BlendTargetInfo_blendAlphaEq_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__BlendOp_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BlendTargetInfo_blendAlphaEq_set) 

static bool js_cc_BlendTargetInfo_blendAlphaEq_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->blendAlphaEq, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BlendTargetInfo_blendAlphaEq_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendAlphaEq, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BlendTargetInfo_blendAlphaEq_get) 

static bool js_cc_BlendTargetInfo_blendColorMask_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->blendColorMask, s.thisObject());
    SE_PRECONDITION2(ok, false, "BlendTargetInfo_blendColorMask_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__ColorMask_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BlendTargetInfo_blendColorMask_set) 

static bool js_cc_BlendTargetInfo_blendColorMask_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->blendColorMask, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BlendTargetInfo_blendColorMask_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendColorMask, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BlendTargetInfo_blendColorMask_get) 

static bool js_cc_BlendTargetInfo_fromGFXBlendTarget(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    cc::gfx::BlendTarget *arg2 = 0 ;
    cc::gfx::BlendTarget temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BlendTargetInfo_fromGFXBlendTarget,2,SWIGTYPE_p_cc__gfx__BlendTarget");
    arg2 = &temp2;
    
    (arg1)->fromGFXBlendTarget((cc::gfx::BlendTarget const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BlendTargetInfo_fromGFXBlendTarget) 

static bool js_cc_BlendTargetInfo_assignToGFXBlendTarget(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    cc::gfx::BlendTarget *arg2 = 0 ;
    cc::gfx::BlendTarget temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BlendTargetInfo_assignToGFXBlendTarget,2,SWIGTYPE_p_cc__gfx__BlendTarget");
    arg2 = &temp2;
    
    ((cc::BlendTargetInfo const *)arg1)->assignToGFXBlendTarget(*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BlendTargetInfo_assignToGFXBlendTarget) 

// js_ctor
static bool js_new_cc_BlendTargetInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::BlendTargetInfo *result;
    result = (cc::BlendTargetInfo *)new cc::BlendTargetInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_BlendTargetInfo, __jsb_cc_BlendTargetInfo_class, js_delete_cc_BlendTargetInfo)

static bool js_delete_cc_BlendTargetInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_BlendTargetInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::BlendTargetInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::BlendTargetInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("blend", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blend), ctx);
    }
    
    
    json->getProperty("blendSrc", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendSrc), ctx);
    }
    
    
    json->getProperty("blendDst", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendDst), ctx);
    }
    
    
    json->getProperty("blendEq", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendEq), ctx);
    }
    
    
    json->getProperty("blendSrcAlpha", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendSrcAlpha), ctx);
    }
    
    
    json->getProperty("blendDstAlpha", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendDstAlpha), ctx);
    }
    
    
    json->getProperty("blendAlphaEq", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendAlphaEq), ctx);
    }
    
    
    json->getProperty("blendColorMask", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendColorMask), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_BlendTargetInfo(se::Object* obj) {
    auto* cls = se::Class::create("BlendTargetInfo", obj, nullptr, _SE(js_new_cc_BlendTargetInfo)); 
    
    cls->defineProperty("blend", _SE(js_cc_BlendTargetInfo_blend_get), _SE(js_cc_BlendTargetInfo_blend_set)); 
    cls->defineProperty("blendSrc", _SE(js_cc_BlendTargetInfo_blendSrc_get), _SE(js_cc_BlendTargetInfo_blendSrc_set)); 
    cls->defineProperty("blendDst", _SE(js_cc_BlendTargetInfo_blendDst_get), _SE(js_cc_BlendTargetInfo_blendDst_set)); 
    cls->defineProperty("blendEq", _SE(js_cc_BlendTargetInfo_blendEq_get), _SE(js_cc_BlendTargetInfo_blendEq_set)); 
    cls->defineProperty("blendSrcAlpha", _SE(js_cc_BlendTargetInfo_blendSrcAlpha_get), _SE(js_cc_BlendTargetInfo_blendSrcAlpha_set)); 
    cls->defineProperty("blendDstAlpha", _SE(js_cc_BlendTargetInfo_blendDstAlpha_get), _SE(js_cc_BlendTargetInfo_blendDstAlpha_set)); 
    cls->defineProperty("blendAlphaEq", _SE(js_cc_BlendTargetInfo_blendAlphaEq_get), _SE(js_cc_BlendTargetInfo_blendAlphaEq_set)); 
    cls->defineProperty("blendColorMask", _SE(js_cc_BlendTargetInfo_blendColorMask_get), _SE(js_cc_BlendTargetInfo_blendColorMask_set)); 
    
    cls->defineFunction("fromGFXBlendTarget", _SE(js_cc_BlendTargetInfo_fromGFXBlendTarget)); 
    cls->defineFunction("assignToGFXBlendTarget", _SE(js_cc_BlendTargetInfo_assignToGFXBlendTarget)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_BlendTargetInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::BlendTargetInfo>(cls);
    
    __jsb_cc_BlendTargetInfo_proto = cls->getProto();
    __jsb_cc_BlendTargetInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_BlendStateInfo_class = nullptr;
se::Object* __jsb_cc_BlendStateInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_BlendStateInfo) 

static bool js_cc_BlendStateInfo_isA2C_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendStateInfo *arg1 = (cc::BlendStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->isA2C, s.thisObject());
    SE_PRECONDITION2(ok, false, "BlendStateInfo_isA2C_set,2,SWIGTYPE_ccstd__optionalT_bool_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BlendStateInfo_isA2C_set) 

static bool js_cc_BlendStateInfo_isA2C_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BlendStateInfo *arg1 = (cc::BlendStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->isA2C, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BlendStateInfo_isA2C_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->isA2C, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BlendStateInfo_isA2C_get) 

static bool js_cc_BlendStateInfo_isIndepend_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendStateInfo *arg1 = (cc::BlendStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->isIndepend, s.thisObject());
    SE_PRECONDITION2(ok, false, "BlendStateInfo_isIndepend_set,2,SWIGTYPE_ccstd__optionalT_bool_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BlendStateInfo_isIndepend_set) 

static bool js_cc_BlendStateInfo_isIndepend_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BlendStateInfo *arg1 = (cc::BlendStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->isIndepend, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BlendStateInfo_isIndepend_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->isIndepend, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BlendStateInfo_isIndepend_get) 

static bool js_cc_BlendStateInfo_blendColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendStateInfo *arg1 = (cc::BlendStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->blendColor, s.thisObject());
    SE_PRECONDITION2(ok, false, "BlendStateInfo_blendColor_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__Color_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BlendStateInfo_blendColor_set) 

static bool js_cc_BlendStateInfo_blendColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BlendStateInfo *arg1 = (cc::BlendStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->blendColor, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BlendStateInfo_blendColor_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendColor, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BlendStateInfo_blendColor_get) 

static bool js_cc_BlendStateInfo_targets_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendStateInfo *arg1 = (cc::BlendStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->targets, s.thisObject());
    SE_PRECONDITION2(ok, false, "BlendStateInfo_targets_set,2,SWIGTYPE_ccstd__optionalT_cc__BlendTargetInfoList_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BlendStateInfo_targets_set) 

static bool js_cc_BlendStateInfo_targets_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BlendStateInfo *arg1 = (cc::BlendStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->targets, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BlendStateInfo_targets_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->targets, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BlendStateInfo_targets_get) 

static bool js_cc_BlendStateInfo_fromGFXBlendState(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendStateInfo *arg1 = (cc::BlendStateInfo *) NULL ;
    cc::gfx::BlendState *arg2 = 0 ;
    cc::gfx::BlendState temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BlendStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BlendStateInfo_fromGFXBlendState,2,SWIGTYPE_p_cc__gfx__BlendState");
    arg2 = &temp2;
    
    (arg1)->fromGFXBlendState((cc::gfx::BlendState const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BlendStateInfo_fromGFXBlendState) 

static bool js_cc_BlendStateInfo_assignToGFXBlendState(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendStateInfo *arg1 = (cc::BlendStateInfo *) NULL ;
    cc::gfx::BlendState *arg2 = 0 ;
    cc::gfx::BlendState temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BlendStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BlendStateInfo_assignToGFXBlendState,2,SWIGTYPE_p_cc__gfx__BlendState");
    arg2 = &temp2;
    
    ((cc::BlendStateInfo const *)arg1)->assignToGFXBlendState(*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BlendStateInfo_assignToGFXBlendState) 

// js_ctor
static bool js_new_cc_BlendStateInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::BlendStateInfo *result;
    result = (cc::BlendStateInfo *)new cc::BlendStateInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_BlendStateInfo, __jsb_cc_BlendStateInfo_class, js_delete_cc_BlendStateInfo)

static bool js_delete_cc_BlendStateInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_BlendStateInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::BlendStateInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::BlendStateInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("isA2C", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isA2C), ctx);
    }
    
    
    json->getProperty("isIndepend", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isIndepend), ctx);
    }
    
    
    json->getProperty("blendColor", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendColor), ctx);
    }
    
    
    json->getProperty("targets", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->targets), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_BlendStateInfo(se::Object* obj) {
    auto* cls = se::Class::create("BlendStateInfo", obj, nullptr, _SE(js_new_cc_BlendStateInfo)); 
    
    cls->defineProperty("isA2C", _SE(js_cc_BlendStateInfo_isA2C_get), _SE(js_cc_BlendStateInfo_isA2C_set)); 
    cls->defineProperty("isIndepend", _SE(js_cc_BlendStateInfo_isIndepend_get), _SE(js_cc_BlendStateInfo_isIndepend_set)); 
    cls->defineProperty("blendColor", _SE(js_cc_BlendStateInfo_blendColor_get), _SE(js_cc_BlendStateInfo_blendColor_set)); 
    cls->defineProperty("targets", _SE(js_cc_BlendStateInfo_targets_get), _SE(js_cc_BlendStateInfo_targets_set)); 
    
    cls->defineFunction("fromGFXBlendState", _SE(js_cc_BlendStateInfo_fromGFXBlendState)); 
    cls->defineFunction("assignToGFXBlendState", _SE(js_cc_BlendStateInfo_assignToGFXBlendState)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_BlendStateInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::BlendStateInfo>(cls);
    
    __jsb_cc_BlendStateInfo_proto = cls->getProto();
    __jsb_cc_BlendStateInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IPassStates_class = nullptr;
se::Object* __jsb_cc_IPassStates_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IPassStates) 

static bool js_cc_IPassStates_priority_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->priority, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPassStates_priority_set,2,SWIGTYPE_ccstd__optionalT_int32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassStates_priority_set) 

static bool js_cc_IPassStates_priority_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->priority, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPassStates_priority_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->priority, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassStates_priority_get) 

static bool js_cc_IPassStates_primitive_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->primitive, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPassStates_primitive_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__PrimitiveMode_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassStates_primitive_set) 

static bool js_cc_IPassStates_primitive_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->primitive, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPassStates_primitive_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->primitive, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassStates_primitive_get) 

static bool js_cc_IPassStates_stage_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stage, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPassStates_stage_set,2,SWIGTYPE_ccstd__optionalT_cc__pipeline__RenderPassStage_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassStates_stage_set) 

static bool js_cc_IPassStates_stage_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stage, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPassStates_stage_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stage, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassStates_stage_get) 

static bool js_cc_IPassStates_rasterizerState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->rasterizerState, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPassStates_rasterizerState_set,2,SWIGTYPE_ccstd__optionalT_cc__RasterizerStateInfo_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassStates_rasterizerState_set) 

static bool js_cc_IPassStates_rasterizerState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->rasterizerState, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPassStates_rasterizerState_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->rasterizerState, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassStates_rasterizerState_get) 

static bool js_cc_IPassStates_depthStencilState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->depthStencilState, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPassStates_depthStencilState_set,2,SWIGTYPE_ccstd__optionalT_cc__DepthStencilStateInfo_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassStates_depthStencilState_set) 

static bool js_cc_IPassStates_depthStencilState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->depthStencilState, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPassStates_depthStencilState_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthStencilState, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassStates_depthStencilState_get) 

static bool js_cc_IPassStates_blendState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->blendState, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPassStates_blendState_set,2,SWIGTYPE_ccstd__optionalT_cc__BlendStateInfo_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassStates_blendState_set) 

static bool js_cc_IPassStates_blendState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->blendState, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPassStates_blendState_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendState, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassStates_blendState_get) 

static bool js_cc_IPassStates_dynamicStates_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->dynamicStates, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPassStates_dynamicStates_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__DynamicStateFlags_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassStates_dynamicStates_set) 

static bool js_cc_IPassStates_dynamicStates_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->dynamicStates, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPassStates_dynamicStates_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->dynamicStates, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassStates_dynamicStates_get) 

static bool js_cc_IPassStates_phase_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->phase, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPassStates_phase_set,2,SWIGTYPE_ccstd__optionalT_ccstd__string_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassStates_phase_set) 

static bool js_cc_IPassStates_phase_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->phase, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPassStates_phase_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->phase, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassStates_phase_get) 

static bool js_new_cc_IPassStates__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::IPassStates *result;
    result = (cc::IPassStates *)new cc::IPassStates();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_IPassStates__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = 0 ;
    cc::IPassInfoFull temp1 ;
    cc::IPassStates *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_IPassStates,1,SWIGTYPE_p_cc__IPassInfoFull");
    arg1 = &temp1;
    
    result = (cc::IPassStates *)new cc::IPassStates((cc::IPassInfoFull const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_IPassStates(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_ctor_dispatcher
    size_t argc = s.args().size();
    bool ret = false;
    
    // switch all cases by means of series of if-returns.
    
    // js_ctor_dispatch_case
    if(argc == 0) {
        ret = js_new_cc_IPassStates__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_IPassStates__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    
    // default:
    SE_REPORT_ERROR("Illegal arguments for construction of IPassStates");
    return false;
}
SE_BIND_CTOR(js_new_IPassStates, __jsb_cc_IPassStates_class, js_delete_cc_IPassStates)

static bool js_cc_IPassStates_overrides(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    cc::IPassInfoFull *arg2 = 0 ;
    cc::IPassInfoFull temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPassStates_overrides,2,SWIGTYPE_p_cc__IPassInfoFull");
    arg2 = &temp2;
    
    (arg1)->overrides((cc::IPassInfoFull const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_IPassStates_overrides) 

static bool js_delete_cc_IPassStates(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IPassStates) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IPassStates * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IPassStates*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("priority", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->priority), ctx);
    }
    
    
    json->getProperty("primitive", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->primitive), ctx);
    }
    
    
    json->getProperty("stage", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stage), ctx);
    }
    
    
    json->getProperty("rasterizerState", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->rasterizerState), ctx);
    }
    
    
    json->getProperty("depthStencilState", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthStencilState), ctx);
    }
    
    
    json->getProperty("blendState", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendState), ctx);
    }
    
    
    json->getProperty("dynamicStates", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dynamicStates), ctx);
    }
    
    
    json->getProperty("phase", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->phase), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IPassStates(se::Object* obj) {
    auto* cls = se::Class::create("IPassStates", obj, nullptr, _SE(js_new_IPassStates)); 
    
    cls->defineProperty("priority", _SE(js_cc_IPassStates_priority_get), _SE(js_cc_IPassStates_priority_set)); 
    cls->defineProperty("primitive", _SE(js_cc_IPassStates_primitive_get), _SE(js_cc_IPassStates_primitive_set)); 
    cls->defineProperty("stage", _SE(js_cc_IPassStates_stage_get), _SE(js_cc_IPassStates_stage_set)); 
    cls->defineProperty("rasterizerState", _SE(js_cc_IPassStates_rasterizerState_get), _SE(js_cc_IPassStates_rasterizerState_set)); 
    cls->defineProperty("depthStencilState", _SE(js_cc_IPassStates_depthStencilState_get), _SE(js_cc_IPassStates_depthStencilState_set)); 
    cls->defineProperty("blendState", _SE(js_cc_IPassStates_blendState_get), _SE(js_cc_IPassStates_blendState_set)); 
    cls->defineProperty("dynamicStates", _SE(js_cc_IPassStates_dynamicStates_get), _SE(js_cc_IPassStates_dynamicStates_set)); 
    cls->defineProperty("phase", _SE(js_cc_IPassStates_phase_get), _SE(js_cc_IPassStates_phase_set)); 
    
    cls->defineFunction("overrides", _SE(js_cc_IPassStates_overrides)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IPassStates));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IPassStates>(cls);
    
    __jsb_cc_IPassStates_proto = cls->getProto();
    __jsb_cc_IPassStates_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IPassInfoFull_class = nullptr;
se::Object* __jsb_cc_IPassInfoFull_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IPassInfoFull) 

static bool js_cc_IPassInfoFull_priority_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->priority, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPassInfoFull_priority_set,2,SWIGTYPE_ccstd__optionalT_int32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_priority_set) 

static bool js_cc_IPassInfoFull_priority_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->priority, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPassInfoFull_priority_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->priority, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_priority_get) 

static bool js_cc_IPassInfoFull_primitive_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->primitive, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPassInfoFull_primitive_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__PrimitiveMode_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_primitive_set) 

static bool js_cc_IPassInfoFull_primitive_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->primitive, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPassInfoFull_primitive_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->primitive, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_primitive_get) 

static bool js_cc_IPassInfoFull_stage_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stage, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPassInfoFull_stage_set,2,SWIGTYPE_ccstd__optionalT_cc__pipeline__RenderPassStage_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_stage_set) 

static bool js_cc_IPassInfoFull_stage_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stage, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPassInfoFull_stage_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stage, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_stage_get) 

static bool js_cc_IPassInfoFull_rasterizerState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->rasterizerState, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPassInfoFull_rasterizerState_set,2,SWIGTYPE_ccstd__optionalT_cc__RasterizerStateInfo_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_rasterizerState_set) 

static bool js_cc_IPassInfoFull_rasterizerState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->rasterizerState, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPassInfoFull_rasterizerState_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->rasterizerState, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_rasterizerState_get) 

static bool js_cc_IPassInfoFull_depthStencilState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->depthStencilState, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPassInfoFull_depthStencilState_set,2,SWIGTYPE_ccstd__optionalT_cc__DepthStencilStateInfo_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_depthStencilState_set) 

static bool js_cc_IPassInfoFull_depthStencilState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->depthStencilState, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPassInfoFull_depthStencilState_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthStencilState, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_depthStencilState_get) 

static bool js_cc_IPassInfoFull_blendState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->blendState, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPassInfoFull_blendState_set,2,SWIGTYPE_ccstd__optionalT_cc__BlendStateInfo_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_blendState_set) 

static bool js_cc_IPassInfoFull_blendState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->blendState, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPassInfoFull_blendState_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendState, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_blendState_get) 

static bool js_cc_IPassInfoFull_dynamicStates_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->dynamicStates, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPassInfoFull_dynamicStates_set,2,SWIGTYPE_ccstd__optionalT_cc__gfx__DynamicStateFlags_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_dynamicStates_set) 

static bool js_cc_IPassInfoFull_dynamicStates_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->dynamicStates, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPassInfoFull_dynamicStates_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->dynamicStates, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_dynamicStates_get) 

static bool js_cc_IPassInfoFull_phase_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->phase, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPassInfoFull_phase_set,2,SWIGTYPE_ccstd__optionalT_ccstd__string_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_phase_set) 

static bool js_cc_IPassInfoFull_phase_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->phase, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPassInfoFull_phase_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->phase, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_phase_get) 

static bool js_cc_IPassInfoFull_program_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->program, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPassInfoFull_program_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_program_set) 

static bool js_cc_IPassInfoFull_program_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->program, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPassInfoFull_program_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->program, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_program_get) 

static bool js_cc_IPassInfoFull_embeddedMacros_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->embeddedMacros, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPassInfoFull_embeddedMacros_set,2,SWIGTYPE_ccstd__optionalT_cc__MacroRecord_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_embeddedMacros_set) 

static bool js_cc_IPassInfoFull_embeddedMacros_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->embeddedMacros, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPassInfoFull_embeddedMacros_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->embeddedMacros, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_embeddedMacros_get) 

static bool js_cc_IPassInfoFull_propertyIndex_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->propertyIndex, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPassInfoFull_propertyIndex_set,2,SWIGTYPE_int32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_propertyIndex_set) 

static bool js_cc_IPassInfoFull_propertyIndex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->propertyIndex, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPassInfoFull_propertyIndex_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->propertyIndex, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_propertyIndex_get) 

static bool js_cc_IPassInfoFull_cpp_keyword_switch_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->switch_, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPassInfoFull_cpp_keyword_switch_set,2,SWIGTYPE_ccstd__optionalT_ccstd__string_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_cpp_keyword_switch_set) 

static bool js_cc_IPassInfoFull_cpp_keyword_switch_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->switch_, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPassInfoFull_cpp_keyword_switch_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->switch_, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_cpp_keyword_switch_get) 

static bool js_cc_IPassInfoFull_properties_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->properties, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPassInfoFull_properties_set,2,SWIGTYPE_ccstd__optionalT_cc__PassPropertyInfoMap_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_properties_set) 

static bool js_cc_IPassInfoFull_properties_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->properties, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPassInfoFull_properties_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->properties, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_properties_get) 

static bool js_cc_IPassInfoFull_passIndex_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->passIndex, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPassInfoFull_passIndex_set,2,SWIGTYPE_int32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_passIndex_set) 

static bool js_cc_IPassInfoFull_passIndex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->passIndex, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPassInfoFull_passIndex_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->passIndex, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_passIndex_get) 

static bool js_cc_IPassInfoFull_defines_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->defines, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPassInfoFull_defines_set,2,SWIGTYPE_ccstd__unordered_mapT_ccstd__string_cc__MacroValue_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_defines_set) 

static bool js_cc_IPassInfoFull_defines_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->defines, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPassInfoFull_defines_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->defines, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_defines_get) 

static bool js_cc_IPassInfoFull_stateOverrides_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stateOverrides, s.thisObject());
    SE_PRECONDITION2(ok, false, "IPassInfoFull_stateOverrides_set,2,SWIGTYPE_ccstd__optionalT_cc__PassOverrides_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_stateOverrides_set) 

static bool js_cc_IPassInfoFull_stateOverrides_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stateOverrides, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IPassInfoFull_stateOverrides_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stateOverrides, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_stateOverrides_get) 

static bool js_new_cc_IPassInfoFull__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *result;
    result = (cc::IPassInfoFull *)new cc::IPassInfoFull();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_IPassInfoFull__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::IPassStates *arg1 = 0 ;
    cc::IPassStates temp1 ;
    cc::IPassInfoFull *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_IPassInfoFull,1,SWIGTYPE_p_cc__IPassStates");
    arg1 = &temp1;
    
    result = (cc::IPassInfoFull *)new cc::IPassInfoFull((cc::IPassStates const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_IPassInfoFull(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_ctor_dispatcher
    size_t argc = s.args().size();
    bool ret = false;
    
    // switch all cases by means of series of if-returns.
    
    // js_ctor_dispatch_case
    if(argc == 0) {
        ret = js_new_cc_IPassInfoFull__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_IPassInfoFull__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    
    // default:
    SE_REPORT_ERROR("Illegal arguments for construction of IPassInfoFull");
    return false;
}
SE_BIND_CTOR(js_new_IPassInfoFull, __jsb_cc_IPassInfoFull_class, js_delete_cc_IPassInfoFull)

static bool js_delete_cc_IPassInfoFull(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IPassInfoFull) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IPassInfoFull * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IPassInfoFull*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("priority", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->priority), ctx);
    }
    
    
    json->getProperty("primitive", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->primitive), ctx);
    }
    
    
    json->getProperty("stage", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stage), ctx);
    }
    
    
    json->getProperty("rasterizerState", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->rasterizerState), ctx);
    }
    
    
    json->getProperty("depthStencilState", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthStencilState), ctx);
    }
    
    
    json->getProperty("blendState", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendState), ctx);
    }
    
    
    json->getProperty("dynamicStates", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dynamicStates), ctx);
    }
    
    
    json->getProperty("phase", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->phase), ctx);
    }
    
    
    json->getProperty("program", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->program), ctx);
    }
    
    
    json->getProperty("embeddedMacros", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->embeddedMacros), ctx);
    }
    
    
    json->getProperty("propertyIndex", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->propertyIndex), ctx);
    }
    
    
    json->getProperty("switch", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->switch_), ctx);
    }
    
    
    json->getProperty("properties", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->properties), ctx);
    }
    
    
    json->getProperty("passIndex", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->passIndex), ctx);
    }
    
    
    json->getProperty("defines", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->defines), ctx);
    }
    
    
    json->getProperty("stateOverrides", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stateOverrides), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IPassInfoFull(se::Object* obj) {
    auto* cls = se::Class::create("IPassInfoFull", obj, nullptr, _SE(js_new_IPassInfoFull)); 
    
    cls->defineProperty("priority", _SE(js_cc_IPassInfoFull_priority_get), _SE(js_cc_IPassInfoFull_priority_set)); 
    cls->defineProperty("primitive", _SE(js_cc_IPassInfoFull_primitive_get), _SE(js_cc_IPassInfoFull_primitive_set)); 
    cls->defineProperty("stage", _SE(js_cc_IPassInfoFull_stage_get), _SE(js_cc_IPassInfoFull_stage_set)); 
    cls->defineProperty("rasterizerState", _SE(js_cc_IPassInfoFull_rasterizerState_get), _SE(js_cc_IPassInfoFull_rasterizerState_set)); 
    cls->defineProperty("depthStencilState", _SE(js_cc_IPassInfoFull_depthStencilState_get), _SE(js_cc_IPassInfoFull_depthStencilState_set)); 
    cls->defineProperty("blendState", _SE(js_cc_IPassInfoFull_blendState_get), _SE(js_cc_IPassInfoFull_blendState_set)); 
    cls->defineProperty("dynamicStates", _SE(js_cc_IPassInfoFull_dynamicStates_get), _SE(js_cc_IPassInfoFull_dynamicStates_set)); 
    cls->defineProperty("phase", _SE(js_cc_IPassInfoFull_phase_get), _SE(js_cc_IPassInfoFull_phase_set)); 
    cls->defineProperty("program", _SE(js_cc_IPassInfoFull_program_get), _SE(js_cc_IPassInfoFull_program_set)); 
    cls->defineProperty("embeddedMacros", _SE(js_cc_IPassInfoFull_embeddedMacros_get), _SE(js_cc_IPassInfoFull_embeddedMacros_set)); 
    cls->defineProperty("propertyIndex", _SE(js_cc_IPassInfoFull_propertyIndex_get), _SE(js_cc_IPassInfoFull_propertyIndex_set)); 
    cls->defineProperty("switch", _SE(js_cc_IPassInfoFull_cpp_keyword_switch_get), _SE(js_cc_IPassInfoFull_cpp_keyword_switch_set)); 
    cls->defineProperty("properties", _SE(js_cc_IPassInfoFull_properties_get), _SE(js_cc_IPassInfoFull_properties_set)); 
    cls->defineProperty("passIndex", _SE(js_cc_IPassInfoFull_passIndex_get), _SE(js_cc_IPassInfoFull_passIndex_set)); 
    cls->defineProperty("defines", _SE(js_cc_IPassInfoFull_defines_get), _SE(js_cc_IPassInfoFull_defines_set)); 
    cls->defineProperty("stateOverrides", _SE(js_cc_IPassInfoFull_stateOverrides_get), _SE(js_cc_IPassInfoFull_stateOverrides_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IPassInfoFull));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IPassInfoFull>(cls);
    
    __jsb_cc_IPassInfoFull_proto = cls->getProto();
    __jsb_cc_IPassInfoFull_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_ITechniqueInfo_class = nullptr;
se::Object* __jsb_cc_ITechniqueInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_ITechniqueInfo) 

static bool js_cc_ITechniqueInfo_passes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITechniqueInfo *arg1 = (cc::ITechniqueInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITechniqueInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->passes, s.thisObject());
    SE_PRECONDITION2(ok, false, "ITechniqueInfo_passes_set,2,SWIGTYPE_ccstd__vectorT_cc__IPassInfoFull_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITechniqueInfo_passes_set) 

static bool js_cc_ITechniqueInfo_passes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITechniqueInfo *arg1 = (cc::ITechniqueInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITechniqueInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->passes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ITechniqueInfo_passes_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->passes, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITechniqueInfo_passes_get) 

static bool js_cc_ITechniqueInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITechniqueInfo *arg1 = (cc::ITechniqueInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITechniqueInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "ITechniqueInfo_name_set,2,SWIGTYPE_ccstd__optionalT_ccstd__string_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITechniqueInfo_name_set) 

static bool js_cc_ITechniqueInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITechniqueInfo *arg1 = (cc::ITechniqueInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITechniqueInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ITechniqueInfo_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITechniqueInfo_name_get) 

// js_ctor
static bool js_new_cc_ITechniqueInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::ITechniqueInfo *result;
    result = (cc::ITechniqueInfo *)new cc::ITechniqueInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_ITechniqueInfo, __jsb_cc_ITechniqueInfo_class, js_delete_cc_ITechniqueInfo)

static bool js_delete_cc_ITechniqueInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_ITechniqueInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::ITechniqueInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::ITechniqueInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("passes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->passes), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_ITechniqueInfo(se::Object* obj) {
    auto* cls = se::Class::create("ITechniqueInfo", obj, nullptr, _SE(js_new_cc_ITechniqueInfo)); 
    
    cls->defineProperty("passes", _SE(js_cc_ITechniqueInfo_passes_get), _SE(js_cc_ITechniqueInfo_passes_set)); 
    cls->defineProperty("name", _SE(js_cc_ITechniqueInfo_name_get), _SE(js_cc_ITechniqueInfo_name_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_ITechniqueInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::ITechniqueInfo>(cls);
    
    __jsb_cc_ITechniqueInfo_proto = cls->getProto();
    __jsb_cc_ITechniqueInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IBlockInfo_class = nullptr;
se::Object* __jsb_cc_IBlockInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IBlockInfo) 

static bool js_cc_IBlockInfo_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBlockInfo *arg1 = (cc::IBlockInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBlockInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "IBlockInfo_binding_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBlockInfo_binding_set) 

static bool js_cc_IBlockInfo_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBlockInfo *arg1 = (cc::IBlockInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBlockInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IBlockInfo_binding_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->binding, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBlockInfo_binding_get) 

static bool js_cc_IBlockInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBlockInfo *arg1 = (cc::IBlockInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBlockInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "IBlockInfo_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBlockInfo_name_set) 

static bool js_cc_IBlockInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBlockInfo *arg1 = (cc::IBlockInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBlockInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IBlockInfo_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBlockInfo_name_get) 

static bool js_cc_IBlockInfo_members_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBlockInfo *arg1 = (cc::IBlockInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBlockInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->members, s.thisObject());
    SE_PRECONDITION2(ok, false, "IBlockInfo_members_set,2,SWIGTYPE_ccstd__vectorT_cc__gfx__Uniform_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBlockInfo_members_set) 

static bool js_cc_IBlockInfo_members_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBlockInfo *arg1 = (cc::IBlockInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBlockInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->members, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IBlockInfo_members_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->members, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBlockInfo_members_get) 

static bool js_cc_IBlockInfo_stageFlags_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBlockInfo *arg1 = (cc::IBlockInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::IBlockInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "IBlockInfo_stageFlags_set,2,SWIGTYPE_cc__gfx__ShaderStageFlagBit");
    arg1->stageFlags = (cc::gfx::ShaderStageFlags)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBlockInfo_stageFlags_set) 

static bool js_cc_IBlockInfo_stageFlags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBlockInfo *arg1 = (cc::IBlockInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::IBlockInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->stageFlags));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBlockInfo_stageFlags_get) 

// js_ctor
static bool js_new_cc_IBlockInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IBlockInfo *result;
    result = (cc::IBlockInfo *)new cc::IBlockInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IBlockInfo, __jsb_cc_IBlockInfo_class, js_delete_cc_IBlockInfo)

static bool js_delete_cc_IBlockInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IBlockInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IBlockInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IBlockInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("members", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->members), ctx);
    }
    
    
    json->getProperty("stageFlags", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stageFlags), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IBlockInfo(se::Object* obj) {
    auto* cls = se::Class::create("IBlockInfo", obj, nullptr, _SE(js_new_cc_IBlockInfo)); 
    
    cls->defineProperty("binding", _SE(js_cc_IBlockInfo_binding_get), _SE(js_cc_IBlockInfo_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_IBlockInfo_name_get), _SE(js_cc_IBlockInfo_name_set)); 
    cls->defineProperty("members", _SE(js_cc_IBlockInfo_members_get), _SE(js_cc_IBlockInfo_members_set)); 
    cls->defineProperty("stageFlags", _SE(js_cc_IBlockInfo_stageFlags_get), _SE(js_cc_IBlockInfo_stageFlags_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IBlockInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IBlockInfo>(cls);
    
    __jsb_cc_IBlockInfo_proto = cls->getProto();
    __jsb_cc_IBlockInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_ISamplerTextureInfo_class = nullptr;
se::Object* __jsb_cc_ISamplerTextureInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_ISamplerTextureInfo) 

static bool js_cc_ISamplerTextureInfo_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ISamplerTextureInfo *arg1 = (cc::ISamplerTextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerTextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "ISamplerTextureInfo_binding_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ISamplerTextureInfo_binding_set) 

static bool js_cc_ISamplerTextureInfo_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ISamplerTextureInfo *arg1 = (cc::ISamplerTextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerTextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ISamplerTextureInfo_binding_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->binding, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ISamplerTextureInfo_binding_get) 

static bool js_cc_ISamplerTextureInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ISamplerTextureInfo *arg1 = (cc::ISamplerTextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerTextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "ISamplerTextureInfo_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ISamplerTextureInfo_name_set) 

static bool js_cc_ISamplerTextureInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ISamplerTextureInfo *arg1 = (cc::ISamplerTextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerTextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ISamplerTextureInfo_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ISamplerTextureInfo_name_get) 

static bool js_cc_ISamplerTextureInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ISamplerTextureInfo *arg1 = (cc::ISamplerTextureInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerTextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "ISamplerTextureInfo_type_set,2,SWIGTYPE_cc__gfx__Type");
    arg1->type = (cc::gfx::Type)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ISamplerTextureInfo_type_set) 

static bool js_cc_ISamplerTextureInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ISamplerTextureInfo *arg1 = (cc::ISamplerTextureInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerTextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->type));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ISamplerTextureInfo_type_get) 

static bool js_cc_ISamplerTextureInfo_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ISamplerTextureInfo *arg1 = (cc::ISamplerTextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerTextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "ISamplerTextureInfo_count_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ISamplerTextureInfo_count_set) 

static bool js_cc_ISamplerTextureInfo_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ISamplerTextureInfo *arg1 = (cc::ISamplerTextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerTextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ISamplerTextureInfo_count_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->count, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ISamplerTextureInfo_count_get) 

static bool js_cc_ISamplerTextureInfo_stageFlags_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ISamplerTextureInfo *arg1 = (cc::ISamplerTextureInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerTextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "ISamplerTextureInfo_stageFlags_set,2,SWIGTYPE_cc__gfx__ShaderStageFlagBit");
    arg1->stageFlags = (cc::gfx::ShaderStageFlags)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ISamplerTextureInfo_stageFlags_set) 

static bool js_cc_ISamplerTextureInfo_stageFlags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ISamplerTextureInfo *arg1 = (cc::ISamplerTextureInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerTextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->stageFlags));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ISamplerTextureInfo_stageFlags_get) 

// js_ctor
static bool js_new_cc_ISamplerTextureInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::ISamplerTextureInfo *result;
    result = (cc::ISamplerTextureInfo *)new cc::ISamplerTextureInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_ISamplerTextureInfo, __jsb_cc_ISamplerTextureInfo_class, js_delete_cc_ISamplerTextureInfo)

static bool js_delete_cc_ISamplerTextureInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_ISamplerTextureInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::ISamplerTextureInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::ISamplerTextureInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("stageFlags", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stageFlags), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_ISamplerTextureInfo(se::Object* obj) {
    auto* cls = se::Class::create("ISamplerTextureInfo", obj, nullptr, _SE(js_new_cc_ISamplerTextureInfo)); 
    
    cls->defineProperty("binding", _SE(js_cc_ISamplerTextureInfo_binding_get), _SE(js_cc_ISamplerTextureInfo_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_ISamplerTextureInfo_name_get), _SE(js_cc_ISamplerTextureInfo_name_set)); 
    cls->defineProperty("type", _SE(js_cc_ISamplerTextureInfo_type_get), _SE(js_cc_ISamplerTextureInfo_type_set)); 
    cls->defineProperty("count", _SE(js_cc_ISamplerTextureInfo_count_get), _SE(js_cc_ISamplerTextureInfo_count_set)); 
    cls->defineProperty("stageFlags", _SE(js_cc_ISamplerTextureInfo_stageFlags_get), _SE(js_cc_ISamplerTextureInfo_stageFlags_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_ISamplerTextureInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::ISamplerTextureInfo>(cls);
    
    __jsb_cc_ISamplerTextureInfo_proto = cls->getProto();
    __jsb_cc_ISamplerTextureInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_ITextureInfo_class = nullptr;
se::Object* __jsb_cc_ITextureInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_ITextureInfo) 

static bool js_cc_ITextureInfo_set_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureInfo *arg1 = (cc::ITextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->set, s.thisObject());
    SE_PRECONDITION2(ok, false, "ITextureInfo_set_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureInfo_set_set) 

static bool js_cc_ITextureInfo_set_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureInfo *arg1 = (cc::ITextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->set, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ITextureInfo_set_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->set, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureInfo_set_get) 

static bool js_cc_ITextureInfo_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureInfo *arg1 = (cc::ITextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "ITextureInfo_binding_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureInfo_binding_set) 

static bool js_cc_ITextureInfo_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureInfo *arg1 = (cc::ITextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ITextureInfo_binding_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->binding, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureInfo_binding_get) 

static bool js_cc_ITextureInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureInfo *arg1 = (cc::ITextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "ITextureInfo_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureInfo_name_set) 

static bool js_cc_ITextureInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureInfo *arg1 = (cc::ITextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ITextureInfo_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureInfo_name_get) 

static bool js_cc_ITextureInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureInfo *arg1 = (cc::ITextureInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "ITextureInfo_type_set,2,SWIGTYPE_cc__gfx__Type");
    arg1->type = (cc::gfx::Type)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureInfo_type_set) 

static bool js_cc_ITextureInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureInfo *arg1 = (cc::ITextureInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->type));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureInfo_type_get) 

static bool js_cc_ITextureInfo_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureInfo *arg1 = (cc::ITextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "ITextureInfo_count_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureInfo_count_set) 

static bool js_cc_ITextureInfo_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureInfo *arg1 = (cc::ITextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ITextureInfo_count_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->count, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureInfo_count_get) 

static bool js_cc_ITextureInfo_stageFlags_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureInfo *arg1 = (cc::ITextureInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "ITextureInfo_stageFlags_set,2,SWIGTYPE_cc__gfx__ShaderStageFlagBit");
    arg1->stageFlags = (cc::gfx::ShaderStageFlags)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureInfo_stageFlags_set) 

static bool js_cc_ITextureInfo_stageFlags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureInfo *arg1 = (cc::ITextureInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->stageFlags));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureInfo_stageFlags_get) 

// js_ctor
static bool js_new_cc_ITextureInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::ITextureInfo *result;
    result = (cc::ITextureInfo *)new cc::ITextureInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_ITextureInfo, __jsb_cc_ITextureInfo_class, js_delete_cc_ITextureInfo)

static bool js_delete_cc_ITextureInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_ITextureInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::ITextureInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::ITextureInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("set", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->set), ctx);
    }
    
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("stageFlags", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stageFlags), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_ITextureInfo(se::Object* obj) {
    auto* cls = se::Class::create("ITextureInfo", obj, nullptr, _SE(js_new_cc_ITextureInfo)); 
    
    cls->defineProperty("set", _SE(js_cc_ITextureInfo_set_get), _SE(js_cc_ITextureInfo_set_set)); 
    cls->defineProperty("binding", _SE(js_cc_ITextureInfo_binding_get), _SE(js_cc_ITextureInfo_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_ITextureInfo_name_get), _SE(js_cc_ITextureInfo_name_set)); 
    cls->defineProperty("type", _SE(js_cc_ITextureInfo_type_get), _SE(js_cc_ITextureInfo_type_set)); 
    cls->defineProperty("count", _SE(js_cc_ITextureInfo_count_get), _SE(js_cc_ITextureInfo_count_set)); 
    cls->defineProperty("stageFlags", _SE(js_cc_ITextureInfo_stageFlags_get), _SE(js_cc_ITextureInfo_stageFlags_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_ITextureInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::ITextureInfo>(cls);
    
    __jsb_cc_ITextureInfo_proto = cls->getProto();
    __jsb_cc_ITextureInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_ISamplerInfo_class = nullptr;
se::Object* __jsb_cc_ISamplerInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_ISamplerInfo) 

static bool js_cc_ISamplerInfo_set_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ISamplerInfo *arg1 = (cc::ISamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->set, s.thisObject());
    SE_PRECONDITION2(ok, false, "ISamplerInfo_set_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ISamplerInfo_set_set) 

static bool js_cc_ISamplerInfo_set_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ISamplerInfo *arg1 = (cc::ISamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->set, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ISamplerInfo_set_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->set, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ISamplerInfo_set_get) 

static bool js_cc_ISamplerInfo_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ISamplerInfo *arg1 = (cc::ISamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "ISamplerInfo_binding_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ISamplerInfo_binding_set) 

static bool js_cc_ISamplerInfo_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ISamplerInfo *arg1 = (cc::ISamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ISamplerInfo_binding_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->binding, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ISamplerInfo_binding_get) 

static bool js_cc_ISamplerInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ISamplerInfo *arg1 = (cc::ISamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "ISamplerInfo_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ISamplerInfo_name_set) 

static bool js_cc_ISamplerInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ISamplerInfo *arg1 = (cc::ISamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ISamplerInfo_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ISamplerInfo_name_get) 

static bool js_cc_ISamplerInfo_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ISamplerInfo *arg1 = (cc::ISamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "ISamplerInfo_count_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ISamplerInfo_count_set) 

static bool js_cc_ISamplerInfo_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ISamplerInfo *arg1 = (cc::ISamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ISamplerInfo_count_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->count, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ISamplerInfo_count_get) 

static bool js_cc_ISamplerInfo_stageFlags_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ISamplerInfo *arg1 = (cc::ISamplerInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "ISamplerInfo_stageFlags_set,2,SWIGTYPE_cc__gfx__ShaderStageFlagBit");
    arg1->stageFlags = (cc::gfx::ShaderStageFlags)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ISamplerInfo_stageFlags_set) 

static bool js_cc_ISamplerInfo_stageFlags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ISamplerInfo *arg1 = (cc::ISamplerInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->stageFlags));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ISamplerInfo_stageFlags_get) 

// js_ctor
static bool js_new_cc_ISamplerInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::ISamplerInfo *result;
    result = (cc::ISamplerInfo *)new cc::ISamplerInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_ISamplerInfo, __jsb_cc_ISamplerInfo_class, js_delete_cc_ISamplerInfo)

static bool js_delete_cc_ISamplerInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_ISamplerInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::ISamplerInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::ISamplerInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("set", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->set), ctx);
    }
    
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("stageFlags", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stageFlags), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_ISamplerInfo(se::Object* obj) {
    auto* cls = se::Class::create("ISamplerInfo", obj, nullptr, _SE(js_new_cc_ISamplerInfo)); 
    
    cls->defineProperty("set", _SE(js_cc_ISamplerInfo_set_get), _SE(js_cc_ISamplerInfo_set_set)); 
    cls->defineProperty("binding", _SE(js_cc_ISamplerInfo_binding_get), _SE(js_cc_ISamplerInfo_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_ISamplerInfo_name_get), _SE(js_cc_ISamplerInfo_name_set)); 
    cls->defineProperty("count", _SE(js_cc_ISamplerInfo_count_get), _SE(js_cc_ISamplerInfo_count_set)); 
    cls->defineProperty("stageFlags", _SE(js_cc_ISamplerInfo_stageFlags_get), _SE(js_cc_ISamplerInfo_stageFlags_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_ISamplerInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::ISamplerInfo>(cls);
    
    __jsb_cc_ISamplerInfo_proto = cls->getProto();
    __jsb_cc_ISamplerInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IBufferInfo_class = nullptr;
se::Object* __jsb_cc_IBufferInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IBufferInfo) 

static bool js_cc_IBufferInfo_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBufferInfo *arg1 = (cc::IBufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "IBufferInfo_binding_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBufferInfo_binding_set) 

static bool js_cc_IBufferInfo_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBufferInfo *arg1 = (cc::IBufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IBufferInfo_binding_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->binding, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBufferInfo_binding_get) 

static bool js_cc_IBufferInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBufferInfo *arg1 = (cc::IBufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "IBufferInfo_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBufferInfo_name_set) 

static bool js_cc_IBufferInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBufferInfo *arg1 = (cc::IBufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IBufferInfo_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBufferInfo_name_get) 

static bool js_cc_IBufferInfo_memoryAccess_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBufferInfo *arg1 = (cc::IBufferInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::IBufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "IBufferInfo_memoryAccess_set,2,SWIGTYPE_cc__gfx__MemoryAccessBit");
    arg1->memoryAccess = (cc::gfx::MemoryAccess)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBufferInfo_memoryAccess_set) 

static bool js_cc_IBufferInfo_memoryAccess_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBufferInfo *arg1 = (cc::IBufferInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::IBufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->memoryAccess));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBufferInfo_memoryAccess_get) 

static bool js_cc_IBufferInfo_stageFlags_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBufferInfo *arg1 = (cc::IBufferInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::IBufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "IBufferInfo_stageFlags_set,2,SWIGTYPE_cc__gfx__ShaderStageFlagBit");
    arg1->stageFlags = (cc::gfx::ShaderStageFlags)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBufferInfo_stageFlags_set) 

static bool js_cc_IBufferInfo_stageFlags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBufferInfo *arg1 = (cc::IBufferInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::IBufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->stageFlags));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBufferInfo_stageFlags_get) 

// js_ctor
static bool js_new_cc_IBufferInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IBufferInfo *result;
    result = (cc::IBufferInfo *)new cc::IBufferInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IBufferInfo, __jsb_cc_IBufferInfo_class, js_delete_cc_IBufferInfo)

static bool js_delete_cc_IBufferInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IBufferInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IBufferInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IBufferInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("memoryAccess", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->memoryAccess), ctx);
    }
    
    
    json->getProperty("stageFlags", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stageFlags), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IBufferInfo(se::Object* obj) {
    auto* cls = se::Class::create("IBufferInfo", obj, nullptr, _SE(js_new_cc_IBufferInfo)); 
    
    cls->defineProperty("binding", _SE(js_cc_IBufferInfo_binding_get), _SE(js_cc_IBufferInfo_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_IBufferInfo_name_get), _SE(js_cc_IBufferInfo_name_set)); 
    cls->defineProperty("memoryAccess", _SE(js_cc_IBufferInfo_memoryAccess_get), _SE(js_cc_IBufferInfo_memoryAccess_set)); 
    cls->defineProperty("stageFlags", _SE(js_cc_IBufferInfo_stageFlags_get), _SE(js_cc_IBufferInfo_stageFlags_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IBufferInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IBufferInfo>(cls);
    
    __jsb_cc_IBufferInfo_proto = cls->getProto();
    __jsb_cc_IBufferInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IImageInfo_class = nullptr;
se::Object* __jsb_cc_IImageInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IImageInfo) 

static bool js_cc_IImageInfo_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IImageInfo *arg1 = (cc::IImageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IImageInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "IImageInfo_binding_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IImageInfo_binding_set) 

static bool js_cc_IImageInfo_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IImageInfo *arg1 = (cc::IImageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IImageInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IImageInfo_binding_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->binding, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IImageInfo_binding_get) 

static bool js_cc_IImageInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IImageInfo *arg1 = (cc::IImageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IImageInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "IImageInfo_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IImageInfo_name_set) 

static bool js_cc_IImageInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IImageInfo *arg1 = (cc::IImageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IImageInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IImageInfo_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IImageInfo_name_get) 

static bool js_cc_IImageInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IImageInfo *arg1 = (cc::IImageInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::IImageInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "IImageInfo_type_set,2,SWIGTYPE_cc__gfx__Type");
    arg1->type = (cc::gfx::Type)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IImageInfo_type_set) 

static bool js_cc_IImageInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IImageInfo *arg1 = (cc::IImageInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::IImageInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->type));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IImageInfo_type_get) 

static bool js_cc_IImageInfo_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IImageInfo *arg1 = (cc::IImageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IImageInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "IImageInfo_count_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IImageInfo_count_set) 

static bool js_cc_IImageInfo_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IImageInfo *arg1 = (cc::IImageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IImageInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IImageInfo_count_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->count, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IImageInfo_count_get) 

static bool js_cc_IImageInfo_memoryAccess_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IImageInfo *arg1 = (cc::IImageInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::IImageInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "IImageInfo_memoryAccess_set,2,SWIGTYPE_cc__gfx__MemoryAccessBit");
    arg1->memoryAccess = (cc::gfx::MemoryAccess)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IImageInfo_memoryAccess_set) 

static bool js_cc_IImageInfo_memoryAccess_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IImageInfo *arg1 = (cc::IImageInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::IImageInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->memoryAccess));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IImageInfo_memoryAccess_get) 

static bool js_cc_IImageInfo_stageFlags_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IImageInfo *arg1 = (cc::IImageInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::IImageInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "IImageInfo_stageFlags_set,2,SWIGTYPE_cc__gfx__ShaderStageFlagBit");
    arg1->stageFlags = (cc::gfx::ShaderStageFlags)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IImageInfo_stageFlags_set) 

static bool js_cc_IImageInfo_stageFlags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IImageInfo *arg1 = (cc::IImageInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::IImageInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->stageFlags));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IImageInfo_stageFlags_get) 

// js_ctor
static bool js_new_cc_IImageInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IImageInfo *result;
    result = (cc::IImageInfo *)new cc::IImageInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IImageInfo, __jsb_cc_IImageInfo_class, js_delete_cc_IImageInfo)

static bool js_delete_cc_IImageInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IImageInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IImageInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IImageInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("memoryAccess", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->memoryAccess), ctx);
    }
    
    
    json->getProperty("stageFlags", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stageFlags), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IImageInfo(se::Object* obj) {
    auto* cls = se::Class::create("IImageInfo", obj, nullptr, _SE(js_new_cc_IImageInfo)); 
    
    cls->defineProperty("binding", _SE(js_cc_IImageInfo_binding_get), _SE(js_cc_IImageInfo_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_IImageInfo_name_get), _SE(js_cc_IImageInfo_name_set)); 
    cls->defineProperty("type", _SE(js_cc_IImageInfo_type_get), _SE(js_cc_IImageInfo_type_set)); 
    cls->defineProperty("count", _SE(js_cc_IImageInfo_count_get), _SE(js_cc_IImageInfo_count_set)); 
    cls->defineProperty("memoryAccess", _SE(js_cc_IImageInfo_memoryAccess_get), _SE(js_cc_IImageInfo_memoryAccess_set)); 
    cls->defineProperty("stageFlags", _SE(js_cc_IImageInfo_stageFlags_get), _SE(js_cc_IImageInfo_stageFlags_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IImageInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IImageInfo>(cls);
    
    __jsb_cc_IImageInfo_proto = cls->getProto();
    __jsb_cc_IImageInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IInputAttachmentInfo_class = nullptr;
se::Object* __jsb_cc_IInputAttachmentInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IInputAttachmentInfo) 

static bool js_cc_IInputAttachmentInfo_set_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IInputAttachmentInfo *arg1 = (cc::IInputAttachmentInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IInputAttachmentInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->set, s.thisObject());
    SE_PRECONDITION2(ok, false, "IInputAttachmentInfo_set_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IInputAttachmentInfo_set_set) 

static bool js_cc_IInputAttachmentInfo_set_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IInputAttachmentInfo *arg1 = (cc::IInputAttachmentInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IInputAttachmentInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->set, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IInputAttachmentInfo_set_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->set, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IInputAttachmentInfo_set_get) 

static bool js_cc_IInputAttachmentInfo_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IInputAttachmentInfo *arg1 = (cc::IInputAttachmentInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IInputAttachmentInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "IInputAttachmentInfo_binding_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IInputAttachmentInfo_binding_set) 

static bool js_cc_IInputAttachmentInfo_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IInputAttachmentInfo *arg1 = (cc::IInputAttachmentInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IInputAttachmentInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IInputAttachmentInfo_binding_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->binding, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IInputAttachmentInfo_binding_get) 

static bool js_cc_IInputAttachmentInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IInputAttachmentInfo *arg1 = (cc::IInputAttachmentInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IInputAttachmentInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "IInputAttachmentInfo_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IInputAttachmentInfo_name_set) 

static bool js_cc_IInputAttachmentInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IInputAttachmentInfo *arg1 = (cc::IInputAttachmentInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IInputAttachmentInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IInputAttachmentInfo_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IInputAttachmentInfo_name_get) 

static bool js_cc_IInputAttachmentInfo_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IInputAttachmentInfo *arg1 = (cc::IInputAttachmentInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IInputAttachmentInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "IInputAttachmentInfo_count_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IInputAttachmentInfo_count_set) 

static bool js_cc_IInputAttachmentInfo_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IInputAttachmentInfo *arg1 = (cc::IInputAttachmentInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IInputAttachmentInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IInputAttachmentInfo_count_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->count, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IInputAttachmentInfo_count_get) 

static bool js_cc_IInputAttachmentInfo_stageFlags_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IInputAttachmentInfo *arg1 = (cc::IInputAttachmentInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::IInputAttachmentInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "IInputAttachmentInfo_stageFlags_set,2,SWIGTYPE_cc__gfx__ShaderStageFlagBit");
    arg1->stageFlags = (cc::gfx::ShaderStageFlags)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IInputAttachmentInfo_stageFlags_set) 

static bool js_cc_IInputAttachmentInfo_stageFlags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IInputAttachmentInfo *arg1 = (cc::IInputAttachmentInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::IInputAttachmentInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->stageFlags));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IInputAttachmentInfo_stageFlags_get) 

// js_ctor
static bool js_new_cc_IInputAttachmentInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IInputAttachmentInfo *result;
    result = (cc::IInputAttachmentInfo *)new cc::IInputAttachmentInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IInputAttachmentInfo, __jsb_cc_IInputAttachmentInfo_class, js_delete_cc_IInputAttachmentInfo)

static bool js_delete_cc_IInputAttachmentInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IInputAttachmentInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IInputAttachmentInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IInputAttachmentInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("set", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->set), ctx);
    }
    
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("stageFlags", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stageFlags), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IInputAttachmentInfo(se::Object* obj) {
    auto* cls = se::Class::create("IInputAttachmentInfo", obj, nullptr, _SE(js_new_cc_IInputAttachmentInfo)); 
    
    cls->defineProperty("set", _SE(js_cc_IInputAttachmentInfo_set_get), _SE(js_cc_IInputAttachmentInfo_set_set)); 
    cls->defineProperty("binding", _SE(js_cc_IInputAttachmentInfo_binding_get), _SE(js_cc_IInputAttachmentInfo_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_IInputAttachmentInfo_name_get), _SE(js_cc_IInputAttachmentInfo_name_set)); 
    cls->defineProperty("count", _SE(js_cc_IInputAttachmentInfo_count_get), _SE(js_cc_IInputAttachmentInfo_count_set)); 
    cls->defineProperty("stageFlags", _SE(js_cc_IInputAttachmentInfo_stageFlags_get), _SE(js_cc_IInputAttachmentInfo_stageFlags_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IInputAttachmentInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IInputAttachmentInfo>(cls);
    
    __jsb_cc_IInputAttachmentInfo_proto = cls->getProto();
    __jsb_cc_IInputAttachmentInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IAttributeInfo_class = nullptr;
se::Object* __jsb_cc_IAttributeInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IAttributeInfo) 

static bool js_cc_IAttributeInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "IAttributeInfo_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IAttributeInfo_name_set) 

static bool js_cc_IAttributeInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IAttributeInfo_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IAttributeInfo_name_get) 

static bool js_cc_IAttributeInfo_format_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "IAttributeInfo_format_set,2,SWIGTYPE_cc__gfx__Format");
    arg1->format = (cc::gfx::Format)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IAttributeInfo_format_set) 

static bool js_cc_IAttributeInfo_format_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->format));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IAttributeInfo_format_get) 

static bool js_cc_IAttributeInfo_isNormalized_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->isNormalized);
    SE_PRECONDITION2(ok, false, "IAttributeInfo_isNormalized_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IAttributeInfo_isNormalized_set) 

static bool js_cc_IAttributeInfo_isNormalized_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->isNormalized, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IAttributeInfo_isNormalized_get) 

static bool js_cc_IAttributeInfo_stream_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stream, s.thisObject());
    SE_PRECONDITION2(ok, false, "IAttributeInfo_stream_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IAttributeInfo_stream_set) 

static bool js_cc_IAttributeInfo_stream_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stream, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IAttributeInfo_stream_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stream, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IAttributeInfo_stream_get) 

static bool js_cc_IAttributeInfo_isInstanced_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->isInstanced);
    SE_PRECONDITION2(ok, false, "IAttributeInfo_isInstanced_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IAttributeInfo_isInstanced_set) 

static bool js_cc_IAttributeInfo_isInstanced_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->isInstanced, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IAttributeInfo_isInstanced_get) 

static bool js_cc_IAttributeInfo_location_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->location, s.thisObject());
    SE_PRECONDITION2(ok, false, "IAttributeInfo_location_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IAttributeInfo_location_set) 

static bool js_cc_IAttributeInfo_location_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->location, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IAttributeInfo_location_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->location, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IAttributeInfo_location_get) 

static bool js_cc_IAttributeInfo_defines_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->defines, s.thisObject());
    SE_PRECONDITION2(ok, false, "IAttributeInfo_defines_set,2,SWIGTYPE_ccstd__vectorT_ccstd__string_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IAttributeInfo_defines_set) 

static bool js_cc_IAttributeInfo_defines_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->defines, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IAttributeInfo_defines_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->defines, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IAttributeInfo_defines_get) 

// js_ctor
static bool js_new_cc_IAttributeInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IAttributeInfo *result;
    result = (cc::IAttributeInfo *)new cc::IAttributeInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IAttributeInfo, __jsb_cc_IAttributeInfo_class, js_delete_cc_IAttributeInfo)

static bool js_delete_cc_IAttributeInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IAttributeInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IAttributeInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IAttributeInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("format", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->format), ctx);
    }
    
    
    json->getProperty("isNormalized", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isNormalized), ctx);
    }
    
    
    json->getProperty("stream", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stream), ctx);
    }
    
    
    json->getProperty("isInstanced", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isInstanced), ctx);
    }
    
    
    json->getProperty("location", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->location), ctx);
    }
    
    
    json->getProperty("defines", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->defines), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IAttributeInfo(se::Object* obj) {
    auto* cls = se::Class::create("IAttributeInfo", obj, nullptr, _SE(js_new_cc_IAttributeInfo)); 
    
    cls->defineProperty("name", _SE(js_cc_IAttributeInfo_name_get), _SE(js_cc_IAttributeInfo_name_set)); 
    cls->defineProperty("format", _SE(js_cc_IAttributeInfo_format_get), _SE(js_cc_IAttributeInfo_format_set)); 
    cls->defineProperty("isNormalized", _SE(js_cc_IAttributeInfo_isNormalized_get), _SE(js_cc_IAttributeInfo_isNormalized_set)); 
    cls->defineProperty("stream", _SE(js_cc_IAttributeInfo_stream_get), _SE(js_cc_IAttributeInfo_stream_set)); 
    cls->defineProperty("isInstanced", _SE(js_cc_IAttributeInfo_isInstanced_get), _SE(js_cc_IAttributeInfo_isInstanced_set)); 
    cls->defineProperty("location", _SE(js_cc_IAttributeInfo_location_get), _SE(js_cc_IAttributeInfo_location_set)); 
    cls->defineProperty("defines", _SE(js_cc_IAttributeInfo_defines_get), _SE(js_cc_IAttributeInfo_defines_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IAttributeInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IAttributeInfo>(cls);
    
    __jsb_cc_IAttributeInfo_proto = cls->getProto();
    __jsb_cc_IAttributeInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IDefineInfo_class = nullptr;
se::Object* __jsb_cc_IDefineInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IDefineInfo) 

static bool js_cc_IDefineInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDefineInfo *arg1 = (cc::IDefineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "IDefineInfo_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDefineInfo_name_set) 

static bool js_cc_IDefineInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDefineInfo *arg1 = (cc::IDefineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IDefineInfo_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDefineInfo_name_get) 

static bool js_cc_IDefineInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDefineInfo *arg1 = (cc::IDefineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->type, s.thisObject());
    SE_PRECONDITION2(ok, false, "IDefineInfo_type_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDefineInfo_type_set) 

static bool js_cc_IDefineInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDefineInfo *arg1 = (cc::IDefineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->type, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IDefineInfo_type_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->type, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDefineInfo_type_get) 

static bool js_cc_IDefineInfo_range_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDefineInfo *arg1 = (cc::IDefineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->range, s.thisObject());
    SE_PRECONDITION2(ok, false, "IDefineInfo_range_set,2,SWIGTYPE_ccstd__optionalT_ccstd__vectorT_int32_t_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDefineInfo_range_set) 

static bool js_cc_IDefineInfo_range_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDefineInfo *arg1 = (cc::IDefineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->range, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IDefineInfo_range_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->range, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDefineInfo_range_get) 

static bool js_cc_IDefineInfo_options_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDefineInfo *arg1 = (cc::IDefineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->options, s.thisObject());
    SE_PRECONDITION2(ok, false, "IDefineInfo_options_set,2,SWIGTYPE_ccstd__optionalT_ccstd__vectorT_ccstd__string_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDefineInfo_options_set) 

static bool js_cc_IDefineInfo_options_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDefineInfo *arg1 = (cc::IDefineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->options, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IDefineInfo_options_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->options, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDefineInfo_options_get) 

static bool js_cc_IDefineInfo_defaultVal_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDefineInfo *arg1 = (cc::IDefineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->defaultVal, s.thisObject());
    SE_PRECONDITION2(ok, false, "IDefineInfo_defaultVal_set,2,SWIGTYPE_ccstd__optionalT_ccstd__string_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDefineInfo_defaultVal_set) 

static bool js_cc_IDefineInfo_defaultVal_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDefineInfo *arg1 = (cc::IDefineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->defaultVal, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IDefineInfo_defaultVal_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->defaultVal, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDefineInfo_defaultVal_get) 

// js_ctor
static bool js_new_cc_IDefineInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IDefineInfo *result;
    result = (cc::IDefineInfo *)new cc::IDefineInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IDefineInfo, __jsb_cc_IDefineInfo_class, js_delete_cc_IDefineInfo)

static bool js_delete_cc_IDefineInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IDefineInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IDefineInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IDefineInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("range", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->range), ctx);
    }
    
    
    json->getProperty("options", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->options), ctx);
    }
    
    
    json->getProperty("defaultVal", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->defaultVal), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IDefineInfo(se::Object* obj) {
    auto* cls = se::Class::create("IDefineInfo", obj, nullptr, _SE(js_new_cc_IDefineInfo)); 
    
    cls->defineProperty("name", _SE(js_cc_IDefineInfo_name_get), _SE(js_cc_IDefineInfo_name_set)); 
    cls->defineProperty("type", _SE(js_cc_IDefineInfo_type_get), _SE(js_cc_IDefineInfo_type_set)); 
    cls->defineProperty("range", _SE(js_cc_IDefineInfo_range_get), _SE(js_cc_IDefineInfo_range_set)); 
    cls->defineProperty("options", _SE(js_cc_IDefineInfo_options_get), _SE(js_cc_IDefineInfo_options_set)); 
    cls->defineProperty("defaultVal", _SE(js_cc_IDefineInfo_defaultVal_get), _SE(js_cc_IDefineInfo_defaultVal_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IDefineInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IDefineInfo>(cls);
    
    __jsb_cc_IDefineInfo_proto = cls->getProto();
    __jsb_cc_IDefineInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IBuiltin_class = nullptr;
se::Object* __jsb_cc_IBuiltin_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IBuiltin) 

static bool js_cc_IBuiltin_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBuiltin *arg1 = (cc::IBuiltin *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltin>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "IBuiltin_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBuiltin_name_set) 

static bool js_cc_IBuiltin_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBuiltin *arg1 = (cc::IBuiltin *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltin>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IBuiltin_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBuiltin_name_get) 

static bool js_cc_IBuiltin_defines_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBuiltin *arg1 = (cc::IBuiltin *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltin>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->defines, s.thisObject());
    SE_PRECONDITION2(ok, false, "IBuiltin_defines_set,2,SWIGTYPE_ccstd__vectorT_ccstd__string_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBuiltin_defines_set) 

static bool js_cc_IBuiltin_defines_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBuiltin *arg1 = (cc::IBuiltin *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltin>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->defines, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IBuiltin_defines_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->defines, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBuiltin_defines_get) 

// js_ctor
static bool js_new_cc_IBuiltin(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IBuiltin *result;
    result = (cc::IBuiltin *)new cc::IBuiltin();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IBuiltin, __jsb_cc_IBuiltin_class, js_delete_cc_IBuiltin)

static bool js_delete_cc_IBuiltin(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IBuiltin) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IBuiltin * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IBuiltin*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("defines", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->defines), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IBuiltin(se::Object* obj) {
    auto* cls = se::Class::create("IBuiltin", obj, nullptr, _SE(js_new_cc_IBuiltin)); 
    
    cls->defineProperty("name", _SE(js_cc_IBuiltin_name_get), _SE(js_cc_IBuiltin_name_set)); 
    cls->defineProperty("defines", _SE(js_cc_IBuiltin_defines_get), _SE(js_cc_IBuiltin_defines_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IBuiltin));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IBuiltin>(cls);
    
    __jsb_cc_IBuiltin_proto = cls->getProto();
    __jsb_cc_IBuiltin_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IBuiltinInfo_class = nullptr;
se::Object* __jsb_cc_IBuiltinInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IBuiltinInfo) 

static bool js_cc_IBuiltinInfo_buffers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBuiltinInfo *arg1 = (cc::IBuiltinInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltinInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->buffers, s.thisObject());
    SE_PRECONDITION2(ok, false, "IBuiltinInfo_buffers_set,2,SWIGTYPE_ccstd__vectorT_cc__IBuiltin_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBuiltinInfo_buffers_set) 

static bool js_cc_IBuiltinInfo_buffers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBuiltinInfo *arg1 = (cc::IBuiltinInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltinInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->buffers, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IBuiltinInfo_buffers_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->buffers, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBuiltinInfo_buffers_get) 

static bool js_cc_IBuiltinInfo_blocks_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBuiltinInfo *arg1 = (cc::IBuiltinInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltinInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->blocks, s.thisObject());
    SE_PRECONDITION2(ok, false, "IBuiltinInfo_blocks_set,2,SWIGTYPE_ccstd__vectorT_cc__IBuiltin_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBuiltinInfo_blocks_set) 

static bool js_cc_IBuiltinInfo_blocks_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBuiltinInfo *arg1 = (cc::IBuiltinInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltinInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->blocks, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IBuiltinInfo_blocks_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blocks, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBuiltinInfo_blocks_get) 

static bool js_cc_IBuiltinInfo_samplerTextures_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBuiltinInfo *arg1 = (cc::IBuiltinInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltinInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->samplerTextures, s.thisObject());
    SE_PRECONDITION2(ok, false, "IBuiltinInfo_samplerTextures_set,2,SWIGTYPE_ccstd__vectorT_cc__IBuiltin_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBuiltinInfo_samplerTextures_set) 

static bool js_cc_IBuiltinInfo_samplerTextures_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBuiltinInfo *arg1 = (cc::IBuiltinInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltinInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->samplerTextures, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IBuiltinInfo_samplerTextures_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->samplerTextures, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBuiltinInfo_samplerTextures_get) 

static bool js_cc_IBuiltinInfo_images_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBuiltinInfo *arg1 = (cc::IBuiltinInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltinInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->images, s.thisObject());
    SE_PRECONDITION2(ok, false, "IBuiltinInfo_images_set,2,SWIGTYPE_ccstd__vectorT_cc__IBuiltin_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBuiltinInfo_images_set) 

static bool js_cc_IBuiltinInfo_images_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBuiltinInfo *arg1 = (cc::IBuiltinInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltinInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->images, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IBuiltinInfo_images_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->images, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBuiltinInfo_images_get) 

// js_ctor
static bool js_new_cc_IBuiltinInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IBuiltinInfo *result;
    result = (cc::IBuiltinInfo *)new cc::IBuiltinInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IBuiltinInfo, __jsb_cc_IBuiltinInfo_class, js_delete_cc_IBuiltinInfo)

static bool js_delete_cc_IBuiltinInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IBuiltinInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IBuiltinInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IBuiltinInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("buffers", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->buffers), ctx);
    }
    
    
    json->getProperty("blocks", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blocks), ctx);
    }
    
    
    json->getProperty("samplerTextures", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->samplerTextures), ctx);
    }
    
    
    json->getProperty("images", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->images), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IBuiltinInfo(se::Object* obj) {
    auto* cls = se::Class::create("IBuiltinInfo", obj, nullptr, _SE(js_new_cc_IBuiltinInfo)); 
    
    cls->defineProperty("buffers", _SE(js_cc_IBuiltinInfo_buffers_get), _SE(js_cc_IBuiltinInfo_buffers_set)); 
    cls->defineProperty("blocks", _SE(js_cc_IBuiltinInfo_blocks_get), _SE(js_cc_IBuiltinInfo_blocks_set)); 
    cls->defineProperty("samplerTextures", _SE(js_cc_IBuiltinInfo_samplerTextures_get), _SE(js_cc_IBuiltinInfo_samplerTextures_set)); 
    cls->defineProperty("images", _SE(js_cc_IBuiltinInfo_images_get), _SE(js_cc_IBuiltinInfo_images_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IBuiltinInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IBuiltinInfo>(cls);
    
    __jsb_cc_IBuiltinInfo_proto = cls->getProto();
    __jsb_cc_IBuiltinInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IBuiltins_class = nullptr;
se::Object* __jsb_cc_IBuiltins_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IBuiltins) 

static bool js_cc_IBuiltins_globals_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBuiltins *arg1 = (cc::IBuiltins *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltins>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->globals, s.thisObject());
    SE_PRECONDITION2(ok, false, "IBuiltins_globals_set,2,SWIGTYPE_cc__IBuiltinInfo"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBuiltins_globals_set) 

static bool js_cc_IBuiltins_globals_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBuiltins *arg1 = (cc::IBuiltins *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltins>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->globals, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IBuiltins_globals_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->globals, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBuiltins_globals_get) 

static bool js_cc_IBuiltins_locals_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBuiltins *arg1 = (cc::IBuiltins *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltins>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->locals, s.thisObject());
    SE_PRECONDITION2(ok, false, "IBuiltins_locals_set,2,SWIGTYPE_cc__IBuiltinInfo"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBuiltins_locals_set) 

static bool js_cc_IBuiltins_locals_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBuiltins *arg1 = (cc::IBuiltins *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltins>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->locals, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IBuiltins_locals_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->locals, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBuiltins_locals_get) 

static bool js_cc_IBuiltins_statistics_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBuiltins *arg1 = (cc::IBuiltins *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltins>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->statistics, s.thisObject());
    SE_PRECONDITION2(ok, false, "IBuiltins_statistics_set,2,SWIGTYPE_ccstd__unordered_mapT_ccstd__string_int32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBuiltins_statistics_set) 

static bool js_cc_IBuiltins_statistics_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBuiltins *arg1 = (cc::IBuiltins *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltins>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->statistics, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IBuiltins_statistics_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->statistics, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBuiltins_statistics_get) 

// js_ctor
static bool js_new_cc_IBuiltins(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IBuiltins *result;
    result = (cc::IBuiltins *)new cc::IBuiltins();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IBuiltins, __jsb_cc_IBuiltins_class, js_delete_cc_IBuiltins)

static bool js_delete_cc_IBuiltins(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IBuiltins) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IBuiltins * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IBuiltins*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("globals", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->globals), ctx);
    }
    
    
    json->getProperty("locals", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->locals), ctx);
    }
    
    
    json->getProperty("statistics", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->statistics), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IBuiltins(se::Object* obj) {
    auto* cls = se::Class::create("IBuiltins", obj, nullptr, _SE(js_new_cc_IBuiltins)); 
    
    cls->defineProperty("globals", _SE(js_cc_IBuiltins_globals_get), _SE(js_cc_IBuiltins_globals_set)); 
    cls->defineProperty("locals", _SE(js_cc_IBuiltins_locals_get), _SE(js_cc_IBuiltins_locals_set)); 
    cls->defineProperty("statistics", _SE(js_cc_IBuiltins_statistics_get), _SE(js_cc_IBuiltins_statistics_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IBuiltins));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IBuiltins>(cls);
    
    __jsb_cc_IBuiltins_proto = cls->getProto();
    __jsb_cc_IBuiltins_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IShaderSource_class = nullptr;
se::Object* __jsb_cc_IShaderSource_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IShaderSource) 

static bool js_cc_IShaderSource_vert_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderSource *arg1 = (cc::IShaderSource *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderSource>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->vert, s.thisObject());
    SE_PRECONDITION2(ok, false, "IShaderSource_vert_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderSource_vert_set) 

static bool js_cc_IShaderSource_vert_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderSource *arg1 = (cc::IShaderSource *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderSource>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->vert, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IShaderSource_vert_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->vert, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderSource_vert_get) 

static bool js_cc_IShaderSource_frag_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderSource *arg1 = (cc::IShaderSource *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderSource>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->frag, s.thisObject());
    SE_PRECONDITION2(ok, false, "IShaderSource_frag_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderSource_frag_set) 

static bool js_cc_IShaderSource_frag_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderSource *arg1 = (cc::IShaderSource *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderSource>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->frag, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IShaderSource_frag_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->frag, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderSource_frag_get) 

// js_ctor
static bool js_new_cc_IShaderSource(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IShaderSource *result;
    result = (cc::IShaderSource *)new cc::IShaderSource();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IShaderSource, __jsb_cc_IShaderSource_class, js_delete_cc_IShaderSource)

static bool js_delete_cc_IShaderSource(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IShaderSource) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IShaderSource * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IShaderSource*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("vert", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->vert), ctx);
    }
    
    
    json->getProperty("frag", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->frag), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IShaderSource(se::Object* obj) {
    auto* cls = se::Class::create("IShaderSource", obj, nullptr, _SE(js_new_cc_IShaderSource)); 
    
    cls->defineProperty("vert", _SE(js_cc_IShaderSource_vert_get), _SE(js_cc_IShaderSource_vert_set)); 
    cls->defineProperty("frag", _SE(js_cc_IShaderSource_frag_get), _SE(js_cc_IShaderSource_frag_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IShaderSource));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IShaderSource>(cls);
    
    __jsb_cc_IShaderSource_proto = cls->getProto();
    __jsb_cc_IShaderSource_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IShaderInfo_class = nullptr;
se::Object* __jsb_cc_IShaderInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IShaderInfo) 

static bool js_cc_IShaderInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "IShaderInfo_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_name_set) 

static bool js_cc_IShaderInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IShaderInfo_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_name_get) 

static bool js_cc_IShaderInfo_hash_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->hash, s.thisObject());
    SE_PRECONDITION2(ok, false, "IShaderInfo_hash_set,2,SWIGTYPE_ccstd__hash_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_hash_set) 

static bool js_cc_IShaderInfo_hash_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->hash, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IShaderInfo_hash_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->hash, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_hash_get) 

static bool js_cc_IShaderInfo_glsl4_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->glsl4, s.thisObject());
    SE_PRECONDITION2(ok, false, "IShaderInfo_glsl4_set,2,SWIGTYPE_cc__IShaderSource"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_glsl4_set) 

static bool js_cc_IShaderInfo_glsl4_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->glsl4, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IShaderInfo_glsl4_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->glsl4, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_glsl4_get) 

static bool js_cc_IShaderInfo_glsl3_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->glsl3, s.thisObject());
    SE_PRECONDITION2(ok, false, "IShaderInfo_glsl3_set,2,SWIGTYPE_cc__IShaderSource"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_glsl3_set) 

static bool js_cc_IShaderInfo_glsl3_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->glsl3, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IShaderInfo_glsl3_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->glsl3, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_glsl3_get) 

static bool js_cc_IShaderInfo_glsl1_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->glsl1, s.thisObject());
    SE_PRECONDITION2(ok, false, "IShaderInfo_glsl1_set,2,SWIGTYPE_cc__IShaderSource"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_glsl1_set) 

static bool js_cc_IShaderInfo_glsl1_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->glsl1, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IShaderInfo_glsl1_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->glsl1, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_glsl1_get) 

static bool js_cc_IShaderInfo_builtins_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->builtins, s.thisObject());
    SE_PRECONDITION2(ok, false, "IShaderInfo_builtins_set,2,SWIGTYPE_cc__IBuiltins"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_builtins_set) 

static bool js_cc_IShaderInfo_builtins_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->builtins, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IShaderInfo_builtins_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->builtins, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_builtins_get) 

static bool js_cc_IShaderInfo_defines_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->defines, s.thisObject());
    SE_PRECONDITION2(ok, false, "IShaderInfo_defines_set,2,SWIGTYPE_ccstd__vectorT_cc__IDefineInfo_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_defines_set) 

static bool js_cc_IShaderInfo_defines_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->defines, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IShaderInfo_defines_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->defines, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_defines_get) 

static bool js_cc_IShaderInfo_attributes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->attributes, s.thisObject());
    SE_PRECONDITION2(ok, false, "IShaderInfo_attributes_set,2,SWIGTYPE_ccstd__vectorT_cc__IAttributeInfo_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_attributes_set) 

static bool js_cc_IShaderInfo_attributes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->attributes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IShaderInfo_attributes_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->attributes, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_attributes_get) 

static bool js_cc_IShaderInfo_blocks_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->blocks, s.thisObject());
    SE_PRECONDITION2(ok, false, "IShaderInfo_blocks_set,2,SWIGTYPE_ccstd__vectorT_cc__IBlockInfo_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_blocks_set) 

static bool js_cc_IShaderInfo_blocks_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->blocks, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IShaderInfo_blocks_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blocks, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_blocks_get) 

static bool js_cc_IShaderInfo_samplerTextures_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->samplerTextures, s.thisObject());
    SE_PRECONDITION2(ok, false, "IShaderInfo_samplerTextures_set,2,SWIGTYPE_ccstd__vectorT_cc__ISamplerTextureInfo_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_samplerTextures_set) 

static bool js_cc_IShaderInfo_samplerTextures_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->samplerTextures, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IShaderInfo_samplerTextures_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->samplerTextures, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_samplerTextures_get) 

static bool js_cc_IShaderInfo_samplers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->samplers, s.thisObject());
    SE_PRECONDITION2(ok, false, "IShaderInfo_samplers_set,2,SWIGTYPE_ccstd__vectorT_cc__ISamplerInfo_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_samplers_set) 

static bool js_cc_IShaderInfo_samplers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->samplers, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IShaderInfo_samplers_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->samplers, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_samplers_get) 

static bool js_cc_IShaderInfo_textures_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->textures, s.thisObject());
    SE_PRECONDITION2(ok, false, "IShaderInfo_textures_set,2,SWIGTYPE_ccstd__vectorT_cc__ITextureInfo_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_textures_set) 

static bool js_cc_IShaderInfo_textures_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->textures, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IShaderInfo_textures_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->textures, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_textures_get) 

static bool js_cc_IShaderInfo_buffers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->buffers, s.thisObject());
    SE_PRECONDITION2(ok, false, "IShaderInfo_buffers_set,2,SWIGTYPE_ccstd__vectorT_cc__IBufferInfo_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_buffers_set) 

static bool js_cc_IShaderInfo_buffers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->buffers, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IShaderInfo_buffers_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->buffers, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_buffers_get) 

static bool js_cc_IShaderInfo_images_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->images, s.thisObject());
    SE_PRECONDITION2(ok, false, "IShaderInfo_images_set,2,SWIGTYPE_ccstd__vectorT_cc__IImageInfo_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_images_set) 

static bool js_cc_IShaderInfo_images_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->images, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IShaderInfo_images_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->images, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_images_get) 

static bool js_cc_IShaderInfo_subpassInputs_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->subpassInputs, s.thisObject());
    SE_PRECONDITION2(ok, false, "IShaderInfo_subpassInputs_set,2,SWIGTYPE_ccstd__vectorT_cc__IInputAttachmentInfo_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_subpassInputs_set) 

static bool js_cc_IShaderInfo_subpassInputs_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->subpassInputs, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IShaderInfo_subpassInputs_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->subpassInputs, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_subpassInputs_get) 

static bool js_cc_IShaderInfo_getSource(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    cc::IShaderSource *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "IShaderInfo_getSource,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = (cc::IShaderSource *)((cc::IShaderInfo const *)arg1)->getSource((ccstd::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IShaderInfo_getSource, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_IShaderInfo_getSource) 

// js_ctor
static bool js_new_cc_IShaderInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IShaderInfo *result;
    result = (cc::IShaderInfo *)new cc::IShaderInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IShaderInfo, __jsb_cc_IShaderInfo_class, js_delete_cc_IShaderInfo)

static bool js_delete_cc_IShaderInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IShaderInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IShaderInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IShaderInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("hash", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->hash), ctx);
    }
    
    
    json->getProperty("glsl4", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->glsl4), ctx);
    }
    
    
    json->getProperty("glsl3", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->glsl3), ctx);
    }
    
    
    json->getProperty("glsl1", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->glsl1), ctx);
    }
    
    
    json->getProperty("builtins", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->builtins), ctx);
    }
    
    
    json->getProperty("defines", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->defines), ctx);
    }
    
    
    json->getProperty("attributes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->attributes), ctx);
    }
    
    
    json->getProperty("blocks", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blocks), ctx);
    }
    
    
    json->getProperty("samplerTextures", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->samplerTextures), ctx);
    }
    
    
    json->getProperty("samplers", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->samplers), ctx);
    }
    
    
    json->getProperty("textures", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->textures), ctx);
    }
    
    
    json->getProperty("buffers", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->buffers), ctx);
    }
    
    
    json->getProperty("images", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->images), ctx);
    }
    
    
    json->getProperty("subpassInputs", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->subpassInputs), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IShaderInfo(se::Object* obj) {
    auto* cls = se::Class::create("IShaderInfo", obj, nullptr, _SE(js_new_cc_IShaderInfo)); 
    
    cls->defineProperty("name", _SE(js_cc_IShaderInfo_name_get), _SE(js_cc_IShaderInfo_name_set)); 
    cls->defineProperty("hash", _SE(js_cc_IShaderInfo_hash_get), _SE(js_cc_IShaderInfo_hash_set)); 
    cls->defineProperty("glsl4", _SE(js_cc_IShaderInfo_glsl4_get), _SE(js_cc_IShaderInfo_glsl4_set)); 
    cls->defineProperty("glsl3", _SE(js_cc_IShaderInfo_glsl3_get), _SE(js_cc_IShaderInfo_glsl3_set)); 
    cls->defineProperty("glsl1", _SE(js_cc_IShaderInfo_glsl1_get), _SE(js_cc_IShaderInfo_glsl1_set)); 
    cls->defineProperty("builtins", _SE(js_cc_IShaderInfo_builtins_get), _SE(js_cc_IShaderInfo_builtins_set)); 
    cls->defineProperty("defines", _SE(js_cc_IShaderInfo_defines_get), _SE(js_cc_IShaderInfo_defines_set)); 
    cls->defineProperty("attributes", _SE(js_cc_IShaderInfo_attributes_get), _SE(js_cc_IShaderInfo_attributes_set)); 
    cls->defineProperty("blocks", _SE(js_cc_IShaderInfo_blocks_get), _SE(js_cc_IShaderInfo_blocks_set)); 
    cls->defineProperty("samplerTextures", _SE(js_cc_IShaderInfo_samplerTextures_get), _SE(js_cc_IShaderInfo_samplerTextures_set)); 
    cls->defineProperty("samplers", _SE(js_cc_IShaderInfo_samplers_get), _SE(js_cc_IShaderInfo_samplers_set)); 
    cls->defineProperty("textures", _SE(js_cc_IShaderInfo_textures_get), _SE(js_cc_IShaderInfo_textures_set)); 
    cls->defineProperty("buffers", _SE(js_cc_IShaderInfo_buffers_get), _SE(js_cc_IShaderInfo_buffers_set)); 
    cls->defineProperty("images", _SE(js_cc_IShaderInfo_images_get), _SE(js_cc_IShaderInfo_images_set)); 
    cls->defineProperty("subpassInputs", _SE(js_cc_IShaderInfo_subpassInputs_get), _SE(js_cc_IShaderInfo_subpassInputs_set)); 
    
    cls->defineFunction("getSource", _SE(js_cc_IShaderInfo_getSource)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IShaderInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IShaderInfo>(cls);
    
    __jsb_cc_IShaderInfo_proto = cls->getProto();
    __jsb_cc_IShaderInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_EffectAsset_class = nullptr;
se::Object* __jsb_cc_EffectAsset_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_EffectAsset) 

// js_ctor
static bool js_new_cc_EffectAsset(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::EffectAsset *result;
    result = (cc::EffectAsset *)new cc::EffectAsset();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_EffectAsset, __jsb_cc_EffectAsset_class, js_delete_cc_EffectAsset)

static bool js_delete_cc_EffectAsset(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_EffectAsset) 

static bool js_cc_EffectAsset_cpp_keyword_register_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::EffectAsset *arg1 = (cc::EffectAsset *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "EffectAsset_cpp_keyword_register,1,SWIGTYPE_p_cc__EffectAsset"); 
    cc::EffectAsset::registerAsset(arg1);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_EffectAsset_cpp_keyword_register_static) 

static bool js_cc_EffectAsset_remove_static__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    ccstd::string *arg1 = 0 ;
    ccstd::string temp1 ;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "EffectAsset_remove,1,SWIGTYPE_p_ccstd__string");
    arg1 = &temp1;
    
    cc::EffectAsset::remove((ccstd::string const &)*arg1);
    
    
    return true;
}

static bool js_cc_EffectAsset_remove_static__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::EffectAsset *arg1 = (cc::EffectAsset *) NULL ;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "EffectAsset_remove,1,SWIGTYPE_p_cc__EffectAsset"); 
    cc::EffectAsset::remove(arg1);
    
    
    return true;
}

static bool js_cc_EffectAsset_remove_static(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_EffectAsset_remove_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_EffectAsset_remove_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_EffectAsset_remove_static) 

static bool js_cc_EffectAsset_get_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    ccstd::string *arg1 = 0 ;
    ccstd::string temp1 ;
    cc::EffectAsset *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "EffectAsset_get,1,SWIGTYPE_p_ccstd__string");
    arg1 = &temp1;
    
    result = (cc::EffectAsset *)cc::EffectAsset::get((ccstd::string const &)*arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "EffectAsset_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_EffectAsset_get_static) 

static bool js_cc_EffectAsset_getAll_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::EffectAsset::RegisteredEffectAssetMap *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::EffectAsset::RegisteredEffectAssetMap *) &cc::EffectAsset::getAll();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "EffectAsset_getAll, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_EffectAsset_getAll_static) 

static bool js_cc_EffectAsset_isLayoutValid_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (bool)cc::EffectAsset::isLayoutValid();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_EffectAsset_isLayoutValid_static) 

static bool js_cc_EffectAsset_setLayoutValid_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    cc::EffectAsset::setLayoutValid();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_EffectAsset_setLayoutValid_static) 

static bool js_cc_EffectAsset_hideInEditor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::EffectAsset *arg1 = (cc::EffectAsset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EffectAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->hideInEditor);
    SE_PRECONDITION2(ok, false, "EffectAsset_hideInEditor_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_EffectAsset_hideInEditor_set) 

static bool js_cc_EffectAsset_hideInEditor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::EffectAsset *arg1 = (cc::EffectAsset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EffectAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->hideInEditor, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_EffectAsset_hideInEditor_get) 

static bool js_cc_EffectAsset__techniques_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::EffectAsset *arg1 = (cc::EffectAsset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EffectAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_techniques, s.thisObject());
    SE_PRECONDITION2(ok, false, "EffectAsset__techniques_set,2,SWIGTYPE_ccstd__vectorT_cc__ITechniqueInfo_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_EffectAsset__techniques_set) 

static bool js_cc_EffectAsset__techniques_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::EffectAsset *arg1 = (cc::EffectAsset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EffectAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_techniques, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "EffectAsset__techniques_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_techniques, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_EffectAsset__techniques_get) 

static bool js_cc_EffectAsset__shaders_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::EffectAsset *arg1 = (cc::EffectAsset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EffectAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_shaders, s.thisObject());
    SE_PRECONDITION2(ok, false, "EffectAsset__shaders_set,2,SWIGTYPE_ccstd__vectorT_cc__IShaderInfo_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_EffectAsset__shaders_set) 

static bool js_cc_EffectAsset__shaders_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::EffectAsset *arg1 = (cc::EffectAsset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EffectAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_shaders, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "EffectAsset__shaders_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_shaders, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_EffectAsset__shaders_get) 

static bool js_cc_EffectAsset__combinations_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::EffectAsset *arg1 = (cc::EffectAsset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EffectAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_combinations, s.thisObject());
    SE_PRECONDITION2(ok, false, "EffectAsset__combinations_set,2,SWIGTYPE_ccstd__vectorT_cc__IPreCompileInfo_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_EffectAsset__combinations_set) 

static bool js_cc_EffectAsset__combinations_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::EffectAsset *arg1 = (cc::EffectAsset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EffectAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_combinations, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "EffectAsset__combinations_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_combinations, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_EffectAsset__combinations_get) 

static bool js_cc_EffectAsset_techniques_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::EffectAsset *arg1 = (cc::EffectAsset *) NULL ;
    ccstd::vector< cc::ITechniqueInfo > *arg2 = 0 ;
    ccstd::vector< cc::ITechniqueInfo > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::EffectAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "EffectAsset_techniques_set,2,SWIGTYPE_p_ccstd__vectorT_cc__ITechniqueInfo_t");
    arg2 = &temp2;
    
    cc_EffectAsset_techniques_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_EffectAsset_techniques_set) 

static bool js_cc_EffectAsset_techniques_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::EffectAsset *arg1 = (cc::EffectAsset *) NULL ;
    ccstd::vector< cc::ITechniqueInfo > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::EffectAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::ITechniqueInfo > *) &cc_EffectAsset_techniques_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "EffectAsset_techniques_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_EffectAsset_techniques_get) 

static bool js_cc_EffectAsset_shaders_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::EffectAsset *arg1 = (cc::EffectAsset *) NULL ;
    ccstd::vector< cc::IShaderInfo > *arg2 = 0 ;
    ccstd::vector< cc::IShaderInfo > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::EffectAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "EffectAsset_shaders_set,2,SWIGTYPE_p_ccstd__vectorT_cc__IShaderInfo_t");
    arg2 = &temp2;
    
    cc_EffectAsset_shaders_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_EffectAsset_shaders_set) 

static bool js_cc_EffectAsset_shaders_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::EffectAsset *arg1 = (cc::EffectAsset *) NULL ;
    ccstd::vector< cc::IShaderInfo > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::EffectAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::IShaderInfo > *) &cc_EffectAsset_shaders_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "EffectAsset_shaders_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_EffectAsset_shaders_get) 

static bool js_cc_EffectAsset_combinations_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::EffectAsset *arg1 = (cc::EffectAsset *) NULL ;
    ccstd::vector< cc::IPreCompileInfo > *arg2 = 0 ;
    ccstd::vector< cc::IPreCompileInfo > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::EffectAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "EffectAsset_combinations_set,2,SWIGTYPE_p_ccstd__vectorT_cc__IPreCompileInfo_t");
    arg2 = &temp2;
    
    cc_EffectAsset_combinations_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_EffectAsset_combinations_set) 

static bool js_cc_EffectAsset_combinations_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::EffectAsset *arg1 = (cc::EffectAsset *) NULL ;
    ccstd::vector< cc::IPreCompileInfo > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::EffectAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::IPreCompileInfo > *) &cc_EffectAsset_combinations_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "EffectAsset_combinations_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_EffectAsset_combinations_get) 

bool js_register_cc_EffectAsset(se::Object* obj) {
    auto* cls = se::Class::create("EffectAsset", obj, __jsb_cc_Asset_proto, _SE(js_new_cc_EffectAsset)); 
    
    cls->defineProperty("hideInEditor", _SE(js_cc_EffectAsset_hideInEditor_get), _SE(js_cc_EffectAsset_hideInEditor_set)); 
    cls->defineProperty("_techniques", _SE(js_cc_EffectAsset__techniques_get), _SE(js_cc_EffectAsset__techniques_set)); 
    cls->defineProperty("_shaders", _SE(js_cc_EffectAsset__shaders_get), _SE(js_cc_EffectAsset__shaders_set)); 
    cls->defineProperty("_combinations", _SE(js_cc_EffectAsset__combinations_get), _SE(js_cc_EffectAsset__combinations_set)); 
    cls->defineProperty("techniques", _SE(js_cc_EffectAsset_techniques_get), _SE(js_cc_EffectAsset_techniques_set)); 
    cls->defineProperty("shaders", _SE(js_cc_EffectAsset_shaders_get), _SE(js_cc_EffectAsset_shaders_set)); 
    cls->defineProperty("combinations", _SE(js_cc_EffectAsset_combinations_get), _SE(js_cc_EffectAsset_combinations_set)); 
    
    
    
    cls->defineStaticFunction("register", _SE(js_cc_EffectAsset_cpp_keyword_register_static)); 
    cls->defineStaticFunction("remove", _SE(js_cc_EffectAsset_remove_static)); 
    cls->defineStaticFunction("get", _SE(js_cc_EffectAsset_get_static)); 
    cls->defineStaticFunction("getAll", _SE(js_cc_EffectAsset_getAll_static)); 
    cls->defineStaticFunction("isLayoutValid", _SE(js_cc_EffectAsset_isLayoutValid_static)); 
    cls->defineStaticFunction("setLayoutValid", _SE(js_cc_EffectAsset_setLayoutValid_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_EffectAsset));
    
    
    cls->install();
    JSBClassType::registerClass<cc::EffectAsset>(cls);
    
    __jsb_cc_EffectAsset_proto = cls->getProto();
    __jsb_cc_EffectAsset_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IMemoryImageSource_class = nullptr;
se::Object* __jsb_cc_IMemoryImageSource_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IMemoryImageSource) 

static bool js_cc_IMemoryImageSource__data_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMemoryImageSource *arg1 = (cc::IMemoryImageSource *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMemoryImageSource>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->data, s.thisObject());
    SE_PRECONDITION2(ok, false, "IMemoryImageSource__data_set,2,SWIGTYPE_cc__IntrusivePtrT_cc__ArrayBuffer_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMemoryImageSource__data_set) 

static bool js_cc_IMemoryImageSource__data_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMemoryImageSource *arg1 = (cc::IMemoryImageSource *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMemoryImageSource>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->data, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IMemoryImageSource__data_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->data, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMemoryImageSource__data_get) 

static bool js_cc_IMemoryImageSource__compressed_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMemoryImageSource *arg1 = (cc::IMemoryImageSource *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMemoryImageSource>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->compressed);
    SE_PRECONDITION2(ok, false, "IMemoryImageSource__compressed_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMemoryImageSource__compressed_set) 

static bool js_cc_IMemoryImageSource__compressed_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMemoryImageSource *arg1 = (cc::IMemoryImageSource *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMemoryImageSource>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->compressed, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMemoryImageSource__compressed_get) 

static bool js_cc_IMemoryImageSource_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMemoryImageSource *arg1 = (cc::IMemoryImageSource *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMemoryImageSource>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->width, s.thisObject());
    SE_PRECONDITION2(ok, false, "IMemoryImageSource_width_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMemoryImageSource_width_set) 

static bool js_cc_IMemoryImageSource_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMemoryImageSource *arg1 = (cc::IMemoryImageSource *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMemoryImageSource>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->width, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IMemoryImageSource_width_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->width, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMemoryImageSource_width_get) 

static bool js_cc_IMemoryImageSource_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMemoryImageSource *arg1 = (cc::IMemoryImageSource *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMemoryImageSource>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->height, s.thisObject());
    SE_PRECONDITION2(ok, false, "IMemoryImageSource_height_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMemoryImageSource_height_set) 

static bool js_cc_IMemoryImageSource_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMemoryImageSource *arg1 = (cc::IMemoryImageSource *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMemoryImageSource>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->height, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IMemoryImageSource_height_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->height, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMemoryImageSource_height_get) 

static bool js_cc_IMemoryImageSource_format_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMemoryImageSource *arg1 = (cc::IMemoryImageSource *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::IMemoryImageSource>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "IMemoryImageSource_format_set,2,SWIGTYPE_cc__PixelFormat");
    arg1->format = (cc::PixelFormat)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMemoryImageSource_format_set) 

static bool js_cc_IMemoryImageSource_format_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMemoryImageSource *arg1 = (cc::IMemoryImageSource *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::IMemoryImageSource>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->format));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMemoryImageSource_format_get) 

// js_ctor
static bool js_new_cc_IMemoryImageSource(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IMemoryImageSource *result;
    result = (cc::IMemoryImageSource *)new cc::IMemoryImageSource();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IMemoryImageSource, __jsb_cc_IMemoryImageSource_class, js_delete_cc_IMemoryImageSource)

static bool js_delete_cc_IMemoryImageSource(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IMemoryImageSource) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IMemoryImageSource * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IMemoryImageSource*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("_data", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->data), ctx);
    }
    
    
    json->getProperty("_compressed", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->compressed), ctx);
    }
    
    
    json->getProperty("width", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->width), ctx);
    }
    
    
    json->getProperty("height", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->height), ctx);
    }
    
    
    json->getProperty("format", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->format), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IMemoryImageSource(se::Object* obj) {
    auto* cls = se::Class::create("IMemoryImageSource", obj, nullptr, _SE(js_new_cc_IMemoryImageSource)); 
    
    cls->defineProperty("_data", _SE(js_cc_IMemoryImageSource__data_get), _SE(js_cc_IMemoryImageSource__data_set)); 
    cls->defineProperty("_compressed", _SE(js_cc_IMemoryImageSource__compressed_get), _SE(js_cc_IMemoryImageSource__compressed_set)); 
    cls->defineProperty("width", _SE(js_cc_IMemoryImageSource_width_get), _SE(js_cc_IMemoryImageSource_width_set)); 
    cls->defineProperty("height", _SE(js_cc_IMemoryImageSource_height_get), _SE(js_cc_IMemoryImageSource_height_set)); 
    cls->defineProperty("format", _SE(js_cc_IMemoryImageSource_format_get), _SE(js_cc_IMemoryImageSource_format_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IMemoryImageSource));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IMemoryImageSource>(cls);
    
    __jsb_cc_IMemoryImageSource_proto = cls->getProto();
    __jsb_cc_IMemoryImageSource_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_ImageAsset_class = nullptr;
se::Object* __jsb_cc_ImageAsset_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_ImageAsset) 

// js_ctor
static bool js_new_cc_ImageAsset(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::ImageAsset *result;
    result = (cc::ImageAsset *)new cc::ImageAsset();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_ImageAsset, __jsb_cc_ImageAsset_class, js_delete_cc_ImageAsset)

static bool js_delete_cc_ImageAsset(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_ImageAsset) 

static bool js_cc_ImageAsset_getData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ImageAsset *arg1 = (cc::ImageAsset *) NULL ;
    uint8_t *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ImageAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (uint8_t *)((cc::ImageAsset const *)arg1)->getData();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ImageAsset_getData, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ImageAsset_getData) 

static bool js_cc_ImageAsset_getWidth(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ImageAsset *arg1 = (cc::ImageAsset *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ImageAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::ImageAsset const *)arg1)->getWidth();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ImageAsset_getWidth, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ImageAsset_getWidth) 

static bool js_cc_ImageAsset_getHeight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ImageAsset *arg1 = (cc::ImageAsset *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ImageAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::ImageAsset const *)arg1)->getHeight();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ImageAsset_getHeight, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ImageAsset_getHeight) 

static bool js_cc_ImageAsset_isCompressed(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ImageAsset *arg1 = (cc::ImageAsset *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ImageAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((cc::ImageAsset const *)arg1)->isCompressed();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ImageAsset_isCompressed) 

static bool js_cc_ImageAsset_setWidth(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ImageAsset *arg1 = (cc::ImageAsset *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ImageAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ImageAsset_setWidth,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setWidth(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ImageAsset_setWidth) 

static bool js_cc_ImageAsset_setHeight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ImageAsset *arg1 = (cc::ImageAsset *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ImageAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ImageAsset_setHeight,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setHeight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ImageAsset_setHeight) 

static bool js_cc_ImageAsset_format_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ImageAsset *arg1 = (cc::ImageAsset *) NULL ;
    cc::PixelFormat arg2 ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::ImageAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "ImageAsset_format_set,2,SWIGTYPE_cc__PixelFormat");
    arg2 = (cc::PixelFormat)temp2;
    cc_ImageAsset_format_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ImageAsset_format_set) 

static bool js_cc_ImageAsset_format_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ImageAsset *arg1 = (cc::ImageAsset *) NULL ;
    cc::PixelFormat result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::ImageAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::PixelFormat)cc_ImageAsset_format_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ImageAsset_format_get) 

static bool js_cc_ImageAsset_url_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ImageAsset *arg1 = (cc::ImageAsset *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::ImageAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ImageAsset_url_set,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    cc_ImageAsset_url_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ImageAsset_url_set) 

static bool js_cc_ImageAsset_url_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ImageAsset *arg1 = (cc::ImageAsset *) NULL ;
    ccstd::string *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::ImageAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::string *) &cc_ImageAsset_url_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ImageAsset_url_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ImageAsset_url_get) 

bool js_register_cc_ImageAsset(se::Object* obj) {
    auto* cls = se::Class::create("ImageAsset", obj, __jsb_cc_Asset_proto, _SE(js_new_cc_ImageAsset)); 
    
    cls->defineProperty("format", _SE(js_cc_ImageAsset_format_get), _SE(js_cc_ImageAsset_format_set)); 
    cls->defineProperty("url", _SE(js_cc_ImageAsset_url_get), _SE(js_cc_ImageAsset_url_set)); 
    
    cls->defineFunction("getData", _SE(js_cc_ImageAsset_getData)); 
    cls->defineFunction("getWidth", _SE(js_cc_ImageAsset_getWidth)); 
    cls->defineFunction("getHeight", _SE(js_cc_ImageAsset_getHeight)); 
    cls->defineFunction("isCompressed", _SE(js_cc_ImageAsset_isCompressed)); 
    cls->defineFunction("setWidth", _SE(js_cc_ImageAsset_setWidth)); 
    cls->defineFunction("setHeight", _SE(js_cc_ImageAsset_setHeight)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_ImageAsset));
    
    
    cls->install();
    JSBClassType::registerClass<cc::ImageAsset>(cls);
    
    __jsb_cc_ImageAsset_proto = cls->getProto();
    __jsb_cc_ImageAsset_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_SceneAsset_class = nullptr;
se::Object* __jsb_cc_SceneAsset_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_SceneAsset) 

// js_ctor
static bool js_new_cc_SceneAsset(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::SceneAsset *result;
    result = (cc::SceneAsset *)new cc::SceneAsset();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_SceneAsset, __jsb_cc_SceneAsset_class, js_delete_cc_SceneAsset)

static bool js_delete_cc_SceneAsset(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_SceneAsset) 

static bool js_cc_SceneAsset_getScene(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneAsset *arg1 = (cc::SceneAsset *) NULL ;
    cc::Scene *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Scene *)((cc::SceneAsset const *)arg1)->getScene();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SceneAsset_getScene, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneAsset_getScene) 

static bool js_cc_SceneAsset_setScene(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneAsset *arg1 = (cc::SceneAsset *) NULL ;
    cc::Scene *arg2 = (cc::Scene *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SceneAsset_setScene,2,SWIGTYPE_p_cc__Scene"); 
    (arg1)->setScene(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneAsset_setScene) 

bool js_register_cc_SceneAsset(se::Object* obj) {
    auto* cls = se::Class::create("SceneAsset", obj, __jsb_cc_Asset_proto, _SE(js_new_cc_SceneAsset)); 
    
    
    cls->defineFunction("getScene", _SE(js_cc_SceneAsset_getScene)); 
    cls->defineFunction("setScene", _SE(js_cc_SceneAsset_setScene)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_SceneAsset));
    
    
    cls->install();
    JSBClassType::registerClass<cc::SceneAsset>(cls);
    
    __jsb_cc_SceneAsset_proto = cls->getProto();
    __jsb_cc_SceneAsset_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_TextAsset_class = nullptr;
se::Object* __jsb_cc_TextAsset_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_TextAsset) 

// js_ctor
static bool js_new_cc_TextAsset(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::TextAsset *result;
    result = (cc::TextAsset *)new cc::TextAsset();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_TextAsset, __jsb_cc_TextAsset_class, js_delete_cc_TextAsset)

static bool js_delete_cc_TextAsset(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_TextAsset) 

static bool js_cc_TextAsset_text_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextAsset *arg1 = (cc::TextAsset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->text, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextAsset_text_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextAsset_text_set) 

static bool js_cc_TextAsset_text_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextAsset *arg1 = (cc::TextAsset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextAsset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->text, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextAsset_text_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->text, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextAsset_text_get) 

bool js_register_cc_TextAsset(se::Object* obj) {
    auto* cls = se::Class::create("TextAsset", obj, __jsb_cc_Asset_proto, _SE(js_new_cc_TextAsset)); 
    
    cls->defineProperty("text", _SE(js_cc_TextAsset_text_get), _SE(js_cc_TextAsset_text_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_TextAsset));
    
    
    cls->install();
    JSBClassType::registerClass<cc::TextAsset>(cls);
    
    __jsb_cc_TextAsset_proto = cls->getProto();
    __jsb_cc_TextAsset_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IMaterialInfo_class = nullptr;
se::Object* __jsb_cc_IMaterialInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IMaterialInfo) 

static bool js_cc_IMaterialInfo_effectAsset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMaterialInfo *arg1 = (cc::IMaterialInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->effectAsset, s.thisObject());
    SE_PRECONDITION2(ok, false, "IMaterialInfo_effectAsset_set,2,SWIGTYPE_p_cc__EffectAsset"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMaterialInfo_effectAsset_set) 

static bool js_cc_IMaterialInfo_effectAsset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMaterialInfo *arg1 = (cc::IMaterialInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->effectAsset, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IMaterialInfo_effectAsset_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->effectAsset, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMaterialInfo_effectAsset_get) 

static bool js_cc_IMaterialInfo_effectName_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMaterialInfo *arg1 = (cc::IMaterialInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->effectName, s.thisObject());
    SE_PRECONDITION2(ok, false, "IMaterialInfo_effectName_set,2,SWIGTYPE_ccstd__optionalT_ccstd__string_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMaterialInfo_effectName_set) 

static bool js_cc_IMaterialInfo_effectName_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMaterialInfo *arg1 = (cc::IMaterialInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->effectName, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IMaterialInfo_effectName_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->effectName, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMaterialInfo_effectName_get) 

static bool js_cc_IMaterialInfo_technique_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMaterialInfo *arg1 = (cc::IMaterialInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->technique, s.thisObject());
    SE_PRECONDITION2(ok, false, "IMaterialInfo_technique_set,2,SWIGTYPE_ccstd__optionalT_uint32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMaterialInfo_technique_set) 

static bool js_cc_IMaterialInfo_technique_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMaterialInfo *arg1 = (cc::IMaterialInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->technique, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IMaterialInfo_technique_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->technique, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMaterialInfo_technique_get) 

static bool js_cc_IMaterialInfo_defines_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMaterialInfo *arg1 = (cc::IMaterialInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->defines, s.thisObject());
    SE_PRECONDITION2(ok, false, "IMaterialInfo_defines_set,2,SWIGTYPE_ccstd__optionalT_cc__IMaterialInfo__DefinesType_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMaterialInfo_defines_set) 

static bool js_cc_IMaterialInfo_defines_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMaterialInfo *arg1 = (cc::IMaterialInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->defines, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IMaterialInfo_defines_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->defines, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMaterialInfo_defines_get) 

static bool js_cc_IMaterialInfo_states_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMaterialInfo *arg1 = (cc::IMaterialInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->states, s.thisObject());
    SE_PRECONDITION2(ok, false, "IMaterialInfo_states_set,2,SWIGTYPE_ccstd__optionalT_cc__IMaterialInfo__PassOverridesType_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMaterialInfo_states_set) 

static bool js_cc_IMaterialInfo_states_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMaterialInfo *arg1 = (cc::IMaterialInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->states, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IMaterialInfo_states_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->states, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMaterialInfo_states_get) 

// js_ctor
static bool js_new_cc_IMaterialInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IMaterialInfo *result;
    result = (cc::IMaterialInfo *)new cc::IMaterialInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IMaterialInfo, __jsb_cc_IMaterialInfo_class, js_delete_cc_IMaterialInfo)

static bool js_delete_cc_IMaterialInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IMaterialInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IMaterialInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IMaterialInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("effectAsset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->effectAsset), ctx);
    }
    
    
    json->getProperty("effectName", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->effectName), ctx);
    }
    
    
    json->getProperty("technique", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->technique), ctx);
    }
    
    
    json->getProperty("defines", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->defines), ctx);
    }
    
    
    json->getProperty("states", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->states), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IMaterialInfo(se::Object* obj) {
    auto* cls = se::Class::create("IMaterialInfo", obj, nullptr, _SE(js_new_cc_IMaterialInfo)); 
    
    cls->defineProperty("effectAsset", _SE(js_cc_IMaterialInfo_effectAsset_get), _SE(js_cc_IMaterialInfo_effectAsset_set)); 
    cls->defineProperty("effectName", _SE(js_cc_IMaterialInfo_effectName_get), _SE(js_cc_IMaterialInfo_effectName_set)); 
    cls->defineProperty("technique", _SE(js_cc_IMaterialInfo_technique_get), _SE(js_cc_IMaterialInfo_technique_set)); 
    cls->defineProperty("defines", _SE(js_cc_IMaterialInfo_defines_get), _SE(js_cc_IMaterialInfo_defines_set)); 
    cls->defineProperty("states", _SE(js_cc_IMaterialInfo_states_get), _SE(js_cc_IMaterialInfo_states_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IMaterialInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IMaterialInfo>(cls);
    
    __jsb_cc_IMaterialInfo_proto = cls->getProto();
    __jsb_cc_IMaterialInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Material_class = nullptr;
se::Object* __jsb_cc_Material_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Material) 

static bool js_cc_Material_getHashForMaterial_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::hash_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_getHashForMaterial,1,SWIGTYPE_p_cc__Material"); 
    result = cc::Material::getHashForMaterial(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Material_getHashForMaterial, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Material_getHashForMaterial_static) 

// js_ctor
static bool js_new_cc_Material(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::Material *result;
    result = (cc::Material *)new cc::Material();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Material, __jsb_cc_Material_class, js_delete_cc_Material)

static bool js_delete_cc_Material(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Material) 

static bool js_cc_Material_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Material *arg1 = (cc::Material *) NULL ;
    cc::IMaterialInfo *arg2 = 0 ;
    cc::IMaterialInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_initialize,2,SWIGTYPE_p_cc__IMaterialInfo");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::IMaterialInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Material_initialize) 

static bool js_cc_Material_reset(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Material *arg1 = (cc::Material *) NULL ;
    cc::IMaterialInfo *arg2 = 0 ;
    cc::IMaterialInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_reset,2,SWIGTYPE_p_cc__IMaterialInfo");
    arg2 = &temp2;
    
    (arg1)->reset((cc::IMaterialInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Material_reset) 

static bool js_cc_Material_recompileShaders__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    cc::MacroRecord *arg2 = 0 ;
    cc::MacroRecord temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_recompileShaders,2,SWIGTYPE_p_ccstd__unordered_mapT_ccstd__string_cc__MacroValue_t");
    arg2 = &temp2;
    
    (arg1)->recompileShaders((cc::MacroRecord const &)*arg2);
    
    
    return true;
}

static bool js_cc_Material_recompileShaders__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    cc::MacroRecord *arg2 = 0 ;
    index_t arg3 ;
    cc::MacroRecord temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_recompileShaders,2,SWIGTYPE_p_ccstd__unordered_mapT_ccstd__string_cc__MacroValue_t");
    arg2 = &temp2;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_recompileShaders,3,SWIGTYPE_int32_t"); 
    
    (arg1)->recompileShaders((cc::MacroRecord const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_Material_recompileShaders(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Material_recompileShaders__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Material_recompileShaders__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_recompileShaders) 

static bool js_cc_Material_overridePipelineStates__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    cc::PassOverrides *arg2 = 0 ;
    cc::PassOverrides temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_overridePipelineStates,2,SWIGTYPE_p_cc__IPassStates");
    arg2 = &temp2;
    
    (arg1)->overridePipelineStates((cc::PassOverrides const &)*arg2);
    
    
    return true;
}

static bool js_cc_Material_overridePipelineStates__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    cc::PassOverrides *arg2 = 0 ;
    index_t arg3 ;
    cc::PassOverrides temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_overridePipelineStates,2,SWIGTYPE_p_cc__IPassStates");
    arg2 = &temp2;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_overridePipelineStates,3,SWIGTYPE_int32_t"); 
    
    (arg1)->overridePipelineStates((cc::PassOverrides const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_Material_overridePipelineStates(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Material_overridePipelineStates__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Material_overridePipelineStates__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_overridePipelineStates) 

static bool js_cc_Material_resetUniforms__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Material_resetUniforms,2,SWIGTYPE_bool"); 
    (arg1)->resetUniforms(arg2);
    
    
    return true;
}

static bool js_cc_Material_resetUniforms__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->resetUniforms();
    
    
    return true;
}

static bool js_cc_Material_resetUniforms(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Material_resetUniforms__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 0) {
        ok = js_cc_Material_resetUniforms__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_resetUniforms) 

static bool js_cc_Material_setPropertyNull__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    index_t arg3 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyNull,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyNull,3,SWIGTYPE_int32_t"); 
    
    (arg1)->setPropertyNull((ccstd::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyNull__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyNull,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    (arg1)->setPropertyNull((ccstd::string const &)*arg2);
    
    
    return true;
}

static bool js_cc_Material_setPropertyNull(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Material_setPropertyNull__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Material_setPropertyNull__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyNull) 

static bool js_cc_Material_setPropertyFloat32__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    float arg3 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyFloat32,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Material_setPropertyFloat32,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyFloat32,4,SWIGTYPE_int32_t"); 
    
    (arg1)->setPropertyFloat32((ccstd::string const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyFloat32__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    float arg3 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyFloat32,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Material_setPropertyFloat32,3,SWIGTYPE_float"); 
    (arg1)->setPropertyFloat32((ccstd::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyFloat32(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Material_setPropertyFloat32__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Material_setPropertyFloat32__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyFloat32) 

static bool js_cc_Material_setPropertyInt32__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    int32_t arg3 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyInt32,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyInt32,3,SWIGTYPE_int32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyInt32,4,SWIGTYPE_int32_t"); 
    
    (arg1)->setPropertyInt32((ccstd::string const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyInt32__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    int32_t arg3 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyInt32,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyInt32,3,SWIGTYPE_int32_t"); 
    
    (arg1)->setPropertyInt32((ccstd::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyInt32(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Material_setPropertyInt32__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Material_setPropertyInt32__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyInt32) 

static bool js_cc_Material_setPropertyVec2__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Vec2 *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    cc::Vec2 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec2,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec2,3,SWIGTYPE_p_cc__Vec2");
    arg3 = &temp3;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec2,4,SWIGTYPE_int32_t"); 
    
    (arg1)->setPropertyVec2((ccstd::string const &)*arg2,(cc::Vec2 const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyVec2__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Vec2 *arg3 = 0 ;
    ccstd::string temp2 ;
    cc::Vec2 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec2,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec2,3,SWIGTYPE_p_cc__Vec2");
    arg3 = &temp3;
    
    (arg1)->setPropertyVec2((ccstd::string const &)*arg2,(cc::Vec2 const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyVec2(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Material_setPropertyVec2__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Material_setPropertyVec2__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyVec2) 

static bool js_cc_Material_setPropertyVec3__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    cc::Vec3 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec3,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec3,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec3,4,SWIGTYPE_int32_t"); 
    
    (arg1)->setPropertyVec3((ccstd::string const &)*arg2,(cc::Vec3 const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyVec3__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    ccstd::string temp2 ;
    cc::Vec3 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec3,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec3,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    (arg1)->setPropertyVec3((ccstd::string const &)*arg2,(cc::Vec3 const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyVec3(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Material_setPropertyVec3__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Material_setPropertyVec3__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyVec3) 

static bool js_cc_Material_setPropertyVec4__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Vec4 *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    cc::Vec4 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec4,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec4,3,SWIGTYPE_p_cc__Vec4");
    arg3 = &temp3;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec4,4,SWIGTYPE_int32_t"); 
    
    (arg1)->setPropertyVec4((ccstd::string const &)*arg2,(cc::Vec4 const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyVec4__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Vec4 *arg3 = 0 ;
    ccstd::string temp2 ;
    cc::Vec4 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec4,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec4,3,SWIGTYPE_p_cc__Vec4");
    arg3 = &temp3;
    
    (arg1)->setPropertyVec4((ccstd::string const &)*arg2,(cc::Vec4 const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyVec4(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Material_setPropertyVec4__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Material_setPropertyVec4__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyVec4) 

static bool js_cc_Material_setPropertyColor__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Color *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    cc::Color temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyColor,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyColor,3,SWIGTYPE_p_cc__Color");
    arg3 = &temp3;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyColor,4,SWIGTYPE_int32_t"); 
    
    (arg1)->setPropertyColor((ccstd::string const &)*arg2,(cc::Color const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyColor__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Color *arg3 = 0 ;
    ccstd::string temp2 ;
    cc::Color temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyColor,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyColor,3,SWIGTYPE_p_cc__Color");
    arg3 = &temp3;
    
    (arg1)->setPropertyColor((ccstd::string const &)*arg2,(cc::Color const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyColor(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Material_setPropertyColor__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Material_setPropertyColor__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyColor) 

static bool js_cc_Material_setPropertyMat3__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Mat3 *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    cc::Mat3 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyMat3,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyMat3,3,SWIGTYPE_p_cc__Mat3");
    arg3 = &temp3;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyMat3,4,SWIGTYPE_int32_t"); 
    
    (arg1)->setPropertyMat3((ccstd::string const &)*arg2,(cc::Mat3 const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyMat3__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Mat3 *arg3 = 0 ;
    ccstd::string temp2 ;
    cc::Mat3 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyMat3,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyMat3,3,SWIGTYPE_p_cc__Mat3");
    arg3 = &temp3;
    
    (arg1)->setPropertyMat3((ccstd::string const &)*arg2,(cc::Mat3 const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyMat3(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Material_setPropertyMat3__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Material_setPropertyMat3__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyMat3) 

static bool js_cc_Material_setPropertyMat4__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Mat4 *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    cc::Mat4 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyMat4,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyMat4,3,SWIGTYPE_p_cc__Mat4");
    arg3 = &temp3;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyMat4,4,SWIGTYPE_int32_t"); 
    
    (arg1)->setPropertyMat4((ccstd::string const &)*arg2,(cc::Mat4 const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyMat4__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Mat4 *arg3 = 0 ;
    ccstd::string temp2 ;
    cc::Mat4 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyMat4,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyMat4,3,SWIGTYPE_p_cc__Mat4");
    arg3 = &temp3;
    
    (arg1)->setPropertyMat4((ccstd::string const &)*arg2,(cc::Mat4 const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyMat4(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Material_setPropertyMat4__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Material_setPropertyMat4__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyMat4) 

static bool js_cc_Material_setPropertyQuaternion__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Quaternion *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    cc::Quaternion temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyQuaternion,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyQuaternion,3,SWIGTYPE_p_cc__Quaternion");
    arg3 = &temp3;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyQuaternion,4,SWIGTYPE_int32_t"); 
    
    (arg1)->setPropertyQuaternion((ccstd::string const &)*arg2,(cc::Quaternion const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyQuaternion__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Quaternion *arg3 = 0 ;
    ccstd::string temp2 ;
    cc::Quaternion temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyQuaternion,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyQuaternion,3,SWIGTYPE_p_cc__Quaternion");
    arg3 = &temp3;
    
    (arg1)->setPropertyQuaternion((ccstd::string const &)*arg2,(cc::Quaternion const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyQuaternion(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Material_setPropertyQuaternion__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Material_setPropertyQuaternion__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyQuaternion) 

static bool js_cc_Material_setPropertyTextureBase__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::TextureBase *arg3 = (cc::TextureBase *) NULL ;
    index_t arg4 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyTextureBase,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyTextureBase,3,SWIGTYPE_p_cc__TextureBase"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyTextureBase,4,SWIGTYPE_int32_t"); 
    
    (arg1)->setPropertyTextureBase((ccstd::string const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyTextureBase__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::TextureBase *arg3 = (cc::TextureBase *) NULL ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyTextureBase,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyTextureBase,3,SWIGTYPE_p_cc__TextureBase"); 
    (arg1)->setPropertyTextureBase((ccstd::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyTextureBase(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Material_setPropertyTextureBase__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Material_setPropertyTextureBase__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyTextureBase) 

static bool js_cc_Material_setPropertyGFXTexture__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::gfx::Texture *arg3 = (cc::gfx::Texture *) NULL ;
    index_t arg4 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyGFXTexture,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyGFXTexture,3,SWIGTYPE_p_cc__gfx__Texture"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyGFXTexture,4,SWIGTYPE_int32_t"); 
    
    (arg1)->setPropertyGFXTexture((ccstd::string const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyGFXTexture__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::gfx::Texture *arg3 = (cc::gfx::Texture *) NULL ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyGFXTexture,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyGFXTexture,3,SWIGTYPE_p_cc__gfx__Texture"); 
    (arg1)->setPropertyGFXTexture((ccstd::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyGFXTexture(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Material_setPropertyGFXTexture__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Material_setPropertyGFXTexture__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyGFXTexture) 

static bool js_cc_Material_setPropertyFloat32Array__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< float > *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    ccstd::vector< float > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyFloat32Array,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyFloat32Array,3,SWIGTYPE_p_ccstd__vectorT_float_t");
    arg3 = &temp3;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyFloat32Array,4,SWIGTYPE_int32_t"); 
    
    (arg1)->setPropertyFloat32Array((ccstd::string const &)*arg2,(ccstd::vector< float > const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyFloat32Array__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< float > *arg3 = 0 ;
    ccstd::string temp2 ;
    ccstd::vector< float > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyFloat32Array,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyFloat32Array,3,SWIGTYPE_p_ccstd__vectorT_float_t");
    arg3 = &temp3;
    
    (arg1)->setPropertyFloat32Array((ccstd::string const &)*arg2,(ccstd::vector< float > const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyFloat32Array(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Material_setPropertyFloat32Array__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Material_setPropertyFloat32Array__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyFloat32Array) 

static bool js_cc_Material_setPropertyInt32Array__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< int32_t > *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    ccstd::vector< int32_t > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyInt32Array,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyInt32Array,3,SWIGTYPE_p_ccstd__vectorT_int32_t_t");
    arg3 = &temp3;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyInt32Array,4,SWIGTYPE_int32_t"); 
    
    (arg1)->setPropertyInt32Array((ccstd::string const &)*arg2,(ccstd::vector< int32_t > const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyInt32Array__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< int32_t > *arg3 = 0 ;
    ccstd::string temp2 ;
    ccstd::vector< int32_t > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyInt32Array,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyInt32Array,3,SWIGTYPE_p_ccstd__vectorT_int32_t_t");
    arg3 = &temp3;
    
    (arg1)->setPropertyInt32Array((ccstd::string const &)*arg2,(ccstd::vector< int32_t > const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyInt32Array(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Material_setPropertyInt32Array__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Material_setPropertyInt32Array__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyInt32Array) 

static bool js_cc_Material_setPropertyVec2Array__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Vec2 > *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Vec2 > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec2Array,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec2Array,3,SWIGTYPE_p_ccstd__vectorT_cc__Vec2_t");
    arg3 = &temp3;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec2Array,4,SWIGTYPE_int32_t"); 
    
    (arg1)->setPropertyVec2Array((ccstd::string const &)*arg2,(ccstd::vector< cc::Vec2 > const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyVec2Array__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Vec2 > *arg3 = 0 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Vec2 > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec2Array,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec2Array,3,SWIGTYPE_p_ccstd__vectorT_cc__Vec2_t");
    arg3 = &temp3;
    
    (arg1)->setPropertyVec2Array((ccstd::string const &)*arg2,(ccstd::vector< cc::Vec2 > const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyVec2Array(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Material_setPropertyVec2Array__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Material_setPropertyVec2Array__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyVec2Array) 

static bool js_cc_Material_setPropertyVec3Array__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Vec3 > *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Vec3 > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec3Array,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec3Array,3,SWIGTYPE_p_ccstd__vectorT_cc__Vec3_t");
    arg3 = &temp3;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec3Array,4,SWIGTYPE_int32_t"); 
    
    (arg1)->setPropertyVec3Array((ccstd::string const &)*arg2,(ccstd::vector< cc::Vec3 > const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyVec3Array__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Vec3 > *arg3 = 0 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Vec3 > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec3Array,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec3Array,3,SWIGTYPE_p_ccstd__vectorT_cc__Vec3_t");
    arg3 = &temp3;
    
    (arg1)->setPropertyVec3Array((ccstd::string const &)*arg2,(ccstd::vector< cc::Vec3 > const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyVec3Array(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Material_setPropertyVec3Array__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Material_setPropertyVec3Array__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyVec3Array) 

static bool js_cc_Material_setPropertyVec4Array__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Vec4 > *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Vec4 > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec4Array,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec4Array,3,SWIGTYPE_p_ccstd__vectorT_cc__Vec4_t");
    arg3 = &temp3;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec4Array,4,SWIGTYPE_int32_t"); 
    
    (arg1)->setPropertyVec4Array((ccstd::string const &)*arg2,(ccstd::vector< cc::Vec4 > const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyVec4Array__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Vec4 > *arg3 = 0 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Vec4 > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec4Array,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyVec4Array,3,SWIGTYPE_p_ccstd__vectorT_cc__Vec4_t");
    arg3 = &temp3;
    
    (arg1)->setPropertyVec4Array((ccstd::string const &)*arg2,(ccstd::vector< cc::Vec4 > const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyVec4Array(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Material_setPropertyVec4Array__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Material_setPropertyVec4Array__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyVec4Array) 

static bool js_cc_Material_setPropertyColorArray__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Color > *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Color > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyColorArray,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyColorArray,3,SWIGTYPE_p_ccstd__vectorT_cc__Color_t");
    arg3 = &temp3;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyColorArray,4,SWIGTYPE_int32_t"); 
    
    (arg1)->setPropertyColorArray((ccstd::string const &)*arg2,(ccstd::vector< cc::Color > const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyColorArray__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Color > *arg3 = 0 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Color > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyColorArray,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyColorArray,3,SWIGTYPE_p_ccstd__vectorT_cc__Color_t");
    arg3 = &temp3;
    
    (arg1)->setPropertyColorArray((ccstd::string const &)*arg2,(ccstd::vector< cc::Color > const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyColorArray(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Material_setPropertyColorArray__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Material_setPropertyColorArray__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyColorArray) 

static bool js_cc_Material_setPropertyMat3Array__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Mat3 > *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Mat3 > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyMat3Array,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyMat3Array,3,SWIGTYPE_p_ccstd__vectorT_cc__Mat3_t");
    arg3 = &temp3;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyMat3Array,4,SWIGTYPE_int32_t"); 
    
    (arg1)->setPropertyMat3Array((ccstd::string const &)*arg2,(ccstd::vector< cc::Mat3 > const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyMat3Array__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Mat3 > *arg3 = 0 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Mat3 > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyMat3Array,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyMat3Array,3,SWIGTYPE_p_ccstd__vectorT_cc__Mat3_t");
    arg3 = &temp3;
    
    (arg1)->setPropertyMat3Array((ccstd::string const &)*arg2,(ccstd::vector< cc::Mat3 > const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyMat3Array(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Material_setPropertyMat3Array__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Material_setPropertyMat3Array__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyMat3Array) 

static bool js_cc_Material_setPropertyMat4Array__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Mat4 > *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Mat4 > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyMat4Array,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyMat4Array,3,SWIGTYPE_p_ccstd__vectorT_cc__Mat4_t");
    arg3 = &temp3;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyMat4Array,4,SWIGTYPE_int32_t"); 
    
    (arg1)->setPropertyMat4Array((ccstd::string const &)*arg2,(ccstd::vector< cc::Mat4 > const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyMat4Array__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Mat4 > *arg3 = 0 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Mat4 > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyMat4Array,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyMat4Array,3,SWIGTYPE_p_ccstd__vectorT_cc__Mat4_t");
    arg3 = &temp3;
    
    (arg1)->setPropertyMat4Array((ccstd::string const &)*arg2,(ccstd::vector< cc::Mat4 > const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyMat4Array(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Material_setPropertyMat4Array__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Material_setPropertyMat4Array__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyMat4Array) 

static bool js_cc_Material_setPropertyQuaternionArray__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Quaternion > *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Quaternion > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyQuaternionArray,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyQuaternionArray,3,SWIGTYPE_p_ccstd__vectorT_cc__Quaternion_t");
    arg3 = &temp3;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyQuaternionArray,4,SWIGTYPE_int32_t"); 
    
    (arg1)->setPropertyQuaternionArray((ccstd::string const &)*arg2,(ccstd::vector< cc::Quaternion > const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyQuaternionArray__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Quaternion > *arg3 = 0 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Quaternion > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyQuaternionArray,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyQuaternionArray,3,SWIGTYPE_p_ccstd__vectorT_cc__Quaternion_t");
    arg3 = &temp3;
    
    (arg1)->setPropertyQuaternionArray((ccstd::string const &)*arg2,(ccstd::vector< cc::Quaternion > const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyQuaternionArray(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Material_setPropertyQuaternionArray__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Material_setPropertyQuaternionArray__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyQuaternionArray) 

static bool js_cc_Material_setPropertyTextureBaseArray__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::TextureBase * > *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::TextureBase * > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyTextureBaseArray,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyTextureBaseArray,3,SWIGTYPE_p_ccstd__vectorT_cc__TextureBase_p_t");
    arg3 = &temp3;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyTextureBaseArray,4,SWIGTYPE_int32_t"); 
    
    (arg1)->setPropertyTextureBaseArray((ccstd::string const &)*arg2,(ccstd::vector< cc::TextureBase * > const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyTextureBaseArray__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::TextureBase * > *arg3 = 0 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::TextureBase * > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyTextureBaseArray,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyTextureBaseArray,3,SWIGTYPE_p_ccstd__vectorT_cc__TextureBase_p_t");
    arg3 = &temp3;
    
    (arg1)->setPropertyTextureBaseArray((ccstd::string const &)*arg2,(ccstd::vector< cc::TextureBase * > const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyTextureBaseArray(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Material_setPropertyTextureBaseArray__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Material_setPropertyTextureBaseArray__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyTextureBaseArray) 

static bool js_cc_Material_setPropertyGFXTextureArray__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::gfx::Texture * > *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::gfx::Texture * > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyGFXTextureArray,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyGFXTextureArray,3,SWIGTYPE_p_ccstd__vectorT_cc__gfx__Texture_p_t");
    arg3 = &temp3;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyGFXTextureArray,4,SWIGTYPE_int32_t"); 
    
    (arg1)->setPropertyGFXTextureArray((ccstd::string const &)*arg2,(ccstd::vector< cc::gfx::Texture * > const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyGFXTextureArray__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::gfx::Texture * > *arg3 = 0 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::gfx::Texture * > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyGFXTextureArray,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_setPropertyGFXTextureArray,3,SWIGTYPE_p_ccstd__vectorT_cc__gfx__Texture_p_t");
    arg3 = &temp3;
    
    (arg1)->setPropertyGFXTextureArray((ccstd::string const &)*arg2,(ccstd::vector< cc::gfx::Texture * > const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyGFXTextureArray(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Material_setPropertyGFXTextureArray__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Material_setPropertyGFXTextureArray__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyGFXTextureArray) 

static bool js_cc_Material__getProperty__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    index_t arg3 ;
    ccstd::string temp2 ;
    cc::MaterialPropertyVariant *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material__getProperty,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material__getProperty,3,SWIGTYPE_int32_t"); 
    
    result = (cc::MaterialPropertyVariant *)((cc::Material const *)arg1)->getProperty((ccstd::string const &)*arg2,arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Material__getProperty, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_Material__getProperty__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    cc::MaterialPropertyVariant *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material__getProperty,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = (cc::MaterialPropertyVariant *)((cc::Material const *)arg1)->getProperty((ccstd::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Material__getProperty, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_Material__getProperty(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Material__getProperty__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Material__getProperty__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material__getProperty) 

static bool js_cc_Material_copy__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    cc::Material *arg2 = (cc::Material *) NULL ;
    cc::IMaterialInfo *arg3 = (cc::IMaterialInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_copy,2,SWIGTYPE_p_cc__Material"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_copy,3,SWIGTYPE_p_cc__IMaterialInfo"); 
    (arg1)->copy((cc::Material const *)arg2,arg3);
    
    
    return true;
}

static bool js_cc_Material_copy__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    cc::Material *arg2 = (cc::Material *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_copy,2,SWIGTYPE_p_cc__Material"); 
    (arg1)->copy((cc::Material const *)arg2);
    
    
    return true;
}

static bool js_cc_Material_copy(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Material_copy__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Material_copy__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_copy) 

static bool js_cc_Material_fillInfo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Material *arg1 = (cc::Material *) NULL ;
    cc::IMaterialInfo *arg2 = 0 ;
    cc::IMaterialInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_fillInfo,2,SWIGTYPE_p_cc__IMaterialInfo");
    arg2 = &temp2;
    
    (arg1)->fillInfo((cc::IMaterialInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Material_fillInfo) 

static bool js_cc_Material__effectAsset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Material *arg1 = (cc::Material *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_effectAsset, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material__effectAsset_set,2,SWIGTYPE_cc__IntrusivePtrT_cc__EffectAsset_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Material__effectAsset_set) 

static bool js_cc_Material__effectAsset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Material *arg1 = (cc::Material *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_effectAsset, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Material__effectAsset_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_effectAsset, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Material__effectAsset_get) 

static bool js_cc_Material__techIdx_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Material *arg1 = (cc::Material *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_techIdx, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material__techIdx_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Material__techIdx_set) 

static bool js_cc_Material__techIdx_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Material *arg1 = (cc::Material *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_techIdx, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Material__techIdx_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_techIdx, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Material__techIdx_get) 

static bool js_cc_Material__defines_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Material *arg1 = (cc::Material *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_defines, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material__defines_set,2,SWIGTYPE_ccstd__vectorT_cc__MacroRecord_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Material__defines_set) 

static bool js_cc_Material__defines_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Material *arg1 = (cc::Material *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_defines, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Material__defines_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_defines, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Material__defines_get) 

static bool js_cc_Material__states_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Material *arg1 = (cc::Material *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_states, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material__states_set,2,SWIGTYPE_ccstd__vectorT_cc__PassOverrides_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Material__states_set) 

static bool js_cc_Material__states_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Material *arg1 = (cc::Material *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_states, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Material__states_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_states, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Material__states_get) 

static bool js_cc_Material__propsInternal_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Material *arg1 = (cc::Material *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_props, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material__propsInternal_set,2,SWIGTYPE_ccstd__vectorT_ccstd__unordered_mapT_ccstd__string_cc__MaterialPropertyVariant_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Material__propsInternal_set) 

static bool js_cc_Material__propsInternal_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Material *arg1 = (cc::Material *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_props, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Material__propsInternal_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_props, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Material__propsInternal_get) 

static bool js_cc_Material_getPasses(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Material *arg1 = (cc::Material *) NULL ;
    std::shared_ptr< ccstd::vector< cc::IntrusivePtr< cc::scene::Pass > > > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (std::shared_ptr< ccstd::vector< cc::IntrusivePtr< cc::scene::Pass > > > *) &(arg1)->getPasses();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Material_getPasses, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Material_getPasses) 

static bool js_cc_Material_effectAsset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Material *arg1 = (cc::Material *) NULL ;
    cc::EffectAsset *arg2 = (cc::EffectAsset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Material_effectAsset_set,2,SWIGTYPE_p_cc__EffectAsset"); 
    cc_Material_effectAsset_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Material_effectAsset_set) 

static bool js_cc_Material_effectAsset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Material *arg1 = (cc::Material *) NULL ;
    cc::EffectAsset *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::EffectAsset *)cc_Material_effectAsset_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Material_effectAsset_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Material_effectAsset_get) 

static bool js_cc_Material_effectName_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string result;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_Material_effectName_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Material_effectName_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Material_effectName_get) 

static bool js_cc_Material_technique_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Material *arg1 = (cc::Material *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_Material_technique_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Material_technique_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Material_technique_get) 

static bool js_cc_Material_hash_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::hash_t result;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_Material_hash_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Material_hash_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Material_hash_get) 

static bool js_cc_Material_parent_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Material *arg1 = (cc::Material *) NULL ;
    cc::Material *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Material *)cc_Material_parent_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Material_parent_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Material_parent_get) 

bool js_register_cc_Material(se::Object* obj) {
    auto* cls = se::Class::create("Material", obj, __jsb_cc_Asset_proto, _SE(js_new_cc_Material)); 
    
    cls->defineProperty("_effectAsset", _SE(js_cc_Material__effectAsset_get), _SE(js_cc_Material__effectAsset_set)); 
    cls->defineProperty("_techIdx", _SE(js_cc_Material__techIdx_get), _SE(js_cc_Material__techIdx_set)); 
    cls->defineProperty("_defines", _SE(js_cc_Material__defines_get), _SE(js_cc_Material__defines_set)); 
    cls->defineProperty("_states", _SE(js_cc_Material__states_get), _SE(js_cc_Material__states_set)); 
    cls->defineProperty("_propsInternal", _SE(js_cc_Material__propsInternal_get), _SE(js_cc_Material__propsInternal_set)); 
    cls->defineProperty("effectAsset", _SE(js_cc_Material_effectAsset_get), _SE(js_cc_Material_effectAsset_set)); 
    cls->defineProperty("effectName", _SE(js_cc_Material_effectName_get), nullptr); 
    cls->defineProperty("technique", _SE(js_cc_Material_technique_get), nullptr); 
    cls->defineProperty("hash", _SE(js_cc_Material_hash_get), nullptr); 
    cls->defineProperty("parent", _SE(js_cc_Material_parent_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_Material_initialize)); 
    cls->defineFunction("reset", _SE(js_cc_Material_reset)); 
    cls->defineFunction("recompileShaders", _SE(js_cc_Material_recompileShaders)); 
    cls->defineFunction("overridePipelineStates", _SE(js_cc_Material_overridePipelineStates)); 
    cls->defineFunction("resetUniforms", _SE(js_cc_Material_resetUniforms)); 
    cls->defineFunction("setPropertyNull", _SE(js_cc_Material_setPropertyNull)); 
    cls->defineFunction("setPropertyFloat32", _SE(js_cc_Material_setPropertyFloat32)); 
    cls->defineFunction("setPropertyInt32", _SE(js_cc_Material_setPropertyInt32)); 
    cls->defineFunction("setPropertyVec2", _SE(js_cc_Material_setPropertyVec2)); 
    cls->defineFunction("setPropertyVec3", _SE(js_cc_Material_setPropertyVec3)); 
    cls->defineFunction("setPropertyVec4", _SE(js_cc_Material_setPropertyVec4)); 
    cls->defineFunction("setPropertyColor", _SE(js_cc_Material_setPropertyColor)); 
    cls->defineFunction("setPropertyMat3", _SE(js_cc_Material_setPropertyMat3)); 
    cls->defineFunction("setPropertyMat4", _SE(js_cc_Material_setPropertyMat4)); 
    cls->defineFunction("setPropertyQuaternion", _SE(js_cc_Material_setPropertyQuaternion)); 
    cls->defineFunction("setPropertyTextureBase", _SE(js_cc_Material_setPropertyTextureBase)); 
    cls->defineFunction("setPropertyGFXTexture", _SE(js_cc_Material_setPropertyGFXTexture)); 
    cls->defineFunction("setPropertyFloat32Array", _SE(js_cc_Material_setPropertyFloat32Array)); 
    cls->defineFunction("setPropertyInt32Array", _SE(js_cc_Material_setPropertyInt32Array)); 
    cls->defineFunction("setPropertyVec2Array", _SE(js_cc_Material_setPropertyVec2Array)); 
    cls->defineFunction("setPropertyVec3Array", _SE(js_cc_Material_setPropertyVec3Array)); 
    cls->defineFunction("setPropertyVec4Array", _SE(js_cc_Material_setPropertyVec4Array)); 
    cls->defineFunction("setPropertyColorArray", _SE(js_cc_Material_setPropertyColorArray)); 
    cls->defineFunction("setPropertyMat3Array", _SE(js_cc_Material_setPropertyMat3Array)); 
    cls->defineFunction("setPropertyMat4Array", _SE(js_cc_Material_setPropertyMat4Array)); 
    cls->defineFunction("setPropertyQuaternionArray", _SE(js_cc_Material_setPropertyQuaternionArray)); 
    cls->defineFunction("setPropertyTextureBaseArray", _SE(js_cc_Material_setPropertyTextureBaseArray)); 
    cls->defineFunction("setPropertyGFXTextureArray", _SE(js_cc_Material_setPropertyGFXTextureArray)); 
    cls->defineFunction("_getProperty", _SE(js_cc_Material__getProperty)); 
    cls->defineFunction("copy", _SE(js_cc_Material_copy)); 
    cls->defineFunction("fillInfo", _SE(js_cc_Material_fillInfo)); 
    cls->defineFunction("getPasses", _SE(js_cc_Material_getPasses)); 
    
    
    cls->defineStaticFunction("getHashForMaterial", _SE(js_cc_Material_getHashForMaterial_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Material));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Material>(cls);
    
    __jsb_cc_Material_proto = cls->getProto();
    __jsb_cc_Material_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IGeometricInfo_class = nullptr;
se::Object* __jsb_cc_IGeometricInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IGeometricInfo) 

static bool js_cc_IGeometricInfo_positions_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometricInfo *arg1 = (cc::IGeometricInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometricInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->positions, s.thisObject());
    SE_PRECONDITION2(ok, false, "IGeometricInfo_positions_set,2,SWIGTYPE_cc__TypedArrayTempT_float_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometricInfo_positions_set) 

static bool js_cc_IGeometricInfo_positions_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometricInfo *arg1 = (cc::IGeometricInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometricInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(out) cc::Float32Array
    ok &= nativevalue_to_se(arg1->positions, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IGeometricInfo_positions_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->positions, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometricInfo_positions_get) 

static bool js_cc_IGeometricInfo_indices_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometricInfo *arg1 = (cc::IGeometricInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometricInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->indices, s.thisObject());
    SE_PRECONDITION2(ok, false, "IGeometricInfo_indices_set,2,SWIGTYPE_ccstd__optionalT_cc__IBArray_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometricInfo_indices_set) 

static bool js_cc_IGeometricInfo_indices_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometricInfo *arg1 = (cc::IGeometricInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometricInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->indices, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IGeometricInfo_indices_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->indices, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometricInfo_indices_get) 

static bool js_cc_IGeometricInfo_doubleSided_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometricInfo *arg1 = (cc::IGeometricInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometricInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->doubleSided, s.thisObject());
    SE_PRECONDITION2(ok, false, "IGeometricInfo_doubleSided_set,2,SWIGTYPE_ccstd__optionalT_bool_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometricInfo_doubleSided_set) 

static bool js_cc_IGeometricInfo_doubleSided_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometricInfo *arg1 = (cc::IGeometricInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometricInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->doubleSided, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IGeometricInfo_doubleSided_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->doubleSided, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometricInfo_doubleSided_get) 

static bool js_cc_IGeometricInfo_boundingBox_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometricInfo *arg1 = (cc::IGeometricInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometricInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->boundingBox, s.thisObject());
    SE_PRECONDITION2(ok, false, "IGeometricInfo_boundingBox_set,2,SWIGTYPE_cc__BoundingBox"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometricInfo_boundingBox_set) 

static bool js_cc_IGeometricInfo_boundingBox_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometricInfo *arg1 = (cc::IGeometricInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometricInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->boundingBox, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IGeometricInfo_boundingBox_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->boundingBox, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometricInfo_boundingBox_get) 

// js_ctor
static bool js_new_cc_IGeometricInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IGeometricInfo *result;
    result = (cc::IGeometricInfo *)new cc::IGeometricInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IGeometricInfo, __jsb_cc_IGeometricInfo_class, js_delete_cc_IGeometricInfo)

static bool js_delete_cc_IGeometricInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IGeometricInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IGeometricInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IGeometricInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("positions", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->positions), ctx);
    }
    
    
    json->getProperty("indices", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->indices), ctx);
    }
    
    
    json->getProperty("doubleSided", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->doubleSided), ctx);
    }
    
    
    json->getProperty("boundingBox", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->boundingBox), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IGeometricInfo(se::Object* obj) {
    auto* cls = se::Class::create("IGeometricInfo", obj, nullptr, _SE(js_new_cc_IGeometricInfo)); 
    
    cls->defineProperty("positions", _SE(js_cc_IGeometricInfo_positions_get), _SE(js_cc_IGeometricInfo_positions_set)); 
    cls->defineProperty("indices", _SE(js_cc_IGeometricInfo_indices_get), _SE(js_cc_IGeometricInfo_indices_set)); 
    cls->defineProperty("doubleSided", _SE(js_cc_IGeometricInfo_doubleSided_get), _SE(js_cc_IGeometricInfo_doubleSided_set)); 
    cls->defineProperty("boundingBox", _SE(js_cc_IGeometricInfo_boundingBox_get), _SE(js_cc_IGeometricInfo_boundingBox_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IGeometricInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IGeometricInfo>(cls);
    
    __jsb_cc_IGeometricInfo_proto = cls->getProto();
    __jsb_cc_IGeometricInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IFlatBuffer_class = nullptr;
se::Object* __jsb_cc_IFlatBuffer_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IFlatBuffer) 

static bool js_cc_IFlatBuffer_stride_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IFlatBuffer *arg1 = (cc::IFlatBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IFlatBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stride, s.thisObject());
    SE_PRECONDITION2(ok, false, "IFlatBuffer_stride_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IFlatBuffer_stride_set) 

static bool js_cc_IFlatBuffer_stride_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IFlatBuffer *arg1 = (cc::IFlatBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IFlatBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stride, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IFlatBuffer_stride_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stride, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IFlatBuffer_stride_get) 

static bool js_cc_IFlatBuffer_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IFlatBuffer *arg1 = (cc::IFlatBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IFlatBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "IFlatBuffer_count_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IFlatBuffer_count_set) 

static bool js_cc_IFlatBuffer_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IFlatBuffer *arg1 = (cc::IFlatBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IFlatBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IFlatBuffer_count_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->count, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IFlatBuffer_count_get) 

static bool js_cc_IFlatBuffer_buffer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IFlatBuffer *arg1 = (cc::IFlatBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IFlatBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->buffer, s.thisObject());
    SE_PRECONDITION2(ok, false, "IFlatBuffer_buffer_set,2,SWIGTYPE_cc__TypedArrayTempT_uint8_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IFlatBuffer_buffer_set) 

static bool js_cc_IFlatBuffer_buffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IFlatBuffer *arg1 = (cc::IFlatBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IFlatBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->buffer, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IFlatBuffer_buffer_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->buffer, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IFlatBuffer_buffer_get) 

// js_ctor
static bool js_new_cc_IFlatBuffer(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IFlatBuffer *result;
    result = (cc::IFlatBuffer *)new cc::IFlatBuffer();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IFlatBuffer, __jsb_cc_IFlatBuffer_class, js_delete_cc_IFlatBuffer)

static bool js_delete_cc_IFlatBuffer(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IFlatBuffer) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IFlatBuffer * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IFlatBuffer*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("stride", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stride), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("buffer", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->buffer), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IFlatBuffer(se::Object* obj) {
    auto* cls = se::Class::create("IFlatBuffer", obj, nullptr, _SE(js_new_cc_IFlatBuffer)); 
    
    cls->defineProperty("stride", _SE(js_cc_IFlatBuffer_stride_get), _SE(js_cc_IFlatBuffer_stride_set)); 
    cls->defineProperty("count", _SE(js_cc_IFlatBuffer_count_get), _SE(js_cc_IFlatBuffer_count_set)); 
    cls->defineProperty("buffer", _SE(js_cc_IFlatBuffer_buffer_get), _SE(js_cc_IFlatBuffer_buffer_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IFlatBuffer));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IFlatBuffer>(cls);
    
    __jsb_cc_IFlatBuffer_proto = cls->getProto();
    __jsb_cc_IFlatBuffer_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_RenderingSubMesh_class = nullptr;
se::Object* __jsb_cc_RenderingSubMesh_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_RenderingSubMesh) 

static bool js_new_cc_RenderingSubMesh__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::gfx::BufferList *arg1 = 0 ;
    cc::gfx::AttributeList *arg2 = 0 ;
    cc::gfx::PrimitiveMode arg3 ;
    cc::gfx::BufferList temp1 ;
    cc::gfx::AttributeList temp2 ;
    int32_t temp3 ;
    cc::RenderingSubMesh *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_RenderingSubMesh,1,SWIGTYPE_p_ccstd__vectorT_cc__gfx__Buffer_p_t");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_RenderingSubMesh,2,SWIGTYPE_p_ccstd__vectorT_cc__gfx__Attribute_t");
    arg2 = &temp2;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp3)
    ok &= sevalue_to_native(args[2], &temp3);
    SE_PRECONDITION2(ok, false, "new_RenderingSubMesh,3,SWIGTYPE_cc__gfx__PrimitiveMode");
    arg3 = (cc::gfx::PrimitiveMode)temp3;
    result = (cc::RenderingSubMesh *)new cc::RenderingSubMesh((cc::gfx::BufferList const &)*arg1,(cc::gfx::AttributeList const &)*arg2,arg3);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_RenderingSubMesh__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::gfx::BufferList *arg1 = 0 ;
    cc::gfx::AttributeList *arg2 = 0 ;
    cc::gfx::PrimitiveMode arg3 ;
    cc::gfx::Buffer *arg4 = (cc::gfx::Buffer *) NULL ;
    cc::gfx::BufferList temp1 ;
    cc::gfx::AttributeList temp2 ;
    int32_t temp3 ;
    cc::RenderingSubMesh *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_RenderingSubMesh,1,SWIGTYPE_p_ccstd__vectorT_cc__gfx__Buffer_p_t");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_RenderingSubMesh,2,SWIGTYPE_p_ccstd__vectorT_cc__gfx__Attribute_t");
    arg2 = &temp2;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp3)
    ok &= sevalue_to_native(args[2], &temp3);
    SE_PRECONDITION2(ok, false, "new_RenderingSubMesh,3,SWIGTYPE_cc__gfx__PrimitiveMode");
    arg3 = (cc::gfx::PrimitiveMode)temp3;
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[3], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_RenderingSubMesh,4,SWIGTYPE_p_cc__gfx__Buffer"); 
    result = (cc::RenderingSubMesh *)new cc::RenderingSubMesh((cc::gfx::BufferList const &)*arg1,(cc::gfx::AttributeList const &)*arg2,arg3,arg4);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_RenderingSubMesh__SWIG_2(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::gfx::BufferList *arg1 = 0 ;
    cc::gfx::AttributeList *arg2 = 0 ;
    cc::gfx::PrimitiveMode arg3 ;
    cc::gfx::Buffer *arg4 = (cc::gfx::Buffer *) NULL ;
    cc::gfx::Buffer *arg5 = (cc::gfx::Buffer *) NULL ;
    cc::gfx::BufferList temp1 ;
    cc::gfx::AttributeList temp2 ;
    int32_t temp3 ;
    cc::RenderingSubMesh *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_RenderingSubMesh,1,SWIGTYPE_p_ccstd__vectorT_cc__gfx__Buffer_p_t");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_RenderingSubMesh,2,SWIGTYPE_p_ccstd__vectorT_cc__gfx__Attribute_t");
    arg2 = &temp2;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp3)
    ok &= sevalue_to_native(args[2], &temp3);
    SE_PRECONDITION2(ok, false, "new_RenderingSubMesh,3,SWIGTYPE_cc__gfx__PrimitiveMode");
    arg3 = (cc::gfx::PrimitiveMode)temp3;
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[3], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_RenderingSubMesh,4,SWIGTYPE_p_cc__gfx__Buffer"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[4], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_RenderingSubMesh,5,SWIGTYPE_p_cc__gfx__Buffer"); 
    result = (cc::RenderingSubMesh *)new cc::RenderingSubMesh((cc::gfx::BufferList const &)*arg1,(cc::gfx::AttributeList const &)*arg2,arg3,arg4,arg5);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_RenderingSubMesh__SWIG_3(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::gfx::BufferList *arg1 = 0 ;
    cc::gfx::AttributeList *arg2 = 0 ;
    cc::gfx::PrimitiveMode arg3 ;
    cc::gfx::Buffer *arg4 = (cc::gfx::Buffer *) NULL ;
    cc::gfx::Buffer *arg5 = (cc::gfx::Buffer *) NULL ;
    bool arg6 ;
    cc::gfx::BufferList temp1 ;
    cc::gfx::AttributeList temp2 ;
    int32_t temp3 ;
    cc::RenderingSubMesh *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_RenderingSubMesh,1,SWIGTYPE_p_ccstd__vectorT_cc__gfx__Buffer_p_t");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_RenderingSubMesh,2,SWIGTYPE_p_ccstd__vectorT_cc__gfx__Attribute_t");
    arg2 = &temp2;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp3)
    ok &= sevalue_to_native(args[2], &temp3);
    SE_PRECONDITION2(ok, false, "new_RenderingSubMesh,3,SWIGTYPE_cc__gfx__PrimitiveMode");
    arg3 = (cc::gfx::PrimitiveMode)temp3;
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[3], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_RenderingSubMesh,4,SWIGTYPE_p_cc__gfx__Buffer"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[4], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_RenderingSubMesh,5,SWIGTYPE_p_cc__gfx__Buffer"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg6);
    SE_PRECONDITION2(ok, false, "new_RenderingSubMesh,6,SWIGTYPE_bool"); 
    result = (cc::RenderingSubMesh *)new cc::RenderingSubMesh((cc::gfx::BufferList const &)*arg1,(cc::gfx::AttributeList const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_RenderingSubMesh(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_ctor_dispatcher
    size_t argc = s.args().size();
    bool ret = false;
    
    // switch all cases by means of series of if-returns.
    
    // js_ctor_dispatch_case
    if(argc == 3) {
        ret = js_new_cc_RenderingSubMesh__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 4) {
        ret = js_new_cc_RenderingSubMesh__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 5) {
        ret = js_new_cc_RenderingSubMesh__SWIG_2(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 6) {
        ret = js_new_cc_RenderingSubMesh__SWIG_3(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    
    // default:
    SE_REPORT_ERROR("Illegal arguments for construction of RenderingSubMesh");
    return false;
}
SE_BIND_CTOR(js_new_RenderingSubMesh, __jsb_cc_RenderingSubMesh_class, js_delete_cc_RenderingSubMesh)

static bool js_delete_cc_RenderingSubMesh(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_RenderingSubMesh) 

static bool js_cc_RenderingSubMesh_getAttributes(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    cc::gfx::AttributeList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::AttributeList *) &((cc::RenderingSubMesh const *)arg1)->getAttributes();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderingSubMesh_getAttributes, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderingSubMesh_getAttributes) 

static bool js_cc_RenderingSubMesh_getVertexBuffers(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    cc::gfx::BufferList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::BufferList *) &((cc::RenderingSubMesh const *)arg1)->getVertexBuffers();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderingSubMesh_getVertexBuffers, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderingSubMesh_getVertexBuffers) 

static bool js_cc_RenderingSubMesh_getIndexBuffer(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    cc::gfx::Buffer *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Buffer *)((cc::RenderingSubMesh const *)arg1)->getIndexBuffer();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderingSubMesh_getIndexBuffer, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderingSubMesh_getIndexBuffer) 

static bool js_cc_RenderingSubMesh_indirectBuffer(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    cc::gfx::Buffer *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Buffer *)((cc::RenderingSubMesh const *)arg1)->indirectBuffer();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderingSubMesh_indirectBuffer, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderingSubMesh_indirectBuffer) 

static bool js_cc_RenderingSubMesh_getGeometricInfo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    cc::IGeometricInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::IGeometricInfo *) &(arg1)->getGeometricInfo();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderingSubMesh_getGeometricInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderingSubMesh_getGeometricInfo) 

static bool js_cc_RenderingSubMesh_invalidateGeometricInfo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->invalidateGeometricInfo();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderingSubMesh_invalidateGeometricInfo) 

static bool js_cc_RenderingSubMesh_genFlatBuffers(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->genFlatBuffers();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderingSubMesh_genFlatBuffers) 

static bool js_cc_RenderingSubMesh_setDrawInfo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    cc::gfx::DrawInfo *arg2 = 0 ;
    cc::gfx::DrawInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderingSubMesh_setDrawInfo,2,SWIGTYPE_p_cc__gfx__DrawInfo");
    arg2 = &temp2;
    
    (arg1)->setDrawInfo((cc::gfx::DrawInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderingSubMesh_setDrawInfo) 

static bool js_cc_RenderingSubMesh_getDrawInfo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    ccstd::optional< cc::gfx::DrawInfo > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::optional< cc::gfx::DrawInfo > *) &(arg1)->getDrawInfo();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderingSubMesh_getDrawInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderingSubMesh_getDrawInfo) 

static bool js_cc_RenderingSubMesh_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->destroy();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderingSubMesh_destroy) 

static bool js_cc_RenderingSubMesh_enableVertexIdChannel(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    cc::gfx::Device *arg2 = (cc::gfx::Device *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderingSubMesh_enableVertexIdChannel,2,SWIGTYPE_p_cc__gfx__Device"); 
    (arg1)->enableVertexIdChannel(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderingSubMesh_enableVertexIdChannel) 

static bool js_cc_RenderingSubMesh_mesh_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    cc::Mesh *arg2 = (cc::Mesh *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderingSubMesh_mesh_set,2,SWIGTYPE_p_cc__Mesh"); 
    cc_RenderingSubMesh_mesh_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderingSubMesh_mesh_set) 

static bool js_cc_RenderingSubMesh_mesh_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    cc::Mesh *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Mesh *)cc_RenderingSubMesh_mesh_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderingSubMesh_mesh_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderingSubMesh_mesh_get) 

static bool js_cc_RenderingSubMesh_subMeshIdx_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    ccstd::optional< uint32_t > *arg2 = 0 ;
    ccstd::optional< uint32_t > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderingSubMesh_subMeshIdx_set,2,SWIGTYPE_p_ccstd__optionalT_uint32_t_t");
    arg2 = &temp2;
    
    cc_RenderingSubMesh_subMeshIdx_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderingSubMesh_subMeshIdx_set) 

static bool js_cc_RenderingSubMesh_subMeshIdx_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    ccstd::optional< uint32_t > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::optional< uint32_t > *) &cc_RenderingSubMesh_subMeshIdx_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderingSubMesh_subMeshIdx_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderingSubMesh_subMeshIdx_get) 

static bool js_cc_RenderingSubMesh_flatBuffers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    ccstd::vector< cc::IFlatBuffer > *arg2 = 0 ;
    ccstd::vector< cc::IFlatBuffer > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderingSubMesh_flatBuffers_set,2,SWIGTYPE_p_ccstd__vectorT_cc__IFlatBuffer_t");
    arg2 = &temp2;
    
    cc_RenderingSubMesh_flatBuffers_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderingSubMesh_flatBuffers_set) 

static bool js_cc_RenderingSubMesh_flatBuffers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    ccstd::vector< cc::IFlatBuffer > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::IFlatBuffer > *) &cc_RenderingSubMesh_flatBuffers_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderingSubMesh_flatBuffers_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderingSubMesh_flatBuffers_get) 

static bool js_cc_RenderingSubMesh__flatBuffers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    ccstd::vector< cc::IFlatBuffer > *arg2 = 0 ;
    ccstd::vector< cc::IFlatBuffer > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderingSubMesh__flatBuffers_set,2,SWIGTYPE_p_ccstd__vectorT_cc__IFlatBuffer_t");
    arg2 = &temp2;
    
    cc_RenderingSubMesh__flatBuffers_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderingSubMesh__flatBuffers_set) 

static bool js_cc_RenderingSubMesh__flatBuffers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    ccstd::vector< cc::IFlatBuffer > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::IFlatBuffer > *) &cc_RenderingSubMesh__flatBuffers_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderingSubMesh__flatBuffers_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderingSubMesh__flatBuffers_get) 

static bool js_cc_RenderingSubMesh_jointMappedBuffers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    cc::gfx::BufferList *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::BufferList *) &cc_RenderingSubMesh_jointMappedBuffers_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderingSubMesh_jointMappedBuffers_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderingSubMesh_jointMappedBuffers_get) 

static bool js_cc_RenderingSubMesh_iaInfo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    cc::gfx::InputAssemblerInfo *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::InputAssemblerInfo *) &cc_RenderingSubMesh_iaInfo_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderingSubMesh_iaInfo_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderingSubMesh_iaInfo_get) 

static bool js_cc_RenderingSubMesh__iaInfo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    cc::gfx::InputAssemblerInfo *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::InputAssemblerInfo *) &cc_RenderingSubMesh__iaInfo_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderingSubMesh__iaInfo_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderingSubMesh__iaInfo_get) 

static bool js_cc_RenderingSubMesh_primitiveMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    cc::gfx::PrimitiveMode result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::PrimitiveMode)cc_RenderingSubMesh_primitiveMode_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderingSubMesh_primitiveMode_get) 

bool js_register_cc_RenderingSubMesh(se::Object* obj) {
    auto* cls = se::Class::create("RenderingSubMesh", obj, nullptr, _SE(js_new_RenderingSubMesh)); 
    
    cls->defineProperty("mesh", _SE(js_cc_RenderingSubMesh_mesh_get), _SE(js_cc_RenderingSubMesh_mesh_set)); 
    cls->defineProperty("subMeshIdx", _SE(js_cc_RenderingSubMesh_subMeshIdx_get), _SE(js_cc_RenderingSubMesh_subMeshIdx_set)); 
    cls->defineProperty("flatBuffers", _SE(js_cc_RenderingSubMesh_flatBuffers_get), _SE(js_cc_RenderingSubMesh_flatBuffers_set)); 
    cls->defineProperty("_flatBuffers", _SE(js_cc_RenderingSubMesh__flatBuffers_get), _SE(js_cc_RenderingSubMesh__flatBuffers_set)); 
    cls->defineProperty("jointMappedBuffers", _SE(js_cc_RenderingSubMesh_jointMappedBuffers_get), nullptr); 
    cls->defineProperty("iaInfo", _SE(js_cc_RenderingSubMesh_iaInfo_get), nullptr); 
    cls->defineProperty("_iaInfo", _SE(js_cc_RenderingSubMesh__iaInfo_get), nullptr); 
    cls->defineProperty("primitiveMode", _SE(js_cc_RenderingSubMesh_primitiveMode_get), nullptr); 
    
    cls->defineFunction("getAttributes", _SE(js_cc_RenderingSubMesh_getAttributes)); 
    cls->defineFunction("getVertexBuffers", _SE(js_cc_RenderingSubMesh_getVertexBuffers)); 
    cls->defineFunction("getIndexBuffer", _SE(js_cc_RenderingSubMesh_getIndexBuffer)); 
    cls->defineFunction("indirectBuffer", _SE(js_cc_RenderingSubMesh_indirectBuffer)); 
    cls->defineFunction("getGeometricInfo", _SE(js_cc_RenderingSubMesh_getGeometricInfo)); 
    cls->defineFunction("invalidateGeometricInfo", _SE(js_cc_RenderingSubMesh_invalidateGeometricInfo)); 
    cls->defineFunction("genFlatBuffers", _SE(js_cc_RenderingSubMesh_genFlatBuffers)); 
    cls->defineFunction("setDrawInfo", _SE(js_cc_RenderingSubMesh_setDrawInfo)); 
    cls->defineFunction("getDrawInfo", _SE(js_cc_RenderingSubMesh_getDrawInfo)); 
    cls->defineFunction("destroy", _SE(js_cc_RenderingSubMesh_destroy)); 
    cls->defineFunction("enableVertexIdChannel", _SE(js_cc_RenderingSubMesh_enableVertexIdChannel)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_RenderingSubMesh));
    
    
    cls->install();
    JSBClassType::registerClass<cc::RenderingSubMesh>(cls);
    
    __jsb_cc_RenderingSubMesh_proto = cls->getProto();
    __jsb_cc_RenderingSubMesh_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_BuiltinResMgr_class = nullptr;
se::Object* __jsb_cc_BuiltinResMgr_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_BuiltinResMgr) 

static bool js_cc_BuiltinResMgr_getInstance_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BuiltinResMgr *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::BuiltinResMgr *)cc::BuiltinResMgr::getInstance();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BuiltinResMgr_getInstance, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BuiltinResMgr_getInstance_static) 

// js_ctor
static bool js_new_cc_BuiltinResMgr(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::BuiltinResMgr *result;
    result = (cc::BuiltinResMgr *)new cc::BuiltinResMgr();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_BuiltinResMgr, __jsb_cc_BuiltinResMgr_class, js_delete_cc_BuiltinResMgr)

static bool js_delete_cc_BuiltinResMgr(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_BuiltinResMgr) 

static bool js_cc_BuiltinResMgr_initBuiltinRes(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BuiltinResMgr *arg1 = (cc::BuiltinResMgr *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BuiltinResMgr>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->initBuiltinRes();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BuiltinResMgr_initBuiltinRes) 

static bool js_cc_BuiltinResMgr_isInitialized(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BuiltinResMgr *arg1 = (cc::BuiltinResMgr *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BuiltinResMgr>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((cc::BuiltinResMgr const *)arg1)->isInitialized();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BuiltinResMgr_isInitialized) 

static bool js_cc_BuiltinResMgr_addAsset(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BuiltinResMgr *arg1 = (cc::BuiltinResMgr *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Asset *arg3 = (cc::Asset *) NULL ;
    ccstd::string temp2 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BuiltinResMgr>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BuiltinResMgr_addAsset,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "BuiltinResMgr_addAsset,3,SWIGTYPE_p_cc__Asset"); 
    (arg1)->addAsset((ccstd::string const &)*arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BuiltinResMgr_addAsset) 

static bool js_cc_BuiltinResMgr_getAsset(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BuiltinResMgr *arg1 = (cc::BuiltinResMgr *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    cc::Asset *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BuiltinResMgr>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BuiltinResMgr_getAsset,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = (cc::Asset *)(arg1)->getAsset((ccstd::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BuiltinResMgr_getAsset, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BuiltinResMgr_getAsset) 

bool js_register_cc_BuiltinResMgr(se::Object* obj) {
    auto* cls = se::Class::create("BuiltinResMgr", obj, nullptr, _SE(js_new_cc_BuiltinResMgr)); 
    
    
    cls->defineFunction("initBuiltinRes", _SE(js_cc_BuiltinResMgr_initBuiltinRes)); 
    cls->defineFunction("isInitialized", _SE(js_cc_BuiltinResMgr_isInitialized)); 
    cls->defineFunction("addAsset", _SE(js_cc_BuiltinResMgr_addAsset)); 
    cls->defineFunction("getAsset", _SE(js_cc_BuiltinResMgr_getAsset)); 
    
    
    cls->defineStaticFunction("getInstance", _SE(js_cc_BuiltinResMgr_getInstance_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_BuiltinResMgr));
    
    
    cls->install();
    JSBClassType::registerClass<cc::BuiltinResMgr>(cls);
    
    __jsb_cc_BuiltinResMgr_proto = cls->getProto();
    __jsb_cc_BuiltinResMgr_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IMeshBufferView_class = nullptr;
se::Object* __jsb_cc_IMeshBufferView_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IMeshBufferView) 

static bool js_cc_IMeshBufferView_offset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMeshBufferView *arg1 = (cc::IMeshBufferView *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMeshBufferView>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->offset, s.thisObject());
    SE_PRECONDITION2(ok, false, "IMeshBufferView_offset_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMeshBufferView_offset_set) 

static bool js_cc_IMeshBufferView_offset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMeshBufferView *arg1 = (cc::IMeshBufferView *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMeshBufferView>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->offset, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IMeshBufferView_offset_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->offset, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMeshBufferView_offset_get) 

static bool js_cc_IMeshBufferView_length_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMeshBufferView *arg1 = (cc::IMeshBufferView *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMeshBufferView>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->length, s.thisObject());
    SE_PRECONDITION2(ok, false, "IMeshBufferView_length_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMeshBufferView_length_set) 

static bool js_cc_IMeshBufferView_length_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMeshBufferView *arg1 = (cc::IMeshBufferView *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMeshBufferView>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->length, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IMeshBufferView_length_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->length, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMeshBufferView_length_get) 

static bool js_cc_IMeshBufferView_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMeshBufferView *arg1 = (cc::IMeshBufferView *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMeshBufferView>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "IMeshBufferView_count_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMeshBufferView_count_set) 

static bool js_cc_IMeshBufferView_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMeshBufferView *arg1 = (cc::IMeshBufferView *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMeshBufferView>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IMeshBufferView_count_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->count, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMeshBufferView_count_get) 

static bool js_cc_IMeshBufferView_stride_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMeshBufferView *arg1 = (cc::IMeshBufferView *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMeshBufferView>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stride, s.thisObject());
    SE_PRECONDITION2(ok, false, "IMeshBufferView_stride_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMeshBufferView_stride_set) 

static bool js_cc_IMeshBufferView_stride_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMeshBufferView *arg1 = (cc::IMeshBufferView *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMeshBufferView>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stride, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IMeshBufferView_stride_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stride, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMeshBufferView_stride_get) 

// js_ctor
static bool js_new_cc_IMeshBufferView(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IMeshBufferView *result;
    result = (cc::IMeshBufferView *)new cc::IMeshBufferView();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IMeshBufferView, __jsb_cc_IMeshBufferView_class, js_delete_cc_IMeshBufferView)

static bool js_delete_cc_IMeshBufferView(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IMeshBufferView) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IMeshBufferView * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IMeshBufferView*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("offset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->offset), ctx);
    }
    
    
    json->getProperty("length", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->length), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("stride", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stride), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IMeshBufferView(se::Object* obj) {
    auto* cls = se::Class::create("IMeshBufferView", obj, nullptr, _SE(js_new_cc_IMeshBufferView)); 
    
    cls->defineProperty("offset", _SE(js_cc_IMeshBufferView_offset_get), _SE(js_cc_IMeshBufferView_offset_set)); 
    cls->defineProperty("length", _SE(js_cc_IMeshBufferView_length_get), _SE(js_cc_IMeshBufferView_length_set)); 
    cls->defineProperty("count", _SE(js_cc_IMeshBufferView_count_get), _SE(js_cc_IMeshBufferView_count_set)); 
    cls->defineProperty("stride", _SE(js_cc_IMeshBufferView_stride_get), _SE(js_cc_IMeshBufferView_stride_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IMeshBufferView));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IMeshBufferView>(cls);
    
    __jsb_cc_IMeshBufferView_proto = cls->getProto();
    __jsb_cc_IMeshBufferView_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_MorphTarget_class = nullptr;
se::Object* __jsb_cc_MorphTarget_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_MorphTarget) 

static bool js_cc_MorphTarget_displacements_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MorphTarget *arg1 = (cc::MorphTarget *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MorphTarget>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->displacements, s.thisObject());
    SE_PRECONDITION2(ok, false, "MorphTarget_displacements_set,2,SWIGTYPE_ccstd__vectorT_cc__IMeshBufferView_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_MorphTarget_displacements_set) 

static bool js_cc_MorphTarget_displacements_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::MorphTarget *arg1 = (cc::MorphTarget *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MorphTarget>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->displacements, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MorphTarget_displacements_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->displacements, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_MorphTarget_displacements_get) 

// js_ctor
static bool js_new_cc_MorphTarget(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::MorphTarget *result;
    result = (cc::MorphTarget *)new cc::MorphTarget();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_MorphTarget, __jsb_cc_MorphTarget_class, js_delete_cc_MorphTarget)

static bool js_delete_cc_MorphTarget(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_MorphTarget) 

template<>
bool sevalue_to_native(const se::Value &from, cc::MorphTarget * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::MorphTarget*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("displacements", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->displacements), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_MorphTarget(se::Object* obj) {
    auto* cls = se::Class::create("MorphTarget", obj, nullptr, _SE(js_new_cc_MorphTarget)); 
    
    cls->defineProperty("displacements", _SE(js_cc_MorphTarget_displacements_get), _SE(js_cc_MorphTarget_displacements_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_MorphTarget));
    
    
    cls->install();
    JSBClassType::registerClass<cc::MorphTarget>(cls);
    
    __jsb_cc_MorphTarget_proto = cls->getProto();
    __jsb_cc_MorphTarget_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_SubMeshMorph_class = nullptr;
se::Object* __jsb_cc_SubMeshMorph_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_SubMeshMorph) 

static bool js_cc_SubMeshMorph_attributes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SubMeshMorph *arg1 = (cc::SubMeshMorph *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::SubMeshMorph>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->attributes, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubMeshMorph_attributes_set,2,SWIGTYPE_ccstd__vectorT_ccstd__string_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_SubMeshMorph_attributes_set) 

static bool js_cc_SubMeshMorph_attributes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::SubMeshMorph *arg1 = (cc::SubMeshMorph *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::SubMeshMorph>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->attributes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubMeshMorph_attributes_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->attributes, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_SubMeshMorph_attributes_get) 

static bool js_cc_SubMeshMorph_targets_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SubMeshMorph *arg1 = (cc::SubMeshMorph *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::SubMeshMorph>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->targets, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubMeshMorph_targets_set,2,SWIGTYPE_ccstd__vectorT_cc__MorphTarget_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_SubMeshMorph_targets_set) 

static bool js_cc_SubMeshMorph_targets_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::SubMeshMorph *arg1 = (cc::SubMeshMorph *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::SubMeshMorph>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->targets, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubMeshMorph_targets_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->targets, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_SubMeshMorph_targets_get) 

static bool js_cc_SubMeshMorph_weights_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SubMeshMorph *arg1 = (cc::SubMeshMorph *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::SubMeshMorph>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->weights, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubMeshMorph_weights_set,2,SWIGTYPE_ccstd__optionalT_cc__MeshWeightsType_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_SubMeshMorph_weights_set) 

static bool js_cc_SubMeshMorph_weights_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::SubMeshMorph *arg1 = (cc::SubMeshMorph *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::SubMeshMorph>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->weights, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubMeshMorph_weights_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->weights, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_SubMeshMorph_weights_get) 

// js_ctor
static bool js_new_cc_SubMeshMorph(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::SubMeshMorph *result;
    result = (cc::SubMeshMorph *)new cc::SubMeshMorph();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_SubMeshMorph, __jsb_cc_SubMeshMorph_class, js_delete_cc_SubMeshMorph)

static bool js_delete_cc_SubMeshMorph(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_SubMeshMorph) 

template<>
bool sevalue_to_native(const se::Value &from, cc::SubMeshMorph * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::SubMeshMorph*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("attributes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->attributes), ctx);
    }
    
    
    json->getProperty("targets", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->targets), ctx);
    }
    
    
    json->getProperty("weights", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->weights), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_SubMeshMorph(se::Object* obj) {
    auto* cls = se::Class::create("SubMeshMorph", obj, nullptr, _SE(js_new_cc_SubMeshMorph)); 
    
    cls->defineProperty("attributes", _SE(js_cc_SubMeshMorph_attributes_get), _SE(js_cc_SubMeshMorph_attributes_set)); 
    cls->defineProperty("targets", _SE(js_cc_SubMeshMorph_targets_get), _SE(js_cc_SubMeshMorph_targets_set)); 
    cls->defineProperty("weights", _SE(js_cc_SubMeshMorph_weights_get), _SE(js_cc_SubMeshMorph_weights_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_SubMeshMorph));
    
    
    cls->install();
    JSBClassType::registerClass<cc::SubMeshMorph>(cls);
    
    __jsb_cc_SubMeshMorph_proto = cls->getProto();
    __jsb_cc_SubMeshMorph_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Morph_class = nullptr;
se::Object* __jsb_cc_Morph_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Morph) 

static bool js_cc_Morph_subMeshMorphs_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Morph *arg1 = (cc::Morph *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Morph>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->subMeshMorphs, s.thisObject());
    SE_PRECONDITION2(ok, false, "Morph_subMeshMorphs_set,2,SWIGTYPE_ccstd__vectorT_ccstd__optionalT_cc__SubMeshMorph_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Morph_subMeshMorphs_set) 

static bool js_cc_Morph_subMeshMorphs_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Morph *arg1 = (cc::Morph *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Morph>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->subMeshMorphs, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Morph_subMeshMorphs_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->subMeshMorphs, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Morph_subMeshMorphs_get) 

static bool js_cc_Morph_weights_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Morph *arg1 = (cc::Morph *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Morph>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->weights, s.thisObject());
    SE_PRECONDITION2(ok, false, "Morph_weights_set,2,SWIGTYPE_ccstd__optionalT_cc__MeshWeightsType_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Morph_weights_set) 

static bool js_cc_Morph_weights_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Morph *arg1 = (cc::Morph *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Morph>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->weights, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Morph_weights_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->weights, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Morph_weights_get) 

static bool js_cc_Morph_targetNames_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Morph *arg1 = (cc::Morph *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Morph>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->targetNames, s.thisObject());
    SE_PRECONDITION2(ok, false, "Morph_targetNames_set,2,SWIGTYPE_ccstd__optionalT_ccstd__vectorT_ccstd__string_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Morph_targetNames_set) 

static bool js_cc_Morph_targetNames_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Morph *arg1 = (cc::Morph *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Morph>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->targetNames, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Morph_targetNames_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->targetNames, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Morph_targetNames_get) 

// js_ctor
static bool js_new_cc_Morph(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::Morph *result;
    result = (cc::Morph *)new cc::Morph();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Morph, __jsb_cc_Morph_class, js_delete_cc_Morph)

static bool js_delete_cc_Morph(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Morph) 

template<>
bool sevalue_to_native(const se::Value &from, cc::Morph * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::Morph*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("subMeshMorphs", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->subMeshMorphs), ctx);
    }
    
    
    json->getProperty("weights", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->weights), ctx);
    }
    
    
    json->getProperty("targetNames", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->targetNames), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_Morph(se::Object* obj) {
    auto* cls = se::Class::create("Morph", obj, nullptr, _SE(js_new_cc_Morph)); 
    
    cls->defineProperty("subMeshMorphs", _SE(js_cc_Morph_subMeshMorphs_get), _SE(js_cc_Morph_subMeshMorphs_set)); 
    cls->defineProperty("weights", _SE(js_cc_Morph_weights_get), _SE(js_cc_Morph_weights_set)); 
    cls->defineProperty("targetNames", _SE(js_cc_Morph_targetNames_get), _SE(js_cc_Morph_targetNames_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Morph));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Morph>(cls);
    
    __jsb_cc_Morph_proto = cls->getProto();
    __jsb_cc_Morph_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_MorphRenderingInstance_class = nullptr;
se::Object* __jsb_cc_MorphRenderingInstance_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_MorphRenderingInstance) 

static bool js_delete_cc_MorphRenderingInstance(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_MorphRenderingInstance) 

static bool js_cc_MorphRenderingInstance_setWeights(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MorphRenderingInstance *arg1 = (cc::MorphRenderingInstance *) NULL ;
    index_t arg2 ;
    cc::MeshWeightsType *arg3 = 0 ;
    cc::MeshWeightsType temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::MorphRenderingInstance>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "MorphRenderingInstance_setWeights,2,SWIGTYPE_int32_t"); 
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "MorphRenderingInstance_setWeights,3,SWIGTYPE_p_ccstd__vectorT_float_t");
    arg3 = &temp3;
    
    (arg1)->setWeights(arg2,(cc::MeshWeightsType const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_MorphRenderingInstance_setWeights) 

static bool js_cc_MorphRenderingInstance_adaptPipelineState(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MorphRenderingInstance *arg1 = (cc::MorphRenderingInstance *) NULL ;
    index_t arg2 ;
    cc::gfx::DescriptorSet *arg3 = (cc::gfx::DescriptorSet *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::MorphRenderingInstance>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "MorphRenderingInstance_adaptPipelineState,2,SWIGTYPE_int32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "MorphRenderingInstance_adaptPipelineState,3,SWIGTYPE_p_cc__gfx__DescriptorSet"); 
    (arg1)->adaptPipelineState(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_MorphRenderingInstance_adaptPipelineState) 

static bool js_cc_MorphRenderingInstance_requiredPatches(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MorphRenderingInstance *arg1 = (cc::MorphRenderingInstance *) NULL ;
    index_t arg2 ;
    ccstd::vector< cc::scene::IMacroPatch > result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::MorphRenderingInstance>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "MorphRenderingInstance_requiredPatches,2,SWIGTYPE_int32_t"); 
    
    result = (arg1)->requiredPatches(arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MorphRenderingInstance_requiredPatches, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_MorphRenderingInstance_requiredPatches) 

static bool js_cc_MorphRenderingInstance_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MorphRenderingInstance *arg1 = (cc::MorphRenderingInstance *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::MorphRenderingInstance>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_MorphRenderingInstance_destroy) 

bool js_register_cc_MorphRenderingInstance(se::Object* obj) {
    auto* cls = se::Class::create("MorphRenderingInstance", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("setWeights", _SE(js_cc_MorphRenderingInstance_setWeights)); 
    cls->defineFunction("adaptPipelineState", _SE(js_cc_MorphRenderingInstance_adaptPipelineState)); 
    cls->defineFunction("requiredPatches", _SE(js_cc_MorphRenderingInstance_requiredPatches)); 
    cls->defineFunction("destroy", _SE(js_cc_MorphRenderingInstance_destroy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_MorphRenderingInstance));
    
    
    cls->install();
    JSBClassType::registerClass<cc::MorphRenderingInstance>(cls);
    
    __jsb_cc_MorphRenderingInstance_proto = cls->getProto();
    __jsb_cc_MorphRenderingInstance_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_MorphRendering_class = nullptr;
se::Object* __jsb_cc_MorphRendering_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_MorphRendering) 

static bool js_delete_cc_MorphRendering(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_MorphRendering) 

static bool js_cc_MorphRendering_createInstance(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MorphRendering *arg1 = (cc::MorphRendering *) NULL ;
    cc::MorphRenderingInstance *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::MorphRendering>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::MorphRenderingInstance *)(arg1)->createInstance();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MorphRendering_createInstance, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_MorphRendering_createInstance) 

bool js_register_cc_MorphRendering(se::Object* obj) {
    auto* cls = se::Class::create("MorphRendering", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("createInstance", _SE(js_cc_MorphRendering_createInstance)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_MorphRendering));
    
    
    cls->install();
    JSBClassType::registerClass<cc::MorphRendering>(cls);
    
    __jsb_cc_MorphRendering_proto = cls->getProto();
    __jsb_cc_MorphRendering_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_StdMorphRendering_class = nullptr;
se::Object* __jsb_cc_StdMorphRendering_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_StdMorphRendering) 

// js_ctor
static bool js_new_cc_StdMorphRendering(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 2) {
        SE_REPORT_ERROR("js_new_cc_StdMorphRendering: wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::gfx::Device *arg2 = (cc::gfx::Device *) NULL ;
    cc::StdMorphRendering *result;
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_StdMorphRendering,1,SWIGTYPE_p_cc__Mesh"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_StdMorphRendering,2,SWIGTYPE_p_cc__gfx__Device"); 
    result = (cc::StdMorphRendering *)new cc::StdMorphRendering(arg1,arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_StdMorphRendering, __jsb_cc_StdMorphRendering_class, js_delete_cc_StdMorphRendering)

static bool js_delete_cc_StdMorphRendering(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_StdMorphRendering) 

bool js_register_cc_StdMorphRendering(se::Object* obj) {
    auto* cls = se::Class::create("StdMorphRendering", obj, __jsb_cc_MorphRendering_proto, _SE(js_new_cc_StdMorphRendering)); 
    
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_StdMorphRendering));
    
    
    cls->install();
    JSBClassType::registerClass<cc::StdMorphRendering>(cls);
    
    __jsb_cc_StdMorphRendering_proto = cls->getProto();
    __jsb_cc_StdMorphRendering_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


static bool js_cc_createMorphRendering(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::gfx::Device *arg2 = (cc::gfx::Device *) NULL ;
    cc::MorphRendering *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "createMorphRendering,1,SWIGTYPE_p_cc__Mesh"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "createMorphRendering,2,SWIGTYPE_p_cc__gfx__Device"); 
    result = (cc::MorphRendering *)cc::createMorphRendering(arg1,arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "createMorphRendering, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_createMorphRendering) 

se::Class* __jsb_cc_Mesh_class = nullptr;
se::Object* __jsb_cc_Mesh_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Mesh) 

se::Class* __jsb_cc_Mesh_IVertexBundle_class = nullptr;
se::Object* __jsb_cc_Mesh_IVertexBundle_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Mesh_IVertexBundle) 

static bool js_cc_Mesh_IVertexBundle__padding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IVertexBundle *arg1 = (cc::Mesh::IVertexBundle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IVertexBundle>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_padding, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_IVertexBundle__padding_set,2,SWIGTYPE_ccstd__optionalT_uint8_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IVertexBundle__padding_set) 

static bool js_cc_Mesh_IVertexBundle__padding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IVertexBundle *arg1 = (cc::Mesh::IVertexBundle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IVertexBundle>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_padding, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_IVertexBundle__padding_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_padding, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IVertexBundle__padding_get) 

static bool js_cc_Mesh_IVertexBundle_view_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IVertexBundle *arg1 = (cc::Mesh::IVertexBundle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IVertexBundle>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->view, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_IVertexBundle_view_set,2,SWIGTYPE_cc__IMeshBufferView"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IVertexBundle_view_set) 

static bool js_cc_Mesh_IVertexBundle_view_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IVertexBundle *arg1 = (cc::Mesh::IVertexBundle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IVertexBundle>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->view, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_IVertexBundle_view_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->view, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IVertexBundle_view_get) 

static bool js_cc_Mesh_IVertexBundle_attributes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IVertexBundle *arg1 = (cc::Mesh::IVertexBundle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IVertexBundle>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->attributes, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_IVertexBundle_attributes_set,2,SWIGTYPE_ccstd__vectorT_cc__gfx__Attribute_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IVertexBundle_attributes_set) 

static bool js_cc_Mesh_IVertexBundle_attributes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IVertexBundle *arg1 = (cc::Mesh::IVertexBundle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IVertexBundle>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->attributes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_IVertexBundle_attributes_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->attributes, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IVertexBundle_attributes_get) 

// js_ctor
static bool js_new_cc_Mesh_IVertexBundle(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::Mesh::IVertexBundle *result;
    result = (cc::Mesh::IVertexBundle *)new cc::Mesh::IVertexBundle();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Mesh_IVertexBundle, __jsb_cc_Mesh_IVertexBundle_class, js_delete_cc_Mesh_IVertexBundle)

static bool js_delete_cc_Mesh_IVertexBundle(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Mesh_IVertexBundle) 

template<>
bool sevalue_to_native(const se::Value &from, cc::Mesh::IVertexBundle * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::Mesh::IVertexBundle*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("_padding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->_padding), ctx);
    }
    
    
    json->getProperty("view", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->view), ctx);
    }
    
    
    json->getProperty("attributes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->attributes), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_Mesh_IVertexBundle(se::Object* obj) {
    auto* cls = se::Class::create({"Mesh", "IVertexBundle"}, obj, nullptr, _SE(js_new_cc_Mesh_IVertexBundle)); 
    
    cls->defineProperty("_padding", _SE(js_cc_Mesh_IVertexBundle__padding_get), _SE(js_cc_Mesh_IVertexBundle__padding_set)); 
    cls->defineProperty("view", _SE(js_cc_Mesh_IVertexBundle_view_get), _SE(js_cc_Mesh_IVertexBundle_view_set)); 
    cls->defineProperty("attributes", _SE(js_cc_Mesh_IVertexBundle_attributes_get), _SE(js_cc_Mesh_IVertexBundle_attributes_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Mesh_IVertexBundle));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Mesh::IVertexBundle>(cls);
    
    __jsb_cc_Mesh_IVertexBundle_proto = cls->getProto();
    __jsb_cc_Mesh_IVertexBundle_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Mesh_ISubMesh_class = nullptr;
se::Object* __jsb_cc_Mesh_ISubMesh_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Mesh_ISubMesh) 

static bool js_cc_Mesh_ISubMesh_vertexBundelIndices_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::ISubMesh *arg1 = (cc::Mesh::ISubMesh *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::ISubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->vertexBundelIndices, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_ISubMesh_vertexBundelIndices_set,2,SWIGTYPE_ccstd__vectorT_uint32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_ISubMesh_vertexBundelIndices_set) 

static bool js_cc_Mesh_ISubMesh_vertexBundelIndices_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::ISubMesh *arg1 = (cc::Mesh::ISubMesh *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::ISubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->vertexBundelIndices, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_ISubMesh_vertexBundelIndices_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->vertexBundelIndices, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_ISubMesh_vertexBundelIndices_get) 

static bool js_cc_Mesh_ISubMesh_primitiveMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::ISubMesh *arg1 = (cc::Mesh::ISubMesh *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::ISubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "Mesh_ISubMesh_primitiveMode_set,2,SWIGTYPE_cc__gfx__PrimitiveMode");
    arg1->primitiveMode = (cc::gfx::PrimitiveMode)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_ISubMesh_primitiveMode_set) 

static bool js_cc_Mesh_ISubMesh_primitiveMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::ISubMesh *arg1 = (cc::Mesh::ISubMesh *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::ISubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->primitiveMode));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_ISubMesh_primitiveMode_get) 

static bool js_cc_Mesh_ISubMesh_indexView_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::ISubMesh *arg1 = (cc::Mesh::ISubMesh *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::ISubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->indexView, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_ISubMesh_indexView_set,2,SWIGTYPE_ccstd__optionalT_cc__Mesh__IBufferView_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_ISubMesh_indexView_set) 

static bool js_cc_Mesh_ISubMesh_indexView_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::ISubMesh *arg1 = (cc::Mesh::ISubMesh *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::ISubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->indexView, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_ISubMesh_indexView_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->indexView, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_ISubMesh_indexView_get) 

static bool js_cc_Mesh_ISubMesh_jointMapIndex_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::ISubMesh *arg1 = (cc::Mesh::ISubMesh *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::ISubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->jointMapIndex, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_ISubMesh_jointMapIndex_set,2,SWIGTYPE_ccstd__optionalT_uint32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_ISubMesh_jointMapIndex_set) 

static bool js_cc_Mesh_ISubMesh_jointMapIndex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::ISubMesh *arg1 = (cc::Mesh::ISubMesh *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::ISubMesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->jointMapIndex, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_ISubMesh_jointMapIndex_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->jointMapIndex, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_ISubMesh_jointMapIndex_get) 

// js_ctor
static bool js_new_cc_Mesh_ISubMesh(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::Mesh::ISubMesh *result;
    result = (cc::Mesh::ISubMesh *)new cc::Mesh::ISubMesh();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Mesh_ISubMesh, __jsb_cc_Mesh_ISubMesh_class, js_delete_cc_Mesh_ISubMesh)

static bool js_delete_cc_Mesh_ISubMesh(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Mesh_ISubMesh) 

template<>
bool sevalue_to_native(const se::Value &from, cc::Mesh::ISubMesh * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::Mesh::ISubMesh*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("vertexBundelIndices", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->vertexBundelIndices), ctx);
    }
    
    
    json->getProperty("primitiveMode", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->primitiveMode), ctx);
    }
    
    
    json->getProperty("indexView", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->indexView), ctx);
    }
    
    
    json->getProperty("jointMapIndex", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->jointMapIndex), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_Mesh_ISubMesh(se::Object* obj) {
    auto* cls = se::Class::create({"Mesh", "ISubMesh"}, obj, nullptr, _SE(js_new_cc_Mesh_ISubMesh)); 
    
    cls->defineProperty("vertexBundelIndices", _SE(js_cc_Mesh_ISubMesh_vertexBundelIndices_get), _SE(js_cc_Mesh_ISubMesh_vertexBundelIndices_set)); 
    cls->defineProperty("primitiveMode", _SE(js_cc_Mesh_ISubMesh_primitiveMode_get), _SE(js_cc_Mesh_ISubMesh_primitiveMode_set)); 
    cls->defineProperty("indexView", _SE(js_cc_Mesh_ISubMesh_indexView_get), _SE(js_cc_Mesh_ISubMesh_indexView_set)); 
    cls->defineProperty("jointMapIndex", _SE(js_cc_Mesh_ISubMesh_jointMapIndex_get), _SE(js_cc_Mesh_ISubMesh_jointMapIndex_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Mesh_ISubMesh));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Mesh::ISubMesh>(cls);
    
    __jsb_cc_Mesh_ISubMesh_proto = cls->getProto();
    __jsb_cc_Mesh_ISubMesh_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Mesh_IDynamicInfo_class = nullptr;
se::Object* __jsb_cc_Mesh_IDynamicInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Mesh_IDynamicInfo) 

static bool js_cc_Mesh_IDynamicInfo_maxSubMeshes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IDynamicInfo *arg1 = (cc::Mesh::IDynamicInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IDynamicInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxSubMeshes, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_IDynamicInfo_maxSubMeshes_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IDynamicInfo_maxSubMeshes_set) 

static bool js_cc_Mesh_IDynamicInfo_maxSubMeshes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IDynamicInfo *arg1 = (cc::Mesh::IDynamicInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IDynamicInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxSubMeshes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_IDynamicInfo_maxSubMeshes_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxSubMeshes, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IDynamicInfo_maxSubMeshes_get) 

static bool js_cc_Mesh_IDynamicInfo_maxSubMeshVertices_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IDynamicInfo *arg1 = (cc::Mesh::IDynamicInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IDynamicInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxSubMeshVertices, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_IDynamicInfo_maxSubMeshVertices_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IDynamicInfo_maxSubMeshVertices_set) 

static bool js_cc_Mesh_IDynamicInfo_maxSubMeshVertices_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IDynamicInfo *arg1 = (cc::Mesh::IDynamicInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IDynamicInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxSubMeshVertices, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_IDynamicInfo_maxSubMeshVertices_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxSubMeshVertices, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IDynamicInfo_maxSubMeshVertices_get) 

static bool js_cc_Mesh_IDynamicInfo_maxSubMeshIndices_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IDynamicInfo *arg1 = (cc::Mesh::IDynamicInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IDynamicInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxSubMeshIndices, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_IDynamicInfo_maxSubMeshIndices_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IDynamicInfo_maxSubMeshIndices_set) 

static bool js_cc_Mesh_IDynamicInfo_maxSubMeshIndices_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IDynamicInfo *arg1 = (cc::Mesh::IDynamicInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IDynamicInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxSubMeshIndices, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_IDynamicInfo_maxSubMeshIndices_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxSubMeshIndices, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IDynamicInfo_maxSubMeshIndices_get) 

// js_ctor
static bool js_new_cc_Mesh_IDynamicInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::Mesh::IDynamicInfo *result;
    result = (cc::Mesh::IDynamicInfo *)new cc::Mesh::IDynamicInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Mesh_IDynamicInfo, __jsb_cc_Mesh_IDynamicInfo_class, js_delete_cc_Mesh_IDynamicInfo)

static bool js_delete_cc_Mesh_IDynamicInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Mesh_IDynamicInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::Mesh::IDynamicInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::Mesh::IDynamicInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("maxSubMeshes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxSubMeshes), ctx);
    }
    
    
    json->getProperty("maxSubMeshVertices", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxSubMeshVertices), ctx);
    }
    
    
    json->getProperty("maxSubMeshIndices", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxSubMeshIndices), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_Mesh_IDynamicInfo(se::Object* obj) {
    auto* cls = se::Class::create({"Mesh", "IDynamicInfo"}, obj, nullptr, _SE(js_new_cc_Mesh_IDynamicInfo)); 
    
    cls->defineProperty("maxSubMeshes", _SE(js_cc_Mesh_IDynamicInfo_maxSubMeshes_get), _SE(js_cc_Mesh_IDynamicInfo_maxSubMeshes_set)); 
    cls->defineProperty("maxSubMeshVertices", _SE(js_cc_Mesh_IDynamicInfo_maxSubMeshVertices_get), _SE(js_cc_Mesh_IDynamicInfo_maxSubMeshVertices_set)); 
    cls->defineProperty("maxSubMeshIndices", _SE(js_cc_Mesh_IDynamicInfo_maxSubMeshIndices_get), _SE(js_cc_Mesh_IDynamicInfo_maxSubMeshIndices_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Mesh_IDynamicInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Mesh::IDynamicInfo>(cls);
    
    __jsb_cc_Mesh_IDynamicInfo_proto = cls->getProto();
    __jsb_cc_Mesh_IDynamicInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Mesh_IDynamicStruct_class = nullptr;
se::Object* __jsb_cc_Mesh_IDynamicStruct_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Mesh_IDynamicStruct) 

static bool js_cc_Mesh_IDynamicStruct_info_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IDynamicStruct *arg1 = (cc::Mesh::IDynamicStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IDynamicStruct>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->info, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_IDynamicStruct_info_set,2,SWIGTYPE_cc__Mesh__IDynamicInfo"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IDynamicStruct_info_set) 

static bool js_cc_Mesh_IDynamicStruct_info_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IDynamicStruct *arg1 = (cc::Mesh::IDynamicStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IDynamicStruct>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->info, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_IDynamicStruct_info_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->info, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IDynamicStruct_info_get) 

static bool js_cc_Mesh_IDynamicStruct_bounds_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IDynamicStruct *arg1 = (cc::Mesh::IDynamicStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IDynamicStruct>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->bounds, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_IDynamicStruct_bounds_set,2,SWIGTYPE_ccstd__vectorT_geometry__AABB_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IDynamicStruct_bounds_set) 

static bool js_cc_Mesh_IDynamicStruct_bounds_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IDynamicStruct *arg1 = (cc::Mesh::IDynamicStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IDynamicStruct>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->bounds, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_IDynamicStruct_bounds_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->bounds, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IDynamicStruct_bounds_get) 

// js_ctor
static bool js_new_cc_Mesh_IDynamicStruct(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::Mesh::IDynamicStruct *result;
    result = (cc::Mesh::IDynamicStruct *)new cc::Mesh::IDynamicStruct();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Mesh_IDynamicStruct, __jsb_cc_Mesh_IDynamicStruct_class, js_delete_cc_Mesh_IDynamicStruct)

static bool js_delete_cc_Mesh_IDynamicStruct(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Mesh_IDynamicStruct) 

template<>
bool sevalue_to_native(const se::Value &from, cc::Mesh::IDynamicStruct * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::Mesh::IDynamicStruct*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("info", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->info), ctx);
    }
    
    
    json->getProperty("bounds", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->bounds), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_Mesh_IDynamicStruct(se::Object* obj) {
    auto* cls = se::Class::create({"Mesh", "IDynamicStruct"}, obj, nullptr, _SE(js_new_cc_Mesh_IDynamicStruct)); 
    
    cls->defineProperty("info", _SE(js_cc_Mesh_IDynamicStruct_info_get), _SE(js_cc_Mesh_IDynamicStruct_info_set)); 
    cls->defineProperty("bounds", _SE(js_cc_Mesh_IDynamicStruct_bounds_get), _SE(js_cc_Mesh_IDynamicStruct_bounds_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Mesh_IDynamicStruct));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Mesh::IDynamicStruct>(cls);
    
    __jsb_cc_Mesh_IDynamicStruct_proto = cls->getProto();
    __jsb_cc_Mesh_IDynamicStruct_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Mesh_IStruct_class = nullptr;
se::Object* __jsb_cc_Mesh_IStruct_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Mesh_IStruct) 

static bool js_cc_Mesh_IStruct_vertexBundles_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->vertexBundles, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_IStruct_vertexBundles_set,2,SWIGTYPE_ccstd__vectorT_cc__Mesh__IVertexBundle_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IStruct_vertexBundles_set) 

static bool js_cc_Mesh_IStruct_vertexBundles_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->vertexBundles, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_IStruct_vertexBundles_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->vertexBundles, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IStruct_vertexBundles_get) 

static bool js_cc_Mesh_IStruct_primitives_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->primitives, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_IStruct_primitives_set,2,SWIGTYPE_ccstd__vectorT_cc__Mesh__ISubMesh_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IStruct_primitives_set) 

static bool js_cc_Mesh_IStruct_primitives_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->primitives, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_IStruct_primitives_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->primitives, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IStruct_primitives_get) 

static bool js_cc_Mesh_IStruct_minPosition_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->minPosition, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_IStruct_minPosition_set,2,SWIGTYPE_ccstd__optionalT_cc__Vec3_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IStruct_minPosition_set) 

static bool js_cc_Mesh_IStruct_minPosition_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->minPosition, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_IStruct_minPosition_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->minPosition, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IStruct_minPosition_get) 

static bool js_cc_Mesh_IStruct_maxPosition_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxPosition, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_IStruct_maxPosition_set,2,SWIGTYPE_ccstd__optionalT_cc__Vec3_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IStruct_maxPosition_set) 

static bool js_cc_Mesh_IStruct_maxPosition_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxPosition, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_IStruct_maxPosition_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxPosition, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IStruct_maxPosition_get) 

static bool js_cc_Mesh_IStruct_jointMaps_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->jointMaps, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_IStruct_jointMaps_set,2,SWIGTYPE_ccstd__optionalT_ccstd__vectorT_ccstd__vectorT_index_t_t_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IStruct_jointMaps_set) 

static bool js_cc_Mesh_IStruct_jointMaps_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->jointMaps, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_IStruct_jointMaps_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->jointMaps, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IStruct_jointMaps_get) 

static bool js_cc_Mesh_IStruct_morph_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->morph, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_IStruct_morph_set,2,SWIGTYPE_ccstd__optionalT_cc__Morph_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IStruct_morph_set) 

static bool js_cc_Mesh_IStruct_morph_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->morph, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_IStruct_morph_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->morph, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IStruct_morph_get) 

static bool js_cc_Mesh_IStruct_dynamic_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->dynamic, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_IStruct_dynamic_set,2,SWIGTYPE_ccstd__optionalT_cc__Mesh__IDynamicStruct_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IStruct_dynamic_set) 

static bool js_cc_Mesh_IStruct_dynamic_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->dynamic, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_IStruct_dynamic_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->dynamic, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IStruct_dynamic_get) 

// js_ctor
static bool js_new_cc_Mesh_IStruct(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::Mesh::IStruct *result;
    result = (cc::Mesh::IStruct *)new cc::Mesh::IStruct();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Mesh_IStruct, __jsb_cc_Mesh_IStruct_class, js_delete_cc_Mesh_IStruct)

static bool js_delete_cc_Mesh_IStruct(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Mesh_IStruct) 

template<>
bool sevalue_to_native(const se::Value &from, cc::Mesh::IStruct * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::Mesh::IStruct*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("vertexBundles", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->vertexBundles), ctx);
    }
    
    
    json->getProperty("primitives", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->primitives), ctx);
    }
    
    
    json->getProperty("minPosition", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->minPosition), ctx);
    }
    
    
    json->getProperty("maxPosition", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxPosition), ctx);
    }
    
    
    json->getProperty("jointMaps", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->jointMaps), ctx);
    }
    
    
    json->getProperty("morph", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->morph), ctx);
    }
    
    
    json->getProperty("dynamic", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dynamic), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_Mesh_IStruct(se::Object* obj) {
    auto* cls = se::Class::create({"Mesh", "IStruct"}, obj, nullptr, _SE(js_new_cc_Mesh_IStruct)); 
    
    cls->defineProperty("vertexBundles", _SE(js_cc_Mesh_IStruct_vertexBundles_get), _SE(js_cc_Mesh_IStruct_vertexBundles_set)); 
    cls->defineProperty("primitives", _SE(js_cc_Mesh_IStruct_primitives_get), _SE(js_cc_Mesh_IStruct_primitives_set)); 
    cls->defineProperty("minPosition", _SE(js_cc_Mesh_IStruct_minPosition_get), _SE(js_cc_Mesh_IStruct_minPosition_set)); 
    cls->defineProperty("maxPosition", _SE(js_cc_Mesh_IStruct_maxPosition_get), _SE(js_cc_Mesh_IStruct_maxPosition_set)); 
    cls->defineProperty("jointMaps", _SE(js_cc_Mesh_IStruct_jointMaps_get), _SE(js_cc_Mesh_IStruct_jointMaps_set)); 
    cls->defineProperty("morph", _SE(js_cc_Mesh_IStruct_morph_get), _SE(js_cc_Mesh_IStruct_morph_set)); 
    cls->defineProperty("dynamic", _SE(js_cc_Mesh_IStruct_dynamic_get), _SE(js_cc_Mesh_IStruct_dynamic_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Mesh_IStruct));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Mesh::IStruct>(cls);
    
    __jsb_cc_Mesh_IStruct_proto = cls->getProto();
    __jsb_cc_Mesh_IStruct_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Mesh_ICreateInfo_class = nullptr;
se::Object* __jsb_cc_Mesh_ICreateInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Mesh_ICreateInfo) 

static bool js_cc_Mesh_ICreateInfo_cpp_keyword_struct_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::ICreateInfo *arg1 = (cc::Mesh::ICreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::ICreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->structInfo, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_ICreateInfo_cpp_keyword_struct_set,2,SWIGTYPE_cc__Mesh__IStruct"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_ICreateInfo_cpp_keyword_struct_set) 

static bool js_cc_Mesh_ICreateInfo_cpp_keyword_struct_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::ICreateInfo *arg1 = (cc::Mesh::ICreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::ICreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->structInfo, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_ICreateInfo_cpp_keyword_struct_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->structInfo, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_ICreateInfo_cpp_keyword_struct_get) 

static bool js_cc_Mesh_ICreateInfo_data_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::ICreateInfo *arg1 = (cc::Mesh::ICreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::ICreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->data, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_ICreateInfo_data_set,2,SWIGTYPE_cc__TypedArrayTempT_uint8_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_ICreateInfo_data_set) 

static bool js_cc_Mesh_ICreateInfo_data_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::ICreateInfo *arg1 = (cc::Mesh::ICreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::ICreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->data, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_ICreateInfo_data_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->data, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_ICreateInfo_data_get) 

// js_ctor
static bool js_new_cc_Mesh_ICreateInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::Mesh::ICreateInfo *result;
    result = (cc::Mesh::ICreateInfo *)new cc::Mesh::ICreateInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Mesh_ICreateInfo, __jsb_cc_Mesh_ICreateInfo_class, js_delete_cc_Mesh_ICreateInfo)

static bool js_delete_cc_Mesh_ICreateInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Mesh_ICreateInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::Mesh::ICreateInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::Mesh::ICreateInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("struct", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->structInfo), ctx);
    }
    
    
    json->getProperty("data", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->data), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_Mesh_ICreateInfo(se::Object* obj) {
    auto* cls = se::Class::create({"Mesh", "ICreateInfo"}, obj, nullptr, _SE(js_new_cc_Mesh_ICreateInfo)); 
    
    cls->defineProperty("struct", _SE(js_cc_Mesh_ICreateInfo_cpp_keyword_struct_get), _SE(js_cc_Mesh_ICreateInfo_cpp_keyword_struct_set)); 
    cls->defineProperty("data", _SE(js_cc_Mesh_ICreateInfo_data_get), _SE(js_cc_Mesh_ICreateInfo_data_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Mesh_ICreateInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Mesh::ICreateInfo>(cls);
    
    __jsb_cc_Mesh_ICreateInfo_proto = cls->getProto();
    __jsb_cc_Mesh_ICreateInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


// js_ctor
static bool js_new_cc_Mesh(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::Mesh *result;
    result = (cc::Mesh *)new cc::Mesh();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Mesh, __jsb_cc_Mesh_class, js_delete_cc_Mesh)

static bool js_delete_cc_Mesh(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Mesh) 

static bool js_cc_Mesh_getStruct(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Mesh::IStruct *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Mesh::IStruct *) &((cc::Mesh const *)arg1)->getStruct();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_getStruct, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_getStruct) 

static bool js_cc_Mesh_setStruct(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Mesh::IStruct *arg2 = 0 ;
    cc::Mesh::IStruct temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_setStruct,2,SWIGTYPE_p_cc__Mesh__IStruct");
    arg2 = &temp2;
    
    (arg1)->setStruct((cc::Mesh::IStruct const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_setStruct) 

static bool js_cc_Mesh_setData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Uint8Array *arg2 = 0 ;
    cc::Uint8Array temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_setData,2,SWIGTYPE_p_cc__TypedArrayTempT_uint8_t_t");
    arg2 = &temp2;
    
    (arg1)->setData((cc::Uint8Array const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_setData) 

static bool js_cc_Mesh_setHash(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    ccstd::hash_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_setHash,2,SWIGTYPE_ccstd__hash_t"); 
    
    (arg1)->setHash(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_setHash) 

static bool js_cc_Mesh_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->initialize();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_initialize) 

static bool js_cc_Mesh_destroyRenderingMesh(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroyRenderingMesh();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_destroyRenderingMesh) 

static bool js_cc_Mesh_assign(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Mesh::IStruct *arg2 = 0 ;
    cc::Uint8Array *arg3 = 0 ;
    cc::Mesh::IStruct temp2 ;
    cc::Uint8Array temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_assign,2,SWIGTYPE_p_cc__Mesh__IStruct");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_assign,3,SWIGTYPE_p_cc__TypedArrayTempT_uint8_t_t");
    arg3 = &temp3;
    
    (arg1)->assign((cc::Mesh::IStruct const &)*arg2,(cc::Uint8Array const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_assign) 

static bool js_cc_Mesh_reset(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Mesh::ICreateInfo *arg2 = 0 ;
    cc::Mesh::ICreateInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_reset,2,SWIGTYPE_p_cc__Mesh__ICreateInfo");
    arg2 = &temp2;
    
    (arg1)->reset((cc::Mesh::ICreateInfo &&)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_reset) 

static bool js_cc_Mesh_getBoneSpaceBounds(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Skeleton *arg2 = (cc::Skeleton *) NULL ;
    cc::Mesh::BoneSpaceBounds result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_getBoneSpaceBounds,2,SWIGTYPE_p_cc__Skeleton"); 
    result = (arg1)->getBoneSpaceBounds(arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_getBoneSpaceBounds, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_getBoneSpaceBounds) 

static bool js_cc_Mesh_merge__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Mesh *arg2 = (cc::Mesh *) NULL ;
    cc::Mat4 *arg3 = (cc::Mat4 *) NULL ;
    bool arg4 ;
    cc::Mat4 temp3 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_merge,2,SWIGTYPE_p_cc__Mesh"); 
    
    // %typemap(in) cc::Mat4* (cc::Mat4 temp3) %{
    ok &= sevalue_to_native(args[1], &temp3);
    SE_PRECONDITION2(ok, false, "Mesh_merge,3,SWIGTYPE_p_cc__Mat4");
    arg3 = (cc::Mat4 *) &temp3;
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "Mesh_merge,4,SWIGTYPE_bool"); 
    result = (bool)(arg1)->merge(arg2,(cc::Mat4 const *)arg3,arg4);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_cc_Mesh_merge__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Mesh *arg2 = (cc::Mesh *) NULL ;
    cc::Mat4 *arg3 = (cc::Mat4 *) NULL ;
    cc::Mat4 temp3 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_merge,2,SWIGTYPE_p_cc__Mesh"); 
    
    // %typemap(in) cc::Mat4* (cc::Mat4 temp3) %{
    ok &= sevalue_to_native(args[1], &temp3);
    SE_PRECONDITION2(ok, false, "Mesh_merge,3,SWIGTYPE_p_cc__Mat4");
    arg3 = (cc::Mat4 *) &temp3;
    
    result = (bool)(arg1)->merge(arg2,(cc::Mat4 const *)arg3);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_cc_Mesh_merge__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Mesh *arg2 = (cc::Mesh *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_merge,2,SWIGTYPE_p_cc__Mesh"); 
    result = (bool)(arg1)->merge(arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_cc_Mesh_merge(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Mesh_merge__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Mesh_merge__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Mesh_merge__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Mesh_merge) 

static bool js_cc_Mesh_validateMergingMesh(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Mesh *arg2 = (cc::Mesh *) NULL ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_validateMergingMesh,2,SWIGTYPE_p_cc__Mesh"); 
    result = (bool)(arg1)->validateMergingMesh(arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_validateMergingMesh) 

static bool js_cc_Mesh_readAttribute(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    index_t arg2 ;
    char *arg3 = (char *) NULL ;
    ccstd::string temp3 ;
    cc::TypedArray result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_readAttribute,2,SWIGTYPE_int32_t"); 
    
    
    ok &= sevalue_to_native(args[1], &temp3);
    SE_PRECONDITION2(ok, false, "Mesh_readAttribute,3,SWIGTYPE_p_char");
    arg3 = (char *) temp3.c_str(); 
    result = (arg1)->readAttribute(arg2,(char const *)arg3);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_readAttribute, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_readAttribute) 

static bool js_cc_Mesh_copyAttribute(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    index_t arg2 ;
    char *arg3 = (char *) NULL ;
    cc::ArrayBuffer *arg4 = (cc::ArrayBuffer *) NULL ;
    uint32_t arg5 ;
    uint32_t arg6 ;
    ccstd::string temp3 ;
    bool result;
    
    if(argc != 5) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_copyAttribute,2,SWIGTYPE_int32_t"); 
    
    
    ok &= sevalue_to_native(args[1], &temp3);
    SE_PRECONDITION2(ok, false, "Mesh_copyAttribute,3,SWIGTYPE_p_char");
    arg3 = (char *) temp3.c_str(); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_copyAttribute,4,SWIGTYPE_p_cc__ArrayBuffer"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_copyAttribute,5,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_copyAttribute,6,SWIGTYPE_uint32_t"); 
    
    result = (bool)(arg1)->copyAttribute(arg2,(char const *)arg3,arg4,arg5,arg6);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_copyAttribute) 

static bool js_cc_Mesh_readIndices(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    index_t arg2 ;
    cc::IBArray result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_readIndices,2,SWIGTYPE_int32_t"); 
    
    result = (arg1)->readIndices(arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_readIndices, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_readIndices) 

static bool js_cc_Mesh_copyIndices(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    index_t arg2 ;
    cc::TypedArray *arg3 = 0 ;
    cc::TypedArray temp3 ;
    bool result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_copyIndices,2,SWIGTYPE_int32_t"); 
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_copyIndices,3,SWIGTYPE_p_ccstd__variantT_ccstd__monostate_cc__Int8Array_cc__Int16Array_cc__Int32Array_cc__Uint8Array_cc__Uint16Array_cc__Uint32Array_cc__Float32Array_cc__Float64Array_t");
    arg3 = &temp3;
    
    result = (bool)(arg1)->copyIndices(arg2,*arg3);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_copyIndices) 

static bool js_cc_Mesh_readAttributeFormat(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    index_t arg2 ;
    char *arg3 = (char *) NULL ;
    ccstd::string temp3 ;
    cc::gfx::FormatInfo *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_readAttributeFormat,2,SWIGTYPE_int32_t"); 
    
    
    ok &= sevalue_to_native(args[1], &temp3);
    SE_PRECONDITION2(ok, false, "Mesh_readAttributeFormat,3,SWIGTYPE_p_char");
    arg3 = (char *) temp3.c_str(); 
    result = (cc::gfx::FormatInfo *)(arg1)->readAttributeFormat(arg2,(char const *)arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_readAttributeFormat, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_readAttributeFormat) 

static bool js_cc_Mesh_updateSubMesh(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    index_t arg2 ;
    cc::IDynamicGeometry *arg3 = 0 ;
    cc::IDynamicGeometry temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_updateSubMesh,2,SWIGTYPE_int32_t"); 
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_updateSubMesh,3,SWIGTYPE_p_cc__IDynamicGeometry");
    arg3 = &temp3;
    
    (arg1)->updateSubMesh(arg2,(cc::IDynamicGeometry const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_updateSubMesh) 

static bool js_cc_Mesh_morphRendering_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->morphRendering, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh_morphRendering_set,2,SWIGTYPE_cc__IntrusivePtrT_cc__MorphRendering_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_morphRendering_set) 

static bool js_cc_Mesh_morphRendering_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->morphRendering, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_morphRendering_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->morphRendering, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_morphRendering_get) 

static bool js_cc_Mesh__hash_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    ccstd::hash_t result;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_Mesh__hash_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh__hash_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh__hash_get) 

static bool js_cc_Mesh_hash_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    ccstd::hash_t result;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_Mesh_hash_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_hash_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_hash_get) 

static bool js_cc_Mesh_data_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Uint8Array *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Uint8Array *) &cc_Mesh_data_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_data_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_data_get) 

static bool js_cc_Mesh__data_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Uint8Array *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Uint8Array *) &cc_Mesh__data_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh__data_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh__data_get) 

static bool js_cc_Mesh_jointBufferIndices_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Mesh::JointBufferIndicesType *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Mesh::JointBufferIndicesType *) &cc_Mesh_jointBufferIndices_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_jointBufferIndices_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_jointBufferIndices_get) 

static bool js_cc_Mesh_maxPosition_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Vec3 *) &cc_Mesh_maxPosition_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_maxPosition_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_maxPosition_get) 

static bool js_cc_Mesh_minPosition_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Vec3 *) &cc_Mesh_minPosition_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_minPosition_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_minPosition_get) 

static bool js_cc_Mesh_renderingSubMeshes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Mesh::RenderingSubMeshList *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Mesh::RenderingSubMeshList *) &cc_Mesh_renderingSubMeshes_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_renderingSubMeshes_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_renderingSubMeshes_get) 

static bool js_cc_Mesh_subMeshCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_Mesh_subMeshCount_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh_subMeshCount_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_subMeshCount_get) 

static bool js_cc_Mesh__nativeAsset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::ArrayBuffer *arg2 = (cc::ArrayBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Mesh__nativeAsset_set,2,SWIGTYPE_p_cc__ArrayBuffer"); 
    cc_Mesh__nativeAsset_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh__nativeAsset_set) 

static bool js_cc_Mesh__nativeAsset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::ArrayBuffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::ArrayBuffer *)cc_Mesh__nativeAsset_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Mesh__nativeAsset_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh__nativeAsset_get) 

static bool js_cc_Mesh__allowDataAccess_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Mesh__allowDataAccess_set,2,SWIGTYPE_bool"); 
    cc_Mesh__allowDataAccess_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh__allowDataAccess_set) 

static bool js_cc_Mesh__allowDataAccess_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_Mesh__allowDataAccess_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh__allowDataAccess_get) 

static bool js_cc_Mesh_allowDataAccess_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Mesh_allowDataAccess_set,2,SWIGTYPE_bool"); 
    cc_Mesh_allowDataAccess_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_allowDataAccess_set) 

static bool js_cc_Mesh_allowDataAccess_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_Mesh_allowDataAccess_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_allowDataAccess_get) 

bool js_register_cc_Mesh(se::Object* obj) {
    auto* cls = se::Class::create("Mesh", obj, __jsb_cc_Asset_proto, _SE(js_new_cc_Mesh)); 
    
    cls->defineProperty("morphRendering", _SE(js_cc_Mesh_morphRendering_get), _SE(js_cc_Mesh_morphRendering_set)); 
    cls->defineProperty("_hash", _SE(js_cc_Mesh__hash_get), nullptr); 
    cls->defineProperty("hash", _SE(js_cc_Mesh_hash_get), nullptr); 
    cls->defineProperty("data", _SE(js_cc_Mesh_data_get), nullptr); 
    cls->defineProperty("_data", _SE(js_cc_Mesh__data_get), nullptr); 
    cls->defineProperty("jointBufferIndices", _SE(js_cc_Mesh_jointBufferIndices_get), nullptr); 
    cls->defineProperty("maxPosition", _SE(js_cc_Mesh_maxPosition_get), nullptr); 
    cls->defineProperty("minPosition", _SE(js_cc_Mesh_minPosition_get), nullptr); 
    cls->defineProperty("renderingSubMeshes", _SE(js_cc_Mesh_renderingSubMeshes_get), nullptr); 
    cls->defineProperty("subMeshCount", _SE(js_cc_Mesh_subMeshCount_get), nullptr); 
    cls->defineProperty("_nativeAsset", _SE(js_cc_Mesh__nativeAsset_get), _SE(js_cc_Mesh__nativeAsset_set)); 
    cls->defineProperty("_allowDataAccess", _SE(js_cc_Mesh__allowDataAccess_get), _SE(js_cc_Mesh__allowDataAccess_set)); 
    cls->defineProperty("allowDataAccess", _SE(js_cc_Mesh_allowDataAccess_get), _SE(js_cc_Mesh_allowDataAccess_set)); 
    
    cls->defineFunction("getStruct", _SE(js_cc_Mesh_getStruct)); 
    cls->defineFunction("setStruct", _SE(js_cc_Mesh_setStruct)); 
    cls->defineFunction("setData", _SE(js_cc_Mesh_setData)); 
    cls->defineFunction("setHash", _SE(js_cc_Mesh_setHash)); 
    cls->defineFunction("initialize", _SE(js_cc_Mesh_initialize)); 
    cls->defineFunction("destroyRenderingMesh", _SE(js_cc_Mesh_destroyRenderingMesh)); 
    cls->defineFunction("assign", _SE(js_cc_Mesh_assign)); 
    cls->defineFunction("reset", _SE(js_cc_Mesh_reset)); 
    cls->defineFunction("getBoneSpaceBounds", _SE(js_cc_Mesh_getBoneSpaceBounds)); 
    cls->defineFunction("merge", _SE(js_cc_Mesh_merge)); 
    cls->defineFunction("validateMergingMesh", _SE(js_cc_Mesh_validateMergingMesh)); 
    cls->defineFunction("readAttribute", _SE(js_cc_Mesh_readAttribute)); 
    cls->defineFunction("copyAttribute", _SE(js_cc_Mesh_copyAttribute)); 
    cls->defineFunction("readIndices", _SE(js_cc_Mesh_readIndices)); 
    cls->defineFunction("copyIndices", _SE(js_cc_Mesh_copyIndices)); 
    cls->defineFunction("readAttributeFormat", _SE(js_cc_Mesh_readAttributeFormat)); 
    cls->defineFunction("updateSubMesh", _SE(js_cc_Mesh_updateSubMesh)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Mesh));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Mesh>(cls);
    
    __jsb_cc_Mesh_proto = cls->getProto();
    __jsb_cc_Mesh_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Skeleton_class = nullptr;
se::Object* __jsb_cc_Skeleton_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Skeleton) 

// js_ctor
static bool js_new_cc_Skeleton(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::Skeleton *result;
    result = (cc::Skeleton *)new cc::Skeleton();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Skeleton, __jsb_cc_Skeleton_class, js_delete_cc_Skeleton)

static bool js_delete_cc_Skeleton(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Skeleton) 

static bool js_cc_Skeleton__getBindposes(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Skeleton *arg1 = (cc::Skeleton *) NULL ;
    ccstd::vector< cc::Mat4 > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::Mat4 > *) &((cc::Skeleton const *)arg1)->getBindposes();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skeleton__getBindposes, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Skeleton__getBindposes) 

static bool js_cc_Skeleton__setBindposes(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Skeleton *arg1 = (cc::Skeleton *) NULL ;
    ccstd::vector< cc::Mat4 > *arg2 = 0 ;
    ccstd::vector< cc::Mat4 > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skeleton__setBindposes,2,SWIGTYPE_p_ccstd__vectorT_cc__Mat4_t");
    arg2 = &temp2;
    
    (arg1)->setBindposes((ccstd::vector< cc::Mat4 > const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Skeleton__setBindposes) 

static bool js_cc_Skeleton_joints_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Skeleton *arg1 = (cc::Skeleton *) NULL ;
    ccstd::vector< ccstd::string > *arg2 = 0 ;
    ccstd::vector< ccstd::string > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skeleton_joints_set,2,SWIGTYPE_p_ccstd__vectorT_ccstd__string_t");
    arg2 = &temp2;
    
    cc_Skeleton_joints_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Skeleton_joints_set) 

static bool js_cc_Skeleton_joints_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Skeleton *arg1 = (cc::Skeleton *) NULL ;
    ccstd::vector< ccstd::string > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< ccstd::string > *) &cc_Skeleton_joints_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skeleton_joints_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Skeleton_joints_get) 

static bool js_cc_Skeleton__joints_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Skeleton *arg1 = (cc::Skeleton *) NULL ;
    ccstd::vector< ccstd::string > *arg2 = 0 ;
    ccstd::vector< ccstd::string > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skeleton__joints_set,2,SWIGTYPE_p_ccstd__vectorT_ccstd__string_t");
    arg2 = &temp2;
    
    cc_Skeleton__joints_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Skeleton__joints_set) 

static bool js_cc_Skeleton__joints_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Skeleton *arg1 = (cc::Skeleton *) NULL ;
    ccstd::vector< ccstd::string > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< ccstd::string > *) &cc_Skeleton__joints_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skeleton__joints_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Skeleton__joints_get) 

static bool js_cc_Skeleton_hash_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Skeleton *arg1 = (cc::Skeleton *) NULL ;
    ccstd::hash_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skeleton_hash_set,2,SWIGTYPE_ccstd__hash_t"); 
    
    cc_Skeleton_hash_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Skeleton_hash_set) 

static bool js_cc_Skeleton_hash_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Skeleton *arg1 = (cc::Skeleton *) NULL ;
    ccstd::hash_t result;
    
    arg1 = SE_THIS_OBJECT<cc::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_Skeleton_hash_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skeleton_hash_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Skeleton_hash_get) 

static bool js_cc_Skeleton__hash_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Skeleton *arg1 = (cc::Skeleton *) NULL ;
    ccstd::hash_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skeleton__hash_set,2,SWIGTYPE_ccstd__hash_t"); 
    
    cc_Skeleton__hash_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Skeleton__hash_set) 

static bool js_cc_Skeleton__hash_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Skeleton *arg1 = (cc::Skeleton *) NULL ;
    ccstd::hash_t result;
    
    arg1 = SE_THIS_OBJECT<cc::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_Skeleton__hash_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skeleton__hash_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Skeleton__hash_get) 

static bool js_cc_Skeleton__invBindposes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Skeleton *arg1 = (cc::Skeleton *) NULL ;
    ccstd::vector< cc::Mat4 > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::Mat4 > *) &cc_Skeleton__invBindposes_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skeleton__invBindposes_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Skeleton__invBindposes_get) 

static bool js_cc_Skeleton_inverseBindposes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Skeleton *arg1 = (cc::Skeleton *) NULL ;
    ccstd::vector< cc::Mat4 > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Skeleton>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::Mat4 > *) &cc_Skeleton_inverseBindposes_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skeleton_inverseBindposes_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Skeleton_inverseBindposes_get) 

bool js_register_cc_Skeleton(se::Object* obj) {
    auto* cls = se::Class::create("Skeleton", obj, __jsb_cc_Asset_proto, _SE(js_new_cc_Skeleton)); 
    
    cls->defineProperty("joints", _SE(js_cc_Skeleton_joints_get), _SE(js_cc_Skeleton_joints_set)); 
    cls->defineProperty("_joints", _SE(js_cc_Skeleton__joints_get), _SE(js_cc_Skeleton__joints_set)); 
    cls->defineProperty("hash", _SE(js_cc_Skeleton_hash_get), _SE(js_cc_Skeleton_hash_set)); 
    cls->defineProperty("_hash", _SE(js_cc_Skeleton__hash_get), _SE(js_cc_Skeleton__hash_set)); 
    cls->defineProperty("_invBindposes", _SE(js_cc_Skeleton__invBindposes_get), nullptr); 
    cls->defineProperty("inverseBindposes", _SE(js_cc_Skeleton_inverseBindposes_get), nullptr); 
    
    cls->defineFunction("_getBindposes", _SE(js_cc_Skeleton__getBindposes)); 
    cls->defineFunction("_setBindposes", _SE(js_cc_Skeleton__setBindposes)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Skeleton));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Skeleton>(cls);
    
    __jsb_cc_Skeleton_proto = cls->getProto();
    __jsb_cc_Skeleton_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_ICreateMeshOptions_class = nullptr;
se::Object* __jsb_cc_ICreateMeshOptions_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_ICreateMeshOptions) 

static bool js_cc_ICreateMeshOptions_calculateBounds_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICreateMeshOptions *arg1 = (cc::ICreateMeshOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ICreateMeshOptions>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->calculateBounds, s.thisObject());
    SE_PRECONDITION2(ok, false, "ICreateMeshOptions_calculateBounds_set,2,SWIGTYPE_ccstd__optionalT_bool_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ICreateMeshOptions_calculateBounds_set) 

static bool js_cc_ICreateMeshOptions_calculateBounds_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ICreateMeshOptions *arg1 = (cc::ICreateMeshOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ICreateMeshOptions>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->calculateBounds, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ICreateMeshOptions_calculateBounds_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->calculateBounds, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ICreateMeshOptions_calculateBounds_get) 

// js_ctor
static bool js_new_cc_ICreateMeshOptions(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::ICreateMeshOptions *result;
    result = (cc::ICreateMeshOptions *)new cc::ICreateMeshOptions();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_ICreateMeshOptions, __jsb_cc_ICreateMeshOptions_class, js_delete_cc_ICreateMeshOptions)

static bool js_delete_cc_ICreateMeshOptions(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_ICreateMeshOptions) 

template<>
bool sevalue_to_native(const se::Value &from, cc::ICreateMeshOptions * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::ICreateMeshOptions*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("calculateBounds", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->calculateBounds), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_ICreateMeshOptions(se::Object* obj) {
    auto* cls = se::Class::create("ICreateMeshOptions", obj, nullptr, _SE(js_new_cc_ICreateMeshOptions)); 
    
    cls->defineProperty("calculateBounds", _SE(js_cc_ICreateMeshOptions_calculateBounds_get), _SE(js_cc_ICreateMeshOptions_calculateBounds_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_ICreateMeshOptions));
    
    
    cls->install();
    JSBClassType::registerClass<cc::ICreateMeshOptions>(cls);
    
    __jsb_cc_ICreateMeshOptions_proto = cls->getProto();
    __jsb_cc_ICreateMeshOptions_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_ICreateDynamicMeshOptions_class = nullptr;
se::Object* __jsb_cc_ICreateDynamicMeshOptions_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_ICreateDynamicMeshOptions) 

static bool js_cc_ICreateDynamicMeshOptions_maxSubMeshes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICreateDynamicMeshOptions *arg1 = (cc::ICreateDynamicMeshOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ICreateDynamicMeshOptions>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxSubMeshes, s.thisObject());
    SE_PRECONDITION2(ok, false, "ICreateDynamicMeshOptions_maxSubMeshes_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ICreateDynamicMeshOptions_maxSubMeshes_set) 

static bool js_cc_ICreateDynamicMeshOptions_maxSubMeshes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ICreateDynamicMeshOptions *arg1 = (cc::ICreateDynamicMeshOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ICreateDynamicMeshOptions>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxSubMeshes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ICreateDynamicMeshOptions_maxSubMeshes_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxSubMeshes, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ICreateDynamicMeshOptions_maxSubMeshes_get) 

static bool js_cc_ICreateDynamicMeshOptions_maxSubMeshVertices_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICreateDynamicMeshOptions *arg1 = (cc::ICreateDynamicMeshOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ICreateDynamicMeshOptions>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxSubMeshVertices, s.thisObject());
    SE_PRECONDITION2(ok, false, "ICreateDynamicMeshOptions_maxSubMeshVertices_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ICreateDynamicMeshOptions_maxSubMeshVertices_set) 

static bool js_cc_ICreateDynamicMeshOptions_maxSubMeshVertices_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ICreateDynamicMeshOptions *arg1 = (cc::ICreateDynamicMeshOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ICreateDynamicMeshOptions>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxSubMeshVertices, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ICreateDynamicMeshOptions_maxSubMeshVertices_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxSubMeshVertices, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ICreateDynamicMeshOptions_maxSubMeshVertices_get) 

static bool js_cc_ICreateDynamicMeshOptions_maxSubMeshIndices_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICreateDynamicMeshOptions *arg1 = (cc::ICreateDynamicMeshOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ICreateDynamicMeshOptions>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxSubMeshIndices, s.thisObject());
    SE_PRECONDITION2(ok, false, "ICreateDynamicMeshOptions_maxSubMeshIndices_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ICreateDynamicMeshOptions_maxSubMeshIndices_set) 

static bool js_cc_ICreateDynamicMeshOptions_maxSubMeshIndices_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ICreateDynamicMeshOptions *arg1 = (cc::ICreateDynamicMeshOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ICreateDynamicMeshOptions>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxSubMeshIndices, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ICreateDynamicMeshOptions_maxSubMeshIndices_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxSubMeshIndices, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ICreateDynamicMeshOptions_maxSubMeshIndices_get) 

// js_ctor
static bool js_new_cc_ICreateDynamicMeshOptions(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::ICreateDynamicMeshOptions *result;
    result = (cc::ICreateDynamicMeshOptions *)new cc::ICreateDynamicMeshOptions();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_ICreateDynamicMeshOptions, __jsb_cc_ICreateDynamicMeshOptions_class, js_delete_cc_ICreateDynamicMeshOptions)

static bool js_delete_cc_ICreateDynamicMeshOptions(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_ICreateDynamicMeshOptions) 

template<>
bool sevalue_to_native(const se::Value &from, cc::ICreateDynamicMeshOptions * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::ICreateDynamicMeshOptions*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("maxSubMeshes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxSubMeshes), ctx);
    }
    
    
    json->getProperty("maxSubMeshVertices", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxSubMeshVertices), ctx);
    }
    
    
    json->getProperty("maxSubMeshIndices", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxSubMeshIndices), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_ICreateDynamicMeshOptions(se::Object* obj) {
    auto* cls = se::Class::create("ICreateDynamicMeshOptions", obj, nullptr, _SE(js_new_cc_ICreateDynamicMeshOptions)); 
    
    cls->defineProperty("maxSubMeshes", _SE(js_cc_ICreateDynamicMeshOptions_maxSubMeshes_get), _SE(js_cc_ICreateDynamicMeshOptions_maxSubMeshes_set)); 
    cls->defineProperty("maxSubMeshVertices", _SE(js_cc_ICreateDynamicMeshOptions_maxSubMeshVertices_get), _SE(js_cc_ICreateDynamicMeshOptions_maxSubMeshVertices_set)); 
    cls->defineProperty("maxSubMeshIndices", _SE(js_cc_ICreateDynamicMeshOptions_maxSubMeshIndices_get), _SE(js_cc_ICreateDynamicMeshOptions_maxSubMeshIndices_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_ICreateDynamicMeshOptions));
    
    
    cls->install();
    JSBClassType::registerClass<cc::ICreateDynamicMeshOptions>(cls);
    
    __jsb_cc_ICreateDynamicMeshOptions_proto = cls->getProto();
    __jsb_cc_ICreateDynamicMeshOptions_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_MeshUtils_class = nullptr;
se::Object* __jsb_cc_MeshUtils_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_MeshUtils) 

static bool js_cc_MeshUtils_createMesh_static__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::IGeometry *arg1 = 0 ;
    cc::Mesh *arg2 = (cc::Mesh *) NULL ;
    cc::ICreateMeshOptions *arg3 = 0 ;
    cc::IGeometry temp1 ;
    cc::ICreateMeshOptions temp3 ;
    cc::Mesh *result = 0 ;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "MeshUtils_createMesh,1,SWIGTYPE_p_cc__IGeometry");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "MeshUtils_createMesh,2,SWIGTYPE_p_cc__Mesh"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "MeshUtils_createMesh,3,SWIGTYPE_p_cc__ICreateMeshOptions");
    arg3 = &temp3;
    
    result = (cc::Mesh *)cc::MeshUtils::createMesh((cc::IGeometry const &)*arg1,arg2,(cc::ICreateMeshOptions const &)*arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MeshUtils_createMesh, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_MeshUtils_createMesh_static__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::IGeometry *arg1 = 0 ;
    cc::Mesh *arg2 = (cc::Mesh *) NULL ;
    cc::IGeometry temp1 ;
    cc::Mesh *result = 0 ;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "MeshUtils_createMesh,1,SWIGTYPE_p_cc__IGeometry");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "MeshUtils_createMesh,2,SWIGTYPE_p_cc__Mesh"); 
    result = (cc::Mesh *)cc::MeshUtils::createMesh((cc::IGeometry const &)*arg1,arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MeshUtils_createMesh, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_MeshUtils_createMesh_static__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::IGeometry *arg1 = 0 ;
    cc::IGeometry temp1 ;
    cc::Mesh *result = 0 ;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "MeshUtils_createMesh,1,SWIGTYPE_p_cc__IGeometry");
    arg1 = &temp1;
    
    result = (cc::Mesh *)cc::MeshUtils::createMesh((cc::IGeometry const &)*arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MeshUtils_createMesh, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_MeshUtils_createMesh_static(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_MeshUtils_createMesh_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_MeshUtils_createMesh_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_MeshUtils_createMesh_static__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_MeshUtils_createMesh_static) 

static bool js_cc_MeshUtils_createMeshInfo_static__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::IGeometry *arg1 = 0 ;
    cc::ICreateMeshOptions *arg2 = 0 ;
    cc::IGeometry temp1 ;
    cc::ICreateMeshOptions temp2 ;
    cc::Mesh::ICreateInfo result;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "MeshUtils_createMeshInfo,1,SWIGTYPE_p_cc__IGeometry");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "MeshUtils_createMeshInfo,2,SWIGTYPE_p_cc__ICreateMeshOptions");
    arg2 = &temp2;
    
    result = cc::MeshUtils::createMeshInfo((cc::IGeometry const &)*arg1,(cc::ICreateMeshOptions const &)*arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MeshUtils_createMeshInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_MeshUtils_createMeshInfo_static__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::IGeometry *arg1 = 0 ;
    cc::IGeometry temp1 ;
    cc::Mesh::ICreateInfo result;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "MeshUtils_createMeshInfo,1,SWIGTYPE_p_cc__IGeometry");
    arg1 = &temp1;
    
    result = cc::MeshUtils::createMeshInfo((cc::IGeometry const &)*arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MeshUtils_createMeshInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_MeshUtils_createMeshInfo_static(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_MeshUtils_createMeshInfo_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_MeshUtils_createMeshInfo_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_MeshUtils_createMeshInfo_static) 

static bool js_cc_MeshUtils_createDynamicMesh_static__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    index_t arg1 ;
    cc::IDynamicGeometry *arg2 = 0 ;
    cc::Mesh *arg3 = (cc::Mesh *) NULL ;
    cc::ICreateDynamicMeshOptions *arg4 = 0 ;
    cc::IDynamicGeometry temp2 ;
    cc::ICreateDynamicMeshOptions temp4 ;
    cc::Mesh *result = 0 ;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "MeshUtils_createDynamicMesh,1,SWIGTYPE_int32_t"); 
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "MeshUtils_createDynamicMesh,2,SWIGTYPE_p_cc__IDynamicGeometry");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "MeshUtils_createDynamicMesh,3,SWIGTYPE_p_cc__Mesh"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "MeshUtils_createDynamicMesh,4,SWIGTYPE_p_cc__ICreateDynamicMeshOptions");
    arg4 = &temp4;
    
    result = (cc::Mesh *)cc::MeshUtils::createDynamicMesh(arg1,(cc::IDynamicGeometry const &)*arg2,arg3,(cc::ICreateDynamicMeshOptions const &)*arg4);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MeshUtils_createDynamicMesh, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_MeshUtils_createDynamicMesh_static__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    index_t arg1 ;
    cc::IDynamicGeometry *arg2 = 0 ;
    cc::Mesh *arg3 = (cc::Mesh *) NULL ;
    cc::IDynamicGeometry temp2 ;
    cc::Mesh *result = 0 ;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "MeshUtils_createDynamicMesh,1,SWIGTYPE_int32_t"); 
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "MeshUtils_createDynamicMesh,2,SWIGTYPE_p_cc__IDynamicGeometry");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "MeshUtils_createDynamicMesh,3,SWIGTYPE_p_cc__Mesh"); 
    result = (cc::Mesh *)cc::MeshUtils::createDynamicMesh(arg1,(cc::IDynamicGeometry const &)*arg2,arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MeshUtils_createDynamicMesh, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_MeshUtils_createDynamicMesh_static__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    index_t arg1 ;
    cc::IDynamicGeometry *arg2 = 0 ;
    cc::IDynamicGeometry temp2 ;
    cc::Mesh *result = 0 ;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "MeshUtils_createDynamicMesh,1,SWIGTYPE_int32_t"); 
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "MeshUtils_createDynamicMesh,2,SWIGTYPE_p_cc__IDynamicGeometry");
    arg2 = &temp2;
    
    result = (cc::Mesh *)cc::MeshUtils::createDynamicMesh(arg1,(cc::IDynamicGeometry const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MeshUtils_createDynamicMesh, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_MeshUtils_createDynamicMesh_static(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_MeshUtils_createDynamicMesh_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_MeshUtils_createDynamicMesh_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_MeshUtils_createDynamicMesh_static__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_MeshUtils_createDynamicMesh_static) 

static bool js_cc_MeshUtils_createDynamicMeshInfo_static__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::IDynamicGeometry *arg1 = 0 ;
    cc::ICreateDynamicMeshOptions *arg2 = 0 ;
    cc::IDynamicGeometry temp1 ;
    cc::ICreateDynamicMeshOptions temp2 ;
    cc::Mesh::ICreateInfo result;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "MeshUtils_createDynamicMeshInfo,1,SWIGTYPE_p_cc__IDynamicGeometry");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "MeshUtils_createDynamicMeshInfo,2,SWIGTYPE_p_cc__ICreateDynamicMeshOptions");
    arg2 = &temp2;
    
    result = cc::MeshUtils::createDynamicMeshInfo((cc::IDynamicGeometry const &)*arg1,(cc::ICreateDynamicMeshOptions const &)*arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MeshUtils_createDynamicMeshInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_MeshUtils_createDynamicMeshInfo_static__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::IDynamicGeometry *arg1 = 0 ;
    cc::IDynamicGeometry temp1 ;
    cc::Mesh::ICreateInfo result;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "MeshUtils_createDynamicMeshInfo,1,SWIGTYPE_p_cc__IDynamicGeometry");
    arg1 = &temp1;
    
    result = cc::MeshUtils::createDynamicMeshInfo((cc::IDynamicGeometry const &)*arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MeshUtils_createDynamicMeshInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_MeshUtils_createDynamicMeshInfo_static(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_MeshUtils_createDynamicMeshInfo_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_MeshUtils_createDynamicMeshInfo_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_MeshUtils_createDynamicMeshInfo_static) 

// js_ctor
static bool js_new_cc_MeshUtils(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::MeshUtils *result;
    result = (cc::MeshUtils *)new cc::MeshUtils();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_MeshUtils, __jsb_cc_MeshUtils_class, js_delete_cc_MeshUtils)

static bool js_delete_cc_MeshUtils(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_MeshUtils) 

bool js_register_cc_MeshUtils(se::Object* obj) {
    auto* cls = se::Class::create("MeshUtils", obj, nullptr, _SE(js_new_cc_MeshUtils)); 
    
    
    
    
    cls->defineStaticFunction("createMesh", _SE(js_cc_MeshUtils_createMesh_static)); 
    cls->defineStaticFunction("createMeshInfo", _SE(js_cc_MeshUtils_createMeshInfo_static)); 
    cls->defineStaticFunction("createDynamicMesh", _SE(js_cc_MeshUtils_createDynamicMesh_static)); 
    cls->defineStaticFunction("createDynamicMeshInfo", _SE(js_cc_MeshUtils_createDynamicMeshInfo_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_MeshUtils));
    
    
    cls->install();
    JSBClassType::registerClass<cc::MeshUtils>(cls);
    
    __jsb_cc_MeshUtils_proto = cls->getProto();
    __jsb_cc_MeshUtils_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}




bool register_all_assets(se::Object* obj) {
    // Get the ns
    se::Value nsVal;
    if (!obj->getProperty("jsb", &nsVal, true))
    {
        se::HandleObject jsobj(se::Object::createPlainObject());
        nsVal.setObject(jsobj);
        obj->setProperty("jsb", nsVal);
    }
    se::Object* ns = nsVal.toObject();
    /* Register classes */
    js_register_cc_Error(ns); 
    js_register_cc_BoundingBox(ns); 
    js_register_cc_VertexIdChannel(ns); 
    js_register_cc_NativeDep(ns); 
    js_register_cc_IGeometryOptions(ns); 
    js_register_cc_CustomAttribute(ns); 
    js_register_cc_IGeometry(ns); 
    js_register_cc_DynamicCustomAttribute(ns); 
    js_register_cc_IDynamicGeometry(ns); 
    js_register_cc_Asset(ns); 
    js_register_cc_TextureBase(ns); 
    js_register_cc_SimpleTexture(ns); 
    js_register_cc_ITexture2DSerializeData(ns); 
    js_register_cc_ITexture2DCreateInfo(ns); 
    js_register_cc_Texture2D(ns); 
    js_register_cc_ITextureCubeMipmap(ns); 
    js_register_cc_ITextureCubeSerializeMipmapData(ns); 
    js_register_cc_MipmapAtlasLayoutInfo(ns); 
    js_register_cc_TextureCubeMipmapAtlasInfo(ns); 
    js_register_cc_TextureCubeSerializeData(ns); 
    js_register_cc_TextureCube(ns); 
    js_register_cc_IRenderTextureCreateInfo(ns); 
    js_register_cc_RenderTexture(ns); 
    js_register_cc_BufferAsset(ns); 
    js_register_cc_IPropertyInfo(ns); 
    js_register_cc_RasterizerStateInfo(ns); 
    js_register_cc_DepthStencilStateInfo(ns); 
    js_register_cc_BlendTargetInfo(ns); 
    js_register_cc_BlendStateInfo(ns); 
    js_register_cc_IPassStates(ns); 
    js_register_cc_IPassInfoFull(ns); 
    js_register_cc_ITechniqueInfo(ns); 
    js_register_cc_IBlockInfo(ns); 
    js_register_cc_ISamplerTextureInfo(ns); 
    js_register_cc_ITextureInfo(ns); 
    js_register_cc_ISamplerInfo(ns); 
    js_register_cc_IBufferInfo(ns); 
    js_register_cc_IImageInfo(ns); 
    js_register_cc_IInputAttachmentInfo(ns); 
    js_register_cc_IAttributeInfo(ns); 
    js_register_cc_IDefineInfo(ns); 
    js_register_cc_IBuiltin(ns); 
    js_register_cc_IBuiltinInfo(ns); 
    js_register_cc_IBuiltins(ns); 
    js_register_cc_IShaderSource(ns); 
    js_register_cc_IShaderInfo(ns); 
    js_register_cc_EffectAsset(ns); 
    js_register_cc_IMemoryImageSource(ns); 
    js_register_cc_ImageAsset(ns); 
    js_register_cc_SceneAsset(ns); 
    js_register_cc_TextAsset(ns); 
    js_register_cc_IMaterialInfo(ns); 
    js_register_cc_Material(ns); 
    js_register_cc_IGeometricInfo(ns); 
    js_register_cc_IFlatBuffer(ns); 
    js_register_cc_RenderingSubMesh(ns); 
    js_register_cc_BuiltinResMgr(ns); 
    js_register_cc_IMeshBufferView(ns); 
    js_register_cc_MorphTarget(ns); 
    js_register_cc_SubMeshMorph(ns); 
    js_register_cc_Morph(ns); 
    js_register_cc_MorphRenderingInstance(ns); 
    js_register_cc_MorphRendering(ns); 
    js_register_cc_StdMorphRendering(ns); 
    js_register_cc_Mesh(ns); 
    js_register_cc_Mesh_IVertexBundle(ns); 
    js_register_cc_Mesh_ISubMesh(ns); 
    js_register_cc_Mesh_IDynamicInfo(ns); 
    js_register_cc_Mesh_IDynamicStruct(ns); 
    js_register_cc_Mesh_IStruct(ns); 
    js_register_cc_Mesh_ICreateInfo(ns); 
    js_register_cc_Skeleton(ns); 
    js_register_cc_ICreateMeshOptions(ns); 
    js_register_cc_ICreateDynamicMeshOptions(ns); 
    js_register_cc_MeshUtils(ns); 
    
    /* Register global variables & global functions */
    
    
    
    return true;
}

// clang-format on
