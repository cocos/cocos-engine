// clang-format off

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

/****************************************************************************
 Copyright (c) 2022-2023 Xiamen Yaji Software Co., Ltd.

 http://www.cocos.com

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights to
 use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 of the Software, and to permit persons to whom the Software is furnished to do so,
 subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
****************************************************************************/

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-variable"
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-variable"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4101)
#endif


#define SWIG_STD_MOVE(OBJ) std::move(OBJ)


#include <stdio.h>


#include "bindings/jswrapper/SeApi.h"
#include "bindings/manual/jsb_conversions.h"
#include "bindings/manual/jsb_global.h"


#include "bindings/auto/jsb_assets_auto.h"
#include "bindings/auto/jsb_cocos_auto.h"
#include "bindings/auto/jsb_gfx_auto.h"
#include "bindings/auto/jsb_scene_auto.h"
#include "renderer/core/PassUtils.h"
#include "renderer/gfx-base/GFXDef-common.h"
#include "renderer/pipeline/Define.h"
#include "renderer/pipeline/RenderStage.h"
#include "scene/Pass.h"
#include "scene/RenderWindow.h"
#include "core/scene-graph/Scene.h"


#define cc_Asset__uuid_get(self_) self_->getUuid()
#define cc_Asset__uuid_set(self_, val_) self_->setUuid(val_)
  

#define cc_Asset_nativeUrl_get(self_) self_->getNativeUrl()
  

#define cc_Asset__nativeDep_get(self_) self_->getNativeDep()
  

#define cc_Asset_isDefault_get(self_) self_->isDefault()
  

#define cc_ImageAsset_format_get(self_) self_->getFormat()
#define cc_ImageAsset_format_set(self_, val_) self_->setFormat(val_)
  

#define cc_ImageAsset_url_get(self_) self_->getUrl()
#define cc_ImageAsset_url_set(self_, val_) self_->setUrl(val_)
  

#define cc_BufferAsset__nativeAsset_get(self_) self_->getNativeAssetForJS()
#define cc_BufferAsset__nativeAsset_set(self_, val_) self_->setNativeAssetForJS(val_)
  

#define cc_TextureBase_isCompressed_get(self_) self_->isCompressed()
  

#define cc_TextureBase__width_get(self_) self_->getWidth()
#define cc_TextureBase__width_set(self_, val_) self_->setWidth(val_)
  

#define cc_TextureBase_width_get(self_) self_->getWidth()
#define cc_TextureBase_width_set(self_, val_) self_->setWidth(val_)
  

#define cc_TextureBase__height_get(self_) self_->getHeight()
#define cc_TextureBase__height_set(self_, val_) self_->setHeight(val_)
  

#define cc_TextureBase_height_get(self_) self_->getHeight()
#define cc_TextureBase_height_set(self_, val_) self_->setHeight(val_)
  

#define cc_SimpleTexture_mipmapLevel_get(self_) self_->mipmapLevel()
  

#define cc_RenderTexture_window_get(self_) self_->getWindow()
  

#define cc_Mesh__hash_get(self_) self_->getHash()
#define cc_Mesh__hash_set(self_, val_) self_->setHash(val_)
  

#define cc_Mesh_hash_get(self_) self_->getHash()
  

#define cc_Mesh_data_get(self_) self_->getData()
  

#define cc_Mesh__data_get(self_) self_->getData()
  

#define cc_Mesh_jointBufferIndices_get(self_) self_->getJointBufferIndices()
  

#define cc_Mesh_renderingSubMeshes_get(self_) self_->getRenderingSubMeshes()
  

#define cc_Mesh_subMeshCount_get(self_) self_->getSubMeshCount()
  

#define cc_Mesh__nativeAsset_get(self_) self_->getAssetData()
#define cc_Mesh__nativeAsset_set(self_, val_) self_->setAssetData(val_)
  

#define cc_Mesh__allowDataAccess_get(self_) self_->isAllowDataAccess()
#define cc_Mesh__allowDataAccess_set(self_, val_) self_->setAllowDataAccess(val_)
  

#define cc_Mesh_allowDataAccess_get(self_) self_->isAllowDataAccess()
#define cc_Mesh_allowDataAccess_set(self_, val_) self_->setAllowDataAccess(val_)
  

#define cc_Material_effectAsset_get(self_) self_->getEffectAsset()
#define cc_Material_effectAsset_set(self_, val_) self_->setEffectAsset(val_)
  

#define cc_Material_effectName_get(self_) self_->getEffectName()
  

#define cc_Material_technique_get(self_) self_->getTechniqueIndex()
  

#define cc_Material_hash_get(self_) self_->getHash()
  

#define cc_Material_parent_get(self_) self_->getParent()
  

#define cc_RenderingSubMesh_mesh_get(self_) self_->getMesh()
#define cc_RenderingSubMesh_mesh_set(self_, val_) self_->setMesh(val_)
  

#define cc_RenderingSubMesh_subMeshIdx_get(self_) self_->getSubMeshIdx()
#define cc_RenderingSubMesh_subMeshIdx_set(self_, val_) self_->setSubMeshIdx(val_)
  

#define cc_RenderingSubMesh_flatBuffers_get(self_) self_->getFlatBuffers()
#define cc_RenderingSubMesh_flatBuffers_set(self_, val_) self_->setFlatBuffers(val_)
  

#define cc_RenderingSubMesh__flatBuffers_get(self_) self_->getFlatBuffers()
#define cc_RenderingSubMesh__flatBuffers_set(self_, val_) self_->setFlatBuffers(val_)
  

#define cc_RenderingSubMesh_jointMappedBuffers_get(self_) self_->getJointMappedBuffers()
  

#define cc_RenderingSubMesh_iaInfo_get(self_) self_->getIaInfo()
  

#define cc_RenderingSubMesh__iaInfo_get(self_) self_->getIaInfo()
  

#define cc_RenderingSubMesh_primitiveMode_get(self_) self_->getPrimitiveMode()
  

#define cc_Skeleton_joints_get(self_) self_->getJoints()
#define cc_Skeleton_joints_set(self_, val_) self_->setJoints(val_)
  

#define cc_Skeleton__joints_get(self_) self_->getJoints()
#define cc_Skeleton__joints_set(self_, val_) self_->setJoints(val_)
  

#define cc_Skeleton_hash_get(self_) self_->getHash()
#define cc_Skeleton_hash_set(self_, val_) self_->setHash(val_)
  

#define cc_Skeleton__hash_get(self_) self_->getHash()
#define cc_Skeleton__hash_set(self_, val_) self_->setHash(val_)
  

#define cc_Skeleton__invBindposes_get(self_) self_->getInverseBindposes()
  

#define cc_Skeleton_inverseBindposes_get(self_) self_->getInverseBindposes()
  

#define cc_EffectAsset_techniques_get(self_) self_->getTechniques()
#define cc_EffectAsset_techniques_set(self_, val_) self_->setTechniques(val_)
  

#define cc_EffectAsset_shaders_get(self_) self_->getShaders()
#define cc_EffectAsset_shaders_set(self_, val_) self_->setShaders(val_)
  

#define cc_EffectAsset_combinations_get(self_) self_->getCombinations()
#define cc_EffectAsset_combinations_set(self_, val_) self_->setCombinations(val_)
  


se::Class* __jsb_cc_Error_class = nullptr;
se::Object* __jsb_cc_Error_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Error) 

static bool js_cc_Error_msg_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Error *arg1 = (cc::Error *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Error>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->msg, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Error_msg_set) 

static bool js_cc_Error_msg_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Error *arg1 = (cc::Error *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Error>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->msg, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->msg, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Error_msg_get) 

static bool js_new_cc_Error(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::Error *result;
    result = (cc::Error *)new cc::Error();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Error, __jsb_cc_Error_class, js_delete_cc_Error)

static bool js_delete_cc_Error(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Error) 

template<>
bool sevalue_to_native(const se::Value &from, cc::Error * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::Error*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("msg", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->msg), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_Error(se::Object* obj) {
    auto* cls = se::Class::create("Error", obj, nullptr, _SE(js_new_cc_Error)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("msg", _SE(js_cc_Error_msg_get), _SE(js_cc_Error_msg_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Error));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Error>(cls);
    
    __jsb_cc_Error_proto = cls->getProto();
    __jsb_cc_Error_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_BoundingBox_class = nullptr;
se::Object* __jsb_cc_BoundingBox_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_BoundingBox) 

static bool js_cc_BoundingBox_min_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BoundingBox *arg1 = (cc::BoundingBox *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BoundingBox>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->min, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BoundingBox_min_set) 

static bool js_cc_BoundingBox_min_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BoundingBox *arg1 = (cc::BoundingBox *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BoundingBox>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->min, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->min, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BoundingBox_min_get) 

static bool js_cc_BoundingBox_max_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BoundingBox *arg1 = (cc::BoundingBox *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BoundingBox>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->max, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BoundingBox_max_set) 

static bool js_cc_BoundingBox_max_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BoundingBox *arg1 = (cc::BoundingBox *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BoundingBox>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->max, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->max, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BoundingBox_max_get) 

static bool js_new_cc_BoundingBox(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::BoundingBox *result;
    result = (cc::BoundingBox *)new cc::BoundingBox();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_BoundingBox, __jsb_cc_BoundingBox_class, js_delete_cc_BoundingBox)

static bool js_delete_cc_BoundingBox(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_BoundingBox) 

template<>
bool sevalue_to_native(const se::Value &from, cc::BoundingBox * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::BoundingBox*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("min", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->min), ctx);
    }
    
    
    json->getProperty("max", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->max), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_BoundingBox(se::Object* obj) {
    auto* cls = se::Class::create("BoundingBox", obj, nullptr, _SE(js_new_cc_BoundingBox)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("min", _SE(js_cc_BoundingBox_min_get), _SE(js_cc_BoundingBox_min_set)); 
    cls->defineProperty("max", _SE(js_cc_BoundingBox_max_get), _SE(js_cc_BoundingBox_max_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_BoundingBox));
    
    
    cls->install();
    JSBClassType::registerClass<cc::BoundingBox>(cls);
    
    __jsb_cc_BoundingBox_proto = cls->getProto();
    __jsb_cc_BoundingBox_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_VertexIdChannel_class = nullptr;
se::Object* __jsb_cc_VertexIdChannel_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_VertexIdChannel) 

static bool js_cc_VertexIdChannel_stream_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::VertexIdChannel *arg1 = (cc::VertexIdChannel *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::VertexIdChannel>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stream, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_VertexIdChannel_stream_set) 

static bool js_cc_VertexIdChannel_stream_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::VertexIdChannel *arg1 = (cc::VertexIdChannel *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::VertexIdChannel>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stream, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_VertexIdChannel_stream_get) 

static bool js_cc_VertexIdChannel_index_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::VertexIdChannel *arg1 = (cc::VertexIdChannel *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::VertexIdChannel>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->index, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_VertexIdChannel_index_set) 

static bool js_cc_VertexIdChannel_index_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::VertexIdChannel *arg1 = (cc::VertexIdChannel *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::VertexIdChannel>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->index, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_VertexIdChannel_index_get) 

static bool js_new_cc_VertexIdChannel(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::VertexIdChannel *result;
    result = (cc::VertexIdChannel *)new cc::VertexIdChannel();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_VertexIdChannel, __jsb_cc_VertexIdChannel_class, js_delete_cc_VertexIdChannel)

static bool js_delete_cc_VertexIdChannel(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_VertexIdChannel) 

template<>
bool sevalue_to_native(const se::Value &from, cc::VertexIdChannel * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::VertexIdChannel*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("stream", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stream), ctx);
    }
    
    
    json->getProperty("index", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->index), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_VertexIdChannel(se::Object* obj) {
    auto* cls = se::Class::create("VertexIdChannel", obj, nullptr, _SE(js_new_cc_VertexIdChannel)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("stream", _SE(js_cc_VertexIdChannel_stream_get), _SE(js_cc_VertexIdChannel_stream_set)); 
    cls->defineProperty("index", _SE(js_cc_VertexIdChannel_index_get), _SE(js_cc_VertexIdChannel_index_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_VertexIdChannel));
    
    
    cls->install();
    JSBClassType::registerClass<cc::VertexIdChannel>(cls);
    
    __jsb_cc_VertexIdChannel_proto = cls->getProto();
    __jsb_cc_VertexIdChannel_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_NativeDep_class = nullptr;
se::Object* __jsb_cc_NativeDep_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_NativeDep) 

static bool js_cc_NativeDep_uuid_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::NativeDep *arg1 = (cc::NativeDep *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::NativeDep>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->uuid, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_NativeDep_uuid_set) 

static bool js_cc_NativeDep_uuid_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::NativeDep *arg1 = (cc::NativeDep *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::NativeDep>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->uuid, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->uuid, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_NativeDep_uuid_get) 

static bool js_cc_NativeDep_ext_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::NativeDep *arg1 = (cc::NativeDep *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::NativeDep>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->ext, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_NativeDep_ext_set) 

static bool js_cc_NativeDep_ext_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::NativeDep *arg1 = (cc::NativeDep *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::NativeDep>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->ext, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->ext, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_NativeDep_ext_get) 

static bool js_cc_NativeDep___isNative___set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::NativeDep *arg1 = (cc::NativeDep *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::NativeDep>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->__isNative__);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_NativeDep___isNative___set) 

static bool js_cc_NativeDep___isNative___get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::NativeDep *arg1 = (cc::NativeDep *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::NativeDep>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->__isNative__, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_NativeDep___isNative___get) 

static bool js_new_cc_NativeDep__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::NativeDep *result;
    result = (cc::NativeDep *)new cc::NativeDep();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_NativeDep__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    bool arg1 ;
    ccstd::string arg2 ;
    ccstd::string arg3 ;
    cc::NativeDep *result;
    
    ok &= sevalue_to_native(args[0], &arg1);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = (cc::NativeDep *)new cc::NativeDep(arg1,arg2,arg3);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_NativeDep(se::State& s) // NOLINT(readability-identifier-naming)
{
    size_t argc = s.args().size();
    bool ret = false;
    
    if(argc == 0) {
        ret = js_new_cc_NativeDep__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 3) {
        ret = js_new_cc_NativeDep__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    SE_REPORT_ERROR("Illegal arguments for construction of NativeDep");
    return false;
}
SE_BIND_CTOR(js_new_NativeDep, __jsb_cc_NativeDep_class, js_delete_cc_NativeDep)

static bool js_cc_NativeDep_isValid(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::NativeDep *arg1 = (cc::NativeDep *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::NativeDep>(s);
    if (nullptr == arg1) return true;
    result = (bool)((cc::NativeDep const *)arg1)->isValid();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_NativeDep_isValid) 

static bool js_delete_cc_NativeDep(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_NativeDep) 

template<>
bool sevalue_to_native(const se::Value &from, cc::NativeDep * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::NativeDep*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("uuid", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->uuid), ctx);
    }
    
    
    json->getProperty("ext", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->ext), ctx);
    }
    
    
    json->getProperty("__isNative__", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->__isNative__), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_NativeDep(se::Object* obj) {
    auto* cls = se::Class::create("NativeDep", obj, nullptr, _SE(js_new_NativeDep)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("uuid", _SE(js_cc_NativeDep_uuid_get), _SE(js_cc_NativeDep_uuid_set)); 
    cls->defineProperty("ext", _SE(js_cc_NativeDep_ext_get), _SE(js_cc_NativeDep_ext_set)); 
    cls->defineProperty("__isNative__", _SE(js_cc_NativeDep___isNative___get), _SE(js_cc_NativeDep___isNative___set)); 
    
    cls->defineFunction("isValid", _SE(js_cc_NativeDep_isValid)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_NativeDep));
    
    
    cls->install();
    JSBClassType::registerClass<cc::NativeDep>(cls);
    
    __jsb_cc_NativeDep_proto = cls->getProto();
    __jsb_cc_NativeDep_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IGeometryOptions_class = nullptr;
se::Object* __jsb_cc_IGeometryOptions_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IGeometryOptions) 

static bool js_cc_IGeometryOptions_includeNormal_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometryOptions *arg1 = (cc::IGeometryOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometryOptions>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->includeNormal);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometryOptions_includeNormal_set) 

static bool js_cc_IGeometryOptions_includeNormal_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometryOptions *arg1 = (cc::IGeometryOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometryOptions>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->includeNormal, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometryOptions_includeNormal_get) 

static bool js_cc_IGeometryOptions_includeUV_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometryOptions *arg1 = (cc::IGeometryOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometryOptions>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->includeUV);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometryOptions_includeUV_set) 

static bool js_cc_IGeometryOptions_includeUV_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometryOptions *arg1 = (cc::IGeometryOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometryOptions>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->includeUV, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometryOptions_includeUV_get) 

static bool js_new_cc_IGeometryOptions(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IGeometryOptions *result;
    result = (cc::IGeometryOptions *)new cc::IGeometryOptions();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IGeometryOptions, __jsb_cc_IGeometryOptions_class, js_delete_cc_IGeometryOptions)

static bool js_delete_cc_IGeometryOptions(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IGeometryOptions) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IGeometryOptions * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IGeometryOptions*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("includeNormal", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->includeNormal), ctx);
    }
    
    
    json->getProperty("includeUV", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->includeUV), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IGeometryOptions(se::Object* obj) {
    auto* cls = se::Class::create("IGeometryOptions", obj, nullptr, _SE(js_new_cc_IGeometryOptions)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("includeNormal", _SE(js_cc_IGeometryOptions_includeNormal_get), _SE(js_cc_IGeometryOptions_includeNormal_set)); 
    cls->defineProperty("includeUV", _SE(js_cc_IGeometryOptions_includeUV_get), _SE(js_cc_IGeometryOptions_includeUV_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IGeometryOptions));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IGeometryOptions>(cls);
    
    __jsb_cc_IGeometryOptions_proto = cls->getProto();
    __jsb_cc_IGeometryOptions_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_CustomAttribute_class = nullptr;
se::Object* __jsb_cc_CustomAttribute_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_CustomAttribute) 

static bool js_cc_CustomAttribute_attr_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::CustomAttribute *arg1 = (cc::CustomAttribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CustomAttribute>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->attr, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_CustomAttribute_attr_set) 

static bool js_cc_CustomAttribute_attr_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::CustomAttribute *arg1 = (cc::CustomAttribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CustomAttribute>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->attr, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->attr, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_CustomAttribute_attr_get) 

static bool js_cc_CustomAttribute_values_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::CustomAttribute *arg1 = (cc::CustomAttribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CustomAttribute>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->values, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_CustomAttribute_values_set) 

static bool js_cc_CustomAttribute_values_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::CustomAttribute *arg1 = (cc::CustomAttribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CustomAttribute>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->values, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->values, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_CustomAttribute_values_get) 

static bool js_new_cc_CustomAttribute(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::CustomAttribute *result;
    result = (cc::CustomAttribute *)new cc::CustomAttribute();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_CustomAttribute, __jsb_cc_CustomAttribute_class, js_delete_cc_CustomAttribute)

static bool js_delete_cc_CustomAttribute(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_CustomAttribute) 

template<>
bool sevalue_to_native(const se::Value &from, cc::CustomAttribute * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::CustomAttribute*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("attr", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->attr), ctx);
    }
    
    
    json->getProperty("values", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->values), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_CustomAttribute(se::Object* obj) {
    auto* cls = se::Class::create("CustomAttribute", obj, nullptr, _SE(js_new_cc_CustomAttribute)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("attr", _SE(js_cc_CustomAttribute_attr_get), _SE(js_cc_CustomAttribute_attr_set)); 
    cls->defineProperty("values", _SE(js_cc_CustomAttribute_values_get), _SE(js_cc_CustomAttribute_values_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_CustomAttribute));
    
    
    cls->install();
    JSBClassType::registerClass<cc::CustomAttribute>(cls);
    
    __jsb_cc_CustomAttribute_proto = cls->getProto();
    __jsb_cc_CustomAttribute_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IGeometry_class = nullptr;
se::Object* __jsb_cc_IGeometry_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IGeometry) 

static bool js_cc_IGeometry_positions_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->positions, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometry_positions_set) 

static bool js_cc_IGeometry_positions_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->positions, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->positions, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometry_positions_get) 

static bool js_cc_IGeometry_normals_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->normals, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometry_normals_set) 

static bool js_cc_IGeometry_normals_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->normals, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->normals, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometry_normals_get) 

static bool js_cc_IGeometry_uvs_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->uvs, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometry_uvs_set) 

static bool js_cc_IGeometry_uvs_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->uvs, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->uvs, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometry_uvs_get) 

static bool js_cc_IGeometry_tangents_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->tangents, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometry_tangents_set) 

static bool js_cc_IGeometry_tangents_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->tangents, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->tangents, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometry_tangents_get) 

static bool js_cc_IGeometry_colors_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->colors, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometry_colors_set) 

static bool js_cc_IGeometry_colors_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->colors, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->colors, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometry_colors_get) 

static bool js_cc_IGeometry_attributes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->attributes, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometry_attributes_set) 

static bool js_cc_IGeometry_attributes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->attributes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->attributes, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometry_attributes_get) 

static bool js_cc_IGeometry_customAttributes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->customAttributes, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometry_customAttributes_set) 

static bool js_cc_IGeometry_customAttributes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->customAttributes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->customAttributes, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometry_customAttributes_get) 

static bool js_cc_IGeometry_boundingRadius_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->boundingRadius, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometry_boundingRadius_set) 

static bool js_cc_IGeometry_boundingRadius_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->boundingRadius, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->boundingRadius, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometry_boundingRadius_get) 

static bool js_cc_IGeometry_minPos_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->minPos, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometry_minPos_set) 

static bool js_cc_IGeometry_minPos_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->minPos, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->minPos, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometry_minPos_get) 

static bool js_cc_IGeometry_maxPos_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxPos, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometry_maxPos_set) 

static bool js_cc_IGeometry_maxPos_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxPos, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxPos, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometry_maxPos_get) 

static bool js_cc_IGeometry_indices_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->indices, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometry_indices_set) 

static bool js_cc_IGeometry_indices_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->indices, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->indices, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometry_indices_get) 

static bool js_cc_IGeometry_primitiveMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->primitiveMode, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometry_primitiveMode_set) 

static bool js_cc_IGeometry_primitiveMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->primitiveMode, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->primitiveMode, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometry_primitiveMode_get) 

static bool js_cc_IGeometry_doubleSided_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->doubleSided, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometry_doubleSided_set) 

static bool js_cc_IGeometry_doubleSided_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometry *arg1 = (cc::IGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->doubleSided, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->doubleSided, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometry_doubleSided_get) 

static bool js_new_cc_IGeometry(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IGeometry *result;
    result = (cc::IGeometry *)new cc::IGeometry();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IGeometry, __jsb_cc_IGeometry_class, js_delete_cc_IGeometry)

static bool js_delete_cc_IGeometry(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IGeometry) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IGeometry * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IGeometry*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("positions", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->positions), ctx);
    }
    
    
    json->getProperty("normals", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->normals), ctx);
    }
    
    
    json->getProperty("uvs", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->uvs), ctx);
    }
    
    
    json->getProperty("tangents", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->tangents), ctx);
    }
    
    
    json->getProperty("colors", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->colors), ctx);
    }
    
    
    json->getProperty("attributes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->attributes), ctx);
    }
    
    
    json->getProperty("customAttributes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->customAttributes), ctx);
    }
    
    
    json->getProperty("boundingRadius", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->boundingRadius), ctx);
    }
    
    
    json->getProperty("minPos", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->minPos), ctx);
    }
    
    
    json->getProperty("maxPos", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxPos), ctx);
    }
    
    
    json->getProperty("indices", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->indices), ctx);
    }
    
    
    json->getProperty("primitiveMode", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->primitiveMode), ctx);
    }
    
    
    json->getProperty("doubleSided", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->doubleSided), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IGeometry(se::Object* obj) {
    auto* cls = se::Class::create("IGeometry", obj, nullptr, _SE(js_new_cc_IGeometry)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("positions", _SE(js_cc_IGeometry_positions_get), _SE(js_cc_IGeometry_positions_set)); 
    cls->defineProperty("normals", _SE(js_cc_IGeometry_normals_get), _SE(js_cc_IGeometry_normals_set)); 
    cls->defineProperty("uvs", _SE(js_cc_IGeometry_uvs_get), _SE(js_cc_IGeometry_uvs_set)); 
    cls->defineProperty("tangents", _SE(js_cc_IGeometry_tangents_get), _SE(js_cc_IGeometry_tangents_set)); 
    cls->defineProperty("colors", _SE(js_cc_IGeometry_colors_get), _SE(js_cc_IGeometry_colors_set)); 
    cls->defineProperty("attributes", _SE(js_cc_IGeometry_attributes_get), _SE(js_cc_IGeometry_attributes_set)); 
    cls->defineProperty("customAttributes", _SE(js_cc_IGeometry_customAttributes_get), _SE(js_cc_IGeometry_customAttributes_set)); 
    cls->defineProperty("boundingRadius", _SE(js_cc_IGeometry_boundingRadius_get), _SE(js_cc_IGeometry_boundingRadius_set)); 
    cls->defineProperty("minPos", _SE(js_cc_IGeometry_minPos_get), _SE(js_cc_IGeometry_minPos_set)); 
    cls->defineProperty("maxPos", _SE(js_cc_IGeometry_maxPos_get), _SE(js_cc_IGeometry_maxPos_set)); 
    cls->defineProperty("indices", _SE(js_cc_IGeometry_indices_get), _SE(js_cc_IGeometry_indices_set)); 
    cls->defineProperty("primitiveMode", _SE(js_cc_IGeometry_primitiveMode_get), _SE(js_cc_IGeometry_primitiveMode_set)); 
    cls->defineProperty("doubleSided", _SE(js_cc_IGeometry_doubleSided_get), _SE(js_cc_IGeometry_doubleSided_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IGeometry));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IGeometry>(cls);
    
    __jsb_cc_IGeometry_proto = cls->getProto();
    __jsb_cc_IGeometry_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_DynamicCustomAttribute_class = nullptr;
se::Object* __jsb_cc_DynamicCustomAttribute_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_DynamicCustomAttribute) 

static bool js_cc_DynamicCustomAttribute_attr_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DynamicCustomAttribute *arg1 = (cc::DynamicCustomAttribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DynamicCustomAttribute>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->attr, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DynamicCustomAttribute_attr_set) 

static bool js_cc_DynamicCustomAttribute_attr_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DynamicCustomAttribute *arg1 = (cc::DynamicCustomAttribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DynamicCustomAttribute>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->attr, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->attr, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DynamicCustomAttribute_attr_get) 

static bool js_cc_DynamicCustomAttribute_values_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DynamicCustomAttribute *arg1 = (cc::DynamicCustomAttribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DynamicCustomAttribute>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->values, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DynamicCustomAttribute_values_set) 

static bool js_cc_DynamicCustomAttribute_values_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DynamicCustomAttribute *arg1 = (cc::DynamicCustomAttribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DynamicCustomAttribute>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->values, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->values, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DynamicCustomAttribute_values_get) 

static bool js_new_cc_DynamicCustomAttribute(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::DynamicCustomAttribute *result;
    result = (cc::DynamicCustomAttribute *)new cc::DynamicCustomAttribute();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_DynamicCustomAttribute, __jsb_cc_DynamicCustomAttribute_class, js_delete_cc_DynamicCustomAttribute)

static bool js_delete_cc_DynamicCustomAttribute(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_DynamicCustomAttribute) 

template<>
bool sevalue_to_native(const se::Value &from, cc::DynamicCustomAttribute * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::DynamicCustomAttribute*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("attr", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->attr), ctx);
    }
    
    
    json->getProperty("values", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->values), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_DynamicCustomAttribute(se::Object* obj) {
    auto* cls = se::Class::create("DynamicCustomAttribute", obj, nullptr, _SE(js_new_cc_DynamicCustomAttribute)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("attr", _SE(js_cc_DynamicCustomAttribute_attr_get), _SE(js_cc_DynamicCustomAttribute_attr_set)); 
    cls->defineProperty("values", _SE(js_cc_DynamicCustomAttribute_values_get), _SE(js_cc_DynamicCustomAttribute_values_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_DynamicCustomAttribute));
    
    
    cls->install();
    JSBClassType::registerClass<cc::DynamicCustomAttribute>(cls);
    
    __jsb_cc_DynamicCustomAttribute_proto = cls->getProto();
    __jsb_cc_DynamicCustomAttribute_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IDynamicGeometry_class = nullptr;
se::Object* __jsb_cc_IDynamicGeometry_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IDynamicGeometry) 

static bool js_cc_IDynamicGeometry_positions_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->positions, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDynamicGeometry_positions_set) 

static bool js_cc_IDynamicGeometry_positions_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->positions, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->positions, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDynamicGeometry_positions_get) 

static bool js_cc_IDynamicGeometry_normals_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->normals, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDynamicGeometry_normals_set) 

static bool js_cc_IDynamicGeometry_normals_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->normals, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->normals, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDynamicGeometry_normals_get) 

static bool js_cc_IDynamicGeometry_uvs_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->uvs, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDynamicGeometry_uvs_set) 

static bool js_cc_IDynamicGeometry_uvs_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->uvs, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->uvs, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDynamicGeometry_uvs_get) 

static bool js_cc_IDynamicGeometry_tangents_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->tangents, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDynamicGeometry_tangents_set) 

static bool js_cc_IDynamicGeometry_tangents_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->tangents, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->tangents, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDynamicGeometry_tangents_get) 

static bool js_cc_IDynamicGeometry_colors_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->colors, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDynamicGeometry_colors_set) 

static bool js_cc_IDynamicGeometry_colors_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->colors, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->colors, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDynamicGeometry_colors_get) 

static bool js_cc_IDynamicGeometry_customAttributes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->customAttributes, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDynamicGeometry_customAttributes_set) 

static bool js_cc_IDynamicGeometry_customAttributes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->customAttributes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->customAttributes, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDynamicGeometry_customAttributes_get) 

static bool js_cc_IDynamicGeometry_minPos_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->minPos, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDynamicGeometry_minPos_set) 

static bool js_cc_IDynamicGeometry_minPos_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->minPos, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->minPos, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDynamicGeometry_minPos_get) 

static bool js_cc_IDynamicGeometry_maxPos_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxPos, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDynamicGeometry_maxPos_set) 

static bool js_cc_IDynamicGeometry_maxPos_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxPos, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxPos, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDynamicGeometry_maxPos_get) 

static bool js_cc_IDynamicGeometry_indices16_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->indices16, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDynamicGeometry_indices16_set) 

static bool js_cc_IDynamicGeometry_indices16_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->indices16, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->indices16, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDynamicGeometry_indices16_get) 

static bool js_cc_IDynamicGeometry_indices32_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->indices32, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDynamicGeometry_indices32_set) 

static bool js_cc_IDynamicGeometry_indices32_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->indices32, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->indices32, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDynamicGeometry_indices32_get) 

static bool js_cc_IDynamicGeometry_primitiveMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->primitiveMode, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDynamicGeometry_primitiveMode_set) 

static bool js_cc_IDynamicGeometry_primitiveMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->primitiveMode, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->primitiveMode, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDynamicGeometry_primitiveMode_get) 

static bool js_cc_IDynamicGeometry_doubleSided_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->doubleSided, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDynamicGeometry_doubleSided_set) 

static bool js_cc_IDynamicGeometry_doubleSided_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDynamicGeometry *arg1 = (cc::IDynamicGeometry *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDynamicGeometry>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->doubleSided, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->doubleSided, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDynamicGeometry_doubleSided_get) 

static bool js_new_cc_IDynamicGeometry(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IDynamicGeometry *result;
    result = (cc::IDynamicGeometry *)new cc::IDynamicGeometry();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IDynamicGeometry, __jsb_cc_IDynamicGeometry_class, js_delete_cc_IDynamicGeometry)

static bool js_delete_cc_IDynamicGeometry(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IDynamicGeometry) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IDynamicGeometry * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IDynamicGeometry*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("positions", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->positions), ctx);
    }
    
    
    json->getProperty("normals", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->normals), ctx);
    }
    
    
    json->getProperty("uvs", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->uvs), ctx);
    }
    
    
    json->getProperty("tangents", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->tangents), ctx);
    }
    
    
    json->getProperty("colors", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->colors), ctx);
    }
    
    
    json->getProperty("customAttributes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->customAttributes), ctx);
    }
    
    
    json->getProperty("minPos", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->minPos), ctx);
    }
    
    
    json->getProperty("maxPos", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxPos), ctx);
    }
    
    
    json->getProperty("indices16", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->indices16), ctx);
    }
    
    
    json->getProperty("indices32", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->indices32), ctx);
    }
    
    
    json->getProperty("primitiveMode", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->primitiveMode), ctx);
    }
    
    
    json->getProperty("doubleSided", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->doubleSided), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IDynamicGeometry(se::Object* obj) {
    auto* cls = se::Class::create("IDynamicGeometry", obj, nullptr, _SE(js_new_cc_IDynamicGeometry)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("positions", _SE(js_cc_IDynamicGeometry_positions_get), _SE(js_cc_IDynamicGeometry_positions_set)); 
    cls->defineProperty("normals", _SE(js_cc_IDynamicGeometry_normals_get), _SE(js_cc_IDynamicGeometry_normals_set)); 
    cls->defineProperty("uvs", _SE(js_cc_IDynamicGeometry_uvs_get), _SE(js_cc_IDynamicGeometry_uvs_set)); 
    cls->defineProperty("tangents", _SE(js_cc_IDynamicGeometry_tangents_get), _SE(js_cc_IDynamicGeometry_tangents_set)); 
    cls->defineProperty("colors", _SE(js_cc_IDynamicGeometry_colors_get), _SE(js_cc_IDynamicGeometry_colors_set)); 
    cls->defineProperty("customAttributes", _SE(js_cc_IDynamicGeometry_customAttributes_get), _SE(js_cc_IDynamicGeometry_customAttributes_set)); 
    cls->defineProperty("minPos", _SE(js_cc_IDynamicGeometry_minPos_get), _SE(js_cc_IDynamicGeometry_minPos_set)); 
    cls->defineProperty("maxPos", _SE(js_cc_IDynamicGeometry_maxPos_get), _SE(js_cc_IDynamicGeometry_maxPos_set)); 
    cls->defineProperty("indices16", _SE(js_cc_IDynamicGeometry_indices16_get), _SE(js_cc_IDynamicGeometry_indices16_set)); 
    cls->defineProperty("indices32", _SE(js_cc_IDynamicGeometry_indices32_get), _SE(js_cc_IDynamicGeometry_indices32_set)); 
    cls->defineProperty("primitiveMode", _SE(js_cc_IDynamicGeometry_primitiveMode_get), _SE(js_cc_IDynamicGeometry_primitiveMode_set)); 
    cls->defineProperty("doubleSided", _SE(js_cc_IDynamicGeometry_doubleSided_get), _SE(js_cc_IDynamicGeometry_doubleSided_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IDynamicGeometry));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IDynamicGeometry>(cls);
    
    __jsb_cc_IDynamicGeometry_proto = cls->getProto();
    __jsb_cc_IDynamicGeometry_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Asset_class = nullptr;
se::Object* __jsb_cc_Asset_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Asset) 

static bool js_new_cc_Asset(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::Asset *result;
    result = (cc::Asset *)new cc::Asset();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Asset, __jsb_cc_Asset_class, js_delete_cc_Asset)

static bool js_delete_cc_Asset(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Asset) 

static bool js_cc_Asset_getNativeAsset(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    ccstd::any result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    if (nullptr == arg1) return true;
    result = ((cc::Asset const *)arg1)->getNativeAsset();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Asset_getNativeAsset) 

static bool js_cc_Asset_setNativeAsset(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    ccstd::any *arg2 = 0 ;
    ccstd::any temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setNativeAsset((ccstd::any const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Asset_setNativeAsset) 

static bool js_cc_Asset_addAssetRef(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    if (nullptr == arg1) return true;
    (arg1)->addAssetRef();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Asset_addAssetRef) 

static bool js_cc_Asset_decAssetRef__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->decAssetRef(arg2);
    
    
    return true;
}

static bool js_cc_Asset_decAssetRef__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    if (nullptr == arg1) return true;
    (arg1)->decAssetRef();
    
    
    return true;
}

static bool js_cc_Asset_decAssetRef(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_cc_Asset_decAssetRef__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 0) {
        ok = js_cc_Asset_decAssetRef__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Asset_decAssetRef) 

static bool js_cc_Asset_getAssetRefCount(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    if (nullptr == arg1) return true;
    result = ((cc::Asset const *)arg1)->getAssetRefCount();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Asset_getAssetRefCount) 

static bool js_cc_Asset_onLoaded(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    if (nullptr == arg1) return true;
    (arg1)->onLoaded();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Asset_onLoaded) 

static bool js_cc_Asset_initDefault__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    if (nullptr == arg1) return true;
    (arg1)->initDefault();
    
    
    return true;
}

static bool js_cc_Asset_initDefault__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    ccstd::optional< ccstd::string > *arg2 = 0 ;
    ccstd::optional< ccstd::string > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->initDefault((ccstd::optional< ccstd::string > const &)*arg2);
    
    
    return true;
}

static bool js_cc_Asset_initDefault(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 0) {
        ok = js_cc_Asset_initDefault__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_Asset_initDefault__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Asset_initDefault) 

static bool js_cc_Asset_validate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    if (nullptr == arg1) return true;
    result = (bool)((cc::Asset const *)arg1)->validate();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Asset_validate) 

static bool js_cc_Asset_serialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    ccstd::any *arg2 = 0 ;
    ccstd::any temp2 ;
    ccstd::any result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (arg1)->serialize((ccstd::any const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Asset_serialize) 

static bool js_cc_Asset_deserialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    ccstd::any *arg2 = 0 ;
    ccstd::any *arg3 = 0 ;
    ccstd::any temp2 ;
    ccstd::any temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->deserialize((ccstd::any const &)*arg2,(ccstd::any const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Asset_deserialize) 

static bool js_cc_Asset__native_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_native, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Asset__native_set) 

static bool js_cc_Asset__native_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_native, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_native, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Asset__native_get) 

static bool js_cc_Asset__nativeUrl_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_nativeUrl, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Asset__nativeUrl_set) 

static bool js_cc_Asset__nativeUrl_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_nativeUrl, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_nativeUrl, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Asset__nativeUrl_get) 

static bool js_cc_Asset__uuid_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_Asset__uuid_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Asset__uuid_set) 

static bool js_cc_Asset__uuid_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    ccstd::string *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::string *) &cc_Asset__uuid_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Asset__uuid_get) 

static bool js_cc_Asset_nativeUrl_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    ccstd::string result;
    
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    if (nullptr == arg1) return true;
    result = cc_Asset_nativeUrl_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Asset_nativeUrl_get) 

static bool js_cc_Asset__nativeDep_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    cc::NativeDep result;
    
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    if (nullptr == arg1) return true;
    result = cc_Asset__nativeDep_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Asset__nativeDep_get) 

static bool js_cc_Asset_isDefault_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Asset *arg1 = (cc::Asset *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::Asset>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_Asset_isDefault_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Asset_isDefault_get) 

bool js_register_cc_Asset(se::Object* obj) {
    auto* cls = se::Class::create("Asset", obj, __jsb_cc_CCObject_proto, _SE(js_new_cc_Asset)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("_native", _SE(js_cc_Asset__native_get), _SE(js_cc_Asset__native_set)); 
    cls->defineProperty("_nativeUrl", _SE(js_cc_Asset__nativeUrl_get), _SE(js_cc_Asset__nativeUrl_set)); 
    cls->defineProperty("_uuid", _SE(js_cc_Asset__uuid_get), _SE(js_cc_Asset__uuid_set)); 
    cls->defineProperty("nativeUrl", _SE(js_cc_Asset_nativeUrl_get), nullptr); 
    cls->defineProperty("_nativeDep", _SE(js_cc_Asset__nativeDep_get), nullptr); 
    cls->defineProperty("isDefault", _SE(js_cc_Asset_isDefault_get), nullptr); 
    
    cls->defineFunction("getNativeAsset", _SE(js_cc_Asset_getNativeAsset)); 
    cls->defineFunction("setNativeAsset", _SE(js_cc_Asset_setNativeAsset)); 
    cls->defineFunction("addAssetRef", _SE(js_cc_Asset_addAssetRef)); 
    cls->defineFunction("decAssetRef", _SE(js_cc_Asset_decAssetRef)); 
    cls->defineFunction("getAssetRefCount", _SE(js_cc_Asset_getAssetRefCount)); 
    cls->defineFunction("onLoaded", _SE(js_cc_Asset_onLoaded)); 
    cls->defineFunction("initDefault", _SE(js_cc_Asset_initDefault)); 
    cls->defineFunction("validate", _SE(js_cc_Asset_validate)); 
    cls->defineFunction("serialize", _SE(js_cc_Asset_serialize)); 
    cls->defineFunction("deserialize", _SE(js_cc_Asset_deserialize)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Asset));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Asset>(cls);
    
    __jsb_cc_Asset_proto = cls->getProto();
    __jsb_cc_Asset_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_TextureBase_class = nullptr;
se::Object* __jsb_cc_TextureBase_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_TextureBase) 

static bool js_new_cc_TextureBase(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::TextureBase *result;
    result = (cc::TextureBase *)new cc::TextureBase();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_TextureBase, __jsb_cc_TextureBase_class, js_delete_cc_TextureBase)

static bool js_delete_cc_TextureBase(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_TextureBase) 

static bool js_cc_TextureBase_getId(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    ccstd::string *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::string *) &((cc::TextureBase const *)arg1)->getId();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureBase_getId) 

static bool js_cc_TextureBase_getPixelFormat(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    cc::TextureBase::PixelFormat result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    result = (cc::TextureBase::PixelFormat)((cc::TextureBase const *)arg1)->getPixelFormat();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureBase_getPixelFormat) 

static bool js_cc_TextureBase_getAnisotropy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    result = ((cc::TextureBase const *)arg1)->getAnisotropy();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureBase_getAnisotropy) 

static bool js_cc_TextureBase_setWrapMode__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    cc::TextureBase::WrapMode arg2 ;
    cc::TextureBase::WrapMode arg3 ;
    cc::TextureBase::WrapMode arg4 ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->setWrapMode(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_TextureBase_setWrapMode__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    cc::TextureBase::WrapMode arg2 ;
    cc::TextureBase::WrapMode arg3 ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->setWrapMode(arg2,arg3);
    
    
    return true;
}

static bool js_cc_TextureBase_setWrapMode(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_TextureBase_setWrapMode__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_TextureBase_setWrapMode__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_TextureBase_setWrapMode) 

static bool js_cc_TextureBase_setFilters(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    cc::TextureBase::Filter arg2 ;
    cc::TextureBase::Filter arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->setFilters(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureBase_setFilters) 

static bool js_cc_TextureBase_setMipFilter(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    cc::TextureBase::Filter arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->setMipFilter(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureBase_setMipFilter) 

static bool js_cc_TextureBase_setAnisotropy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setAnisotropy(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureBase_setAnisotropy) 

static bool js_cc_TextureBase_getHash(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    ccstd::hash_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    result = ((cc::TextureBase const *)arg1)->getHash();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureBase_getHash) 

static bool js_cc_TextureBase_getGFXTexture(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    cc::gfx::Texture *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Texture *)((cc::TextureBase const *)arg1)->getGFXTexture();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureBase_getGFXTexture) 

static bool js_cc_TextureBase_getSamplerInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    cc::gfx::SamplerInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::SamplerInfo *) &((cc::TextureBase const *)arg1)->getSamplerInfo();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureBase_getSamplerInfo) 

static bool js_cc_TextureBase_getGFXSampler(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    cc::gfx::Sampler *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Sampler *)((cc::TextureBase const *)arg1)->getGFXSampler();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureBase_getGFXSampler) 

static bool js_cc_TextureBase__format_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_format, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureBase__format_set) 

static bool js_cc_TextureBase__format_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_format, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_format, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureBase__format_get) 

static bool js_cc_TextureBase__minFilter_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_minFilter, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureBase__minFilter_set) 

static bool js_cc_TextureBase__minFilter_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_minFilter, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_minFilter, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureBase__minFilter_get) 

static bool js_cc_TextureBase__magFilter_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_magFilter, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureBase__magFilter_set) 

static bool js_cc_TextureBase__magFilter_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_magFilter, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_magFilter, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureBase__magFilter_get) 

static bool js_cc_TextureBase__mipFilter_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_mipFilter, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureBase__mipFilter_set) 

static bool js_cc_TextureBase__mipFilter_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_mipFilter, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_mipFilter, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureBase__mipFilter_get) 

static bool js_cc_TextureBase__wrapS_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_wrapS, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureBase__wrapS_set) 

static bool js_cc_TextureBase__wrapS_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_wrapS, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_wrapS, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureBase__wrapS_get) 

static bool js_cc_TextureBase__wrapT_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_wrapT, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureBase__wrapT_set) 

static bool js_cc_TextureBase__wrapT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_wrapT, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_wrapT, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureBase__wrapT_get) 

static bool js_cc_TextureBase__wrapR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_wrapR, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureBase__wrapR_set) 

static bool js_cc_TextureBase__wrapR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_wrapR, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_wrapR, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureBase__wrapR_get) 

static bool js_cc_TextureBase__anisotropy_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_anisotropy, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureBase__anisotropy_set) 

static bool js_cc_TextureBase__anisotropy_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_anisotropy, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureBase__anisotropy_get) 

static bool js_cc_TextureBase_isCompressed_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_TextureBase_isCompressed_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureBase_isCompressed_get) 

static bool js_cc_TextureBase__width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_TextureBase__width_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureBase__width_set) 

static bool js_cc_TextureBase__width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    result = cc_TextureBase__width_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureBase__width_get) 

static bool js_cc_TextureBase_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_TextureBase_width_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureBase_width_set) 

static bool js_cc_TextureBase_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    result = cc_TextureBase_width_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureBase_width_get) 

static bool js_cc_TextureBase__height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_TextureBase__height_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureBase__height_set) 

static bool js_cc_TextureBase__height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    result = cc_TextureBase__height_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureBase__height_get) 

static bool js_cc_TextureBase_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_TextureBase_height_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureBase_height_set) 

static bool js_cc_TextureBase_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureBase *arg1 = (cc::TextureBase *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::TextureBase>(s);
    if (nullptr == arg1) return true;
    result = cc_TextureBase_height_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureBase_height_get) 

bool js_register_cc_TextureBase(se::Object* obj) {
    auto* cls = se::Class::create("TextureBase", obj, __jsb_cc_Asset_proto, _SE(js_new_cc_TextureBase)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("_format", _SE(js_cc_TextureBase__format_get), _SE(js_cc_TextureBase__format_set)); 
    cls->defineProperty("_minFilter", _SE(js_cc_TextureBase__minFilter_get), _SE(js_cc_TextureBase__minFilter_set)); 
    cls->defineProperty("_magFilter", _SE(js_cc_TextureBase__magFilter_get), _SE(js_cc_TextureBase__magFilter_set)); 
    cls->defineProperty("_mipFilter", _SE(js_cc_TextureBase__mipFilter_get), _SE(js_cc_TextureBase__mipFilter_set)); 
    cls->defineProperty("_wrapS", _SE(js_cc_TextureBase__wrapS_get), _SE(js_cc_TextureBase__wrapS_set)); 
    cls->defineProperty("_wrapT", _SE(js_cc_TextureBase__wrapT_get), _SE(js_cc_TextureBase__wrapT_set)); 
    cls->defineProperty("_wrapR", _SE(js_cc_TextureBase__wrapR_get), _SE(js_cc_TextureBase__wrapR_set)); 
    cls->defineProperty("_anisotropy", _SE(js_cc_TextureBase__anisotropy_get), _SE(js_cc_TextureBase__anisotropy_set)); 
    cls->defineProperty("isCompressed", _SE(js_cc_TextureBase_isCompressed_get), nullptr); 
    cls->defineProperty("_width", _SE(js_cc_TextureBase__width_get), _SE(js_cc_TextureBase__width_set)); 
    cls->defineProperty("width", _SE(js_cc_TextureBase_width_get), _SE(js_cc_TextureBase_width_set)); 
    cls->defineProperty("_height", _SE(js_cc_TextureBase__height_get), _SE(js_cc_TextureBase__height_set)); 
    cls->defineProperty("height", _SE(js_cc_TextureBase_height_get), _SE(js_cc_TextureBase_height_set)); 
    
    cls->defineFunction("getId", _SE(js_cc_TextureBase_getId)); 
    cls->defineFunction("getPixelFormat", _SE(js_cc_TextureBase_getPixelFormat)); 
    cls->defineFunction("getAnisotropy", _SE(js_cc_TextureBase_getAnisotropy)); 
    cls->defineFunction("setWrapMode", _SE(js_cc_TextureBase_setWrapMode)); 
    cls->defineFunction("setFilters", _SE(js_cc_TextureBase_setFilters)); 
    cls->defineFunction("setMipFilter", _SE(js_cc_TextureBase_setMipFilter)); 
    cls->defineFunction("setAnisotropy", _SE(js_cc_TextureBase_setAnisotropy)); 
    cls->defineFunction("getHash", _SE(js_cc_TextureBase_getHash)); 
    cls->defineFunction("getGFXTexture", _SE(js_cc_TextureBase_getGFXTexture)); 
    cls->defineFunction("getSamplerInfo", _SE(js_cc_TextureBase_getSamplerInfo)); 
    cls->defineFunction("getGFXSampler", _SE(js_cc_TextureBase_getGFXSampler)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_TextureBase));
    
    
    cls->install();
    JSBClassType::registerClass<cc::TextureBase>(cls);
    
    __jsb_cc_TextureBase_proto = cls->getProto();
    __jsb_cc_TextureBase_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_SimpleTexture_class = nullptr;
se::Object* __jsb_cc_SimpleTexture_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_SimpleTexture) 

static bool js_delete_cc_SimpleTexture(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_SimpleTexture) 

static bool js_cc_SimpleTexture_updateImage(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SimpleTexture *arg1 = (cc::SimpleTexture *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SimpleTexture>(s);
    if (nullptr == arg1) return true;
    (arg1)->updateImage();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SimpleTexture_updateImage) 

static bool js_cc_SimpleTexture_updateMipmaps(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SimpleTexture *arg1 = (cc::SimpleTexture *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SimpleTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->updateMipmaps(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SimpleTexture_updateMipmaps) 

static bool js_cc_SimpleTexture_uploadData__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::SimpleTexture *arg1 = (cc::SimpleTexture *) NULL ;
    uint8_t *arg2 = (uint8_t *) NULL ;
    uint32_t arg3 ;
    uint32_t arg4 ;
    
    arg1 = SE_THIS_OBJECT<cc::SimpleTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->uploadData((uint8_t const *)arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_SimpleTexture_uploadData__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::SimpleTexture *arg1 = (cc::SimpleTexture *) NULL ;
    uint8_t *arg2 = (uint8_t *) NULL ;
    uint32_t arg3 ;
    
    arg1 = SE_THIS_OBJECT<cc::SimpleTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->uploadData((uint8_t const *)arg2,arg3);
    
    
    return true;
}

static bool js_cc_SimpleTexture_uploadData__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::SimpleTexture *arg1 = (cc::SimpleTexture *) NULL ;
    uint8_t *arg2 = (uint8_t *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::SimpleTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->uploadData((uint8_t const *)arg2);
    
    
    return true;
}

static bool js_cc_SimpleTexture_uploadData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_SimpleTexture_uploadData__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_SimpleTexture_uploadData__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_SimpleTexture_uploadData__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_SimpleTexture_uploadData) 

static bool js_cc_SimpleTexture_assignImage__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::SimpleTexture *arg1 = (cc::SimpleTexture *) NULL ;
    cc::ImageAsset *arg2 = (cc::ImageAsset *) NULL ;
    uint32_t arg3 ;
    uint32_t arg4 ;
    
    arg1 = SE_THIS_OBJECT<cc::SimpleTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->assignImage(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_SimpleTexture_assignImage__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::SimpleTexture *arg1 = (cc::SimpleTexture *) NULL ;
    cc::ImageAsset *arg2 = (cc::ImageAsset *) NULL ;
    uint32_t arg3 ;
    
    arg1 = SE_THIS_OBJECT<cc::SimpleTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->assignImage(arg2,arg3);
    
    
    return true;
}

static bool js_cc_SimpleTexture_assignImage(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_SimpleTexture_assignImage__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_SimpleTexture_assignImage__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_SimpleTexture_assignImage) 

static bool js_cc_SimpleTexture_checkTextureLoaded(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SimpleTexture *arg1 = (cc::SimpleTexture *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SimpleTexture>(s);
    if (nullptr == arg1) return true;
    (arg1)->checkTextureLoaded();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SimpleTexture_checkTextureLoaded) 

static bool js_cc_SimpleTexture_setMipmapLevel(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SimpleTexture *arg1 = (cc::SimpleTexture *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SimpleTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setMipmapLevel(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SimpleTexture_setMipmapLevel) 

static bool js_cc_SimpleTexture_setMipRange(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SimpleTexture *arg1 = (cc::SimpleTexture *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SimpleTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setMipRange(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SimpleTexture_setMipRange) 

static bool js_cc_SimpleTexture_isUsingOfflineMipmaps(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SimpleTexture *arg1 = (cc::SimpleTexture *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SimpleTexture>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->isUsingOfflineMipmaps();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SimpleTexture_isUsingOfflineMipmaps) 

static bool js_cc_SimpleTexture_mipmapLevel_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::SimpleTexture *arg1 = (cc::SimpleTexture *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::SimpleTexture>(s);
    if (nullptr == arg1) return true;
    result = cc_SimpleTexture_mipmapLevel_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_SimpleTexture_mipmapLevel_get) 

bool js_register_cc_SimpleTexture(se::Object* obj) {
    auto* cls = se::Class::create("SimpleTexture", obj, __jsb_cc_TextureBase_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("mipmapLevel", _SE(js_cc_SimpleTexture_mipmapLevel_get), nullptr); 
    
    cls->defineFunction("updateImage", _SE(js_cc_SimpleTexture_updateImage)); 
    cls->defineFunction("updateMipmaps", _SE(js_cc_SimpleTexture_updateMipmaps)); 
    cls->defineFunction("uploadData", _SE(js_cc_SimpleTexture_uploadData)); 
    cls->defineFunction("assignImage", _SE(js_cc_SimpleTexture_assignImage)); 
    cls->defineFunction("checkTextureLoaded", _SE(js_cc_SimpleTexture_checkTextureLoaded)); 
    cls->defineFunction("setMipmapLevel", _SE(js_cc_SimpleTexture_setMipmapLevel)); 
    cls->defineFunction("setMipRange", _SE(js_cc_SimpleTexture_setMipRange)); 
    cls->defineFunction("isUsingOfflineMipmaps", _SE(js_cc_SimpleTexture_isUsingOfflineMipmaps)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_SimpleTexture));
    
    
    cls->install();
    JSBClassType::registerClass<cc::SimpleTexture>(cls);
    
    __jsb_cc_SimpleTexture_proto = cls->getProto();
    __jsb_cc_SimpleTexture_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_ITexture2DSerializeData_class = nullptr;
se::Object* __jsb_cc_ITexture2DSerializeData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_ITexture2DSerializeData) 

static bool js_cc_ITexture2DSerializeData_base_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITexture2DSerializeData *arg1 = (cc::ITexture2DSerializeData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DSerializeData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->base, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITexture2DSerializeData_base_set) 

static bool js_cc_ITexture2DSerializeData_base_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITexture2DSerializeData *arg1 = (cc::ITexture2DSerializeData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DSerializeData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->base, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->base, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITexture2DSerializeData_base_get) 

static bool js_cc_ITexture2DSerializeData_mipmaps_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITexture2DSerializeData *arg1 = (cc::ITexture2DSerializeData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DSerializeData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->mipmaps, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITexture2DSerializeData_mipmaps_set) 

static bool js_cc_ITexture2DSerializeData_mipmaps_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITexture2DSerializeData *arg1 = (cc::ITexture2DSerializeData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DSerializeData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->mipmaps, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->mipmaps, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITexture2DSerializeData_mipmaps_get) 

static bool js_new_cc_ITexture2DSerializeData(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::ITexture2DSerializeData *result;
    result = (cc::ITexture2DSerializeData *)new cc::ITexture2DSerializeData();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_ITexture2DSerializeData, __jsb_cc_ITexture2DSerializeData_class, js_delete_cc_ITexture2DSerializeData)

static bool js_delete_cc_ITexture2DSerializeData(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_ITexture2DSerializeData) 

template<>
bool sevalue_to_native(const se::Value &from, cc::ITexture2DSerializeData * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::ITexture2DSerializeData*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("base", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->base), ctx);
    }
    
    
    json->getProperty("mipmaps", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->mipmaps), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_ITexture2DSerializeData(se::Object* obj) {
    auto* cls = se::Class::create("ITexture2DSerializeData", obj, nullptr, _SE(js_new_cc_ITexture2DSerializeData)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("base", _SE(js_cc_ITexture2DSerializeData_base_get), _SE(js_cc_ITexture2DSerializeData_base_set)); 
    cls->defineProperty("mipmaps", _SE(js_cc_ITexture2DSerializeData_mipmaps_get), _SE(js_cc_ITexture2DSerializeData_mipmaps_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_ITexture2DSerializeData));
    
    
    cls->install();
    JSBClassType::registerClass<cc::ITexture2DSerializeData>(cls);
    
    __jsb_cc_ITexture2DSerializeData_proto = cls->getProto();
    __jsb_cc_ITexture2DSerializeData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_ITexture2DCreateInfo_class = nullptr;
se::Object* __jsb_cc_ITexture2DCreateInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_ITexture2DCreateInfo) 

static bool js_cc_ITexture2DCreateInfo_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITexture2DCreateInfo *arg1 = (cc::ITexture2DCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DCreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->width, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITexture2DCreateInfo_width_set) 

static bool js_cc_ITexture2DCreateInfo_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITexture2DCreateInfo *arg1 = (cc::ITexture2DCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DCreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->width, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITexture2DCreateInfo_width_get) 

static bool js_cc_ITexture2DCreateInfo_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITexture2DCreateInfo *arg1 = (cc::ITexture2DCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DCreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->height, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITexture2DCreateInfo_height_set) 

static bool js_cc_ITexture2DCreateInfo_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITexture2DCreateInfo *arg1 = (cc::ITexture2DCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DCreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->height, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITexture2DCreateInfo_height_get) 

static bool js_cc_ITexture2DCreateInfo_format_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITexture2DCreateInfo *arg1 = (cc::ITexture2DCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DCreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->format, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITexture2DCreateInfo_format_set) 

static bool js_cc_ITexture2DCreateInfo_format_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITexture2DCreateInfo *arg1 = (cc::ITexture2DCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DCreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->format, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->format, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITexture2DCreateInfo_format_get) 

static bool js_cc_ITexture2DCreateInfo_mipmapLevel_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITexture2DCreateInfo *arg1 = (cc::ITexture2DCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DCreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->mipmapLevel, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITexture2DCreateInfo_mipmapLevel_set) 

static bool js_cc_ITexture2DCreateInfo_mipmapLevel_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITexture2DCreateInfo *arg1 = (cc::ITexture2DCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DCreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->mipmapLevel, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->mipmapLevel, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITexture2DCreateInfo_mipmapLevel_get) 

static bool js_cc_ITexture2DCreateInfo_baseLevel_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITexture2DCreateInfo *arg1 = (cc::ITexture2DCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DCreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->baseLevel, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITexture2DCreateInfo_baseLevel_set) 

static bool js_cc_ITexture2DCreateInfo_baseLevel_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITexture2DCreateInfo *arg1 = (cc::ITexture2DCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DCreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->baseLevel, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->baseLevel, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITexture2DCreateInfo_baseLevel_get) 

static bool js_cc_ITexture2DCreateInfo_maxLevel_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITexture2DCreateInfo *arg1 = (cc::ITexture2DCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DCreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxLevel, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITexture2DCreateInfo_maxLevel_set) 

static bool js_cc_ITexture2DCreateInfo_maxLevel_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITexture2DCreateInfo *arg1 = (cc::ITexture2DCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITexture2DCreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxLevel, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxLevel, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITexture2DCreateInfo_maxLevel_get) 

static bool js_new_cc_ITexture2DCreateInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::ITexture2DCreateInfo *result;
    result = (cc::ITexture2DCreateInfo *)new cc::ITexture2DCreateInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_ITexture2DCreateInfo, __jsb_cc_ITexture2DCreateInfo_class, js_delete_cc_ITexture2DCreateInfo)

static bool js_delete_cc_ITexture2DCreateInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_ITexture2DCreateInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::ITexture2DCreateInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::ITexture2DCreateInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("width", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->width), ctx);
    }
    
    
    json->getProperty("height", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->height), ctx);
    }
    
    
    json->getProperty("format", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->format), ctx);
    }
    
    
    json->getProperty("mipmapLevel", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->mipmapLevel), ctx);
    }
    
    
    json->getProperty("baseLevel", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->baseLevel), ctx);
    }
    
    
    json->getProperty("maxLevel", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxLevel), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_ITexture2DCreateInfo(se::Object* obj) {
    auto* cls = se::Class::create("ITexture2DCreateInfo", obj, nullptr, _SE(js_new_cc_ITexture2DCreateInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("width", _SE(js_cc_ITexture2DCreateInfo_width_get), _SE(js_cc_ITexture2DCreateInfo_width_set)); 
    cls->defineProperty("height", _SE(js_cc_ITexture2DCreateInfo_height_get), _SE(js_cc_ITexture2DCreateInfo_height_set)); 
    cls->defineProperty("format", _SE(js_cc_ITexture2DCreateInfo_format_get), _SE(js_cc_ITexture2DCreateInfo_format_set)); 
    cls->defineProperty("mipmapLevel", _SE(js_cc_ITexture2DCreateInfo_mipmapLevel_get), _SE(js_cc_ITexture2DCreateInfo_mipmapLevel_set)); 
    cls->defineProperty("baseLevel", _SE(js_cc_ITexture2DCreateInfo_baseLevel_get), _SE(js_cc_ITexture2DCreateInfo_baseLevel_set)); 
    cls->defineProperty("maxLevel", _SE(js_cc_ITexture2DCreateInfo_maxLevel_get), _SE(js_cc_ITexture2DCreateInfo_maxLevel_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_ITexture2DCreateInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::ITexture2DCreateInfo>(cls);
    
    __jsb_cc_ITexture2DCreateInfo_proto = cls->getProto();
    __jsb_cc_ITexture2DCreateInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Texture2D_class = nullptr;
se::Object* __jsb_cc_Texture2D_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Texture2D) 

static bool js_new_cc_Texture2D(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::Texture2D *result;
    result = (cc::Texture2D *)new cc::Texture2D();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Texture2D, __jsb_cc_Texture2D_class, js_delete_cc_Texture2D)

static bool js_delete_cc_Texture2D(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Texture2D) 

static bool js_cc_Texture2D_getMipmaps(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::ImageAsset > > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::IntrusivePtr< cc::ImageAsset > > *) &((cc::Texture2D const *)arg1)->getMipmaps();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Texture2D_getMipmaps) 

static bool js_cc_Texture2D_getMipmapsUuids(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    ccstd::vector< ccstd::string > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< ccstd::string > *) &((cc::Texture2D const *)arg1)->getMipmapsUuids();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Texture2D_getMipmapsUuids) 

static bool js_cc_Texture2D_syncMipmapsForJS(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::ImageAsset > > *arg2 = 0 ;
    ccstd::vector< cc::IntrusivePtr< cc::ImageAsset > > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->syncMipmapsForJS((ccstd::vector< cc::IntrusivePtr< cc::ImageAsset > > const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Texture2D_syncMipmapsForJS) 

static bool js_cc_Texture2D_setMipmaps(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::ImageAsset > > *arg2 = 0 ;
    ccstd::vector< cc::IntrusivePtr< cc::ImageAsset > > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setMipmaps((ccstd::vector< cc::IntrusivePtr< cc::ImageAsset > > const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Texture2D_setMipmaps) 

static bool js_cc_Texture2D_getImage(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    cc::ImageAsset *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    if (nullptr == arg1) return true;
    result = (cc::ImageAsset *)((cc::Texture2D const *)arg1)->getImage();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Texture2D_getImage) 

static bool js_cc_Texture2D_setImage(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    cc::ImageAsset *arg2 = (cc::ImageAsset *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setImage(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Texture2D_setImage) 

static bool js_cc_Texture2D_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    if (nullptr == arg1) return true;
    (arg1)->initialize();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Texture2D_initialize) 

static bool js_cc_Texture2D_reset(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    cc::ITexture2DCreateInfo *arg2 = 0 ;
    cc::ITexture2DCreateInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->reset((cc::ITexture2DCreateInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Texture2D_reset) 

static bool js_cc_Texture2D_create__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    cc::TextureBase::PixelFormat arg4 ;
    uint32_t arg5 ;
    uint32_t arg6 ;
    uint32_t arg7 ;
    
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->create(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_Texture2D_create__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    cc::TextureBase::PixelFormat arg4 ;
    uint32_t arg5 ;
    uint32_t arg6 ;
    
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->create(arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_Texture2D_create__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    cc::TextureBase::PixelFormat arg4 ;
    uint32_t arg5 ;
    
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->create(arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_Texture2D_create__SWIG_3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    cc::TextureBase::PixelFormat arg4 ;
    
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->create(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_Texture2D_create__SWIG_4(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->create(arg2,arg3);
    
    
    return true;
}

static bool js_cc_Texture2D_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 6) {
        ok = js_cc_Texture2D_create__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 5) {
        ok = js_cc_Texture2D_create__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 4) {
        ok = js_cc_Texture2D_create__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 3) {
        ok = js_cc_Texture2D_create__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_Texture2D_create__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Texture2D_create) 

static bool js_cc_Texture2D_description(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    ccstd::string result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    if (nullptr == arg1) return true;
    result = ((cc::Texture2D const *)arg1)->description();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Texture2D_description) 

static bool js_cc_Texture2D_releaseTexture(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    if (nullptr == arg1) return true;
    (arg1)->releaseTexture();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Texture2D_releaseTexture) 

static bool js_cc_Texture2D_getGfxTextureCreateInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    cc::gfx::TextureUsageBit arg2 ;
    cc::gfx::Format arg3 ;
    uint32_t arg4 ;
    cc::gfx::TextureFlagBit arg5 ;
    cc::gfx::TextureInfo result;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = (arg1)->getGfxTextureCreateInfo(arg2,arg3,arg4,arg5);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Texture2D_getGfxTextureCreateInfo) 

static bool js_cc_Texture2D_getGfxTextureViewCreateInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Texture2D *arg1 = (cc::Texture2D *) NULL ;
    cc::gfx::Texture *arg2 = (cc::gfx::Texture *) NULL ;
    cc::gfx::Format arg3 ;
    uint32_t arg4 ;
    uint32_t arg5 ;
    cc::gfx::TextureViewInfo result;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Texture2D>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (arg1)->getGfxTextureViewCreateInfo(arg2,arg3,arg4,arg5);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Texture2D_getGfxTextureViewCreateInfo) 

bool js_register_cc_Texture2D(se::Object* obj) {
    auto* cls = se::Class::create("Texture2D", obj, __jsb_cc_SimpleTexture_proto, _SE(js_new_cc_Texture2D)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getMipmaps", _SE(js_cc_Texture2D_getMipmaps)); 
    cls->defineFunction("getMipmapsUuids", _SE(js_cc_Texture2D_getMipmapsUuids)); 
    cls->defineFunction("syncMipmapsForJS", _SE(js_cc_Texture2D_syncMipmapsForJS)); 
    cls->defineFunction("setMipmaps", _SE(js_cc_Texture2D_setMipmaps)); 
    cls->defineFunction("getImage", _SE(js_cc_Texture2D_getImage)); 
    cls->defineFunction("setImage", _SE(js_cc_Texture2D_setImage)); 
    cls->defineFunction("initialize", _SE(js_cc_Texture2D_initialize)); 
    cls->defineFunction("reset", _SE(js_cc_Texture2D_reset)); 
    cls->defineFunction("create", _SE(js_cc_Texture2D_create)); 
    cls->defineFunction("description", _SE(js_cc_Texture2D_description)); 
    cls->defineFunction("releaseTexture", _SE(js_cc_Texture2D_releaseTexture)); 
    cls->defineFunction("getGfxTextureCreateInfo", _SE(js_cc_Texture2D_getGfxTextureCreateInfo)); 
    cls->defineFunction("getGfxTextureViewCreateInfo", _SE(js_cc_Texture2D_getGfxTextureViewCreateInfo)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Texture2D));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Texture2D>(cls);
    
    __jsb_cc_Texture2D_proto = cls->getProto();
    __jsb_cc_Texture2D_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_ITextureCubeMipmap_class = nullptr;
se::Object* __jsb_cc_ITextureCubeMipmap_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_ITextureCubeMipmap) 

static bool js_cc_ITextureCubeMipmap_front_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureCubeMipmap *arg1 = (cc::ITextureCubeMipmap *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeMipmap>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->front, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureCubeMipmap_front_set) 

static bool js_cc_ITextureCubeMipmap_front_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureCubeMipmap *arg1 = (cc::ITextureCubeMipmap *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeMipmap>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->front, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->front, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureCubeMipmap_front_get) 

static bool js_cc_ITextureCubeMipmap_back_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureCubeMipmap *arg1 = (cc::ITextureCubeMipmap *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeMipmap>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->back, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureCubeMipmap_back_set) 

static bool js_cc_ITextureCubeMipmap_back_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureCubeMipmap *arg1 = (cc::ITextureCubeMipmap *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeMipmap>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->back, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->back, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureCubeMipmap_back_get) 

static bool js_cc_ITextureCubeMipmap_left_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureCubeMipmap *arg1 = (cc::ITextureCubeMipmap *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeMipmap>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->left, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureCubeMipmap_left_set) 

static bool js_cc_ITextureCubeMipmap_left_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureCubeMipmap *arg1 = (cc::ITextureCubeMipmap *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeMipmap>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->left, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->left, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureCubeMipmap_left_get) 

static bool js_cc_ITextureCubeMipmap_right_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureCubeMipmap *arg1 = (cc::ITextureCubeMipmap *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeMipmap>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->right, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureCubeMipmap_right_set) 

static bool js_cc_ITextureCubeMipmap_right_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureCubeMipmap *arg1 = (cc::ITextureCubeMipmap *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeMipmap>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->right, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->right, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureCubeMipmap_right_get) 

static bool js_cc_ITextureCubeMipmap_top_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureCubeMipmap *arg1 = (cc::ITextureCubeMipmap *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeMipmap>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->top, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureCubeMipmap_top_set) 

static bool js_cc_ITextureCubeMipmap_top_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureCubeMipmap *arg1 = (cc::ITextureCubeMipmap *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeMipmap>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->top, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->top, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureCubeMipmap_top_get) 

static bool js_cc_ITextureCubeMipmap_bottom_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureCubeMipmap *arg1 = (cc::ITextureCubeMipmap *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeMipmap>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->bottom, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureCubeMipmap_bottom_set) 

static bool js_cc_ITextureCubeMipmap_bottom_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureCubeMipmap *arg1 = (cc::ITextureCubeMipmap *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeMipmap>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->bottom, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->bottom, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureCubeMipmap_bottom_get) 

static bool js_new_cc_ITextureCubeMipmap(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::ITextureCubeMipmap *result;
    result = (cc::ITextureCubeMipmap *)new cc::ITextureCubeMipmap();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_ITextureCubeMipmap, __jsb_cc_ITextureCubeMipmap_class, js_delete_cc_ITextureCubeMipmap)

static bool js_delete_cc_ITextureCubeMipmap(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_ITextureCubeMipmap) 

template<>
bool sevalue_to_native(const se::Value &from, cc::ITextureCubeMipmap * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::ITextureCubeMipmap*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("front", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->front), ctx);
    }
    
    
    json->getProperty("back", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->back), ctx);
    }
    
    
    json->getProperty("left", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->left), ctx);
    }
    
    
    json->getProperty("right", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->right), ctx);
    }
    
    
    json->getProperty("top", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->top), ctx);
    }
    
    
    json->getProperty("bottom", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->bottom), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_ITextureCubeMipmap(se::Object* obj) {
    auto* cls = se::Class::create("ITextureCubeMipmap", obj, nullptr, _SE(js_new_cc_ITextureCubeMipmap)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("front", _SE(js_cc_ITextureCubeMipmap_front_get), _SE(js_cc_ITextureCubeMipmap_front_set)); 
    cls->defineProperty("back", _SE(js_cc_ITextureCubeMipmap_back_get), _SE(js_cc_ITextureCubeMipmap_back_set)); 
    cls->defineProperty("left", _SE(js_cc_ITextureCubeMipmap_left_get), _SE(js_cc_ITextureCubeMipmap_left_set)); 
    cls->defineProperty("right", _SE(js_cc_ITextureCubeMipmap_right_get), _SE(js_cc_ITextureCubeMipmap_right_set)); 
    cls->defineProperty("top", _SE(js_cc_ITextureCubeMipmap_top_get), _SE(js_cc_ITextureCubeMipmap_top_set)); 
    cls->defineProperty("bottom", _SE(js_cc_ITextureCubeMipmap_bottom_get), _SE(js_cc_ITextureCubeMipmap_bottom_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_ITextureCubeMipmap));
    
    
    cls->install();
    JSBClassType::registerClass<cc::ITextureCubeMipmap>(cls);
    
    __jsb_cc_ITextureCubeMipmap_proto = cls->getProto();
    __jsb_cc_ITextureCubeMipmap_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_ITextureCubeSerializeMipmapData_class = nullptr;
se::Object* __jsb_cc_ITextureCubeSerializeMipmapData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_ITextureCubeSerializeMipmapData) 

static bool js_cc_ITextureCubeSerializeMipmapData_front_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureCubeSerializeMipmapData *arg1 = (cc::ITextureCubeSerializeMipmapData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeSerializeMipmapData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->front, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureCubeSerializeMipmapData_front_set) 

static bool js_cc_ITextureCubeSerializeMipmapData_front_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureCubeSerializeMipmapData *arg1 = (cc::ITextureCubeSerializeMipmapData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeSerializeMipmapData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->front, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->front, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureCubeSerializeMipmapData_front_get) 

static bool js_cc_ITextureCubeSerializeMipmapData_back_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureCubeSerializeMipmapData *arg1 = (cc::ITextureCubeSerializeMipmapData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeSerializeMipmapData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->back, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureCubeSerializeMipmapData_back_set) 

static bool js_cc_ITextureCubeSerializeMipmapData_back_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureCubeSerializeMipmapData *arg1 = (cc::ITextureCubeSerializeMipmapData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeSerializeMipmapData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->back, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->back, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureCubeSerializeMipmapData_back_get) 

static bool js_cc_ITextureCubeSerializeMipmapData_left_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureCubeSerializeMipmapData *arg1 = (cc::ITextureCubeSerializeMipmapData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeSerializeMipmapData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->left, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureCubeSerializeMipmapData_left_set) 

static bool js_cc_ITextureCubeSerializeMipmapData_left_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureCubeSerializeMipmapData *arg1 = (cc::ITextureCubeSerializeMipmapData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeSerializeMipmapData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->left, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->left, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureCubeSerializeMipmapData_left_get) 

static bool js_cc_ITextureCubeSerializeMipmapData_right_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureCubeSerializeMipmapData *arg1 = (cc::ITextureCubeSerializeMipmapData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeSerializeMipmapData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->right, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureCubeSerializeMipmapData_right_set) 

static bool js_cc_ITextureCubeSerializeMipmapData_right_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureCubeSerializeMipmapData *arg1 = (cc::ITextureCubeSerializeMipmapData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeSerializeMipmapData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->right, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->right, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureCubeSerializeMipmapData_right_get) 

static bool js_cc_ITextureCubeSerializeMipmapData_top_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureCubeSerializeMipmapData *arg1 = (cc::ITextureCubeSerializeMipmapData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeSerializeMipmapData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->top, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureCubeSerializeMipmapData_top_set) 

static bool js_cc_ITextureCubeSerializeMipmapData_top_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureCubeSerializeMipmapData *arg1 = (cc::ITextureCubeSerializeMipmapData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeSerializeMipmapData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->top, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->top, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureCubeSerializeMipmapData_top_get) 

static bool js_cc_ITextureCubeSerializeMipmapData_bottom_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureCubeSerializeMipmapData *arg1 = (cc::ITextureCubeSerializeMipmapData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeSerializeMipmapData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->bottom, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureCubeSerializeMipmapData_bottom_set) 

static bool js_cc_ITextureCubeSerializeMipmapData_bottom_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureCubeSerializeMipmapData *arg1 = (cc::ITextureCubeSerializeMipmapData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureCubeSerializeMipmapData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->bottom, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->bottom, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureCubeSerializeMipmapData_bottom_get) 

static bool js_new_cc_ITextureCubeSerializeMipmapData(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::ITextureCubeSerializeMipmapData *result;
    result = (cc::ITextureCubeSerializeMipmapData *)new cc::ITextureCubeSerializeMipmapData();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_ITextureCubeSerializeMipmapData, __jsb_cc_ITextureCubeSerializeMipmapData_class, js_delete_cc_ITextureCubeSerializeMipmapData)

static bool js_delete_cc_ITextureCubeSerializeMipmapData(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_ITextureCubeSerializeMipmapData) 

template<>
bool sevalue_to_native(const se::Value &from, cc::ITextureCubeSerializeMipmapData * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::ITextureCubeSerializeMipmapData*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("front", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->front), ctx);
    }
    
    
    json->getProperty("back", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->back), ctx);
    }
    
    
    json->getProperty("left", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->left), ctx);
    }
    
    
    json->getProperty("right", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->right), ctx);
    }
    
    
    json->getProperty("top", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->top), ctx);
    }
    
    
    json->getProperty("bottom", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->bottom), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_ITextureCubeSerializeMipmapData(se::Object* obj) {
    auto* cls = se::Class::create("ITextureCubeSerializeMipmapData", obj, nullptr, _SE(js_new_cc_ITextureCubeSerializeMipmapData)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("front", _SE(js_cc_ITextureCubeSerializeMipmapData_front_get), _SE(js_cc_ITextureCubeSerializeMipmapData_front_set)); 
    cls->defineProperty("back", _SE(js_cc_ITextureCubeSerializeMipmapData_back_get), _SE(js_cc_ITextureCubeSerializeMipmapData_back_set)); 
    cls->defineProperty("left", _SE(js_cc_ITextureCubeSerializeMipmapData_left_get), _SE(js_cc_ITextureCubeSerializeMipmapData_left_set)); 
    cls->defineProperty("right", _SE(js_cc_ITextureCubeSerializeMipmapData_right_get), _SE(js_cc_ITextureCubeSerializeMipmapData_right_set)); 
    cls->defineProperty("top", _SE(js_cc_ITextureCubeSerializeMipmapData_top_get), _SE(js_cc_ITextureCubeSerializeMipmapData_top_set)); 
    cls->defineProperty("bottom", _SE(js_cc_ITextureCubeSerializeMipmapData_bottom_get), _SE(js_cc_ITextureCubeSerializeMipmapData_bottom_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_ITextureCubeSerializeMipmapData));
    
    
    cls->install();
    JSBClassType::registerClass<cc::ITextureCubeSerializeMipmapData>(cls);
    
    __jsb_cc_ITextureCubeSerializeMipmapData_proto = cls->getProto();
    __jsb_cc_ITextureCubeSerializeMipmapData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_MipmapAtlasLayoutInfo_class = nullptr;
se::Object* __jsb_cc_MipmapAtlasLayoutInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_MipmapAtlasLayoutInfo) 

static bool js_cc_MipmapAtlasLayoutInfo_left_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MipmapAtlasLayoutInfo *arg1 = (cc::MipmapAtlasLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MipmapAtlasLayoutInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->left, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_MipmapAtlasLayoutInfo_left_set) 

static bool js_cc_MipmapAtlasLayoutInfo_left_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::MipmapAtlasLayoutInfo *arg1 = (cc::MipmapAtlasLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MipmapAtlasLayoutInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->left, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_MipmapAtlasLayoutInfo_left_get) 

static bool js_cc_MipmapAtlasLayoutInfo_top_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MipmapAtlasLayoutInfo *arg1 = (cc::MipmapAtlasLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MipmapAtlasLayoutInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->top, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_MipmapAtlasLayoutInfo_top_set) 

static bool js_cc_MipmapAtlasLayoutInfo_top_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::MipmapAtlasLayoutInfo *arg1 = (cc::MipmapAtlasLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MipmapAtlasLayoutInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->top, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_MipmapAtlasLayoutInfo_top_get) 

static bool js_cc_MipmapAtlasLayoutInfo_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MipmapAtlasLayoutInfo *arg1 = (cc::MipmapAtlasLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MipmapAtlasLayoutInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->width, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_MipmapAtlasLayoutInfo_width_set) 

static bool js_cc_MipmapAtlasLayoutInfo_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::MipmapAtlasLayoutInfo *arg1 = (cc::MipmapAtlasLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MipmapAtlasLayoutInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->width, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_MipmapAtlasLayoutInfo_width_get) 

static bool js_cc_MipmapAtlasLayoutInfo_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MipmapAtlasLayoutInfo *arg1 = (cc::MipmapAtlasLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MipmapAtlasLayoutInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->height, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_MipmapAtlasLayoutInfo_height_set) 

static bool js_cc_MipmapAtlasLayoutInfo_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::MipmapAtlasLayoutInfo *arg1 = (cc::MipmapAtlasLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MipmapAtlasLayoutInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->height, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_MipmapAtlasLayoutInfo_height_get) 

static bool js_cc_MipmapAtlasLayoutInfo_level_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MipmapAtlasLayoutInfo *arg1 = (cc::MipmapAtlasLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MipmapAtlasLayoutInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->level, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_MipmapAtlasLayoutInfo_level_set) 

static bool js_cc_MipmapAtlasLayoutInfo_level_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::MipmapAtlasLayoutInfo *arg1 = (cc::MipmapAtlasLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MipmapAtlasLayoutInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->level, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_MipmapAtlasLayoutInfo_level_get) 

static bool js_new_cc_MipmapAtlasLayoutInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::MipmapAtlasLayoutInfo *result;
    result = (cc::MipmapAtlasLayoutInfo *)new cc::MipmapAtlasLayoutInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_MipmapAtlasLayoutInfo, __jsb_cc_MipmapAtlasLayoutInfo_class, js_delete_cc_MipmapAtlasLayoutInfo)

static bool js_delete_cc_MipmapAtlasLayoutInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_MipmapAtlasLayoutInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::MipmapAtlasLayoutInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::MipmapAtlasLayoutInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("left", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->left), ctx);
    }
    
    
    json->getProperty("top", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->top), ctx);
    }
    
    
    json->getProperty("width", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->width), ctx);
    }
    
    
    json->getProperty("height", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->height), ctx);
    }
    
    
    json->getProperty("level", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->level), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_MipmapAtlasLayoutInfo(se::Object* obj) {
    auto* cls = se::Class::create("MipmapAtlasLayoutInfo", obj, nullptr, _SE(js_new_cc_MipmapAtlasLayoutInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("left", _SE(js_cc_MipmapAtlasLayoutInfo_left_get), _SE(js_cc_MipmapAtlasLayoutInfo_left_set)); 
    cls->defineProperty("top", _SE(js_cc_MipmapAtlasLayoutInfo_top_get), _SE(js_cc_MipmapAtlasLayoutInfo_top_set)); 
    cls->defineProperty("width", _SE(js_cc_MipmapAtlasLayoutInfo_width_get), _SE(js_cc_MipmapAtlasLayoutInfo_width_set)); 
    cls->defineProperty("height", _SE(js_cc_MipmapAtlasLayoutInfo_height_get), _SE(js_cc_MipmapAtlasLayoutInfo_height_set)); 
    cls->defineProperty("level", _SE(js_cc_MipmapAtlasLayoutInfo_level_get), _SE(js_cc_MipmapAtlasLayoutInfo_level_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_MipmapAtlasLayoutInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::MipmapAtlasLayoutInfo>(cls);
    
    __jsb_cc_MipmapAtlasLayoutInfo_proto = cls->getProto();
    __jsb_cc_MipmapAtlasLayoutInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_TextureCubeMipmapAtlasInfo_class = nullptr;
se::Object* __jsb_cc_TextureCubeMipmapAtlasInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_TextureCubeMipmapAtlasInfo) 

static bool js_cc_TextureCubeMipmapAtlasInfo_atlas_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCubeMipmapAtlasInfo *arg1 = (cc::TextureCubeMipmapAtlasInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeMipmapAtlasInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->atlas, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureCubeMipmapAtlasInfo_atlas_set) 

static bool js_cc_TextureCubeMipmapAtlasInfo_atlas_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureCubeMipmapAtlasInfo *arg1 = (cc::TextureCubeMipmapAtlasInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeMipmapAtlasInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->atlas, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->atlas, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureCubeMipmapAtlasInfo_atlas_get) 

static bool js_cc_TextureCubeMipmapAtlasInfo_layout_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCubeMipmapAtlasInfo *arg1 = (cc::TextureCubeMipmapAtlasInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeMipmapAtlasInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->layout, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureCubeMipmapAtlasInfo_layout_set) 

static bool js_cc_TextureCubeMipmapAtlasInfo_layout_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureCubeMipmapAtlasInfo *arg1 = (cc::TextureCubeMipmapAtlasInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeMipmapAtlasInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->layout, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->layout, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureCubeMipmapAtlasInfo_layout_get) 

static bool js_new_cc_TextureCubeMipmapAtlasInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::TextureCubeMipmapAtlasInfo *result;
    result = (cc::TextureCubeMipmapAtlasInfo *)new cc::TextureCubeMipmapAtlasInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_TextureCubeMipmapAtlasInfo, __jsb_cc_TextureCubeMipmapAtlasInfo_class, js_delete_cc_TextureCubeMipmapAtlasInfo)

static bool js_delete_cc_TextureCubeMipmapAtlasInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_TextureCubeMipmapAtlasInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::TextureCubeMipmapAtlasInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::TextureCubeMipmapAtlasInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("atlas", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->atlas), ctx);
    }
    
    
    json->getProperty("layout", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->layout), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_TextureCubeMipmapAtlasInfo(se::Object* obj) {
    auto* cls = se::Class::create("TextureCubeMipmapAtlasInfo", obj, nullptr, _SE(js_new_cc_TextureCubeMipmapAtlasInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("atlas", _SE(js_cc_TextureCubeMipmapAtlasInfo_atlas_get), _SE(js_cc_TextureCubeMipmapAtlasInfo_atlas_set)); 
    cls->defineProperty("layout", _SE(js_cc_TextureCubeMipmapAtlasInfo_layout_get), _SE(js_cc_TextureCubeMipmapAtlasInfo_layout_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_TextureCubeMipmapAtlasInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::TextureCubeMipmapAtlasInfo>(cls);
    
    __jsb_cc_TextureCubeMipmapAtlasInfo_proto = cls->getProto();
    __jsb_cc_TextureCubeMipmapAtlasInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_TextureCubeSerializeData_class = nullptr;
se::Object* __jsb_cc_TextureCubeSerializeData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_TextureCubeSerializeData) 

static bool js_cc_TextureCubeSerializeData_base_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCubeSerializeData *arg1 = (cc::TextureCubeSerializeData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeSerializeData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->base, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureCubeSerializeData_base_set) 

static bool js_cc_TextureCubeSerializeData_base_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureCubeSerializeData *arg1 = (cc::TextureCubeSerializeData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeSerializeData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->base, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->base, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureCubeSerializeData_base_get) 

static bool js_cc_TextureCubeSerializeData_rgbe_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCubeSerializeData *arg1 = (cc::TextureCubeSerializeData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeSerializeData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->rgbe);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureCubeSerializeData_rgbe_set) 

static bool js_cc_TextureCubeSerializeData_rgbe_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureCubeSerializeData *arg1 = (cc::TextureCubeSerializeData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeSerializeData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->rgbe, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureCubeSerializeData_rgbe_get) 

static bool js_cc_TextureCubeSerializeData_mipmapMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCubeSerializeData *arg1 = (cc::TextureCubeSerializeData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeSerializeData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->mipmapMode, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureCubeSerializeData_mipmapMode_set) 

static bool js_cc_TextureCubeSerializeData_mipmapMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureCubeSerializeData *arg1 = (cc::TextureCubeSerializeData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeSerializeData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->mipmapMode, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->mipmapMode, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureCubeSerializeData_mipmapMode_get) 

static bool js_cc_TextureCubeSerializeData_mipmaps_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCubeSerializeData *arg1 = (cc::TextureCubeSerializeData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeSerializeData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->mipmaps, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureCubeSerializeData_mipmaps_set) 

static bool js_cc_TextureCubeSerializeData_mipmaps_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureCubeSerializeData *arg1 = (cc::TextureCubeSerializeData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeSerializeData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->mipmaps, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->mipmaps, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureCubeSerializeData_mipmaps_get) 

static bool js_cc_TextureCubeSerializeData_mipmapAtlas_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCubeSerializeData *arg1 = (cc::TextureCubeSerializeData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeSerializeData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->mipmapAtlas, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureCubeSerializeData_mipmapAtlas_set) 

static bool js_cc_TextureCubeSerializeData_mipmapAtlas_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureCubeSerializeData *arg1 = (cc::TextureCubeSerializeData *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCubeSerializeData>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->mipmapAtlas, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->mipmapAtlas, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureCubeSerializeData_mipmapAtlas_get) 

static bool js_new_cc_TextureCubeSerializeData(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::TextureCubeSerializeData *result;
    result = (cc::TextureCubeSerializeData *)new cc::TextureCubeSerializeData();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_TextureCubeSerializeData, __jsb_cc_TextureCubeSerializeData_class, js_delete_cc_TextureCubeSerializeData)

static bool js_delete_cc_TextureCubeSerializeData(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_TextureCubeSerializeData) 

template<>
bool sevalue_to_native(const se::Value &from, cc::TextureCubeSerializeData * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::TextureCubeSerializeData*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("base", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->base), ctx);
    }
    
    
    json->getProperty("rgbe", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->rgbe), ctx);
    }
    
    
    json->getProperty("mipmapMode", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->mipmapMode), ctx);
    }
    
    
    json->getProperty("mipmaps", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->mipmaps), ctx);
    }
    
    
    json->getProperty("mipmapAtlas", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->mipmapAtlas), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_TextureCubeSerializeData(se::Object* obj) {
    auto* cls = se::Class::create("TextureCubeSerializeData", obj, nullptr, _SE(js_new_cc_TextureCubeSerializeData)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("base", _SE(js_cc_TextureCubeSerializeData_base_get), _SE(js_cc_TextureCubeSerializeData_base_set)); 
    cls->defineProperty("rgbe", _SE(js_cc_TextureCubeSerializeData_rgbe_get), _SE(js_cc_TextureCubeSerializeData_rgbe_set)); 
    cls->defineProperty("mipmapMode", _SE(js_cc_TextureCubeSerializeData_mipmapMode_get), _SE(js_cc_TextureCubeSerializeData_mipmapMode_set)); 
    cls->defineProperty("mipmaps", _SE(js_cc_TextureCubeSerializeData_mipmaps_get), _SE(js_cc_TextureCubeSerializeData_mipmaps_set)); 
    cls->defineProperty("mipmapAtlas", _SE(js_cc_TextureCubeSerializeData_mipmapAtlas_get), _SE(js_cc_TextureCubeSerializeData_mipmapAtlas_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_TextureCubeSerializeData));
    
    
    cls->install();
    JSBClassType::registerClass<cc::TextureCubeSerializeData>(cls);
    
    __jsb_cc_TextureCubeSerializeData_proto = cls->getProto();
    __jsb_cc_TextureCubeSerializeData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_TextureCube_class = nullptr;
se::Object* __jsb_cc_TextureCube_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_TextureCube) 

static bool js_new_cc_TextureCube(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::TextureCube *result;
    result = (cc::TextureCube *)new cc::TextureCube();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_TextureCube, __jsb_cc_TextureCube_class, js_delete_cc_TextureCube)

static bool js_delete_cc_TextureCube(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_TextureCube) 

static bool js_cc_TextureCube_fromTexture2DArray_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    ccstd::vector< cc::Texture2D * > *arg1 = 0 ;
    ccstd::vector< cc::Texture2D * > temp1 ;
    cc::TextureCube *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = (cc::TextureCube *)cc::TextureCube::fromTexture2DArray((ccstd::vector< cc::Texture2D * > const &)*arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_fromTexture2DArray_static) 

static bool js_cc_TextureCube_getMipmaps(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    ccstd::vector< cc::ITextureCubeMipmap > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::ITextureCubeMipmap > *) &((cc::TextureCube const *)arg1)->getMipmaps();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_getMipmaps) 

static bool js_cc_TextureCube_getMipmapAtlas(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    cc::TextureCubeMipmapAtlasInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    if (nullptr == arg1) return true;
    result = (cc::TextureCubeMipmapAtlasInfo *) &((cc::TextureCube const *)arg1)->getMipmapAtlas();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_getMipmapAtlas) 

static bool js_cc_TextureCube_setMipmaps(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    ccstd::vector< cc::ITextureCubeMipmap > *arg2 = 0 ;
    ccstd::vector< cc::ITextureCubeMipmap > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setMipmaps((ccstd::vector< cc::ITextureCubeMipmap > const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_setMipmaps) 

static bool js_cc_TextureCube_setMipmapsForJS(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    ccstd::vector< cc::ITextureCubeMipmap > *arg2 = 0 ;
    ccstd::vector< cc::ITextureCubeMipmap > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setMipmapsForJS((ccstd::vector< cc::ITextureCubeMipmap > const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_setMipmapsForJS) 

static bool js_cc_TextureCube_setMipmapAtlasForJS(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    cc::TextureCubeMipmapAtlasInfo *arg2 = 0 ;
    cc::TextureCubeMipmapAtlasInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setMipmapAtlasForJS((cc::TextureCubeMipmapAtlasInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_setMipmapAtlasForJS) 

static bool js_cc_TextureCube_setMipmapAtlas(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    cc::TextureCubeMipmapAtlasInfo *arg2 = 0 ;
    cc::TextureCubeMipmapAtlasInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setMipmapAtlas((cc::TextureCubeMipmapAtlasInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_setMipmapAtlas) 

static bool js_cc_TextureCube_getImage(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    cc::ITextureCubeMipmap *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    if (nullptr == arg1) return true;
    result = (cc::ITextureCubeMipmap *)((cc::TextureCube const *)arg1)->getImage();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_getImage) 

static bool js_cc_TextureCube_setImage(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    cc::ITextureCubeMipmap *arg2 = (cc::ITextureCubeMipmap *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setImage((cc::ITextureCubeMipmap const *)arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_setImage) 

static bool js_cc_TextureCube_reset(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    cc::ITextureCubeCreateInfo *arg2 = 0 ;
    cc::ITextureCubeCreateInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->reset((cc::ITextureCubeCreateInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_reset) 

static bool js_cc_TextureCube_releaseTexture(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    if (nullptr == arg1) return true;
    (arg1)->releaseTexture();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_releaseTexture) 

static bool js_cc_TextureCube_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    if (nullptr == arg1) return true;
    (arg1)->initialize();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_initialize) 

static bool js_cc_TextureCube_getGfxTextureCreateInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    cc::gfx::TextureUsageBit arg2 ;
    cc::gfx::Format arg3 ;
    uint32_t arg4 ;
    cc::gfx::TextureFlagBit arg5 ;
    cc::gfx::TextureInfo result;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = (arg1)->getGfxTextureCreateInfo(arg2,arg3,arg4,arg5);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_getGfxTextureCreateInfo) 

static bool js_cc_TextureCube_getGfxTextureViewCreateInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    cc::gfx::Texture *arg2 = (cc::gfx::Texture *) NULL ;
    cc::gfx::Format arg3 ;
    uint32_t arg4 ;
    uint32_t arg5 ;
    cc::gfx::TextureViewInfo result;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (arg1)->getGfxTextureViewCreateInfo(arg2,arg3,arg4,arg5);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_TextureCube_getGfxTextureViewCreateInfo) 

static bool js_cc_TextureCube__mipmapMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_mipmapMode, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureCube__mipmapMode_set) 

static bool js_cc_TextureCube__mipmapMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_mipmapMode, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_mipmapMode, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureCube__mipmapMode_get) 

static bool js_cc_TextureCube_isRGBE_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->isRGBE);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextureCube_isRGBE_set) 

static bool js_cc_TextureCube_isRGBE_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextureCube *arg1 = (cc::TextureCube *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextureCube>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->isRGBE, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextureCube_isRGBE_get) 

bool js_register_cc_TextureCube(se::Object* obj) {
    auto* cls = se::Class::create("TextureCube", obj, __jsb_cc_SimpleTexture_proto, _SE(js_new_cc_TextureCube)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("_mipmapMode", _SE(js_cc_TextureCube__mipmapMode_get), _SE(js_cc_TextureCube__mipmapMode_set)); 
    cls->defineProperty("isRGBE", _SE(js_cc_TextureCube_isRGBE_get), _SE(js_cc_TextureCube_isRGBE_set)); 
    
    cls->defineFunction("getMipmaps", _SE(js_cc_TextureCube_getMipmaps)); 
    cls->defineFunction("getMipmapAtlas", _SE(js_cc_TextureCube_getMipmapAtlas)); 
    cls->defineFunction("setMipmaps", _SE(js_cc_TextureCube_setMipmaps)); 
    cls->defineFunction("setMipmapsForJS", _SE(js_cc_TextureCube_setMipmapsForJS)); 
    cls->defineFunction("setMipmapAtlasForJS", _SE(js_cc_TextureCube_setMipmapAtlasForJS)); 
    cls->defineFunction("setMipmapAtlas", _SE(js_cc_TextureCube_setMipmapAtlas)); 
    cls->defineFunction("getImage", _SE(js_cc_TextureCube_getImage)); 
    cls->defineFunction("setImage", _SE(js_cc_TextureCube_setImage)); 
    cls->defineFunction("reset", _SE(js_cc_TextureCube_reset)); 
    cls->defineFunction("releaseTexture", _SE(js_cc_TextureCube_releaseTexture)); 
    cls->defineFunction("initialize", _SE(js_cc_TextureCube_initialize)); 
    cls->defineFunction("getGfxTextureCreateInfo", _SE(js_cc_TextureCube_getGfxTextureCreateInfo)); 
    cls->defineFunction("getGfxTextureViewCreateInfo", _SE(js_cc_TextureCube_getGfxTextureViewCreateInfo)); 
    
    
    cls->defineStaticFunction("fromTexture2DArray", _SE(js_cc_TextureCube_fromTexture2DArray_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_TextureCube));
    
    
    cls->install();
    JSBClassType::registerClass<cc::TextureCube>(cls);
    
    __jsb_cc_TextureCube_proto = cls->getProto();
    __jsb_cc_TextureCube_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IRenderTextureCreateInfo_class = nullptr;
se::Object* __jsb_cc_IRenderTextureCreateInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IRenderTextureCreateInfo) 

static bool js_cc_IRenderTextureCreateInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IRenderTextureCreateInfo *arg1 = (cc::IRenderTextureCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IRenderTextureCreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IRenderTextureCreateInfo_name_set) 

static bool js_cc_IRenderTextureCreateInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IRenderTextureCreateInfo *arg1 = (cc::IRenderTextureCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IRenderTextureCreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IRenderTextureCreateInfo_name_get) 

static bool js_cc_IRenderTextureCreateInfo_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IRenderTextureCreateInfo *arg1 = (cc::IRenderTextureCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IRenderTextureCreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->width, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IRenderTextureCreateInfo_width_set) 

static bool js_cc_IRenderTextureCreateInfo_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IRenderTextureCreateInfo *arg1 = (cc::IRenderTextureCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IRenderTextureCreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->width, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IRenderTextureCreateInfo_width_get) 

static bool js_cc_IRenderTextureCreateInfo_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IRenderTextureCreateInfo *arg1 = (cc::IRenderTextureCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IRenderTextureCreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->height, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IRenderTextureCreateInfo_height_set) 

static bool js_cc_IRenderTextureCreateInfo_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IRenderTextureCreateInfo *arg1 = (cc::IRenderTextureCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IRenderTextureCreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->height, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IRenderTextureCreateInfo_height_get) 

static bool js_cc_IRenderTextureCreateInfo_passInfo_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IRenderTextureCreateInfo *arg1 = (cc::IRenderTextureCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IRenderTextureCreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->passInfo, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IRenderTextureCreateInfo_passInfo_set) 

static bool js_cc_IRenderTextureCreateInfo_passInfo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IRenderTextureCreateInfo *arg1 = (cc::IRenderTextureCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IRenderTextureCreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->passInfo, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->passInfo, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IRenderTextureCreateInfo_passInfo_get) 

static bool js_new_cc_IRenderTextureCreateInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IRenderTextureCreateInfo *result;
    result = (cc::IRenderTextureCreateInfo *)new cc::IRenderTextureCreateInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IRenderTextureCreateInfo, __jsb_cc_IRenderTextureCreateInfo_class, js_delete_cc_IRenderTextureCreateInfo)

static bool js_delete_cc_IRenderTextureCreateInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IRenderTextureCreateInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IRenderTextureCreateInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IRenderTextureCreateInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("width", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->width), ctx);
    }
    
    
    json->getProperty("height", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->height), ctx);
    }
    
    
    json->getProperty("passInfo", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->passInfo), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IRenderTextureCreateInfo(se::Object* obj) {
    auto* cls = se::Class::create("IRenderTextureCreateInfo", obj, nullptr, _SE(js_new_cc_IRenderTextureCreateInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("name", _SE(js_cc_IRenderTextureCreateInfo_name_get), _SE(js_cc_IRenderTextureCreateInfo_name_set)); 
    cls->defineProperty("width", _SE(js_cc_IRenderTextureCreateInfo_width_get), _SE(js_cc_IRenderTextureCreateInfo_width_set)); 
    cls->defineProperty("height", _SE(js_cc_IRenderTextureCreateInfo_height_get), _SE(js_cc_IRenderTextureCreateInfo_height_set)); 
    cls->defineProperty("passInfo", _SE(js_cc_IRenderTextureCreateInfo_passInfo_get), _SE(js_cc_IRenderTextureCreateInfo_passInfo_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IRenderTextureCreateInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IRenderTextureCreateInfo>(cls);
    
    __jsb_cc_IRenderTextureCreateInfo_proto = cls->getProto();
    __jsb_cc_IRenderTextureCreateInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_RenderTexture_class = nullptr;
se::Object* __jsb_cc_RenderTexture_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_RenderTexture) 

static bool js_new_cc_RenderTexture(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::RenderTexture *result;
    result = (cc::RenderTexture *)new cc::RenderTexture();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_RenderTexture, __jsb_cc_RenderTexture_class, js_delete_cc_RenderTexture)

static bool js_delete_cc_RenderTexture(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_RenderTexture) 

static bool js_cc_RenderTexture_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderTexture *arg1 = (cc::RenderTexture *) NULL ;
    cc::IRenderTextureCreateInfo *arg2 = 0 ;
    cc::IRenderTextureCreateInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::IRenderTextureCreateInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderTexture_initialize) 

static bool js_cc_RenderTexture_reset(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderTexture *arg1 = (cc::RenderTexture *) NULL ;
    cc::IRenderTextureCreateInfo *arg2 = 0 ;
    cc::IRenderTextureCreateInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->reset((cc::IRenderTextureCreateInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderTexture_reset) 

static bool js_cc_RenderTexture_resize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderTexture *arg1 = (cc::RenderTexture *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->resize(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderTexture_resize) 

static bool js_cc_RenderTexture_initWindow__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::RenderTexture *arg1 = (cc::RenderTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderTexture>(s);
    if (nullptr == arg1) return true;
    (arg1)->initWindow();
    
    
    return true;
}

static bool js_cc_RenderTexture_initWindow__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::RenderTexture *arg1 = (cc::RenderTexture *) NULL ;
    cc::IRenderTextureCreateInfo *arg2 = 0 ;
    cc::IRenderTextureCreateInfo temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->initWindow((cc::IRenderTextureCreateInfo const &)*arg2);
    
    
    return true;
}

static bool js_cc_RenderTexture_initWindow(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 0) {
        ok = js_cc_RenderTexture_initWindow__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_RenderTexture_initWindow__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_RenderTexture_initWindow) 

static bool js_cc_RenderTexture_readPixels(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderTexture *arg1 = (cc::RenderTexture *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    uint32_t arg4 ;
    uint32_t arg5 ;
    ccstd::vector< uint8_t > result;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = ((cc::RenderTexture const *)arg1)->readPixels(arg2,arg3,arg4,arg5);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderTexture_readPixels) 

static bool js_cc_RenderTexture_window_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderTexture *arg1 = (cc::RenderTexture *) NULL ;
    cc::scene::RenderWindow *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderTexture>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::RenderWindow *)cc_RenderTexture_window_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderTexture_window_get) 

bool js_register_cc_RenderTexture(se::Object* obj) {
    auto* cls = se::Class::create("RenderTexture", obj, __jsb_cc_TextureBase_proto, _SE(js_new_cc_RenderTexture)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("window", _SE(js_cc_RenderTexture_window_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_RenderTexture_initialize)); 
    cls->defineFunction("reset", _SE(js_cc_RenderTexture_reset)); 
    cls->defineFunction("resize", _SE(js_cc_RenderTexture_resize)); 
    cls->defineFunction("initWindow", _SE(js_cc_RenderTexture_initWindow)); 
    cls->defineFunction("readPixels", _SE(js_cc_RenderTexture_readPixels)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_RenderTexture));
    
    
    cls->install();
    JSBClassType::registerClass<cc::RenderTexture>(cls);
    
    __jsb_cc_RenderTexture_proto = cls->getProto();
    __jsb_cc_RenderTexture_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_BufferAsset_class = nullptr;
se::Object* __jsb_cc_BufferAsset_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_BufferAsset) 

static bool js_new_cc_BufferAsset(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::BufferAsset *result;
    result = (cc::BufferAsset *)new cc::BufferAsset();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_BufferAsset, __jsb_cc_BufferAsset_class, js_delete_cc_BufferAsset)

static bool js_delete_cc_BufferAsset(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_BufferAsset) 

static bool js_cc_BufferAsset_buffer(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BufferAsset *arg1 = (cc::BufferAsset *) NULL ;
    cc::ArrayBuffer *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BufferAsset>(s);
    if (nullptr == arg1) return true;
    result = (cc::ArrayBuffer *)((cc::BufferAsset const *)arg1)->getBuffer();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BufferAsset_buffer) 

static bool js_cc_BufferAsset__nativeAsset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BufferAsset *arg1 = (cc::BufferAsset *) NULL ;
    cc::ArrayBuffer *arg2 = (cc::ArrayBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BufferAsset>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_BufferAsset__nativeAsset_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BufferAsset__nativeAsset_set) 

static bool js_cc_BufferAsset__nativeAsset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BufferAsset *arg1 = (cc::BufferAsset *) NULL ;
    cc::ArrayBuffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::BufferAsset>(s);
    if (nullptr == arg1) return true;
    result = (cc::ArrayBuffer *)cc_BufferAsset__nativeAsset_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BufferAsset__nativeAsset_get) 

bool js_register_cc_BufferAsset(se::Object* obj) {
    auto* cls = se::Class::create("BufferAsset", obj, __jsb_cc_Asset_proto, _SE(js_new_cc_BufferAsset)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("_nativeAsset", _SE(js_cc_BufferAsset__nativeAsset_get), _SE(js_cc_BufferAsset__nativeAsset_set)); 
    
    cls->defineFunction("buffer", _SE(js_cc_BufferAsset_buffer)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_BufferAsset));
    
    
    cls->install();
    JSBClassType::registerClass<cc::BufferAsset>(cls);
    
    __jsb_cc_BufferAsset_proto = cls->getProto();
    __jsb_cc_BufferAsset_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IPropertyInfo_class = nullptr;
se::Object* __jsb_cc_IPropertyInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IPropertyInfo) 

static bool js_cc_IPropertyInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPropertyInfo *arg1 = (cc::IPropertyInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPropertyInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->type, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPropertyInfo_type_set) 

static bool js_cc_IPropertyInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPropertyInfo *arg1 = (cc::IPropertyInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPropertyInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->type, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPropertyInfo_type_get) 

static bool js_cc_IPropertyInfo_handleInfo_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPropertyInfo *arg1 = (cc::IPropertyInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPropertyInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->handleInfo, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPropertyInfo_handleInfo_set) 

static bool js_cc_IPropertyInfo_handleInfo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPropertyInfo *arg1 = (cc::IPropertyInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPropertyInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->handleInfo, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->handleInfo, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPropertyInfo_handleInfo_get) 

static bool js_cc_IPropertyInfo_samplerHash_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPropertyInfo *arg1 = (cc::IPropertyInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPropertyInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->samplerHash, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPropertyInfo_samplerHash_set) 

static bool js_cc_IPropertyInfo_samplerHash_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPropertyInfo *arg1 = (cc::IPropertyInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPropertyInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->samplerHash, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->samplerHash, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPropertyInfo_samplerHash_get) 

static bool js_cc_IPropertyInfo_value_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPropertyInfo *arg1 = (cc::IPropertyInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPropertyInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->value, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPropertyInfo_value_set) 

static bool js_cc_IPropertyInfo_value_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPropertyInfo *arg1 = (cc::IPropertyInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPropertyInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->value, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->value, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPropertyInfo_value_get) 

static bool js_cc_IPropertyInfo_linear_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPropertyInfo *arg1 = (cc::IPropertyInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPropertyInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->linear, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPropertyInfo_linear_set) 

static bool js_cc_IPropertyInfo_linear_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPropertyInfo *arg1 = (cc::IPropertyInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPropertyInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->linear, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->linear, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPropertyInfo_linear_get) 

static bool js_cc_IPropertyInfo_editor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPropertyInfo *arg1 = (cc::IPropertyInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPropertyInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->editor, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPropertyInfo_editor_set) 

static bool js_cc_IPropertyInfo_editor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPropertyInfo *arg1 = (cc::IPropertyInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPropertyInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->editor, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->editor, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPropertyInfo_editor_get) 

static bool js_new_cc_IPropertyInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IPropertyInfo *result;
    result = (cc::IPropertyInfo *)new cc::IPropertyInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IPropertyInfo, __jsb_cc_IPropertyInfo_class, js_delete_cc_IPropertyInfo)

static bool js_delete_cc_IPropertyInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IPropertyInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IPropertyInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IPropertyInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("handleInfo", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->handleInfo), ctx);
    }
    
    
    json->getProperty("samplerHash", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->samplerHash), ctx);
    }
    
    
    json->getProperty("value", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->value), ctx);
    }
    
    
    json->getProperty("linear", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->linear), ctx);
    }
    
    
    json->getProperty("editor", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->editor), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IPropertyInfo(se::Object* obj) {
    auto* cls = se::Class::create("IPropertyInfo", obj, nullptr, _SE(js_new_cc_IPropertyInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("type", _SE(js_cc_IPropertyInfo_type_get), _SE(js_cc_IPropertyInfo_type_set)); 
    cls->defineProperty("handleInfo", _SE(js_cc_IPropertyInfo_handleInfo_get), _SE(js_cc_IPropertyInfo_handleInfo_set)); 
    cls->defineProperty("samplerHash", _SE(js_cc_IPropertyInfo_samplerHash_get), _SE(js_cc_IPropertyInfo_samplerHash_set)); 
    cls->defineProperty("value", _SE(js_cc_IPropertyInfo_value_get), _SE(js_cc_IPropertyInfo_value_set)); 
    cls->defineProperty("linear", _SE(js_cc_IPropertyInfo_linear_get), _SE(js_cc_IPropertyInfo_linear_set)); 
    cls->defineProperty("editor", _SE(js_cc_IPropertyInfo_editor_get), _SE(js_cc_IPropertyInfo_editor_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IPropertyInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IPropertyInfo>(cls);
    
    __jsb_cc_IPropertyInfo_proto = cls->getProto();
    __jsb_cc_IPropertyInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_RasterizerStateInfo_class = nullptr;
se::Object* __jsb_cc_RasterizerStateInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_RasterizerStateInfo) 

static bool js_cc_RasterizerStateInfo_isDiscard_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->isDiscard, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RasterizerStateInfo_isDiscard_set) 

static bool js_cc_RasterizerStateInfo_isDiscard_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->isDiscard, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->isDiscard, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RasterizerStateInfo_isDiscard_get) 

static bool js_cc_RasterizerStateInfo_isFrontFaceCCW_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->isFrontFaceCCW, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RasterizerStateInfo_isFrontFaceCCW_set) 

static bool js_cc_RasterizerStateInfo_isFrontFaceCCW_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->isFrontFaceCCW, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->isFrontFaceCCW, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RasterizerStateInfo_isFrontFaceCCW_get) 

static bool js_cc_RasterizerStateInfo_depthBiasEnabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthBiasEnabled, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RasterizerStateInfo_depthBiasEnabled_set) 

static bool js_cc_RasterizerStateInfo_depthBiasEnabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthBiasEnabled, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthBiasEnabled, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RasterizerStateInfo_depthBiasEnabled_get) 

static bool js_cc_RasterizerStateInfo_isDepthClip_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->isDepthClip, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RasterizerStateInfo_isDepthClip_set) 

static bool js_cc_RasterizerStateInfo_isDepthClip_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->isDepthClip, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->isDepthClip, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RasterizerStateInfo_isDepthClip_get) 

static bool js_cc_RasterizerStateInfo_isMultisample_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->isMultisample, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RasterizerStateInfo_isMultisample_set) 

static bool js_cc_RasterizerStateInfo_isMultisample_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->isMultisample, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->isMultisample, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RasterizerStateInfo_isMultisample_get) 

static bool js_cc_RasterizerStateInfo_polygonMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->polygonMode, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RasterizerStateInfo_polygonMode_set) 

static bool js_cc_RasterizerStateInfo_polygonMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->polygonMode, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->polygonMode, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RasterizerStateInfo_polygonMode_get) 

static bool js_cc_RasterizerStateInfo_shadeModel_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->shadeModel, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RasterizerStateInfo_shadeModel_set) 

static bool js_cc_RasterizerStateInfo_shadeModel_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->shadeModel, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->shadeModel, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RasterizerStateInfo_shadeModel_get) 

static bool js_cc_RasterizerStateInfo_cullMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->cullMode, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RasterizerStateInfo_cullMode_set) 

static bool js_cc_RasterizerStateInfo_cullMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->cullMode, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->cullMode, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RasterizerStateInfo_cullMode_get) 

static bool js_cc_RasterizerStateInfo_depthBias_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthBias, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RasterizerStateInfo_depthBias_set) 

static bool js_cc_RasterizerStateInfo_depthBias_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthBias, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthBias, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RasterizerStateInfo_depthBias_get) 

static bool js_cc_RasterizerStateInfo_depthBiasClamp_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthBiasClamp, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RasterizerStateInfo_depthBiasClamp_set) 

static bool js_cc_RasterizerStateInfo_depthBiasClamp_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthBiasClamp, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthBiasClamp, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RasterizerStateInfo_depthBiasClamp_get) 

static bool js_cc_RasterizerStateInfo_depthBiasSlop_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthBiasSlop, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RasterizerStateInfo_depthBiasSlop_set) 

static bool js_cc_RasterizerStateInfo_depthBiasSlop_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthBiasSlop, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthBiasSlop, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RasterizerStateInfo_depthBiasSlop_get) 

static bool js_cc_RasterizerStateInfo_lineWidth_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->lineWidth, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RasterizerStateInfo_lineWidth_set) 

static bool js_cc_RasterizerStateInfo_lineWidth_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->lineWidth, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->lineWidth, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RasterizerStateInfo_lineWidth_get) 

static bool js_cc_RasterizerStateInfo_fromGFXRasterizerState(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    cc::gfx::RasterizerState *arg2 = 0 ;
    cc::gfx::RasterizerState temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->fromGFXRasterizerState((cc::gfx::RasterizerState const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RasterizerStateInfo_fromGFXRasterizerState) 

static bool js_cc_RasterizerStateInfo_assignToGFXRasterizerState(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RasterizerStateInfo *arg1 = (cc::RasterizerStateInfo *) NULL ;
    cc::gfx::RasterizerState *arg2 = 0 ;
    cc::gfx::RasterizerState temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RasterizerStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    ((cc::RasterizerStateInfo const *)arg1)->assignToGFXRasterizerState(*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RasterizerStateInfo_assignToGFXRasterizerState) 

static bool js_new_cc_RasterizerStateInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::RasterizerStateInfo *result;
    result = (cc::RasterizerStateInfo *)new cc::RasterizerStateInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_RasterizerStateInfo, __jsb_cc_RasterizerStateInfo_class, js_delete_cc_RasterizerStateInfo)

static bool js_delete_cc_RasterizerStateInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_RasterizerStateInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::RasterizerStateInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::RasterizerStateInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("isDiscard", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isDiscard), ctx);
    }
    
    
    json->getProperty("isFrontFaceCCW", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isFrontFaceCCW), ctx);
    }
    
    
    json->getProperty("depthBiasEnabled", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthBiasEnabled), ctx);
    }
    
    
    json->getProperty("isDepthClip", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isDepthClip), ctx);
    }
    
    
    json->getProperty("isMultisample", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isMultisample), ctx);
    }
    
    
    json->getProperty("polygonMode", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->polygonMode), ctx);
    }
    
    
    json->getProperty("shadeModel", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->shadeModel), ctx);
    }
    
    
    json->getProperty("cullMode", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->cullMode), ctx);
    }
    
    
    json->getProperty("depthBias", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthBias), ctx);
    }
    
    
    json->getProperty("depthBiasClamp", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthBiasClamp), ctx);
    }
    
    
    json->getProperty("depthBiasSlop", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthBiasSlop), ctx);
    }
    
    
    json->getProperty("lineWidth", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->lineWidth), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_RasterizerStateInfo(se::Object* obj) {
    auto* cls = se::Class::create("RasterizerStateInfo", obj, nullptr, _SE(js_new_cc_RasterizerStateInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("isDiscard", _SE(js_cc_RasterizerStateInfo_isDiscard_get), _SE(js_cc_RasterizerStateInfo_isDiscard_set)); 
    cls->defineProperty("isFrontFaceCCW", _SE(js_cc_RasterizerStateInfo_isFrontFaceCCW_get), _SE(js_cc_RasterizerStateInfo_isFrontFaceCCW_set)); 
    cls->defineProperty("depthBiasEnabled", _SE(js_cc_RasterizerStateInfo_depthBiasEnabled_get), _SE(js_cc_RasterizerStateInfo_depthBiasEnabled_set)); 
    cls->defineProperty("isDepthClip", _SE(js_cc_RasterizerStateInfo_isDepthClip_get), _SE(js_cc_RasterizerStateInfo_isDepthClip_set)); 
    cls->defineProperty("isMultisample", _SE(js_cc_RasterizerStateInfo_isMultisample_get), _SE(js_cc_RasterizerStateInfo_isMultisample_set)); 
    cls->defineProperty("polygonMode", _SE(js_cc_RasterizerStateInfo_polygonMode_get), _SE(js_cc_RasterizerStateInfo_polygonMode_set)); 
    cls->defineProperty("shadeModel", _SE(js_cc_RasterizerStateInfo_shadeModel_get), _SE(js_cc_RasterizerStateInfo_shadeModel_set)); 
    cls->defineProperty("cullMode", _SE(js_cc_RasterizerStateInfo_cullMode_get), _SE(js_cc_RasterizerStateInfo_cullMode_set)); 
    cls->defineProperty("depthBias", _SE(js_cc_RasterizerStateInfo_depthBias_get), _SE(js_cc_RasterizerStateInfo_depthBias_set)); 
    cls->defineProperty("depthBiasClamp", _SE(js_cc_RasterizerStateInfo_depthBiasClamp_get), _SE(js_cc_RasterizerStateInfo_depthBiasClamp_set)); 
    cls->defineProperty("depthBiasSlop", _SE(js_cc_RasterizerStateInfo_depthBiasSlop_get), _SE(js_cc_RasterizerStateInfo_depthBiasSlop_set)); 
    cls->defineProperty("lineWidth", _SE(js_cc_RasterizerStateInfo_lineWidth_get), _SE(js_cc_RasterizerStateInfo_lineWidth_set)); 
    
    cls->defineFunction("fromGFXRasterizerState", _SE(js_cc_RasterizerStateInfo_fromGFXRasterizerState)); 
    cls->defineFunction("assignToGFXRasterizerState", _SE(js_cc_RasterizerStateInfo_assignToGFXRasterizerState)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_RasterizerStateInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::RasterizerStateInfo>(cls);
    
    __jsb_cc_RasterizerStateInfo_proto = cls->getProto();
    __jsb_cc_RasterizerStateInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_DepthStencilStateInfo_class = nullptr;
se::Object* __jsb_cc_DepthStencilStateInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_DepthStencilStateInfo) 

static bool js_cc_DepthStencilStateInfo_depthTest_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthTest, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_depthTest_set) 

static bool js_cc_DepthStencilStateInfo_depthTest_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthTest, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthTest, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_depthTest_get) 

static bool js_cc_DepthStencilStateInfo_depthWrite_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthWrite, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_depthWrite_set) 

static bool js_cc_DepthStencilStateInfo_depthWrite_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthWrite, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthWrite, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_depthWrite_get) 

static bool js_cc_DepthStencilStateInfo_stencilTestFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilTestFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilTestFront_set) 

static bool js_cc_DepthStencilStateInfo_stencilTestFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilTestFront, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilTestFront, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilTestFront_get) 

static bool js_cc_DepthStencilStateInfo_stencilTestBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilTestBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilTestBack_set) 

static bool js_cc_DepthStencilStateInfo_stencilTestBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilTestBack, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilTestBack, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilTestBack_get) 

static bool js_cc_DepthStencilStateInfo_depthFunc_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthFunc, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_depthFunc_set) 

static bool js_cc_DepthStencilStateInfo_depthFunc_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthFunc, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthFunc, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_depthFunc_get) 

static bool js_cc_DepthStencilStateInfo_stencilFuncFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilFuncFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilFuncFront_set) 

static bool js_cc_DepthStencilStateInfo_stencilFuncFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilFuncFront, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilFuncFront, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilFuncFront_get) 

static bool js_cc_DepthStencilStateInfo_stencilReadMaskFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilReadMaskFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilReadMaskFront_set) 

static bool js_cc_DepthStencilStateInfo_stencilReadMaskFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilReadMaskFront, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilReadMaskFront, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilReadMaskFront_get) 

static bool js_cc_DepthStencilStateInfo_stencilWriteMaskFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilWriteMaskFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilWriteMaskFront_set) 

static bool js_cc_DepthStencilStateInfo_stencilWriteMaskFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilWriteMaskFront, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilWriteMaskFront, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilWriteMaskFront_get) 

static bool js_cc_DepthStencilStateInfo_stencilFailOpFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilFailOpFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilFailOpFront_set) 

static bool js_cc_DepthStencilStateInfo_stencilFailOpFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilFailOpFront, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilFailOpFront, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilFailOpFront_get) 

static bool js_cc_DepthStencilStateInfo_stencilZFailOpFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilZFailOpFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilZFailOpFront_set) 

static bool js_cc_DepthStencilStateInfo_stencilZFailOpFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilZFailOpFront, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilZFailOpFront, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilZFailOpFront_get) 

static bool js_cc_DepthStencilStateInfo_stencilPassOpFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilPassOpFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilPassOpFront_set) 

static bool js_cc_DepthStencilStateInfo_stencilPassOpFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilPassOpFront, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilPassOpFront, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilPassOpFront_get) 

static bool js_cc_DepthStencilStateInfo_stencilRefFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilRefFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilRefFront_set) 

static bool js_cc_DepthStencilStateInfo_stencilRefFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilRefFront, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilRefFront, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilRefFront_get) 

static bool js_cc_DepthStencilStateInfo_stencilFuncBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilFuncBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilFuncBack_set) 

static bool js_cc_DepthStencilStateInfo_stencilFuncBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilFuncBack, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilFuncBack, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilFuncBack_get) 

static bool js_cc_DepthStencilStateInfo_stencilReadMaskBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilReadMaskBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilReadMaskBack_set) 

static bool js_cc_DepthStencilStateInfo_stencilReadMaskBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilReadMaskBack, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilReadMaskBack, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilReadMaskBack_get) 

static bool js_cc_DepthStencilStateInfo_stencilWriteMaskBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilWriteMaskBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilWriteMaskBack_set) 

static bool js_cc_DepthStencilStateInfo_stencilWriteMaskBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilWriteMaskBack, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilWriteMaskBack, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilWriteMaskBack_get) 

static bool js_cc_DepthStencilStateInfo_stencilFailOpBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilFailOpBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilFailOpBack_set) 

static bool js_cc_DepthStencilStateInfo_stencilFailOpBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilFailOpBack, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilFailOpBack, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilFailOpBack_get) 

static bool js_cc_DepthStencilStateInfo_stencilZFailOpBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilZFailOpBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilZFailOpBack_set) 

static bool js_cc_DepthStencilStateInfo_stencilZFailOpBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilZFailOpBack, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilZFailOpBack, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilZFailOpBack_get) 

static bool js_cc_DepthStencilStateInfo_stencilPassOpBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilPassOpBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilPassOpBack_set) 

static bool js_cc_DepthStencilStateInfo_stencilPassOpBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilPassOpBack, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilPassOpBack, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilPassOpBack_get) 

static bool js_cc_DepthStencilStateInfo_stencilRefBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilRefBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DepthStencilStateInfo_stencilRefBack_set) 

static bool js_cc_DepthStencilStateInfo_stencilRefBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilRefBack, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilRefBack, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DepthStencilStateInfo_stencilRefBack_get) 

static bool js_cc_DepthStencilStateInfo_fromGFXDepthStencilState(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    cc::gfx::DepthStencilState *arg2 = 0 ;
    cc::gfx::DepthStencilState temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->fromGFXDepthStencilState((cc::gfx::DepthStencilState const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_DepthStencilStateInfo_fromGFXDepthStencilState) 

static bool js_cc_DepthStencilStateInfo_assignToGFXDepthStencilState(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DepthStencilStateInfo *arg1 = (cc::DepthStencilStateInfo *) NULL ;
    cc::gfx::DepthStencilState *arg2 = 0 ;
    cc::gfx::DepthStencilState temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::DepthStencilStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    ((cc::DepthStencilStateInfo const *)arg1)->assignToGFXDepthStencilState(*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_DepthStencilStateInfo_assignToGFXDepthStencilState) 

static bool js_new_cc_DepthStencilStateInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::DepthStencilStateInfo *result;
    result = (cc::DepthStencilStateInfo *)new cc::DepthStencilStateInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_DepthStencilStateInfo, __jsb_cc_DepthStencilStateInfo_class, js_delete_cc_DepthStencilStateInfo)

static bool js_delete_cc_DepthStencilStateInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_DepthStencilStateInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::DepthStencilStateInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::DepthStencilStateInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("depthTest", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthTest), ctx);
    }
    
    
    json->getProperty("depthWrite", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthWrite), ctx);
    }
    
    
    json->getProperty("stencilTestFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilTestFront), ctx);
    }
    
    
    json->getProperty("stencilTestBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilTestBack), ctx);
    }
    
    
    json->getProperty("depthFunc", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthFunc), ctx);
    }
    
    
    json->getProperty("stencilFuncFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilFuncFront), ctx);
    }
    
    
    json->getProperty("stencilReadMaskFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilReadMaskFront), ctx);
    }
    
    
    json->getProperty("stencilWriteMaskFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilWriteMaskFront), ctx);
    }
    
    
    json->getProperty("stencilFailOpFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilFailOpFront), ctx);
    }
    
    
    json->getProperty("stencilZFailOpFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilZFailOpFront), ctx);
    }
    
    
    json->getProperty("stencilPassOpFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilPassOpFront), ctx);
    }
    
    
    json->getProperty("stencilRefFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilRefFront), ctx);
    }
    
    
    json->getProperty("stencilFuncBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilFuncBack), ctx);
    }
    
    
    json->getProperty("stencilReadMaskBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilReadMaskBack), ctx);
    }
    
    
    json->getProperty("stencilWriteMaskBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilWriteMaskBack), ctx);
    }
    
    
    json->getProperty("stencilFailOpBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilFailOpBack), ctx);
    }
    
    
    json->getProperty("stencilZFailOpBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilZFailOpBack), ctx);
    }
    
    
    json->getProperty("stencilPassOpBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilPassOpBack), ctx);
    }
    
    
    json->getProperty("stencilRefBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilRefBack), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_DepthStencilStateInfo(se::Object* obj) {
    auto* cls = se::Class::create("DepthStencilStateInfo", obj, nullptr, _SE(js_new_cc_DepthStencilStateInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("depthTest", _SE(js_cc_DepthStencilStateInfo_depthTest_get), _SE(js_cc_DepthStencilStateInfo_depthTest_set)); 
    cls->defineProperty("depthWrite", _SE(js_cc_DepthStencilStateInfo_depthWrite_get), _SE(js_cc_DepthStencilStateInfo_depthWrite_set)); 
    cls->defineProperty("stencilTestFront", _SE(js_cc_DepthStencilStateInfo_stencilTestFront_get), _SE(js_cc_DepthStencilStateInfo_stencilTestFront_set)); 
    cls->defineProperty("stencilTestBack", _SE(js_cc_DepthStencilStateInfo_stencilTestBack_get), _SE(js_cc_DepthStencilStateInfo_stencilTestBack_set)); 
    cls->defineProperty("depthFunc", _SE(js_cc_DepthStencilStateInfo_depthFunc_get), _SE(js_cc_DepthStencilStateInfo_depthFunc_set)); 
    cls->defineProperty("stencilFuncFront", _SE(js_cc_DepthStencilStateInfo_stencilFuncFront_get), _SE(js_cc_DepthStencilStateInfo_stencilFuncFront_set)); 
    cls->defineProperty("stencilReadMaskFront", _SE(js_cc_DepthStencilStateInfo_stencilReadMaskFront_get), _SE(js_cc_DepthStencilStateInfo_stencilReadMaskFront_set)); 
    cls->defineProperty("stencilWriteMaskFront", _SE(js_cc_DepthStencilStateInfo_stencilWriteMaskFront_get), _SE(js_cc_DepthStencilStateInfo_stencilWriteMaskFront_set)); 
    cls->defineProperty("stencilFailOpFront", _SE(js_cc_DepthStencilStateInfo_stencilFailOpFront_get), _SE(js_cc_DepthStencilStateInfo_stencilFailOpFront_set)); 
    cls->defineProperty("stencilZFailOpFront", _SE(js_cc_DepthStencilStateInfo_stencilZFailOpFront_get), _SE(js_cc_DepthStencilStateInfo_stencilZFailOpFront_set)); 
    cls->defineProperty("stencilPassOpFront", _SE(js_cc_DepthStencilStateInfo_stencilPassOpFront_get), _SE(js_cc_DepthStencilStateInfo_stencilPassOpFront_set)); 
    cls->defineProperty("stencilRefFront", _SE(js_cc_DepthStencilStateInfo_stencilRefFront_get), _SE(js_cc_DepthStencilStateInfo_stencilRefFront_set)); 
    cls->defineProperty("stencilFuncBack", _SE(js_cc_DepthStencilStateInfo_stencilFuncBack_get), _SE(js_cc_DepthStencilStateInfo_stencilFuncBack_set)); 
    cls->defineProperty("stencilReadMaskBack", _SE(js_cc_DepthStencilStateInfo_stencilReadMaskBack_get), _SE(js_cc_DepthStencilStateInfo_stencilReadMaskBack_set)); 
    cls->defineProperty("stencilWriteMaskBack", _SE(js_cc_DepthStencilStateInfo_stencilWriteMaskBack_get), _SE(js_cc_DepthStencilStateInfo_stencilWriteMaskBack_set)); 
    cls->defineProperty("stencilFailOpBack", _SE(js_cc_DepthStencilStateInfo_stencilFailOpBack_get), _SE(js_cc_DepthStencilStateInfo_stencilFailOpBack_set)); 
    cls->defineProperty("stencilZFailOpBack", _SE(js_cc_DepthStencilStateInfo_stencilZFailOpBack_get), _SE(js_cc_DepthStencilStateInfo_stencilZFailOpBack_set)); 
    cls->defineProperty("stencilPassOpBack", _SE(js_cc_DepthStencilStateInfo_stencilPassOpBack_get), _SE(js_cc_DepthStencilStateInfo_stencilPassOpBack_set)); 
    cls->defineProperty("stencilRefBack", _SE(js_cc_DepthStencilStateInfo_stencilRefBack_get), _SE(js_cc_DepthStencilStateInfo_stencilRefBack_set)); 
    
    cls->defineFunction("fromGFXDepthStencilState", _SE(js_cc_DepthStencilStateInfo_fromGFXDepthStencilState)); 
    cls->defineFunction("assignToGFXDepthStencilState", _SE(js_cc_DepthStencilStateInfo_assignToGFXDepthStencilState)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_DepthStencilStateInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::DepthStencilStateInfo>(cls);
    
    __jsb_cc_DepthStencilStateInfo_proto = cls->getProto();
    __jsb_cc_DepthStencilStateInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_BlendTargetInfo_class = nullptr;
se::Object* __jsb_cc_BlendTargetInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_BlendTargetInfo) 

static bool js_cc_BlendTargetInfo_blend_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blend, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BlendTargetInfo_blend_set) 

static bool js_cc_BlendTargetInfo_blend_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blend, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blend, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BlendTargetInfo_blend_get) 

static bool js_cc_BlendTargetInfo_blendSrc_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blendSrc, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BlendTargetInfo_blendSrc_set) 

static bool js_cc_BlendTargetInfo_blendSrc_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blendSrc, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendSrc, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BlendTargetInfo_blendSrc_get) 

static bool js_cc_BlendTargetInfo_blendDst_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blendDst, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BlendTargetInfo_blendDst_set) 

static bool js_cc_BlendTargetInfo_blendDst_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blendDst, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendDst, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BlendTargetInfo_blendDst_get) 

static bool js_cc_BlendTargetInfo_blendEq_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blendEq, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BlendTargetInfo_blendEq_set) 

static bool js_cc_BlendTargetInfo_blendEq_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blendEq, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendEq, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BlendTargetInfo_blendEq_get) 

static bool js_cc_BlendTargetInfo_blendSrcAlpha_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blendSrcAlpha, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BlendTargetInfo_blendSrcAlpha_set) 

static bool js_cc_BlendTargetInfo_blendSrcAlpha_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blendSrcAlpha, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendSrcAlpha, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BlendTargetInfo_blendSrcAlpha_get) 

static bool js_cc_BlendTargetInfo_blendDstAlpha_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blendDstAlpha, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BlendTargetInfo_blendDstAlpha_set) 

static bool js_cc_BlendTargetInfo_blendDstAlpha_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blendDstAlpha, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendDstAlpha, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BlendTargetInfo_blendDstAlpha_get) 

static bool js_cc_BlendTargetInfo_blendAlphaEq_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blendAlphaEq, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BlendTargetInfo_blendAlphaEq_set) 

static bool js_cc_BlendTargetInfo_blendAlphaEq_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blendAlphaEq, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendAlphaEq, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BlendTargetInfo_blendAlphaEq_get) 

static bool js_cc_BlendTargetInfo_blendColorMask_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blendColorMask, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BlendTargetInfo_blendColorMask_set) 

static bool js_cc_BlendTargetInfo_blendColorMask_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blendColorMask, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendColorMask, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BlendTargetInfo_blendColorMask_get) 

static bool js_cc_BlendTargetInfo_fromGFXBlendTarget(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    cc::gfx::BlendTarget *arg2 = 0 ;
    cc::gfx::BlendTarget temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->fromGFXBlendTarget((cc::gfx::BlendTarget const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BlendTargetInfo_fromGFXBlendTarget) 

static bool js_cc_BlendTargetInfo_assignToGFXBlendTarget(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendTargetInfo *arg1 = (cc::BlendTargetInfo *) NULL ;
    cc::gfx::BlendTarget *arg2 = 0 ;
    cc::gfx::BlendTarget temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BlendTargetInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    ((cc::BlendTargetInfo const *)arg1)->assignToGFXBlendTarget(*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BlendTargetInfo_assignToGFXBlendTarget) 

static bool js_new_cc_BlendTargetInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::BlendTargetInfo *result;
    result = (cc::BlendTargetInfo *)new cc::BlendTargetInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_BlendTargetInfo, __jsb_cc_BlendTargetInfo_class, js_delete_cc_BlendTargetInfo)

static bool js_delete_cc_BlendTargetInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_BlendTargetInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::BlendTargetInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::BlendTargetInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("blend", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blend), ctx);
    }
    
    
    json->getProperty("blendSrc", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendSrc), ctx);
    }
    
    
    json->getProperty("blendDst", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendDst), ctx);
    }
    
    
    json->getProperty("blendEq", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendEq), ctx);
    }
    
    
    json->getProperty("blendSrcAlpha", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendSrcAlpha), ctx);
    }
    
    
    json->getProperty("blendDstAlpha", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendDstAlpha), ctx);
    }
    
    
    json->getProperty("blendAlphaEq", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendAlphaEq), ctx);
    }
    
    
    json->getProperty("blendColorMask", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendColorMask), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_BlendTargetInfo(se::Object* obj) {
    auto* cls = se::Class::create("BlendTargetInfo", obj, nullptr, _SE(js_new_cc_BlendTargetInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("blend", _SE(js_cc_BlendTargetInfo_blend_get), _SE(js_cc_BlendTargetInfo_blend_set)); 
    cls->defineProperty("blendSrc", _SE(js_cc_BlendTargetInfo_blendSrc_get), _SE(js_cc_BlendTargetInfo_blendSrc_set)); 
    cls->defineProperty("blendDst", _SE(js_cc_BlendTargetInfo_blendDst_get), _SE(js_cc_BlendTargetInfo_blendDst_set)); 
    cls->defineProperty("blendEq", _SE(js_cc_BlendTargetInfo_blendEq_get), _SE(js_cc_BlendTargetInfo_blendEq_set)); 
    cls->defineProperty("blendSrcAlpha", _SE(js_cc_BlendTargetInfo_blendSrcAlpha_get), _SE(js_cc_BlendTargetInfo_blendSrcAlpha_set)); 
    cls->defineProperty("blendDstAlpha", _SE(js_cc_BlendTargetInfo_blendDstAlpha_get), _SE(js_cc_BlendTargetInfo_blendDstAlpha_set)); 
    cls->defineProperty("blendAlphaEq", _SE(js_cc_BlendTargetInfo_blendAlphaEq_get), _SE(js_cc_BlendTargetInfo_blendAlphaEq_set)); 
    cls->defineProperty("blendColorMask", _SE(js_cc_BlendTargetInfo_blendColorMask_get), _SE(js_cc_BlendTargetInfo_blendColorMask_set)); 
    
    cls->defineFunction("fromGFXBlendTarget", _SE(js_cc_BlendTargetInfo_fromGFXBlendTarget)); 
    cls->defineFunction("assignToGFXBlendTarget", _SE(js_cc_BlendTargetInfo_assignToGFXBlendTarget)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_BlendTargetInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::BlendTargetInfo>(cls);
    
    __jsb_cc_BlendTargetInfo_proto = cls->getProto();
    __jsb_cc_BlendTargetInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_BlendStateInfo_class = nullptr;
se::Object* __jsb_cc_BlendStateInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_BlendStateInfo) 

static bool js_cc_BlendStateInfo_isA2C_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendStateInfo *arg1 = (cc::BlendStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->isA2C, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BlendStateInfo_isA2C_set) 

static bool js_cc_BlendStateInfo_isA2C_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BlendStateInfo *arg1 = (cc::BlendStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->isA2C, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->isA2C, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BlendStateInfo_isA2C_get) 

static bool js_cc_BlendStateInfo_isIndepend_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendStateInfo *arg1 = (cc::BlendStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->isIndepend, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BlendStateInfo_isIndepend_set) 

static bool js_cc_BlendStateInfo_isIndepend_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BlendStateInfo *arg1 = (cc::BlendStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->isIndepend, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->isIndepend, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BlendStateInfo_isIndepend_get) 

static bool js_cc_BlendStateInfo_blendColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendStateInfo *arg1 = (cc::BlendStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blendColor, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BlendStateInfo_blendColor_set) 

static bool js_cc_BlendStateInfo_blendColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BlendStateInfo *arg1 = (cc::BlendStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blendColor, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendColor, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BlendStateInfo_blendColor_get) 

static bool js_cc_BlendStateInfo_targets_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendStateInfo *arg1 = (cc::BlendStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->targets, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_BlendStateInfo_targets_set) 

static bool js_cc_BlendStateInfo_targets_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::BlendStateInfo *arg1 = (cc::BlendStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::BlendStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->targets, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->targets, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_BlendStateInfo_targets_get) 

static bool js_cc_BlendStateInfo_fromGFXBlendState(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendStateInfo *arg1 = (cc::BlendStateInfo *) NULL ;
    cc::gfx::BlendState *arg2 = 0 ;
    cc::gfx::BlendState temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BlendStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->fromGFXBlendState((cc::gfx::BlendState const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BlendStateInfo_fromGFXBlendState) 

static bool js_cc_BlendStateInfo_assignToGFXBlendState(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BlendStateInfo *arg1 = (cc::BlendStateInfo *) NULL ;
    cc::gfx::BlendState *arg2 = 0 ;
    cc::gfx::BlendState temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BlendStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    ((cc::BlendStateInfo const *)arg1)->assignToGFXBlendState(*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BlendStateInfo_assignToGFXBlendState) 

static bool js_new_cc_BlendStateInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::BlendStateInfo *result;
    result = (cc::BlendStateInfo *)new cc::BlendStateInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_BlendStateInfo, __jsb_cc_BlendStateInfo_class, js_delete_cc_BlendStateInfo)

static bool js_delete_cc_BlendStateInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_BlendStateInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::BlendStateInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::BlendStateInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("isA2C", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isA2C), ctx);
    }
    
    
    json->getProperty("isIndepend", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isIndepend), ctx);
    }
    
    
    json->getProperty("blendColor", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendColor), ctx);
    }
    
    
    json->getProperty("targets", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->targets), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_BlendStateInfo(se::Object* obj) {
    auto* cls = se::Class::create("BlendStateInfo", obj, nullptr, _SE(js_new_cc_BlendStateInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("isA2C", _SE(js_cc_BlendStateInfo_isA2C_get), _SE(js_cc_BlendStateInfo_isA2C_set)); 
    cls->defineProperty("isIndepend", _SE(js_cc_BlendStateInfo_isIndepend_get), _SE(js_cc_BlendStateInfo_isIndepend_set)); 
    cls->defineProperty("blendColor", _SE(js_cc_BlendStateInfo_blendColor_get), _SE(js_cc_BlendStateInfo_blendColor_set)); 
    cls->defineProperty("targets", _SE(js_cc_BlendStateInfo_targets_get), _SE(js_cc_BlendStateInfo_targets_set)); 
    
    cls->defineFunction("fromGFXBlendState", _SE(js_cc_BlendStateInfo_fromGFXBlendState)); 
    cls->defineFunction("assignToGFXBlendState", _SE(js_cc_BlendStateInfo_assignToGFXBlendState)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_BlendStateInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::BlendStateInfo>(cls);
    
    __jsb_cc_BlendStateInfo_proto = cls->getProto();
    __jsb_cc_BlendStateInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IPassStates_class = nullptr;
se::Object* __jsb_cc_IPassStates_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IPassStates) 

static bool js_cc_IPassStates_priority_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->priority, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassStates_priority_set) 

static bool js_cc_IPassStates_priority_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->priority, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->priority, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassStates_priority_get) 

static bool js_cc_IPassStates_primitive_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->primitive, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassStates_primitive_set) 

static bool js_cc_IPassStates_primitive_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->primitive, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->primitive, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassStates_primitive_get) 

static bool js_cc_IPassStates_stage_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stage, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassStates_stage_set) 

static bool js_cc_IPassStates_stage_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stage, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stage, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassStates_stage_get) 

static bool js_cc_IPassStates_rasterizerState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->rasterizerState, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassStates_rasterizerState_set) 

static bool js_cc_IPassStates_rasterizerState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->rasterizerState, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->rasterizerState, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassStates_rasterizerState_get) 

static bool js_cc_IPassStates_depthStencilState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthStencilState, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassStates_depthStencilState_set) 

static bool js_cc_IPassStates_depthStencilState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthStencilState, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthStencilState, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassStates_depthStencilState_get) 

static bool js_cc_IPassStates_blendState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blendState, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassStates_blendState_set) 

static bool js_cc_IPassStates_blendState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blendState, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendState, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassStates_blendState_get) 

static bool js_cc_IPassStates_dynamicStates_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->dynamicStates, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassStates_dynamicStates_set) 

static bool js_cc_IPassStates_dynamicStates_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->dynamicStates, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->dynamicStates, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassStates_dynamicStates_get) 

static bool js_cc_IPassStates_phase_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->phase, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassStates_phase_set) 

static bool js_cc_IPassStates_phase_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->phase, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->phase, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassStates_phase_get) 

static bool js_cc_IPassStates_pass_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->pass, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassStates_pass_set) 

static bool js_cc_IPassStates_pass_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->pass, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->pass, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassStates_pass_get) 

static bool js_new_cc_IPassStates__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::IPassStates *result;
    result = (cc::IPassStates *)new cc::IPassStates();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_IPassStates__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = 0 ;
    cc::IPassInfoFull temp1 ;
    cc::IPassStates *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = (cc::IPassStates *)new cc::IPassStates((cc::IPassInfoFull const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_IPassStates(se::State& s) // NOLINT(readability-identifier-naming)
{
    size_t argc = s.args().size();
    bool ret = false;
    
    if(argc == 0) {
        ret = js_new_cc_IPassStates__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 1) {
        ret = js_new_cc_IPassStates__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    SE_REPORT_ERROR("Illegal arguments for construction of IPassStates");
    return false;
}
SE_BIND_CTOR(js_new_IPassStates, __jsb_cc_IPassStates_class, js_delete_cc_IPassStates)

static bool js_cc_IPassStates_overrides(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassStates *arg1 = (cc::IPassStates *) NULL ;
    cc::IPassInfoFull *arg2 = 0 ;
    cc::IPassInfoFull temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::IPassStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->overrides((cc::IPassInfoFull const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_IPassStates_overrides) 

static bool js_delete_cc_IPassStates(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IPassStates) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IPassStates * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IPassStates*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("priority", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->priority), ctx);
    }
    
    
    json->getProperty("primitive", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->primitive), ctx);
    }
    
    
    json->getProperty("stage", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stage), ctx);
    }
    
    
    json->getProperty("rasterizerState", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->rasterizerState), ctx);
    }
    
    
    json->getProperty("depthStencilState", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthStencilState), ctx);
    }
    
    
    json->getProperty("blendState", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendState), ctx);
    }
    
    
    json->getProperty("dynamicStates", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dynamicStates), ctx);
    }
    
    
    json->getProperty("phase", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->phase), ctx);
    }
    
    
    json->getProperty("pass", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->pass), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IPassStates(se::Object* obj) {
    auto* cls = se::Class::create("IPassStates", obj, nullptr, _SE(js_new_IPassStates)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("priority", _SE(js_cc_IPassStates_priority_get), _SE(js_cc_IPassStates_priority_set)); 
    cls->defineProperty("primitive", _SE(js_cc_IPassStates_primitive_get), _SE(js_cc_IPassStates_primitive_set)); 
    cls->defineProperty("stage", _SE(js_cc_IPassStates_stage_get), _SE(js_cc_IPassStates_stage_set)); 
    cls->defineProperty("rasterizerState", _SE(js_cc_IPassStates_rasterizerState_get), _SE(js_cc_IPassStates_rasterizerState_set)); 
    cls->defineProperty("depthStencilState", _SE(js_cc_IPassStates_depthStencilState_get), _SE(js_cc_IPassStates_depthStencilState_set)); 
    cls->defineProperty("blendState", _SE(js_cc_IPassStates_blendState_get), _SE(js_cc_IPassStates_blendState_set)); 
    cls->defineProperty("dynamicStates", _SE(js_cc_IPassStates_dynamicStates_get), _SE(js_cc_IPassStates_dynamicStates_set)); 
    cls->defineProperty("phase", _SE(js_cc_IPassStates_phase_get), _SE(js_cc_IPassStates_phase_set)); 
    cls->defineProperty("pass", _SE(js_cc_IPassStates_pass_get), _SE(js_cc_IPassStates_pass_set)); 
    
    cls->defineFunction("overrides", _SE(js_cc_IPassStates_overrides)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IPassStates));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IPassStates>(cls);
    
    __jsb_cc_IPassStates_proto = cls->getProto();
    __jsb_cc_IPassStates_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IPassInfoFull_class = nullptr;
se::Object* __jsb_cc_IPassInfoFull_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IPassInfoFull) 

static bool js_cc_IPassInfoFull_priority_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->priority, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_priority_set) 

static bool js_cc_IPassInfoFull_priority_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->priority, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->priority, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_priority_get) 

static bool js_cc_IPassInfoFull_primitive_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->primitive, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_primitive_set) 

static bool js_cc_IPassInfoFull_primitive_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->primitive, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->primitive, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_primitive_get) 

static bool js_cc_IPassInfoFull_stage_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stage, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_stage_set) 

static bool js_cc_IPassInfoFull_stage_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stage, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stage, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_stage_get) 

static bool js_cc_IPassInfoFull_rasterizerState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->rasterizerState, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_rasterizerState_set) 

static bool js_cc_IPassInfoFull_rasterizerState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->rasterizerState, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->rasterizerState, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_rasterizerState_get) 

static bool js_cc_IPassInfoFull_depthStencilState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthStencilState, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_depthStencilState_set) 

static bool js_cc_IPassInfoFull_depthStencilState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthStencilState, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthStencilState, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_depthStencilState_get) 

static bool js_cc_IPassInfoFull_blendState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blendState, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_blendState_set) 

static bool js_cc_IPassInfoFull_blendState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blendState, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendState, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_blendState_get) 

static bool js_cc_IPassInfoFull_dynamicStates_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->dynamicStates, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_dynamicStates_set) 

static bool js_cc_IPassInfoFull_dynamicStates_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->dynamicStates, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->dynamicStates, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_dynamicStates_get) 

static bool js_cc_IPassInfoFull_phase_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->phase, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_phase_set) 

static bool js_cc_IPassInfoFull_phase_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->phase, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->phase, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_phase_get) 

static bool js_cc_IPassInfoFull_pass_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->pass, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_pass_set) 

static bool js_cc_IPassInfoFull_pass_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->pass, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->pass, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_pass_get) 

static bool js_cc_IPassInfoFull_program_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->program, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_program_set) 

static bool js_cc_IPassInfoFull_program_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->program, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->program, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_program_get) 

static bool js_cc_IPassInfoFull_embeddedMacros_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->embeddedMacros, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_embeddedMacros_set) 

static bool js_cc_IPassInfoFull_embeddedMacros_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->embeddedMacros, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->embeddedMacros, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_embeddedMacros_get) 

static bool js_cc_IPassInfoFull_propertyIndex_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->propertyIndex, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_propertyIndex_set) 

static bool js_cc_IPassInfoFull_propertyIndex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->propertyIndex, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->propertyIndex, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_propertyIndex_get) 

static bool js_cc_IPassInfoFull_cpp_keyword_switch_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->switch_, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_cpp_keyword_switch_set) 

static bool js_cc_IPassInfoFull_cpp_keyword_switch_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->switch_, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->switch_, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_cpp_keyword_switch_get) 

static bool js_cc_IPassInfoFull_properties_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->properties, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_properties_set) 

static bool js_cc_IPassInfoFull_properties_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->properties, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->properties, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_properties_get) 

static bool js_cc_IPassInfoFull_passIndex_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->passIndex, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_passIndex_set) 

static bool js_cc_IPassInfoFull_passIndex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->passIndex, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_passIndex_get) 

static bool js_cc_IPassInfoFull_defines_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->defines, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_defines_set) 

static bool js_cc_IPassInfoFull_defines_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->defines, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->defines, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_defines_get) 

static bool js_cc_IPassInfoFull_stateOverrides_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stateOverrides, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IPassInfoFull_stateOverrides_set) 

static bool js_cc_IPassInfoFull_stateOverrides_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *arg1 = (cc::IPassInfoFull *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IPassInfoFull>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stateOverrides, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stateOverrides, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IPassInfoFull_stateOverrides_get) 

static bool js_new_cc_IPassInfoFull__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::IPassInfoFull *result;
    result = (cc::IPassInfoFull *)new cc::IPassInfoFull();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_IPassInfoFull__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::IPassStates *arg1 = 0 ;
    cc::IPassStates temp1 ;
    cc::IPassInfoFull *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = (cc::IPassInfoFull *)new cc::IPassInfoFull((cc::IPassStates const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_IPassInfoFull(se::State& s) // NOLINT(readability-identifier-naming)
{
    size_t argc = s.args().size();
    bool ret = false;
    
    if(argc == 0) {
        ret = js_new_cc_IPassInfoFull__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 1) {
        ret = js_new_cc_IPassInfoFull__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    SE_REPORT_ERROR("Illegal arguments for construction of IPassInfoFull");
    return false;
}
SE_BIND_CTOR(js_new_IPassInfoFull, __jsb_cc_IPassInfoFull_class, js_delete_cc_IPassInfoFull)

static bool js_delete_cc_IPassInfoFull(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IPassInfoFull) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IPassInfoFull * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IPassInfoFull*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("priority", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->priority), ctx);
    }
    
    
    json->getProperty("primitive", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->primitive), ctx);
    }
    
    
    json->getProperty("stage", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stage), ctx);
    }
    
    
    json->getProperty("rasterizerState", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->rasterizerState), ctx);
    }
    
    
    json->getProperty("depthStencilState", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthStencilState), ctx);
    }
    
    
    json->getProperty("blendState", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendState), ctx);
    }
    
    
    json->getProperty("dynamicStates", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dynamicStates), ctx);
    }
    
    
    json->getProperty("phase", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->phase), ctx);
    }
    
    
    json->getProperty("pass", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->pass), ctx);
    }
    
    
    json->getProperty("program", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->program), ctx);
    }
    
    
    json->getProperty("embeddedMacros", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->embeddedMacros), ctx);
    }
    
    
    json->getProperty("propertyIndex", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->propertyIndex), ctx);
    }
    
    
    json->getProperty("switch", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->switch_), ctx);
    }
    
    
    json->getProperty("properties", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->properties), ctx);
    }
    
    
    json->getProperty("passIndex", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->passIndex), ctx);
    }
    
    
    json->getProperty("defines", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->defines), ctx);
    }
    
    
    json->getProperty("stateOverrides", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stateOverrides), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IPassInfoFull(se::Object* obj) {
    auto* cls = se::Class::create("IPassInfoFull", obj, nullptr, _SE(js_new_IPassInfoFull)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("priority", _SE(js_cc_IPassInfoFull_priority_get), _SE(js_cc_IPassInfoFull_priority_set)); 
    cls->defineProperty("primitive", _SE(js_cc_IPassInfoFull_primitive_get), _SE(js_cc_IPassInfoFull_primitive_set)); 
    cls->defineProperty("stage", _SE(js_cc_IPassInfoFull_stage_get), _SE(js_cc_IPassInfoFull_stage_set)); 
    cls->defineProperty("rasterizerState", _SE(js_cc_IPassInfoFull_rasterizerState_get), _SE(js_cc_IPassInfoFull_rasterizerState_set)); 
    cls->defineProperty("depthStencilState", _SE(js_cc_IPassInfoFull_depthStencilState_get), _SE(js_cc_IPassInfoFull_depthStencilState_set)); 
    cls->defineProperty("blendState", _SE(js_cc_IPassInfoFull_blendState_get), _SE(js_cc_IPassInfoFull_blendState_set)); 
    cls->defineProperty("dynamicStates", _SE(js_cc_IPassInfoFull_dynamicStates_get), _SE(js_cc_IPassInfoFull_dynamicStates_set)); 
    cls->defineProperty("phase", _SE(js_cc_IPassInfoFull_phase_get), _SE(js_cc_IPassInfoFull_phase_set)); 
    cls->defineProperty("pass", _SE(js_cc_IPassInfoFull_pass_get), _SE(js_cc_IPassInfoFull_pass_set)); 
    cls->defineProperty("program", _SE(js_cc_IPassInfoFull_program_get), _SE(js_cc_IPassInfoFull_program_set)); 
    cls->defineProperty("embeddedMacros", _SE(js_cc_IPassInfoFull_embeddedMacros_get), _SE(js_cc_IPassInfoFull_embeddedMacros_set)); 
    cls->defineProperty("propertyIndex", _SE(js_cc_IPassInfoFull_propertyIndex_get), _SE(js_cc_IPassInfoFull_propertyIndex_set)); 
    cls->defineProperty("switch", _SE(js_cc_IPassInfoFull_cpp_keyword_switch_get), _SE(js_cc_IPassInfoFull_cpp_keyword_switch_set)); 
    cls->defineProperty("properties", _SE(js_cc_IPassInfoFull_properties_get), _SE(js_cc_IPassInfoFull_properties_set)); 
    cls->defineProperty("passIndex", _SE(js_cc_IPassInfoFull_passIndex_get), _SE(js_cc_IPassInfoFull_passIndex_set)); 
    cls->defineProperty("defines", _SE(js_cc_IPassInfoFull_defines_get), _SE(js_cc_IPassInfoFull_defines_set)); 
    cls->defineProperty("stateOverrides", _SE(js_cc_IPassInfoFull_stateOverrides_get), _SE(js_cc_IPassInfoFull_stateOverrides_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IPassInfoFull));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IPassInfoFull>(cls);
    
    __jsb_cc_IPassInfoFull_proto = cls->getProto();
    __jsb_cc_IPassInfoFull_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_ITechniqueInfo_class = nullptr;
se::Object* __jsb_cc_ITechniqueInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_ITechniqueInfo) 

static bool js_cc_ITechniqueInfo_passes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITechniqueInfo *arg1 = (cc::ITechniqueInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITechniqueInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->passes, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITechniqueInfo_passes_set) 

static bool js_cc_ITechniqueInfo_passes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITechniqueInfo *arg1 = (cc::ITechniqueInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITechniqueInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->passes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->passes, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITechniqueInfo_passes_get) 

static bool js_cc_ITechniqueInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITechniqueInfo *arg1 = (cc::ITechniqueInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITechniqueInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITechniqueInfo_name_set) 

static bool js_cc_ITechniqueInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITechniqueInfo *arg1 = (cc::ITechniqueInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITechniqueInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITechniqueInfo_name_get) 

static bool js_new_cc_ITechniqueInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::ITechniqueInfo *result;
    result = (cc::ITechniqueInfo *)new cc::ITechniqueInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_ITechniqueInfo, __jsb_cc_ITechniqueInfo_class, js_delete_cc_ITechniqueInfo)

static bool js_delete_cc_ITechniqueInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_ITechniqueInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::ITechniqueInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::ITechniqueInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("passes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->passes), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_ITechniqueInfo(se::Object* obj) {
    auto* cls = se::Class::create("ITechniqueInfo", obj, nullptr, _SE(js_new_cc_ITechniqueInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("passes", _SE(js_cc_ITechniqueInfo_passes_get), _SE(js_cc_ITechniqueInfo_passes_set)); 
    cls->defineProperty("name", _SE(js_cc_ITechniqueInfo_name_get), _SE(js_cc_ITechniqueInfo_name_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_ITechniqueInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::ITechniqueInfo>(cls);
    
    __jsb_cc_ITechniqueInfo_proto = cls->getProto();
    __jsb_cc_ITechniqueInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IBlockInfo_class = nullptr;
se::Object* __jsb_cc_IBlockInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IBlockInfo) 

static bool js_cc_IBlockInfo_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBlockInfo *arg1 = (cc::IBlockInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBlockInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBlockInfo_binding_set) 

static bool js_cc_IBlockInfo_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBlockInfo *arg1 = (cc::IBlockInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBlockInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBlockInfo_binding_get) 

static bool js_cc_IBlockInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBlockInfo *arg1 = (cc::IBlockInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBlockInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBlockInfo_name_set) 

static bool js_cc_IBlockInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBlockInfo *arg1 = (cc::IBlockInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBlockInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBlockInfo_name_get) 

static bool js_cc_IBlockInfo_members_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBlockInfo *arg1 = (cc::IBlockInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBlockInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->members, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBlockInfo_members_set) 

static bool js_cc_IBlockInfo_members_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBlockInfo *arg1 = (cc::IBlockInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBlockInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->members, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->members, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBlockInfo_members_get) 

static bool js_cc_IBlockInfo_stageFlags_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBlockInfo *arg1 = (cc::IBlockInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBlockInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stageFlags, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBlockInfo_stageFlags_set) 

static bool js_cc_IBlockInfo_stageFlags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBlockInfo *arg1 = (cc::IBlockInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBlockInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stageFlags, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stageFlags, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBlockInfo_stageFlags_get) 

static bool js_cc_IBlockInfo_defines_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBlockInfo *arg1 = (cc::IBlockInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBlockInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->defines, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBlockInfo_defines_set) 

static bool js_cc_IBlockInfo_defines_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBlockInfo *arg1 = (cc::IBlockInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBlockInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->defines, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->defines, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBlockInfo_defines_get) 

static bool js_new_cc_IBlockInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IBlockInfo *result;
    result = (cc::IBlockInfo *)new cc::IBlockInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IBlockInfo, __jsb_cc_IBlockInfo_class, js_delete_cc_IBlockInfo)

static bool js_delete_cc_IBlockInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IBlockInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IBlockInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IBlockInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("members", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->members), ctx);
    }
    
    
    json->getProperty("stageFlags", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stageFlags), ctx);
    }
    
    
    json->getProperty("defines", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->defines), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IBlockInfo(se::Object* obj) {
    auto* cls = se::Class::create("IBlockInfo", obj, nullptr, _SE(js_new_cc_IBlockInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("binding", _SE(js_cc_IBlockInfo_binding_get), _SE(js_cc_IBlockInfo_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_IBlockInfo_name_get), _SE(js_cc_IBlockInfo_name_set)); 
    cls->defineProperty("members", _SE(js_cc_IBlockInfo_members_get), _SE(js_cc_IBlockInfo_members_set)); 
    cls->defineProperty("stageFlags", _SE(js_cc_IBlockInfo_stageFlags_get), _SE(js_cc_IBlockInfo_stageFlags_set)); 
    cls->defineProperty("defines", _SE(js_cc_IBlockInfo_defines_get), _SE(js_cc_IBlockInfo_defines_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IBlockInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IBlockInfo>(cls);
    
    __jsb_cc_IBlockInfo_proto = cls->getProto();
    __jsb_cc_IBlockInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_ISamplerTextureInfo_class = nullptr;
se::Object* __jsb_cc_ISamplerTextureInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_ISamplerTextureInfo) 

static bool js_cc_ISamplerTextureInfo_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ISamplerTextureInfo *arg1 = (cc::ISamplerTextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerTextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ISamplerTextureInfo_binding_set) 

static bool js_cc_ISamplerTextureInfo_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ISamplerTextureInfo *arg1 = (cc::ISamplerTextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerTextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ISamplerTextureInfo_binding_get) 

static bool js_cc_ISamplerTextureInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ISamplerTextureInfo *arg1 = (cc::ISamplerTextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerTextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ISamplerTextureInfo_name_set) 

static bool js_cc_ISamplerTextureInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ISamplerTextureInfo *arg1 = (cc::ISamplerTextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerTextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ISamplerTextureInfo_name_get) 

static bool js_cc_ISamplerTextureInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ISamplerTextureInfo *arg1 = (cc::ISamplerTextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerTextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->type, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ISamplerTextureInfo_type_set) 

static bool js_cc_ISamplerTextureInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ISamplerTextureInfo *arg1 = (cc::ISamplerTextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerTextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->type, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->type, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ISamplerTextureInfo_type_get) 

static bool js_cc_ISamplerTextureInfo_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ISamplerTextureInfo *arg1 = (cc::ISamplerTextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerTextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ISamplerTextureInfo_count_set) 

static bool js_cc_ISamplerTextureInfo_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ISamplerTextureInfo *arg1 = (cc::ISamplerTextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerTextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ISamplerTextureInfo_count_get) 

static bool js_cc_ISamplerTextureInfo_stageFlags_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ISamplerTextureInfo *arg1 = (cc::ISamplerTextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerTextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stageFlags, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ISamplerTextureInfo_stageFlags_set) 

static bool js_cc_ISamplerTextureInfo_stageFlags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ISamplerTextureInfo *arg1 = (cc::ISamplerTextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerTextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stageFlags, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stageFlags, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ISamplerTextureInfo_stageFlags_get) 

static bool js_cc_ISamplerTextureInfo_defines_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ISamplerTextureInfo *arg1 = (cc::ISamplerTextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerTextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->defines, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ISamplerTextureInfo_defines_set) 

static bool js_cc_ISamplerTextureInfo_defines_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ISamplerTextureInfo *arg1 = (cc::ISamplerTextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerTextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->defines, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->defines, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ISamplerTextureInfo_defines_get) 

static bool js_new_cc_ISamplerTextureInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::ISamplerTextureInfo *result;
    result = (cc::ISamplerTextureInfo *)new cc::ISamplerTextureInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_ISamplerTextureInfo, __jsb_cc_ISamplerTextureInfo_class, js_delete_cc_ISamplerTextureInfo)

static bool js_delete_cc_ISamplerTextureInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_ISamplerTextureInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::ISamplerTextureInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::ISamplerTextureInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("stageFlags", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stageFlags), ctx);
    }
    
    
    json->getProperty("defines", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->defines), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_ISamplerTextureInfo(se::Object* obj) {
    auto* cls = se::Class::create("ISamplerTextureInfo", obj, nullptr, _SE(js_new_cc_ISamplerTextureInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("binding", _SE(js_cc_ISamplerTextureInfo_binding_get), _SE(js_cc_ISamplerTextureInfo_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_ISamplerTextureInfo_name_get), _SE(js_cc_ISamplerTextureInfo_name_set)); 
    cls->defineProperty("type", _SE(js_cc_ISamplerTextureInfo_type_get), _SE(js_cc_ISamplerTextureInfo_type_set)); 
    cls->defineProperty("count", _SE(js_cc_ISamplerTextureInfo_count_get), _SE(js_cc_ISamplerTextureInfo_count_set)); 
    cls->defineProperty("stageFlags", _SE(js_cc_ISamplerTextureInfo_stageFlags_get), _SE(js_cc_ISamplerTextureInfo_stageFlags_set)); 
    cls->defineProperty("defines", _SE(js_cc_ISamplerTextureInfo_defines_get), _SE(js_cc_ISamplerTextureInfo_defines_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_ISamplerTextureInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::ISamplerTextureInfo>(cls);
    
    __jsb_cc_ISamplerTextureInfo_proto = cls->getProto();
    __jsb_cc_ISamplerTextureInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_ITextureInfo_class = nullptr;
se::Object* __jsb_cc_ITextureInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_ITextureInfo) 

static bool js_cc_ITextureInfo_set_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureInfo *arg1 = (cc::ITextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->set, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureInfo_set_set) 

static bool js_cc_ITextureInfo_set_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureInfo *arg1 = (cc::ITextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->set, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureInfo_set_get) 

static bool js_cc_ITextureInfo_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureInfo *arg1 = (cc::ITextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureInfo_binding_set) 

static bool js_cc_ITextureInfo_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureInfo *arg1 = (cc::ITextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureInfo_binding_get) 

static bool js_cc_ITextureInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureInfo *arg1 = (cc::ITextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureInfo_name_set) 

static bool js_cc_ITextureInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureInfo *arg1 = (cc::ITextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureInfo_name_get) 

static bool js_cc_ITextureInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureInfo *arg1 = (cc::ITextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->type, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureInfo_type_set) 

static bool js_cc_ITextureInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureInfo *arg1 = (cc::ITextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->type, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->type, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureInfo_type_get) 

static bool js_cc_ITextureInfo_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureInfo *arg1 = (cc::ITextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureInfo_count_set) 

static bool js_cc_ITextureInfo_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureInfo *arg1 = (cc::ITextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureInfo_count_get) 

static bool js_cc_ITextureInfo_stageFlags_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ITextureInfo *arg1 = (cc::ITextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stageFlags, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ITextureInfo_stageFlags_set) 

static bool js_cc_ITextureInfo_stageFlags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ITextureInfo *arg1 = (cc::ITextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ITextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stageFlags, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stageFlags, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ITextureInfo_stageFlags_get) 

static bool js_new_cc_ITextureInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::ITextureInfo *result;
    result = (cc::ITextureInfo *)new cc::ITextureInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_ITextureInfo, __jsb_cc_ITextureInfo_class, js_delete_cc_ITextureInfo)

static bool js_delete_cc_ITextureInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_ITextureInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::ITextureInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::ITextureInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("set", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->set), ctx);
    }
    
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("stageFlags", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stageFlags), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_ITextureInfo(se::Object* obj) {
    auto* cls = se::Class::create("ITextureInfo", obj, nullptr, _SE(js_new_cc_ITextureInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("set", _SE(js_cc_ITextureInfo_set_get), _SE(js_cc_ITextureInfo_set_set)); 
    cls->defineProperty("binding", _SE(js_cc_ITextureInfo_binding_get), _SE(js_cc_ITextureInfo_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_ITextureInfo_name_get), _SE(js_cc_ITextureInfo_name_set)); 
    cls->defineProperty("type", _SE(js_cc_ITextureInfo_type_get), _SE(js_cc_ITextureInfo_type_set)); 
    cls->defineProperty("count", _SE(js_cc_ITextureInfo_count_get), _SE(js_cc_ITextureInfo_count_set)); 
    cls->defineProperty("stageFlags", _SE(js_cc_ITextureInfo_stageFlags_get), _SE(js_cc_ITextureInfo_stageFlags_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_ITextureInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::ITextureInfo>(cls);
    
    __jsb_cc_ITextureInfo_proto = cls->getProto();
    __jsb_cc_ITextureInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_ISamplerInfo_class = nullptr;
se::Object* __jsb_cc_ISamplerInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_ISamplerInfo) 

static bool js_cc_ISamplerInfo_set_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ISamplerInfo *arg1 = (cc::ISamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->set, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ISamplerInfo_set_set) 

static bool js_cc_ISamplerInfo_set_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ISamplerInfo *arg1 = (cc::ISamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->set, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ISamplerInfo_set_get) 

static bool js_cc_ISamplerInfo_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ISamplerInfo *arg1 = (cc::ISamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ISamplerInfo_binding_set) 

static bool js_cc_ISamplerInfo_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ISamplerInfo *arg1 = (cc::ISamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ISamplerInfo_binding_get) 

static bool js_cc_ISamplerInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ISamplerInfo *arg1 = (cc::ISamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ISamplerInfo_name_set) 

static bool js_cc_ISamplerInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ISamplerInfo *arg1 = (cc::ISamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ISamplerInfo_name_get) 

static bool js_cc_ISamplerInfo_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ISamplerInfo *arg1 = (cc::ISamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ISamplerInfo_count_set) 

static bool js_cc_ISamplerInfo_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ISamplerInfo *arg1 = (cc::ISamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ISamplerInfo_count_get) 

static bool js_cc_ISamplerInfo_stageFlags_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ISamplerInfo *arg1 = (cc::ISamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stageFlags, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ISamplerInfo_stageFlags_set) 

static bool js_cc_ISamplerInfo_stageFlags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ISamplerInfo *arg1 = (cc::ISamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ISamplerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stageFlags, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stageFlags, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ISamplerInfo_stageFlags_get) 

static bool js_new_cc_ISamplerInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::ISamplerInfo *result;
    result = (cc::ISamplerInfo *)new cc::ISamplerInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_ISamplerInfo, __jsb_cc_ISamplerInfo_class, js_delete_cc_ISamplerInfo)

static bool js_delete_cc_ISamplerInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_ISamplerInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::ISamplerInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::ISamplerInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("set", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->set), ctx);
    }
    
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("stageFlags", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stageFlags), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_ISamplerInfo(se::Object* obj) {
    auto* cls = se::Class::create("ISamplerInfo", obj, nullptr, _SE(js_new_cc_ISamplerInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("set", _SE(js_cc_ISamplerInfo_set_get), _SE(js_cc_ISamplerInfo_set_set)); 
    cls->defineProperty("binding", _SE(js_cc_ISamplerInfo_binding_get), _SE(js_cc_ISamplerInfo_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_ISamplerInfo_name_get), _SE(js_cc_ISamplerInfo_name_set)); 
    cls->defineProperty("count", _SE(js_cc_ISamplerInfo_count_get), _SE(js_cc_ISamplerInfo_count_set)); 
    cls->defineProperty("stageFlags", _SE(js_cc_ISamplerInfo_stageFlags_get), _SE(js_cc_ISamplerInfo_stageFlags_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_ISamplerInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::ISamplerInfo>(cls);
    
    __jsb_cc_ISamplerInfo_proto = cls->getProto();
    __jsb_cc_ISamplerInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IBufferInfo_class = nullptr;
se::Object* __jsb_cc_IBufferInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IBufferInfo) 

static bool js_cc_IBufferInfo_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBufferInfo *arg1 = (cc::IBufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBufferInfo_binding_set) 

static bool js_cc_IBufferInfo_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBufferInfo *arg1 = (cc::IBufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBufferInfo_binding_get) 

static bool js_cc_IBufferInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBufferInfo *arg1 = (cc::IBufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBufferInfo_name_set) 

static bool js_cc_IBufferInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBufferInfo *arg1 = (cc::IBufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBufferInfo_name_get) 

static bool js_cc_IBufferInfo_memoryAccess_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBufferInfo *arg1 = (cc::IBufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->memoryAccess, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBufferInfo_memoryAccess_set) 

static bool js_cc_IBufferInfo_memoryAccess_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBufferInfo *arg1 = (cc::IBufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->memoryAccess, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->memoryAccess, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBufferInfo_memoryAccess_get) 

static bool js_cc_IBufferInfo_stageFlags_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBufferInfo *arg1 = (cc::IBufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stageFlags, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBufferInfo_stageFlags_set) 

static bool js_cc_IBufferInfo_stageFlags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBufferInfo *arg1 = (cc::IBufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stageFlags, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stageFlags, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBufferInfo_stageFlags_get) 

static bool js_new_cc_IBufferInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IBufferInfo *result;
    result = (cc::IBufferInfo *)new cc::IBufferInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IBufferInfo, __jsb_cc_IBufferInfo_class, js_delete_cc_IBufferInfo)

static bool js_delete_cc_IBufferInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IBufferInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IBufferInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IBufferInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("memoryAccess", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->memoryAccess), ctx);
    }
    
    
    json->getProperty("stageFlags", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stageFlags), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IBufferInfo(se::Object* obj) {
    auto* cls = se::Class::create("IBufferInfo", obj, nullptr, _SE(js_new_cc_IBufferInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("binding", _SE(js_cc_IBufferInfo_binding_get), _SE(js_cc_IBufferInfo_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_IBufferInfo_name_get), _SE(js_cc_IBufferInfo_name_set)); 
    cls->defineProperty("memoryAccess", _SE(js_cc_IBufferInfo_memoryAccess_get), _SE(js_cc_IBufferInfo_memoryAccess_set)); 
    cls->defineProperty("stageFlags", _SE(js_cc_IBufferInfo_stageFlags_get), _SE(js_cc_IBufferInfo_stageFlags_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IBufferInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IBufferInfo>(cls);
    
    __jsb_cc_IBufferInfo_proto = cls->getProto();
    __jsb_cc_IBufferInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IImageInfo_class = nullptr;
se::Object* __jsb_cc_IImageInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IImageInfo) 

static bool js_cc_IImageInfo_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IImageInfo *arg1 = (cc::IImageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IImageInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IImageInfo_binding_set) 

static bool js_cc_IImageInfo_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IImageInfo *arg1 = (cc::IImageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IImageInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IImageInfo_binding_get) 

static bool js_cc_IImageInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IImageInfo *arg1 = (cc::IImageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IImageInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IImageInfo_name_set) 

static bool js_cc_IImageInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IImageInfo *arg1 = (cc::IImageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IImageInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IImageInfo_name_get) 

static bool js_cc_IImageInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IImageInfo *arg1 = (cc::IImageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IImageInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->type, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IImageInfo_type_set) 

static bool js_cc_IImageInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IImageInfo *arg1 = (cc::IImageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IImageInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->type, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->type, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IImageInfo_type_get) 

static bool js_cc_IImageInfo_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IImageInfo *arg1 = (cc::IImageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IImageInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IImageInfo_count_set) 

static bool js_cc_IImageInfo_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IImageInfo *arg1 = (cc::IImageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IImageInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IImageInfo_count_get) 

static bool js_cc_IImageInfo_memoryAccess_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IImageInfo *arg1 = (cc::IImageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IImageInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->memoryAccess, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IImageInfo_memoryAccess_set) 

static bool js_cc_IImageInfo_memoryAccess_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IImageInfo *arg1 = (cc::IImageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IImageInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->memoryAccess, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->memoryAccess, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IImageInfo_memoryAccess_get) 

static bool js_cc_IImageInfo_stageFlags_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IImageInfo *arg1 = (cc::IImageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IImageInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stageFlags, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IImageInfo_stageFlags_set) 

static bool js_cc_IImageInfo_stageFlags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IImageInfo *arg1 = (cc::IImageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IImageInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stageFlags, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stageFlags, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IImageInfo_stageFlags_get) 

static bool js_new_cc_IImageInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IImageInfo *result;
    result = (cc::IImageInfo *)new cc::IImageInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IImageInfo, __jsb_cc_IImageInfo_class, js_delete_cc_IImageInfo)

static bool js_delete_cc_IImageInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IImageInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IImageInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IImageInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("memoryAccess", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->memoryAccess), ctx);
    }
    
    
    json->getProperty("stageFlags", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stageFlags), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IImageInfo(se::Object* obj) {
    auto* cls = se::Class::create("IImageInfo", obj, nullptr, _SE(js_new_cc_IImageInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("binding", _SE(js_cc_IImageInfo_binding_get), _SE(js_cc_IImageInfo_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_IImageInfo_name_get), _SE(js_cc_IImageInfo_name_set)); 
    cls->defineProperty("type", _SE(js_cc_IImageInfo_type_get), _SE(js_cc_IImageInfo_type_set)); 
    cls->defineProperty("count", _SE(js_cc_IImageInfo_count_get), _SE(js_cc_IImageInfo_count_set)); 
    cls->defineProperty("memoryAccess", _SE(js_cc_IImageInfo_memoryAccess_get), _SE(js_cc_IImageInfo_memoryAccess_set)); 
    cls->defineProperty("stageFlags", _SE(js_cc_IImageInfo_stageFlags_get), _SE(js_cc_IImageInfo_stageFlags_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IImageInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IImageInfo>(cls);
    
    __jsb_cc_IImageInfo_proto = cls->getProto();
    __jsb_cc_IImageInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IInputAttachmentInfo_class = nullptr;
se::Object* __jsb_cc_IInputAttachmentInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IInputAttachmentInfo) 

static bool js_cc_IInputAttachmentInfo_set_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IInputAttachmentInfo *arg1 = (cc::IInputAttachmentInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IInputAttachmentInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->set, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IInputAttachmentInfo_set_set) 

static bool js_cc_IInputAttachmentInfo_set_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IInputAttachmentInfo *arg1 = (cc::IInputAttachmentInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IInputAttachmentInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->set, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IInputAttachmentInfo_set_get) 

static bool js_cc_IInputAttachmentInfo_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IInputAttachmentInfo *arg1 = (cc::IInputAttachmentInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IInputAttachmentInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IInputAttachmentInfo_binding_set) 

static bool js_cc_IInputAttachmentInfo_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IInputAttachmentInfo *arg1 = (cc::IInputAttachmentInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IInputAttachmentInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IInputAttachmentInfo_binding_get) 

static bool js_cc_IInputAttachmentInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IInputAttachmentInfo *arg1 = (cc::IInputAttachmentInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IInputAttachmentInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IInputAttachmentInfo_name_set) 

static bool js_cc_IInputAttachmentInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IInputAttachmentInfo *arg1 = (cc::IInputAttachmentInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IInputAttachmentInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IInputAttachmentInfo_name_get) 

static bool js_cc_IInputAttachmentInfo_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IInputAttachmentInfo *arg1 = (cc::IInputAttachmentInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IInputAttachmentInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IInputAttachmentInfo_count_set) 

static bool js_cc_IInputAttachmentInfo_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IInputAttachmentInfo *arg1 = (cc::IInputAttachmentInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IInputAttachmentInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IInputAttachmentInfo_count_get) 

static bool js_cc_IInputAttachmentInfo_stageFlags_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IInputAttachmentInfo *arg1 = (cc::IInputAttachmentInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IInputAttachmentInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stageFlags, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IInputAttachmentInfo_stageFlags_set) 

static bool js_cc_IInputAttachmentInfo_stageFlags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IInputAttachmentInfo *arg1 = (cc::IInputAttachmentInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IInputAttachmentInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stageFlags, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stageFlags, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IInputAttachmentInfo_stageFlags_get) 

static bool js_new_cc_IInputAttachmentInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IInputAttachmentInfo *result;
    result = (cc::IInputAttachmentInfo *)new cc::IInputAttachmentInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IInputAttachmentInfo, __jsb_cc_IInputAttachmentInfo_class, js_delete_cc_IInputAttachmentInfo)

static bool js_delete_cc_IInputAttachmentInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IInputAttachmentInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IInputAttachmentInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IInputAttachmentInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("set", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->set), ctx);
    }
    
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("stageFlags", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stageFlags), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IInputAttachmentInfo(se::Object* obj) {
    auto* cls = se::Class::create("IInputAttachmentInfo", obj, nullptr, _SE(js_new_cc_IInputAttachmentInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("set", _SE(js_cc_IInputAttachmentInfo_set_get), _SE(js_cc_IInputAttachmentInfo_set_set)); 
    cls->defineProperty("binding", _SE(js_cc_IInputAttachmentInfo_binding_get), _SE(js_cc_IInputAttachmentInfo_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_IInputAttachmentInfo_name_get), _SE(js_cc_IInputAttachmentInfo_name_set)); 
    cls->defineProperty("count", _SE(js_cc_IInputAttachmentInfo_count_get), _SE(js_cc_IInputAttachmentInfo_count_set)); 
    cls->defineProperty("stageFlags", _SE(js_cc_IInputAttachmentInfo_stageFlags_get), _SE(js_cc_IInputAttachmentInfo_stageFlags_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IInputAttachmentInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IInputAttachmentInfo>(cls);
    
    __jsb_cc_IInputAttachmentInfo_proto = cls->getProto();
    __jsb_cc_IInputAttachmentInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IAttributeInfo_class = nullptr;
se::Object* __jsb_cc_IAttributeInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IAttributeInfo) 

static bool js_cc_IAttributeInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IAttributeInfo_name_set) 

static bool js_cc_IAttributeInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IAttributeInfo_name_get) 

static bool js_cc_IAttributeInfo_format_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->format, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IAttributeInfo_format_set) 

static bool js_cc_IAttributeInfo_format_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->format, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->format, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IAttributeInfo_format_get) 

static bool js_cc_IAttributeInfo_isNormalized_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->isNormalized);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IAttributeInfo_isNormalized_set) 

static bool js_cc_IAttributeInfo_isNormalized_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->isNormalized, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IAttributeInfo_isNormalized_get) 

static bool js_cc_IAttributeInfo_stream_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stream, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IAttributeInfo_stream_set) 

static bool js_cc_IAttributeInfo_stream_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stream, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IAttributeInfo_stream_get) 

static bool js_cc_IAttributeInfo_isInstanced_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->isInstanced);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IAttributeInfo_isInstanced_set) 

static bool js_cc_IAttributeInfo_isInstanced_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->isInstanced, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IAttributeInfo_isInstanced_get) 

static bool js_cc_IAttributeInfo_location_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->location, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IAttributeInfo_location_set) 

static bool js_cc_IAttributeInfo_location_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->location, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IAttributeInfo_location_get) 

static bool js_cc_IAttributeInfo_defines_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->defines, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IAttributeInfo_defines_set) 

static bool js_cc_IAttributeInfo_defines_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IAttributeInfo *arg1 = (cc::IAttributeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IAttributeInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->defines, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->defines, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IAttributeInfo_defines_get) 

static bool js_new_cc_IAttributeInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IAttributeInfo *result;
    result = (cc::IAttributeInfo *)new cc::IAttributeInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IAttributeInfo, __jsb_cc_IAttributeInfo_class, js_delete_cc_IAttributeInfo)

static bool js_delete_cc_IAttributeInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IAttributeInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IAttributeInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IAttributeInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("format", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->format), ctx);
    }
    
    
    json->getProperty("isNormalized", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isNormalized), ctx);
    }
    
    
    json->getProperty("stream", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stream), ctx);
    }
    
    
    json->getProperty("isInstanced", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isInstanced), ctx);
    }
    
    
    json->getProperty("location", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->location), ctx);
    }
    
    
    json->getProperty("defines", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->defines), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IAttributeInfo(se::Object* obj) {
    auto* cls = se::Class::create("IAttributeInfo", obj, nullptr, _SE(js_new_cc_IAttributeInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("name", _SE(js_cc_IAttributeInfo_name_get), _SE(js_cc_IAttributeInfo_name_set)); 
    cls->defineProperty("format", _SE(js_cc_IAttributeInfo_format_get), _SE(js_cc_IAttributeInfo_format_set)); 
    cls->defineProperty("isNormalized", _SE(js_cc_IAttributeInfo_isNormalized_get), _SE(js_cc_IAttributeInfo_isNormalized_set)); 
    cls->defineProperty("stream", _SE(js_cc_IAttributeInfo_stream_get), _SE(js_cc_IAttributeInfo_stream_set)); 
    cls->defineProperty("isInstanced", _SE(js_cc_IAttributeInfo_isInstanced_get), _SE(js_cc_IAttributeInfo_isInstanced_set)); 
    cls->defineProperty("location", _SE(js_cc_IAttributeInfo_location_get), _SE(js_cc_IAttributeInfo_location_set)); 
    cls->defineProperty("defines", _SE(js_cc_IAttributeInfo_defines_get), _SE(js_cc_IAttributeInfo_defines_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IAttributeInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IAttributeInfo>(cls);
    
    __jsb_cc_IAttributeInfo_proto = cls->getProto();
    __jsb_cc_IAttributeInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IDefineInfo_class = nullptr;
se::Object* __jsb_cc_IDefineInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IDefineInfo) 

static bool js_cc_IDefineInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDefineInfo *arg1 = (cc::IDefineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDefineInfo_name_set) 

static bool js_cc_IDefineInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDefineInfo *arg1 = (cc::IDefineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDefineInfo_name_get) 

static bool js_cc_IDefineInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDefineInfo *arg1 = (cc::IDefineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->type, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDefineInfo_type_set) 

static bool js_cc_IDefineInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDefineInfo *arg1 = (cc::IDefineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->type, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->type, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDefineInfo_type_get) 

static bool js_cc_IDefineInfo_range_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDefineInfo *arg1 = (cc::IDefineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->range, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDefineInfo_range_set) 

static bool js_cc_IDefineInfo_range_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDefineInfo *arg1 = (cc::IDefineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->range, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->range, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDefineInfo_range_get) 

static bool js_cc_IDefineInfo_options_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDefineInfo *arg1 = (cc::IDefineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->options, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDefineInfo_options_set) 

static bool js_cc_IDefineInfo_options_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDefineInfo *arg1 = (cc::IDefineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->options, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->options, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDefineInfo_options_get) 

static bool js_cc_IDefineInfo_defaultVal_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDefineInfo *arg1 = (cc::IDefineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->defaultVal, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDefineInfo_defaultVal_set) 

static bool js_cc_IDefineInfo_defaultVal_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDefineInfo *arg1 = (cc::IDefineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->defaultVal, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->defaultVal, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDefineInfo_defaultVal_get) 

static bool js_cc_IDefineInfo_defines_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDefineInfo *arg1 = (cc::IDefineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->defines, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDefineInfo_defines_set) 

static bool js_cc_IDefineInfo_defines_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDefineInfo *arg1 = (cc::IDefineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->defines, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->defines, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDefineInfo_defines_get) 

static bool js_cc_IDefineInfo_editor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDefineInfo *arg1 = (cc::IDefineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->editor, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDefineInfo_editor_set) 

static bool js_cc_IDefineInfo_editor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDefineInfo *arg1 = (cc::IDefineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->editor, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->editor, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDefineInfo_editor_get) 

static bool js_new_cc_IDefineInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IDefineInfo *result;
    result = (cc::IDefineInfo *)new cc::IDefineInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IDefineInfo, __jsb_cc_IDefineInfo_class, js_delete_cc_IDefineInfo)

static bool js_delete_cc_IDefineInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IDefineInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IDefineInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IDefineInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("range", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->range), ctx);
    }
    
    
    json->getProperty("options", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->options), ctx);
    }
    
    
    json->getProperty("defaultVal", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->defaultVal), ctx);
    }
    
    
    json->getProperty("defines", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->defines), ctx);
    }
    
    
    json->getProperty("editor", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->editor), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IDefineInfo(se::Object* obj) {
    auto* cls = se::Class::create("IDefineInfo", obj, nullptr, _SE(js_new_cc_IDefineInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("name", _SE(js_cc_IDefineInfo_name_get), _SE(js_cc_IDefineInfo_name_set)); 
    cls->defineProperty("type", _SE(js_cc_IDefineInfo_type_get), _SE(js_cc_IDefineInfo_type_set)); 
    cls->defineProperty("range", _SE(js_cc_IDefineInfo_range_get), _SE(js_cc_IDefineInfo_range_set)); 
    cls->defineProperty("options", _SE(js_cc_IDefineInfo_options_get), _SE(js_cc_IDefineInfo_options_set)); 
    cls->defineProperty("defaultVal", _SE(js_cc_IDefineInfo_defaultVal_get), _SE(js_cc_IDefineInfo_defaultVal_set)); 
    cls->defineProperty("defines", _SE(js_cc_IDefineInfo_defines_get), _SE(js_cc_IDefineInfo_defines_set)); 
    cls->defineProperty("editor", _SE(js_cc_IDefineInfo_editor_get), _SE(js_cc_IDefineInfo_editor_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IDefineInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IDefineInfo>(cls);
    
    __jsb_cc_IDefineInfo_proto = cls->getProto();
    __jsb_cc_IDefineInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IBuiltin_class = nullptr;
se::Object* __jsb_cc_IBuiltin_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IBuiltin) 

static bool js_cc_IBuiltin_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBuiltin *arg1 = (cc::IBuiltin *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltin>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBuiltin_name_set) 

static bool js_cc_IBuiltin_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBuiltin *arg1 = (cc::IBuiltin *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltin>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBuiltin_name_get) 

static bool js_cc_IBuiltin_defines_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBuiltin *arg1 = (cc::IBuiltin *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltin>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->defines, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBuiltin_defines_set) 

static bool js_cc_IBuiltin_defines_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBuiltin *arg1 = (cc::IBuiltin *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltin>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->defines, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->defines, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBuiltin_defines_get) 

static bool js_new_cc_IBuiltin(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IBuiltin *result;
    result = (cc::IBuiltin *)new cc::IBuiltin();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IBuiltin, __jsb_cc_IBuiltin_class, js_delete_cc_IBuiltin)

static bool js_delete_cc_IBuiltin(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IBuiltin) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IBuiltin * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IBuiltin*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("defines", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->defines), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IBuiltin(se::Object* obj) {
    auto* cls = se::Class::create("IBuiltin", obj, nullptr, _SE(js_new_cc_IBuiltin)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("name", _SE(js_cc_IBuiltin_name_get), _SE(js_cc_IBuiltin_name_set)); 
    cls->defineProperty("defines", _SE(js_cc_IBuiltin_defines_get), _SE(js_cc_IBuiltin_defines_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IBuiltin));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IBuiltin>(cls);
    
    __jsb_cc_IBuiltin_proto = cls->getProto();
    __jsb_cc_IBuiltin_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IBuiltinInfo_class = nullptr;
se::Object* __jsb_cc_IBuiltinInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IBuiltinInfo) 

static bool js_cc_IBuiltinInfo_buffers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBuiltinInfo *arg1 = (cc::IBuiltinInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltinInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->buffers, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBuiltinInfo_buffers_set) 

static bool js_cc_IBuiltinInfo_buffers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBuiltinInfo *arg1 = (cc::IBuiltinInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltinInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->buffers, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->buffers, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBuiltinInfo_buffers_get) 

static bool js_cc_IBuiltinInfo_blocks_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBuiltinInfo *arg1 = (cc::IBuiltinInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltinInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blocks, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBuiltinInfo_blocks_set) 

static bool js_cc_IBuiltinInfo_blocks_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBuiltinInfo *arg1 = (cc::IBuiltinInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltinInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blocks, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blocks, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBuiltinInfo_blocks_get) 

static bool js_cc_IBuiltinInfo_samplerTextures_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBuiltinInfo *arg1 = (cc::IBuiltinInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltinInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->samplerTextures, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBuiltinInfo_samplerTextures_set) 

static bool js_cc_IBuiltinInfo_samplerTextures_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBuiltinInfo *arg1 = (cc::IBuiltinInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltinInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->samplerTextures, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->samplerTextures, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBuiltinInfo_samplerTextures_get) 

static bool js_cc_IBuiltinInfo_images_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBuiltinInfo *arg1 = (cc::IBuiltinInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltinInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->images, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBuiltinInfo_images_set) 

static bool js_cc_IBuiltinInfo_images_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBuiltinInfo *arg1 = (cc::IBuiltinInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltinInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->images, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->images, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBuiltinInfo_images_get) 

static bool js_new_cc_IBuiltinInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IBuiltinInfo *result;
    result = (cc::IBuiltinInfo *)new cc::IBuiltinInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IBuiltinInfo, __jsb_cc_IBuiltinInfo_class, js_delete_cc_IBuiltinInfo)

static bool js_delete_cc_IBuiltinInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IBuiltinInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IBuiltinInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IBuiltinInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("buffers", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->buffers), ctx);
    }
    
    
    json->getProperty("blocks", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blocks), ctx);
    }
    
    
    json->getProperty("samplerTextures", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->samplerTextures), ctx);
    }
    
    
    json->getProperty("images", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->images), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IBuiltinInfo(se::Object* obj) {
    auto* cls = se::Class::create("IBuiltinInfo", obj, nullptr, _SE(js_new_cc_IBuiltinInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("buffers", _SE(js_cc_IBuiltinInfo_buffers_get), _SE(js_cc_IBuiltinInfo_buffers_set)); 
    cls->defineProperty("blocks", _SE(js_cc_IBuiltinInfo_blocks_get), _SE(js_cc_IBuiltinInfo_blocks_set)); 
    cls->defineProperty("samplerTextures", _SE(js_cc_IBuiltinInfo_samplerTextures_get), _SE(js_cc_IBuiltinInfo_samplerTextures_set)); 
    cls->defineProperty("images", _SE(js_cc_IBuiltinInfo_images_get), _SE(js_cc_IBuiltinInfo_images_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IBuiltinInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IBuiltinInfo>(cls);
    
    __jsb_cc_IBuiltinInfo_proto = cls->getProto();
    __jsb_cc_IBuiltinInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IBuiltins_class = nullptr;
se::Object* __jsb_cc_IBuiltins_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IBuiltins) 

static bool js_cc_IBuiltins_globals_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBuiltins *arg1 = (cc::IBuiltins *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltins>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->globals, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBuiltins_globals_set) 

static bool js_cc_IBuiltins_globals_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBuiltins *arg1 = (cc::IBuiltins *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltins>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->globals, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->globals, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBuiltins_globals_get) 

static bool js_cc_IBuiltins_locals_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBuiltins *arg1 = (cc::IBuiltins *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltins>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->locals, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBuiltins_locals_set) 

static bool js_cc_IBuiltins_locals_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBuiltins *arg1 = (cc::IBuiltins *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltins>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->locals, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->locals, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBuiltins_locals_get) 

static bool js_cc_IBuiltins_statistics_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IBuiltins *arg1 = (cc::IBuiltins *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltins>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->statistics, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IBuiltins_statistics_set) 

static bool js_cc_IBuiltins_statistics_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IBuiltins *arg1 = (cc::IBuiltins *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IBuiltins>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->statistics, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->statistics, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IBuiltins_statistics_get) 

static bool js_new_cc_IBuiltins(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IBuiltins *result;
    result = (cc::IBuiltins *)new cc::IBuiltins();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IBuiltins, __jsb_cc_IBuiltins_class, js_delete_cc_IBuiltins)

static bool js_delete_cc_IBuiltins(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IBuiltins) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IBuiltins * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IBuiltins*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("globals", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->globals), ctx);
    }
    
    
    json->getProperty("locals", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->locals), ctx);
    }
    
    
    json->getProperty("statistics", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->statistics), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IBuiltins(se::Object* obj) {
    auto* cls = se::Class::create("IBuiltins", obj, nullptr, _SE(js_new_cc_IBuiltins)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("globals", _SE(js_cc_IBuiltins_globals_get), _SE(js_cc_IBuiltins_globals_set)); 
    cls->defineProperty("locals", _SE(js_cc_IBuiltins_locals_get), _SE(js_cc_IBuiltins_locals_set)); 
    cls->defineProperty("statistics", _SE(js_cc_IBuiltins_statistics_get), _SE(js_cc_IBuiltins_statistics_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IBuiltins));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IBuiltins>(cls);
    
    __jsb_cc_IBuiltins_proto = cls->getProto();
    __jsb_cc_IBuiltins_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IDescriptorInfo_class = nullptr;
se::Object* __jsb_cc_IDescriptorInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IDescriptorInfo) 

static bool js_cc_IDescriptorInfo_rate_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDescriptorInfo *arg1 = (cc::IDescriptorInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDescriptorInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->rate, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDescriptorInfo_rate_set) 

static bool js_cc_IDescriptorInfo_rate_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDescriptorInfo *arg1 = (cc::IDescriptorInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDescriptorInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->rate, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDescriptorInfo_rate_get) 

static bool js_cc_IDescriptorInfo_blocks_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDescriptorInfo *arg1 = (cc::IDescriptorInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDescriptorInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blocks, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDescriptorInfo_blocks_set) 

static bool js_cc_IDescriptorInfo_blocks_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDescriptorInfo *arg1 = (cc::IDescriptorInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDescriptorInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blocks, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blocks, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDescriptorInfo_blocks_get) 

static bool js_cc_IDescriptorInfo_samplerTextures_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDescriptorInfo *arg1 = (cc::IDescriptorInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDescriptorInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->samplerTextures, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDescriptorInfo_samplerTextures_set) 

static bool js_cc_IDescriptorInfo_samplerTextures_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDescriptorInfo *arg1 = (cc::IDescriptorInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDescriptorInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->samplerTextures, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->samplerTextures, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDescriptorInfo_samplerTextures_get) 

static bool js_cc_IDescriptorInfo_samplers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDescriptorInfo *arg1 = (cc::IDescriptorInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDescriptorInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->samplers, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDescriptorInfo_samplers_set) 

static bool js_cc_IDescriptorInfo_samplers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDescriptorInfo *arg1 = (cc::IDescriptorInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDescriptorInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->samplers, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->samplers, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDescriptorInfo_samplers_get) 

static bool js_cc_IDescriptorInfo_textures_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDescriptorInfo *arg1 = (cc::IDescriptorInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDescriptorInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->textures, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDescriptorInfo_textures_set) 

static bool js_cc_IDescriptorInfo_textures_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDescriptorInfo *arg1 = (cc::IDescriptorInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDescriptorInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->textures, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->textures, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDescriptorInfo_textures_get) 

static bool js_cc_IDescriptorInfo_buffers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDescriptorInfo *arg1 = (cc::IDescriptorInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDescriptorInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->buffers, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDescriptorInfo_buffers_set) 

static bool js_cc_IDescriptorInfo_buffers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDescriptorInfo *arg1 = (cc::IDescriptorInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDescriptorInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->buffers, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->buffers, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDescriptorInfo_buffers_get) 

static bool js_cc_IDescriptorInfo_images_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDescriptorInfo *arg1 = (cc::IDescriptorInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDescriptorInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->images, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDescriptorInfo_images_set) 

static bool js_cc_IDescriptorInfo_images_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDescriptorInfo *arg1 = (cc::IDescriptorInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDescriptorInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->images, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->images, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDescriptorInfo_images_get) 

static bool js_cc_IDescriptorInfo_subpassInputs_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDescriptorInfo *arg1 = (cc::IDescriptorInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDescriptorInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->subpassInputs, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDescriptorInfo_subpassInputs_set) 

static bool js_cc_IDescriptorInfo_subpassInputs_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDescriptorInfo *arg1 = (cc::IDescriptorInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDescriptorInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->subpassInputs, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->subpassInputs, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDescriptorInfo_subpassInputs_get) 

static bool js_new_cc_IDescriptorInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IDescriptorInfo *result;
    result = (cc::IDescriptorInfo *)new cc::IDescriptorInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IDescriptorInfo, __jsb_cc_IDescriptorInfo_class, js_delete_cc_IDescriptorInfo)

static bool js_delete_cc_IDescriptorInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IDescriptorInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IDescriptorInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IDescriptorInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("rate", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->rate), ctx);
    }
    
    
    json->getProperty("blocks", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blocks), ctx);
    }
    
    
    json->getProperty("samplerTextures", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->samplerTextures), ctx);
    }
    
    
    json->getProperty("samplers", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->samplers), ctx);
    }
    
    
    json->getProperty("textures", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->textures), ctx);
    }
    
    
    json->getProperty("buffers", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->buffers), ctx);
    }
    
    
    json->getProperty("images", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->images), ctx);
    }
    
    
    json->getProperty("subpassInputs", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->subpassInputs), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IDescriptorInfo(se::Object* obj) {
    auto* cls = se::Class::create("IDescriptorInfo", obj, nullptr, _SE(js_new_cc_IDescriptorInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("rate", _SE(js_cc_IDescriptorInfo_rate_get), _SE(js_cc_IDescriptorInfo_rate_set)); 
    cls->defineProperty("blocks", _SE(js_cc_IDescriptorInfo_blocks_get), _SE(js_cc_IDescriptorInfo_blocks_set)); 
    cls->defineProperty("samplerTextures", _SE(js_cc_IDescriptorInfo_samplerTextures_get), _SE(js_cc_IDescriptorInfo_samplerTextures_set)); 
    cls->defineProperty("samplers", _SE(js_cc_IDescriptorInfo_samplers_get), _SE(js_cc_IDescriptorInfo_samplers_set)); 
    cls->defineProperty("textures", _SE(js_cc_IDescriptorInfo_textures_get), _SE(js_cc_IDescriptorInfo_textures_set)); 
    cls->defineProperty("buffers", _SE(js_cc_IDescriptorInfo_buffers_get), _SE(js_cc_IDescriptorInfo_buffers_set)); 
    cls->defineProperty("images", _SE(js_cc_IDescriptorInfo_images_get), _SE(js_cc_IDescriptorInfo_images_set)); 
    cls->defineProperty("subpassInputs", _SE(js_cc_IDescriptorInfo_subpassInputs_get), _SE(js_cc_IDescriptorInfo_subpassInputs_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IDescriptorInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IDescriptorInfo>(cls);
    
    __jsb_cc_IDescriptorInfo_proto = cls->getProto();
    __jsb_cc_IDescriptorInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IShaderSource_class = nullptr;
se::Object* __jsb_cc_IShaderSource_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IShaderSource) 

static bool js_cc_IShaderSource_vert_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderSource *arg1 = (cc::IShaderSource *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderSource>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->vert, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderSource_vert_set) 

static bool js_cc_IShaderSource_vert_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderSource *arg1 = (cc::IShaderSource *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderSource>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->vert, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->vert, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderSource_vert_get) 

static bool js_cc_IShaderSource_frag_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderSource *arg1 = (cc::IShaderSource *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderSource>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->frag, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderSource_frag_set) 

static bool js_cc_IShaderSource_frag_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderSource *arg1 = (cc::IShaderSource *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderSource>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->frag, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->frag, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderSource_frag_get) 

static bool js_cc_IShaderSource_compute_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderSource *arg1 = (cc::IShaderSource *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderSource>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->compute, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderSource_compute_set) 

static bool js_cc_IShaderSource_compute_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderSource *arg1 = (cc::IShaderSource *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderSource>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->compute, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->compute, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderSource_compute_get) 

static bool js_new_cc_IShaderSource(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IShaderSource *result;
    result = (cc::IShaderSource *)new cc::IShaderSource();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IShaderSource, __jsb_cc_IShaderSource_class, js_delete_cc_IShaderSource)

static bool js_delete_cc_IShaderSource(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IShaderSource) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IShaderSource * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IShaderSource*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("vert", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->vert), ctx);
    }
    
    
    json->getProperty("frag", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->frag), ctx);
    }
    
    
    json->getProperty("compute", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->compute), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IShaderSource(se::Object* obj) {
    auto* cls = se::Class::create("IShaderSource", obj, nullptr, _SE(js_new_cc_IShaderSource)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("vert", _SE(js_cc_IShaderSource_vert_get), _SE(js_cc_IShaderSource_vert_set)); 
    cls->defineProperty("frag", _SE(js_cc_IShaderSource_frag_get), _SE(js_cc_IShaderSource_frag_set)); 
    cls->defineProperty("compute", _SE(js_cc_IShaderSource_compute_get), _SE(js_cc_IShaderSource_compute_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IShaderSource));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IShaderSource>(cls);
    
    __jsb_cc_IShaderSource_proto = cls->getProto();
    __jsb_cc_IShaderSource_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IShaderInfo_class = nullptr;
se::Object* __jsb_cc_IShaderInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IShaderInfo) 

static bool js_cc_IShaderInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_name_set) 

static bool js_cc_IShaderInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_name_get) 

static bool js_cc_IShaderInfo_hash_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->hash, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_hash_set) 

static bool js_cc_IShaderInfo_hash_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->hash, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->hash, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_hash_get) 

static bool js_cc_IShaderInfo_glsl4_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->glsl4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_glsl4_set) 

static bool js_cc_IShaderInfo_glsl4_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->glsl4, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->glsl4, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_glsl4_get) 

static bool js_cc_IShaderInfo_glsl3_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->glsl3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_glsl3_set) 

static bool js_cc_IShaderInfo_glsl3_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->glsl3, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->glsl3, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_glsl3_get) 

static bool js_cc_IShaderInfo_glsl1_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->glsl1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_glsl1_set) 

static bool js_cc_IShaderInfo_glsl1_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->glsl1, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->glsl1, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_glsl1_get) 

static bool js_cc_IShaderInfo_builtins_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->builtins, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_builtins_set) 

static bool js_cc_IShaderInfo_builtins_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->builtins, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->builtins, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_builtins_get) 

static bool js_cc_IShaderInfo_defines_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->defines, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_defines_set) 

static bool js_cc_IShaderInfo_defines_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->defines, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->defines, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_defines_get) 

static bool js_cc_IShaderInfo_attributes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->attributes, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_attributes_set) 

static bool js_cc_IShaderInfo_attributes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->attributes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->attributes, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_attributes_get) 

static bool js_cc_IShaderInfo_blocks_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blocks, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_blocks_set) 

static bool js_cc_IShaderInfo_blocks_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blocks, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blocks, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_blocks_get) 

static bool js_cc_IShaderInfo_samplerTextures_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->samplerTextures, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_samplerTextures_set) 

static bool js_cc_IShaderInfo_samplerTextures_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->samplerTextures, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->samplerTextures, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_samplerTextures_get) 

static bool js_cc_IShaderInfo_samplers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->samplers, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_samplers_set) 

static bool js_cc_IShaderInfo_samplers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->samplers, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->samplers, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_samplers_get) 

static bool js_cc_IShaderInfo_textures_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->textures, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_textures_set) 

static bool js_cc_IShaderInfo_textures_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->textures, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->textures, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_textures_get) 

static bool js_cc_IShaderInfo_buffers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->buffers, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_buffers_set) 

static bool js_cc_IShaderInfo_buffers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->buffers, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->buffers, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_buffers_get) 

static bool js_cc_IShaderInfo_images_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->images, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_images_set) 

static bool js_cc_IShaderInfo_images_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->images, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->images, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_images_get) 

static bool js_cc_IShaderInfo_subpassInputs_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->subpassInputs, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_subpassInputs_set) 

static bool js_cc_IShaderInfo_subpassInputs_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->subpassInputs, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->subpassInputs, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_subpassInputs_get) 

static bool js_cc_IShaderInfo_descriptors_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->descriptors, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IShaderInfo_descriptors_set) 

static bool js_cc_IShaderInfo_descriptors_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->descriptors, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->descriptors, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IShaderInfo_descriptors_get) 

static bool js_cc_IShaderInfo_getSource__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    cc::IShaderSource *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::IShaderSource *)((cc::IShaderInfo const *)arg1)->getSource((ccstd::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_IShaderInfo_getSource__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::IShaderInfo *arg1 = (cc::IShaderInfo *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    cc::IShaderSource *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::IShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::IShaderSource *)(arg1)->getSource((ccstd::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_IShaderInfo_getSource(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_cc_IShaderInfo_getSource__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_IShaderInfo_getSource__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_IShaderInfo_getSource) 

static bool js_new_cc_IShaderInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IShaderInfo *result;
    result = (cc::IShaderInfo *)new cc::IShaderInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IShaderInfo, __jsb_cc_IShaderInfo_class, js_delete_cc_IShaderInfo)

static bool js_delete_cc_IShaderInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IShaderInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IShaderInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IShaderInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("hash", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->hash), ctx);
    }
    
    
    json->getProperty("glsl4", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->glsl4), ctx);
    }
    
    
    json->getProperty("glsl3", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->glsl3), ctx);
    }
    
    
    json->getProperty("glsl1", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->glsl1), ctx);
    }
    
    
    json->getProperty("builtins", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->builtins), ctx);
    }
    
    
    json->getProperty("defines", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->defines), ctx);
    }
    
    
    json->getProperty("attributes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->attributes), ctx);
    }
    
    
    json->getProperty("blocks", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blocks), ctx);
    }
    
    
    json->getProperty("samplerTextures", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->samplerTextures), ctx);
    }
    
    
    json->getProperty("samplers", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->samplers), ctx);
    }
    
    
    json->getProperty("textures", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->textures), ctx);
    }
    
    
    json->getProperty("buffers", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->buffers), ctx);
    }
    
    
    json->getProperty("images", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->images), ctx);
    }
    
    
    json->getProperty("subpassInputs", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->subpassInputs), ctx);
    }
    
    
    json->getProperty("descriptors", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->descriptors), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IShaderInfo(se::Object* obj) {
    auto* cls = se::Class::create("IShaderInfo", obj, nullptr, _SE(js_new_cc_IShaderInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("name", _SE(js_cc_IShaderInfo_name_get), _SE(js_cc_IShaderInfo_name_set)); 
    cls->defineProperty("hash", _SE(js_cc_IShaderInfo_hash_get), _SE(js_cc_IShaderInfo_hash_set)); 
    cls->defineProperty("glsl4", _SE(js_cc_IShaderInfo_glsl4_get), _SE(js_cc_IShaderInfo_glsl4_set)); 
    cls->defineProperty("glsl3", _SE(js_cc_IShaderInfo_glsl3_get), _SE(js_cc_IShaderInfo_glsl3_set)); 
    cls->defineProperty("glsl1", _SE(js_cc_IShaderInfo_glsl1_get), _SE(js_cc_IShaderInfo_glsl1_set)); 
    cls->defineProperty("builtins", _SE(js_cc_IShaderInfo_builtins_get), _SE(js_cc_IShaderInfo_builtins_set)); 
    cls->defineProperty("defines", _SE(js_cc_IShaderInfo_defines_get), _SE(js_cc_IShaderInfo_defines_set)); 
    cls->defineProperty("attributes", _SE(js_cc_IShaderInfo_attributes_get), _SE(js_cc_IShaderInfo_attributes_set)); 
    cls->defineProperty("blocks", _SE(js_cc_IShaderInfo_blocks_get), _SE(js_cc_IShaderInfo_blocks_set)); 
    cls->defineProperty("samplerTextures", _SE(js_cc_IShaderInfo_samplerTextures_get), _SE(js_cc_IShaderInfo_samplerTextures_set)); 
    cls->defineProperty("samplers", _SE(js_cc_IShaderInfo_samplers_get), _SE(js_cc_IShaderInfo_samplers_set)); 
    cls->defineProperty("textures", _SE(js_cc_IShaderInfo_textures_get), _SE(js_cc_IShaderInfo_textures_set)); 
    cls->defineProperty("buffers", _SE(js_cc_IShaderInfo_buffers_get), _SE(js_cc_IShaderInfo_buffers_set)); 
    cls->defineProperty("images", _SE(js_cc_IShaderInfo_images_get), _SE(js_cc_IShaderInfo_images_set)); 
    cls->defineProperty("subpassInputs", _SE(js_cc_IShaderInfo_subpassInputs_get), _SE(js_cc_IShaderInfo_subpassInputs_set)); 
    cls->defineProperty("descriptors", _SE(js_cc_IShaderInfo_descriptors_get), _SE(js_cc_IShaderInfo_descriptors_set)); 
    
    cls->defineFunction("getSource", _SE(js_cc_IShaderInfo_getSource)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IShaderInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IShaderInfo>(cls);
    
    __jsb_cc_IShaderInfo_proto = cls->getProto();
    __jsb_cc_IShaderInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_EffectAsset_class = nullptr;
se::Object* __jsb_cc_EffectAsset_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_EffectAsset) 

static bool js_new_cc_EffectAsset(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::EffectAsset *result;
    result = (cc::EffectAsset *)new cc::EffectAsset();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_EffectAsset, __jsb_cc_EffectAsset_class, js_delete_cc_EffectAsset)

static bool js_delete_cc_EffectAsset(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_EffectAsset) 

static bool js_cc_EffectAsset_cpp_keyword_register_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::EffectAsset *arg1 = (cc::EffectAsset *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc::EffectAsset::registerAsset(arg1);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_EffectAsset_cpp_keyword_register_static) 

static bool js_cc_EffectAsset_remove_static__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    ccstd::string *arg1 = 0 ;
    ccstd::string temp1 ;
    
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    cc::EffectAsset::remove((ccstd::string const &)*arg1);
    
    
    return true;
}

static bool js_cc_EffectAsset_remove_static__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::EffectAsset *arg1 = (cc::EffectAsset *) NULL ;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc::EffectAsset::remove(arg1);
    
    
    return true;
}

static bool js_cc_EffectAsset_remove_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_cc_EffectAsset_remove_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_EffectAsset_remove_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_EffectAsset_remove_static) 

static bool js_cc_EffectAsset_get_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    ccstd::string *arg1 = 0 ;
    ccstd::string temp1 ;
    cc::EffectAsset *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = (cc::EffectAsset *)cc::EffectAsset::get((ccstd::string const &)*arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_EffectAsset_get_static) 

static bool js_cc_EffectAsset_getAll_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::EffectAsset::RegisteredEffectAssetMap *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::EffectAsset::RegisteredEffectAssetMap *) &cc::EffectAsset::getAll();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_EffectAsset_getAll_static) 

static bool js_cc_EffectAsset_isLayoutValid_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (bool)cc::EffectAsset::isLayoutValid();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_EffectAsset_isLayoutValid_static) 

static bool js_cc_EffectAsset_setLayoutValid_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    cc::EffectAsset::setLayoutValid();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_EffectAsset_setLayoutValid_static) 

static bool js_cc_EffectAsset_hideInEditor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::EffectAsset *arg1 = (cc::EffectAsset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EffectAsset>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->hideInEditor);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_EffectAsset_hideInEditor_set) 

static bool js_cc_EffectAsset_hideInEditor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::EffectAsset *arg1 = (cc::EffectAsset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EffectAsset>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->hideInEditor, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_EffectAsset_hideInEditor_get) 

static bool js_cc_EffectAsset_techniques_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::EffectAsset *arg1 = (cc::EffectAsset *) NULL ;
    ccstd::vector< cc::ITechniqueInfo > *arg2 = 0 ;
    ccstd::vector< cc::ITechniqueInfo > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::EffectAsset>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_EffectAsset_techniques_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_EffectAsset_techniques_set) 

static bool js_cc_EffectAsset_techniques_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::EffectAsset *arg1 = (cc::EffectAsset *) NULL ;
    ccstd::vector< cc::ITechniqueInfo > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::EffectAsset>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::ITechniqueInfo > *) &cc_EffectAsset_techniques_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_EffectAsset_techniques_get) 

static bool js_cc_EffectAsset_shaders_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::EffectAsset *arg1 = (cc::EffectAsset *) NULL ;
    ccstd::vector< cc::IShaderInfo > *arg2 = 0 ;
    ccstd::vector< cc::IShaderInfo > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::EffectAsset>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_EffectAsset_shaders_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_EffectAsset_shaders_set) 

static bool js_cc_EffectAsset_shaders_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::EffectAsset *arg1 = (cc::EffectAsset *) NULL ;
    ccstd::vector< cc::IShaderInfo > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::EffectAsset>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::IShaderInfo > *) &cc_EffectAsset_shaders_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_EffectAsset_shaders_get) 

static bool js_cc_EffectAsset_combinations_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::EffectAsset *arg1 = (cc::EffectAsset *) NULL ;
    ccstd::vector< cc::IPreCompileInfo > *arg2 = 0 ;
    ccstd::vector< cc::IPreCompileInfo > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::EffectAsset>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_EffectAsset_combinations_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_EffectAsset_combinations_set) 

static bool js_cc_EffectAsset_combinations_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::EffectAsset *arg1 = (cc::EffectAsset *) NULL ;
    ccstd::vector< cc::IPreCompileInfo > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::EffectAsset>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::IPreCompileInfo > *) &cc_EffectAsset_combinations_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_EffectAsset_combinations_get) 

bool js_register_cc_EffectAsset(se::Object* obj) {
    auto* cls = se::Class::create("EffectAsset", obj, __jsb_cc_Asset_proto, _SE(js_new_cc_EffectAsset)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("hideInEditor", _SE(js_cc_EffectAsset_hideInEditor_get), _SE(js_cc_EffectAsset_hideInEditor_set)); 
    cls->defineProperty("techniques", _SE(js_cc_EffectAsset_techniques_get), _SE(js_cc_EffectAsset_techniques_set)); 
    cls->defineProperty("shaders", _SE(js_cc_EffectAsset_shaders_get), _SE(js_cc_EffectAsset_shaders_set)); 
    cls->defineProperty("combinations", _SE(js_cc_EffectAsset_combinations_get), _SE(js_cc_EffectAsset_combinations_set)); 
    
    
    
    cls->defineStaticFunction("register", _SE(js_cc_EffectAsset_cpp_keyword_register_static)); 
    cls->defineStaticFunction("remove", _SE(js_cc_EffectAsset_remove_static)); 
    cls->defineStaticFunction("get", _SE(js_cc_EffectAsset_get_static)); 
    cls->defineStaticFunction("getAll", _SE(js_cc_EffectAsset_getAll_static)); 
    cls->defineStaticFunction("isLayoutValid", _SE(js_cc_EffectAsset_isLayoutValid_static)); 
    cls->defineStaticFunction("setLayoutValid", _SE(js_cc_EffectAsset_setLayoutValid_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_EffectAsset));
    
    
    cls->install();
    JSBClassType::registerClass<cc::EffectAsset>(cls);
    
    __jsb_cc_EffectAsset_proto = cls->getProto();
    __jsb_cc_EffectAsset_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IMemoryImageSource_class = nullptr;
se::Object* __jsb_cc_IMemoryImageSource_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IMemoryImageSource) 

static bool js_cc_IMemoryImageSource_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMemoryImageSource *arg1 = (cc::IMemoryImageSource *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMemoryImageSource>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->width, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMemoryImageSource_width_set) 

static bool js_cc_IMemoryImageSource_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMemoryImageSource *arg1 = (cc::IMemoryImageSource *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMemoryImageSource>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->width, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMemoryImageSource_width_get) 

static bool js_cc_IMemoryImageSource_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMemoryImageSource *arg1 = (cc::IMemoryImageSource *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMemoryImageSource>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->height, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMemoryImageSource_height_set) 

static bool js_cc_IMemoryImageSource_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMemoryImageSource *arg1 = (cc::IMemoryImageSource *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMemoryImageSource>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->height, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMemoryImageSource_height_get) 

static bool js_cc_IMemoryImageSource_format_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMemoryImageSource *arg1 = (cc::IMemoryImageSource *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMemoryImageSource>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->format, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMemoryImageSource_format_set) 

static bool js_cc_IMemoryImageSource_format_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMemoryImageSource *arg1 = (cc::IMemoryImageSource *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMemoryImageSource>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->format, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->format, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMemoryImageSource_format_get) 

static bool js_cc_IMemoryImageSource_mipmapLevelDataSize_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMemoryImageSource *arg1 = (cc::IMemoryImageSource *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMemoryImageSource>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->mipmapLevelDataSize, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMemoryImageSource_mipmapLevelDataSize_set) 

static bool js_cc_IMemoryImageSource_mipmapLevelDataSize_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMemoryImageSource *arg1 = (cc::IMemoryImageSource *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMemoryImageSource>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->mipmapLevelDataSize, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->mipmapLevelDataSize, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMemoryImageSource_mipmapLevelDataSize_get) 

static bool js_new_cc_IMemoryImageSource(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IMemoryImageSource *result;
    result = (cc::IMemoryImageSource *)new cc::IMemoryImageSource();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IMemoryImageSource, __jsb_cc_IMemoryImageSource_class, js_delete_cc_IMemoryImageSource)

static bool js_delete_cc_IMemoryImageSource(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IMemoryImageSource) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IMemoryImageSource * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IMemoryImageSource*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("width", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->width), ctx);
    }
    
    
    json->getProperty("height", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->height), ctx);
    }
    
    
    json->getProperty("format", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->format), ctx);
    }
    
    
    json->getProperty("mipmapLevelDataSize", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->mipmapLevelDataSize), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IMemoryImageSource(se::Object* obj) {
    auto* cls = se::Class::create("IMemoryImageSource", obj, nullptr, _SE(js_new_cc_IMemoryImageSource)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("width", _SE(js_cc_IMemoryImageSource_width_get), _SE(js_cc_IMemoryImageSource_width_set)); 
    cls->defineProperty("height", _SE(js_cc_IMemoryImageSource_height_get), _SE(js_cc_IMemoryImageSource_height_set)); 
    cls->defineProperty("format", _SE(js_cc_IMemoryImageSource_format_get), _SE(js_cc_IMemoryImageSource_format_set)); 
    cls->defineProperty("mipmapLevelDataSize", _SE(js_cc_IMemoryImageSource_mipmapLevelDataSize_get), _SE(js_cc_IMemoryImageSource_mipmapLevelDataSize_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IMemoryImageSource));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IMemoryImageSource>(cls);
    
    __jsb_cc_IMemoryImageSource_proto = cls->getProto();
    __jsb_cc_IMemoryImageSource_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_ImageAsset_class = nullptr;
se::Object* __jsb_cc_ImageAsset_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_ImageAsset) 

static bool js_new_cc_ImageAsset(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::ImageAsset *result;
    result = (cc::ImageAsset *)new cc::ImageAsset();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_ImageAsset, __jsb_cc_ImageAsset_class, js_delete_cc_ImageAsset)

static bool js_delete_cc_ImageAsset(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_ImageAsset) 

static bool js_cc_ImageAsset_getData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ImageAsset *arg1 = (cc::ImageAsset *) NULL ;
    uint8_t *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ImageAsset>(s);
    if (nullptr == arg1) return true;
    result = (uint8_t *)((cc::ImageAsset const *)arg1)->getData();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ImageAsset_getData) 

static bool js_cc_ImageAsset_getWidth(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ImageAsset *arg1 = (cc::ImageAsset *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ImageAsset>(s);
    if (nullptr == arg1) return true;
    result = ((cc::ImageAsset const *)arg1)->getWidth();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ImageAsset_getWidth) 

static bool js_cc_ImageAsset_getHeight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ImageAsset *arg1 = (cc::ImageAsset *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ImageAsset>(s);
    if (nullptr == arg1) return true;
    result = ((cc::ImageAsset const *)arg1)->getHeight();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ImageAsset_getHeight) 

static bool js_cc_ImageAsset_getMipmapLevelDataSize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ImageAsset *arg1 = (cc::ImageAsset *) NULL ;
    ccstd::vector< uint32_t > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ImageAsset>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< uint32_t > *) &((cc::ImageAsset const *)arg1)->getMipmapLevelDataSize();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ImageAsset_getMipmapLevelDataSize) 

static bool js_cc_ImageAsset_isCompressed(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ImageAsset *arg1 = (cc::ImageAsset *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ImageAsset>(s);
    if (nullptr == arg1) return true;
    result = (bool)((cc::ImageAsset const *)arg1)->isCompressed();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ImageAsset_isCompressed) 

static bool js_cc_ImageAsset_setWidth(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ImageAsset *arg1 = (cc::ImageAsset *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ImageAsset>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setWidth(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ImageAsset_setWidth) 

static bool js_cc_ImageAsset_setHeight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ImageAsset *arg1 = (cc::ImageAsset *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ImageAsset>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setHeight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ImageAsset_setHeight) 

static bool js_cc_ImageAsset_setNeedFreeData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ImageAsset *arg1 = (cc::ImageAsset *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ImageAsset>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setNeedFreeData(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ImageAsset_setNeedFreeData) 

static bool js_cc_ImageAsset_setMipmapLevelDataSize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ImageAsset *arg1 = (cc::ImageAsset *) NULL ;
    ccstd::vector< uint32_t > *arg2 = 0 ;
    ccstd::vector< uint32_t > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ImageAsset>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setMipmapLevelDataSize((ccstd::vector< uint32_t > const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ImageAsset_setMipmapLevelDataSize) 

static bool js_cc_ImageAsset_format_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ImageAsset *arg1 = (cc::ImageAsset *) NULL ;
    cc::PixelFormat arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::ImageAsset>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_ImageAsset_format_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ImageAsset_format_set) 

static bool js_cc_ImageAsset_format_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ImageAsset *arg1 = (cc::ImageAsset *) NULL ;
    cc::PixelFormat result;
    
    arg1 = SE_THIS_OBJECT<cc::ImageAsset>(s);
    if (nullptr == arg1) return true;
    result = (cc::PixelFormat)cc_ImageAsset_format_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ImageAsset_format_get) 

static bool js_cc_ImageAsset_url_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ImageAsset *arg1 = (cc::ImageAsset *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::ImageAsset>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_ImageAsset_url_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ImageAsset_url_set) 

static bool js_cc_ImageAsset_url_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ImageAsset *arg1 = (cc::ImageAsset *) NULL ;
    ccstd::string *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::ImageAsset>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::string *) &cc_ImageAsset_url_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ImageAsset_url_get) 

bool js_register_cc_ImageAsset(se::Object* obj) {
    auto* cls = se::Class::create("ImageAsset", obj, __jsb_cc_Asset_proto, _SE(js_new_cc_ImageAsset)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("format", _SE(js_cc_ImageAsset_format_get), _SE(js_cc_ImageAsset_format_set)); 
    cls->defineProperty("url", _SE(js_cc_ImageAsset_url_get), _SE(js_cc_ImageAsset_url_set)); 
    
    cls->defineFunction("getData", _SE(js_cc_ImageAsset_getData)); 
    cls->defineFunction("getWidth", _SE(js_cc_ImageAsset_getWidth)); 
    cls->defineFunction("getHeight", _SE(js_cc_ImageAsset_getHeight)); 
    cls->defineFunction("getMipmapLevelDataSize", _SE(js_cc_ImageAsset_getMipmapLevelDataSize)); 
    cls->defineFunction("isCompressed", _SE(js_cc_ImageAsset_isCompressed)); 
    cls->defineFunction("setWidth", _SE(js_cc_ImageAsset_setWidth)); 
    cls->defineFunction("setHeight", _SE(js_cc_ImageAsset_setHeight)); 
    cls->defineFunction("setNeedFreeData", _SE(js_cc_ImageAsset_setNeedFreeData)); 
    cls->defineFunction("setMipmapLevelDataSize", _SE(js_cc_ImageAsset_setMipmapLevelDataSize)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_ImageAsset));
    
    
    cls->install();
    JSBClassType::registerClass<cc::ImageAsset>(cls);
    
    __jsb_cc_ImageAsset_proto = cls->getProto();
    __jsb_cc_ImageAsset_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_SceneAsset_class = nullptr;
se::Object* __jsb_cc_SceneAsset_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_SceneAsset) 

static bool js_new_cc_SceneAsset(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::SceneAsset *result;
    result = (cc::SceneAsset *)new cc::SceneAsset();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_SceneAsset, __jsb_cc_SceneAsset_class, js_delete_cc_SceneAsset)

static bool js_delete_cc_SceneAsset(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_SceneAsset) 

static bool js_cc_SceneAsset_getScene(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneAsset *arg1 = (cc::SceneAsset *) NULL ;
    cc::Scene *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneAsset>(s);
    if (nullptr == arg1) return true;
    result = (cc::Scene *)((cc::SceneAsset const *)arg1)->getScene();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneAsset_getScene) 

static bool js_cc_SceneAsset_setScene(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneAsset *arg1 = (cc::SceneAsset *) NULL ;
    cc::Scene *arg2 = (cc::Scene *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneAsset>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setScene(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneAsset_setScene) 

bool js_register_cc_SceneAsset(se::Object* obj) {
    auto* cls = se::Class::create("SceneAsset", obj, __jsb_cc_Asset_proto, _SE(js_new_cc_SceneAsset)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getScene", _SE(js_cc_SceneAsset_getScene)); 
    cls->defineFunction("setScene", _SE(js_cc_SceneAsset_setScene)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_SceneAsset));
    
    
    cls->install();
    JSBClassType::registerClass<cc::SceneAsset>(cls);
    
    __jsb_cc_SceneAsset_proto = cls->getProto();
    __jsb_cc_SceneAsset_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_TextAsset_class = nullptr;
se::Object* __jsb_cc_TextAsset_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_TextAsset) 

static bool js_new_cc_TextAsset(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::TextAsset *result;
    result = (cc::TextAsset *)new cc::TextAsset();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_TextAsset, __jsb_cc_TextAsset_class, js_delete_cc_TextAsset)

static bool js_delete_cc_TextAsset(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_TextAsset) 

static bool js_cc_TextAsset_text_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::TextAsset *arg1 = (cc::TextAsset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextAsset>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->text, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_TextAsset_text_set) 

static bool js_cc_TextAsset_text_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::TextAsset *arg1 = (cc::TextAsset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::TextAsset>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->text, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->text, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_TextAsset_text_get) 

bool js_register_cc_TextAsset(se::Object* obj) {
    auto* cls = se::Class::create("TextAsset", obj, __jsb_cc_Asset_proto, _SE(js_new_cc_TextAsset)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("text", _SE(js_cc_TextAsset_text_get), _SE(js_cc_TextAsset_text_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_TextAsset));
    
    
    cls->install();
    JSBClassType::registerClass<cc::TextAsset>(cls);
    
    __jsb_cc_TextAsset_proto = cls->getProto();
    __jsb_cc_TextAsset_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IMaterialInfo_class = nullptr;
se::Object* __jsb_cc_IMaterialInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IMaterialInfo) 

static bool js_cc_IMaterialInfo_effectAsset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMaterialInfo *arg1 = (cc::IMaterialInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->effectAsset, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMaterialInfo_effectAsset_set) 

static bool js_cc_IMaterialInfo_effectAsset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMaterialInfo *arg1 = (cc::IMaterialInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->effectAsset, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->effectAsset, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMaterialInfo_effectAsset_get) 

static bool js_cc_IMaterialInfo_effectName_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMaterialInfo *arg1 = (cc::IMaterialInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->effectName, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMaterialInfo_effectName_set) 

static bool js_cc_IMaterialInfo_effectName_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMaterialInfo *arg1 = (cc::IMaterialInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->effectName, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->effectName, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMaterialInfo_effectName_get) 

static bool js_cc_IMaterialInfo_technique_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMaterialInfo *arg1 = (cc::IMaterialInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->technique, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMaterialInfo_technique_set) 

static bool js_cc_IMaterialInfo_technique_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMaterialInfo *arg1 = (cc::IMaterialInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->technique, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->technique, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMaterialInfo_technique_get) 

static bool js_cc_IMaterialInfo_defines_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMaterialInfo *arg1 = (cc::IMaterialInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->defines, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMaterialInfo_defines_set) 

static bool js_cc_IMaterialInfo_defines_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMaterialInfo *arg1 = (cc::IMaterialInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->defines, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->defines, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMaterialInfo_defines_get) 

static bool js_cc_IMaterialInfo_states_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMaterialInfo *arg1 = (cc::IMaterialInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->states, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMaterialInfo_states_set) 

static bool js_cc_IMaterialInfo_states_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMaterialInfo *arg1 = (cc::IMaterialInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->states, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->states, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMaterialInfo_states_get) 

static bool js_new_cc_IMaterialInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IMaterialInfo *result;
    result = (cc::IMaterialInfo *)new cc::IMaterialInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IMaterialInfo, __jsb_cc_IMaterialInfo_class, js_delete_cc_IMaterialInfo)

static bool js_delete_cc_IMaterialInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IMaterialInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IMaterialInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IMaterialInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("effectAsset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->effectAsset), ctx);
    }
    
    
    json->getProperty("effectName", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->effectName), ctx);
    }
    
    
    json->getProperty("technique", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->technique), ctx);
    }
    
    
    json->getProperty("defines", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->defines), ctx);
    }
    
    
    json->getProperty("states", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->states), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IMaterialInfo(se::Object* obj) {
    auto* cls = se::Class::create("IMaterialInfo", obj, nullptr, _SE(js_new_cc_IMaterialInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("effectAsset", _SE(js_cc_IMaterialInfo_effectAsset_get), _SE(js_cc_IMaterialInfo_effectAsset_set)); 
    cls->defineProperty("effectName", _SE(js_cc_IMaterialInfo_effectName_get), _SE(js_cc_IMaterialInfo_effectName_set)); 
    cls->defineProperty("technique", _SE(js_cc_IMaterialInfo_technique_get), _SE(js_cc_IMaterialInfo_technique_set)); 
    cls->defineProperty("defines", _SE(js_cc_IMaterialInfo_defines_get), _SE(js_cc_IMaterialInfo_defines_set)); 
    cls->defineProperty("states", _SE(js_cc_IMaterialInfo_states_get), _SE(js_cc_IMaterialInfo_states_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IMaterialInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IMaterialInfo>(cls);
    
    __jsb_cc_IMaterialInfo_proto = cls->getProto();
    __jsb_cc_IMaterialInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Material_class = nullptr;
se::Object* __jsb_cc_Material_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Material) 

static bool js_cc_Material_getHash_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::hash_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = cc::Material::getHashForMaterial(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Material_getHash_static) 

static bool js_new_cc_Material(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::Material *result;
    result = (cc::Material *)new cc::Material();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Material, __jsb_cc_Material_class, js_delete_cc_Material)

static bool js_delete_cc_Material(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Material) 

static bool js_cc_Material_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Material *arg1 = (cc::Material *) NULL ;
    cc::IMaterialInfo *arg2 = 0 ;
    cc::IMaterialInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::IMaterialInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Material_initialize) 

static bool js_cc_Material_reset(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Material *arg1 = (cc::Material *) NULL ;
    cc::IMaterialInfo *arg2 = 0 ;
    cc::IMaterialInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->reset((cc::IMaterialInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Material_reset) 

static bool js_cc_Material_recompileShaders__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    cc::MacroRecord *arg2 = 0 ;
    cc::MacroRecord temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->recompileShaders((cc::MacroRecord const &)*arg2);
    
    
    return true;
}

static bool js_cc_Material_recompileShaders__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    cc::MacroRecord *arg2 = 0 ;
    index_t arg3 ;
    cc::MacroRecord temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->recompileShaders((cc::MacroRecord const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_Material_recompileShaders(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_cc_Material_recompileShaders__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_Material_recompileShaders__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_recompileShaders) 

static bool js_cc_Material_overridePipelineStates__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    cc::PassOverrides *arg2 = 0 ;
    cc::PassOverrides temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->overridePipelineStates((cc::PassOverrides const &)*arg2);
    
    
    return true;
}

static bool js_cc_Material_overridePipelineStates__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    cc::PassOverrides *arg2 = 0 ;
    index_t arg3 ;
    cc::PassOverrides temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->overridePipelineStates((cc::PassOverrides const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_Material_overridePipelineStates(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_cc_Material_overridePipelineStates__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_Material_overridePipelineStates__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_overridePipelineStates) 

static bool js_cc_Material_resetUniforms__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->resetUniforms(arg2);
    
    
    return true;
}

static bool js_cc_Material_resetUniforms__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    (arg1)->resetUniforms();
    
    
    return true;
}

static bool js_cc_Material_resetUniforms(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_cc_Material_resetUniforms__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 0) {
        ok = js_cc_Material_resetUniforms__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_resetUniforms) 

static bool js_cc_Material_setPropertyNull__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    index_t arg3 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPropertyNull((ccstd::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyNull__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setPropertyNull((ccstd::string const &)*arg2);
    
    
    return true;
}

static bool js_cc_Material_setPropertyNull(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_cc_Material_setPropertyNull__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_Material_setPropertyNull__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyNull) 

static bool js_cc_Material_setPropertyFloat32__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    float arg3 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPropertyFloat32((ccstd::string const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyFloat32__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    float arg3 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPropertyFloat32((ccstd::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyFloat32(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_Material_setPropertyFloat32__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_Material_setPropertyFloat32__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyFloat32) 

static bool js_cc_Material_setPropertyInt32__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    int32_t arg3 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPropertyInt32((ccstd::string const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyInt32__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    int32_t arg3 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPropertyInt32((ccstd::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyInt32(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_Material_setPropertyInt32__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_Material_setPropertyInt32__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyInt32) 

static bool js_cc_Material_setPropertyVec2__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Vec2 *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    cc::Vec2 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPropertyVec2((ccstd::string const &)*arg2,(cc::Vec2 const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyVec2__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Vec2 *arg3 = 0 ;
    ccstd::string temp2 ;
    cc::Vec2 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setPropertyVec2((ccstd::string const &)*arg2,(cc::Vec2 const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyVec2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_Material_setPropertyVec2__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_Material_setPropertyVec2__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyVec2) 

static bool js_cc_Material_setPropertyVec3__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    cc::Vec3 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPropertyVec3((ccstd::string const &)*arg2,(cc::Vec3 const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyVec3__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    ccstd::string temp2 ;
    cc::Vec3 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setPropertyVec3((ccstd::string const &)*arg2,(cc::Vec3 const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyVec3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_Material_setPropertyVec3__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_Material_setPropertyVec3__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyVec3) 

static bool js_cc_Material_setPropertyVec4__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Vec4 *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    cc::Vec4 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPropertyVec4((ccstd::string const &)*arg2,(cc::Vec4 const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyVec4__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Vec4 *arg3 = 0 ;
    ccstd::string temp2 ;
    cc::Vec4 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setPropertyVec4((ccstd::string const &)*arg2,(cc::Vec4 const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyVec4(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_Material_setPropertyVec4__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_Material_setPropertyVec4__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyVec4) 

static bool js_cc_Material_setPropertyColor__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Color *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    cc::Color temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPropertyColor((ccstd::string const &)*arg2,(cc::Color const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyColor__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Color *arg3 = 0 ;
    ccstd::string temp2 ;
    cc::Color temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setPropertyColor((ccstd::string const &)*arg2,(cc::Color const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyColor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_Material_setPropertyColor__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_Material_setPropertyColor__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyColor) 

static bool js_cc_Material_setPropertyMat3__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Mat3 *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    cc::Mat3 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPropertyMat3((ccstd::string const &)*arg2,(cc::Mat3 const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyMat3__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Mat3 *arg3 = 0 ;
    ccstd::string temp2 ;
    cc::Mat3 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setPropertyMat3((ccstd::string const &)*arg2,(cc::Mat3 const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyMat3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_Material_setPropertyMat3__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_Material_setPropertyMat3__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyMat3) 

static bool js_cc_Material_setPropertyMat4__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Mat4 *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    cc::Mat4 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPropertyMat4((ccstd::string const &)*arg2,(cc::Mat4 const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyMat4__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Mat4 *arg3 = 0 ;
    ccstd::string temp2 ;
    cc::Mat4 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setPropertyMat4((ccstd::string const &)*arg2,(cc::Mat4 const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyMat4(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_Material_setPropertyMat4__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_Material_setPropertyMat4__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyMat4) 

static bool js_cc_Material_setPropertyQuaternion__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Quaternion *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    cc::Quaternion temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPropertyQuaternion((ccstd::string const &)*arg2,(cc::Quaternion const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyQuaternion__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Quaternion *arg3 = 0 ;
    ccstd::string temp2 ;
    cc::Quaternion temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setPropertyQuaternion((ccstd::string const &)*arg2,(cc::Quaternion const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyQuaternion(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_Material_setPropertyQuaternion__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_Material_setPropertyQuaternion__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyQuaternion) 

static bool js_cc_Material_setPropertyTextureBase__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::TextureBase *arg3 = (cc::TextureBase *) NULL ;
    index_t arg4 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPropertyTextureBase((ccstd::string const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyTextureBase__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::TextureBase *arg3 = (cc::TextureBase *) NULL ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPropertyTextureBase((ccstd::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyTextureBase(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_Material_setPropertyTextureBase__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_Material_setPropertyTextureBase__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyTextureBase) 

static bool js_cc_Material_setPropertyGFXTexture__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::gfx::Texture *arg3 = (cc::gfx::Texture *) NULL ;
    index_t arg4 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPropertyGFXTexture((ccstd::string const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyGFXTexture__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::gfx::Texture *arg3 = (cc::gfx::Texture *) NULL ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPropertyGFXTexture((ccstd::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyGFXTexture(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_Material_setPropertyGFXTexture__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_Material_setPropertyGFXTexture__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyGFXTexture) 

static bool js_cc_Material_setPropertyFloat32Array__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< float > *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    ccstd::vector< float > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPropertyFloat32Array((ccstd::string const &)*arg2,(ccstd::vector< float > const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyFloat32Array__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< float > *arg3 = 0 ;
    ccstd::string temp2 ;
    ccstd::vector< float > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setPropertyFloat32Array((ccstd::string const &)*arg2,(ccstd::vector< float > const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyFloat32Array(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_Material_setPropertyFloat32Array__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_Material_setPropertyFloat32Array__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyFloat32Array) 

static bool js_cc_Material_setPropertyInt32Array__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< int32_t > *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    ccstd::vector< int32_t > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPropertyInt32Array((ccstd::string const &)*arg2,(ccstd::vector< int32_t > const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyInt32Array__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< int32_t > *arg3 = 0 ;
    ccstd::string temp2 ;
    ccstd::vector< int32_t > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setPropertyInt32Array((ccstd::string const &)*arg2,(ccstd::vector< int32_t > const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyInt32Array(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_Material_setPropertyInt32Array__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_Material_setPropertyInt32Array__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyInt32Array) 

static bool js_cc_Material_setPropertyVec2Array__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Vec2 > *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Vec2 > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPropertyVec2Array((ccstd::string const &)*arg2,(ccstd::vector< cc::Vec2 > const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyVec2Array__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Vec2 > *arg3 = 0 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Vec2 > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setPropertyVec2Array((ccstd::string const &)*arg2,(ccstd::vector< cc::Vec2 > const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyVec2Array(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_Material_setPropertyVec2Array__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_Material_setPropertyVec2Array__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyVec2Array) 

static bool js_cc_Material_setPropertyVec3Array__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Vec3 > *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Vec3 > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPropertyVec3Array((ccstd::string const &)*arg2,(ccstd::vector< cc::Vec3 > const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyVec3Array__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Vec3 > *arg3 = 0 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Vec3 > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setPropertyVec3Array((ccstd::string const &)*arg2,(ccstd::vector< cc::Vec3 > const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyVec3Array(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_Material_setPropertyVec3Array__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_Material_setPropertyVec3Array__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyVec3Array) 

static bool js_cc_Material_setPropertyVec4Array__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Vec4 > *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Vec4 > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPropertyVec4Array((ccstd::string const &)*arg2,(ccstd::vector< cc::Vec4 > const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyVec4Array__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Vec4 > *arg3 = 0 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Vec4 > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setPropertyVec4Array((ccstd::string const &)*arg2,(ccstd::vector< cc::Vec4 > const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyVec4Array(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_Material_setPropertyVec4Array__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_Material_setPropertyVec4Array__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyVec4Array) 

static bool js_cc_Material_setPropertyColorArray__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Color > *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Color > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPropertyColorArray((ccstd::string const &)*arg2,(ccstd::vector< cc::Color > const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyColorArray__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Color > *arg3 = 0 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Color > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setPropertyColorArray((ccstd::string const &)*arg2,(ccstd::vector< cc::Color > const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyColorArray(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_Material_setPropertyColorArray__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_Material_setPropertyColorArray__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyColorArray) 

static bool js_cc_Material_setPropertyMat3Array__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Mat3 > *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Mat3 > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPropertyMat3Array((ccstd::string const &)*arg2,(ccstd::vector< cc::Mat3 > const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyMat3Array__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Mat3 > *arg3 = 0 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Mat3 > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setPropertyMat3Array((ccstd::string const &)*arg2,(ccstd::vector< cc::Mat3 > const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyMat3Array(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_Material_setPropertyMat3Array__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_Material_setPropertyMat3Array__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyMat3Array) 

static bool js_cc_Material_setPropertyMat4Array__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Mat4 > *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Mat4 > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPropertyMat4Array((ccstd::string const &)*arg2,(ccstd::vector< cc::Mat4 > const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyMat4Array__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Mat4 > *arg3 = 0 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Mat4 > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setPropertyMat4Array((ccstd::string const &)*arg2,(ccstd::vector< cc::Mat4 > const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyMat4Array(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_Material_setPropertyMat4Array__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_Material_setPropertyMat4Array__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyMat4Array) 

static bool js_cc_Material_setPropertyQuaternionArray__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Quaternion > *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Quaternion > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPropertyQuaternionArray((ccstd::string const &)*arg2,(ccstd::vector< cc::Quaternion > const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyQuaternionArray__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::Quaternion > *arg3 = 0 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::Quaternion > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setPropertyQuaternionArray((ccstd::string const &)*arg2,(ccstd::vector< cc::Quaternion > const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyQuaternionArray(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_Material_setPropertyQuaternionArray__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_Material_setPropertyQuaternionArray__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyQuaternionArray) 

static bool js_cc_Material_setPropertyTextureBaseArray__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::TextureBase * > *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::TextureBase * > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPropertyTextureBaseArray((ccstd::string const &)*arg2,(ccstd::vector< cc::TextureBase * > const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyTextureBaseArray__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::TextureBase * > *arg3 = 0 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::TextureBase * > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setPropertyTextureBaseArray((ccstd::string const &)*arg2,(ccstd::vector< cc::TextureBase * > const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyTextureBaseArray(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_Material_setPropertyTextureBaseArray__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_Material_setPropertyTextureBaseArray__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyTextureBaseArray) 

static bool js_cc_Material_setPropertyGFXTextureArray__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::gfx::Texture * > *arg3 = 0 ;
    index_t arg4 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::gfx::Texture * > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPropertyGFXTextureArray((ccstd::string const &)*arg2,(ccstd::vector< cc::gfx::Texture * > const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Material_setPropertyGFXTextureArray__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::vector< cc::gfx::Texture * > *arg3 = 0 ;
    ccstd::string temp2 ;
    ccstd::vector< cc::gfx::Texture * > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setPropertyGFXTextureArray((ccstd::string const &)*arg2,(ccstd::vector< cc::gfx::Texture * > const &)*arg3);
    
    
    return true;
}

static bool js_cc_Material_setPropertyGFXTextureArray(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_Material_setPropertyGFXTextureArray__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_Material_setPropertyGFXTextureArray__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_setPropertyGFXTextureArray) 

static bool js_cc_Material__getProperty__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    index_t arg3 ;
    ccstd::string temp2 ;
    cc::MaterialPropertyVariant *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::MaterialPropertyVariant *)((cc::Material const *)arg1)->getProperty((ccstd::string const &)*arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_Material__getProperty__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    cc::MaterialPropertyVariant *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::MaterialPropertyVariant *)((cc::Material const *)arg1)->getProperty((ccstd::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_Material__getProperty(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_cc_Material__getProperty__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_Material__getProperty__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material__getProperty) 

static bool js_cc_Material_copy__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    cc::Material *arg2 = (cc::Material *) NULL ;
    cc::IMaterialInfo *arg3 = (cc::IMaterialInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->copy((cc::Material const *)arg2,arg3);
    
    
    return true;
}

static bool js_cc_Material_copy__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Material *arg1 = (cc::Material *) NULL ;
    cc::Material *arg2 = (cc::Material *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->copy((cc::Material const *)arg2);
    
    
    return true;
}

static bool js_cc_Material_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_cc_Material_copy__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_Material_copy__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Material_copy) 

static bool js_cc_Material_fillInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Material *arg1 = (cc::Material *) NULL ;
    cc::IMaterialInfo *arg2 = 0 ;
    cc::IMaterialInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->fillInfo((cc::IMaterialInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Material_fillInfo) 

static bool js_cc_Material__effectAsset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Material *arg1 = (cc::Material *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_effectAsset, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Material__effectAsset_set) 

static bool js_cc_Material__effectAsset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Material *arg1 = (cc::Material *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_effectAsset, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_effectAsset, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Material__effectAsset_get) 

static bool js_cc_Material__techIdx_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Material *arg1 = (cc::Material *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_techIdx, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Material__techIdx_set) 

static bool js_cc_Material__techIdx_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Material *arg1 = (cc::Material *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_techIdx, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Material__techIdx_get) 

static bool js_cc_Material__defines_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Material *arg1 = (cc::Material *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_defines, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Material__defines_set) 

static bool js_cc_Material__defines_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Material *arg1 = (cc::Material *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_defines, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_defines, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Material__defines_get) 

static bool js_cc_Material__states_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Material *arg1 = (cc::Material *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_states, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Material__states_set) 

static bool js_cc_Material__states_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Material *arg1 = (cc::Material *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_states, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_states, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Material__states_get) 

static bool js_cc_Material__propsInternal_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Material *arg1 = (cc::Material *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_props, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Material__propsInternal_set) 

static bool js_cc_Material__propsInternal_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Material *arg1 = (cc::Material *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_props, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_props, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Material__propsInternal_get) 

static bool js_cc_Material_getPasses(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Material *arg1 = (cc::Material *) NULL ;
    std::shared_ptr< ccstd::vector< cc::IntrusivePtr< cc::scene::Pass > > > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    result = (std::shared_ptr< ccstd::vector< cc::IntrusivePtr< cc::scene::Pass > > > *) &(arg1)->getPasses();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Material_getPasses) 

static bool js_cc_Material_effectAsset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Material *arg1 = (cc::Material *) NULL ;
    cc::EffectAsset *arg2 = (cc::EffectAsset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_Material_effectAsset_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Material_effectAsset_set) 

static bool js_cc_Material_effectAsset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Material *arg1 = (cc::Material *) NULL ;
    cc::EffectAsset *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    result = (cc::EffectAsset *)cc_Material_effectAsset_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Material_effectAsset_get) 

static bool js_cc_Material_effectName_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::string result;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    result = cc_Material_effectName_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Material_effectName_get) 

static bool js_cc_Material_technique_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Material *arg1 = (cc::Material *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    result = cc_Material_technique_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Material_technique_get) 

static bool js_cc_Material_hash_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Material *arg1 = (cc::Material *) NULL ;
    ccstd::hash_t result;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    result = cc_Material_hash_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Material_hash_get) 

static bool js_cc_Material_parent_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Material *arg1 = (cc::Material *) NULL ;
    cc::Material *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Material>(s);
    if (nullptr == arg1) return true;
    result = (cc::Material *)cc_Material_parent_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Material_parent_get) 

bool js_register_cc_Material(se::Object* obj) {
    auto* cls = se::Class::create("Material", obj, __jsb_cc_Asset_proto, _SE(js_new_cc_Material)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("_effectAsset", _SE(js_cc_Material__effectAsset_get), _SE(js_cc_Material__effectAsset_set)); 
    cls->defineProperty("_techIdx", _SE(js_cc_Material__techIdx_get), _SE(js_cc_Material__techIdx_set)); 
    cls->defineProperty("_defines", _SE(js_cc_Material__defines_get), _SE(js_cc_Material__defines_set)); 
    cls->defineProperty("_states", _SE(js_cc_Material__states_get), _SE(js_cc_Material__states_set)); 
    cls->defineProperty("_propsInternal", _SE(js_cc_Material__propsInternal_get), _SE(js_cc_Material__propsInternal_set)); 
    cls->defineProperty("effectAsset", _SE(js_cc_Material_effectAsset_get), _SE(js_cc_Material_effectAsset_set)); 
    cls->defineProperty("effectName", _SE(js_cc_Material_effectName_get), nullptr); 
    cls->defineProperty("technique", _SE(js_cc_Material_technique_get), nullptr); 
    cls->defineProperty("hash", _SE(js_cc_Material_hash_get), nullptr); 
    cls->defineProperty("parent", _SE(js_cc_Material_parent_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_Material_initialize)); 
    cls->defineFunction("reset", _SE(js_cc_Material_reset)); 
    cls->defineFunction("recompileShaders", _SE(js_cc_Material_recompileShaders)); 
    cls->defineFunction("overridePipelineStates", _SE(js_cc_Material_overridePipelineStates)); 
    cls->defineFunction("resetUniforms", _SE(js_cc_Material_resetUniforms)); 
    cls->defineFunction("setPropertyNull", _SE(js_cc_Material_setPropertyNull)); 
    cls->defineFunction("setPropertyFloat32", _SE(js_cc_Material_setPropertyFloat32)); 
    cls->defineFunction("setPropertyInt32", _SE(js_cc_Material_setPropertyInt32)); 
    cls->defineFunction("setPropertyVec2", _SE(js_cc_Material_setPropertyVec2)); 
    cls->defineFunction("setPropertyVec3", _SE(js_cc_Material_setPropertyVec3)); 
    cls->defineFunction("setPropertyVec4", _SE(js_cc_Material_setPropertyVec4)); 
    cls->defineFunction("setPropertyColor", _SE(js_cc_Material_setPropertyColor)); 
    cls->defineFunction("setPropertyMat3", _SE(js_cc_Material_setPropertyMat3)); 
    cls->defineFunction("setPropertyMat4", _SE(js_cc_Material_setPropertyMat4)); 
    cls->defineFunction("setPropertyQuaternion", _SE(js_cc_Material_setPropertyQuaternion)); 
    cls->defineFunction("setPropertyTextureBase", _SE(js_cc_Material_setPropertyTextureBase)); 
    cls->defineFunction("setPropertyGFXTexture", _SE(js_cc_Material_setPropertyGFXTexture)); 
    cls->defineFunction("setPropertyFloat32Array", _SE(js_cc_Material_setPropertyFloat32Array)); 
    cls->defineFunction("setPropertyInt32Array", _SE(js_cc_Material_setPropertyInt32Array)); 
    cls->defineFunction("setPropertyVec2Array", _SE(js_cc_Material_setPropertyVec2Array)); 
    cls->defineFunction("setPropertyVec3Array", _SE(js_cc_Material_setPropertyVec3Array)); 
    cls->defineFunction("setPropertyVec4Array", _SE(js_cc_Material_setPropertyVec4Array)); 
    cls->defineFunction("setPropertyColorArray", _SE(js_cc_Material_setPropertyColorArray)); 
    cls->defineFunction("setPropertyMat3Array", _SE(js_cc_Material_setPropertyMat3Array)); 
    cls->defineFunction("setPropertyMat4Array", _SE(js_cc_Material_setPropertyMat4Array)); 
    cls->defineFunction("setPropertyQuaternionArray", _SE(js_cc_Material_setPropertyQuaternionArray)); 
    cls->defineFunction("setPropertyTextureBaseArray", _SE(js_cc_Material_setPropertyTextureBaseArray)); 
    cls->defineFunction("setPropertyGFXTextureArray", _SE(js_cc_Material_setPropertyGFXTextureArray)); 
    cls->defineFunction("_getProperty", _SE(js_cc_Material__getProperty)); 
    cls->defineFunction("copy", _SE(js_cc_Material_copy)); 
    cls->defineFunction("fillInfo", _SE(js_cc_Material_fillInfo)); 
    cls->defineFunction("getPasses", _SE(js_cc_Material_getPasses)); 
    
    
    cls->defineStaticFunction("getHash", _SE(js_cc_Material_getHash_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Material));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Material>(cls);
    
    __jsb_cc_Material_proto = cls->getProto();
    __jsb_cc_Material_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IGeometricInfo_class = nullptr;
se::Object* __jsb_cc_IGeometricInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IGeometricInfo) 

static bool js_cc_IGeometricInfo_positions_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometricInfo *arg1 = (cc::IGeometricInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometricInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->positions, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometricInfo_positions_set) 

static bool js_cc_IGeometricInfo_positions_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometricInfo *arg1 = (cc::IGeometricInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometricInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->positions, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->positions, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometricInfo_positions_get) 

static bool js_cc_IGeometricInfo_indices_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometricInfo *arg1 = (cc::IGeometricInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometricInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->indices, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometricInfo_indices_set) 

static bool js_cc_IGeometricInfo_indices_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometricInfo *arg1 = (cc::IGeometricInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometricInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->indices, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->indices, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometricInfo_indices_get) 

static bool js_cc_IGeometricInfo_doubleSided_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometricInfo *arg1 = (cc::IGeometricInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometricInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->doubleSided, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometricInfo_doubleSided_set) 

static bool js_cc_IGeometricInfo_doubleSided_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometricInfo *arg1 = (cc::IGeometricInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometricInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->doubleSided, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->doubleSided, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometricInfo_doubleSided_get) 

static bool js_cc_IGeometricInfo_boundingBox_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IGeometricInfo *arg1 = (cc::IGeometricInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometricInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->boundingBox, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IGeometricInfo_boundingBox_set) 

static bool js_cc_IGeometricInfo_boundingBox_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IGeometricInfo *arg1 = (cc::IGeometricInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IGeometricInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->boundingBox, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->boundingBox, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IGeometricInfo_boundingBox_get) 

static bool js_new_cc_IGeometricInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IGeometricInfo *result;
    result = (cc::IGeometricInfo *)new cc::IGeometricInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IGeometricInfo, __jsb_cc_IGeometricInfo_class, js_delete_cc_IGeometricInfo)

static bool js_delete_cc_IGeometricInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IGeometricInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IGeometricInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IGeometricInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("positions", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->positions), ctx);
    }
    
    
    json->getProperty("indices", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->indices), ctx);
    }
    
    
    json->getProperty("doubleSided", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->doubleSided), ctx);
    }
    
    
    json->getProperty("boundingBox", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->boundingBox), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IGeometricInfo(se::Object* obj) {
    auto* cls = se::Class::create("IGeometricInfo", obj, nullptr, _SE(js_new_cc_IGeometricInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("positions", _SE(js_cc_IGeometricInfo_positions_get), _SE(js_cc_IGeometricInfo_positions_set)); 
    cls->defineProperty("indices", _SE(js_cc_IGeometricInfo_indices_get), _SE(js_cc_IGeometricInfo_indices_set)); 
    cls->defineProperty("doubleSided", _SE(js_cc_IGeometricInfo_doubleSided_get), _SE(js_cc_IGeometricInfo_doubleSided_set)); 
    cls->defineProperty("boundingBox", _SE(js_cc_IGeometricInfo_boundingBox_get), _SE(js_cc_IGeometricInfo_boundingBox_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IGeometricInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IGeometricInfo>(cls);
    
    __jsb_cc_IGeometricInfo_proto = cls->getProto();
    __jsb_cc_IGeometricInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IFlatBuffer_class = nullptr;
se::Object* __jsb_cc_IFlatBuffer_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IFlatBuffer) 

static bool js_cc_IFlatBuffer_stride_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IFlatBuffer *arg1 = (cc::IFlatBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IFlatBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stride, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IFlatBuffer_stride_set) 

static bool js_cc_IFlatBuffer_stride_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IFlatBuffer *arg1 = (cc::IFlatBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IFlatBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stride, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IFlatBuffer_stride_get) 

static bool js_cc_IFlatBuffer_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IFlatBuffer *arg1 = (cc::IFlatBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IFlatBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IFlatBuffer_count_set) 

static bool js_cc_IFlatBuffer_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IFlatBuffer *arg1 = (cc::IFlatBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IFlatBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IFlatBuffer_count_get) 

static bool js_cc_IFlatBuffer_buffer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IFlatBuffer *arg1 = (cc::IFlatBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IFlatBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->buffer, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IFlatBuffer_buffer_set) 

static bool js_cc_IFlatBuffer_buffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IFlatBuffer *arg1 = (cc::IFlatBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IFlatBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->buffer, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->buffer, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IFlatBuffer_buffer_get) 

static bool js_new_cc_IFlatBuffer(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IFlatBuffer *result;
    result = (cc::IFlatBuffer *)new cc::IFlatBuffer();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IFlatBuffer, __jsb_cc_IFlatBuffer_class, js_delete_cc_IFlatBuffer)

static bool js_delete_cc_IFlatBuffer(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IFlatBuffer) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IFlatBuffer * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IFlatBuffer*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("stride", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stride), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("buffer", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->buffer), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IFlatBuffer(se::Object* obj) {
    auto* cls = se::Class::create("IFlatBuffer", obj, nullptr, _SE(js_new_cc_IFlatBuffer)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("stride", _SE(js_cc_IFlatBuffer_stride_get), _SE(js_cc_IFlatBuffer_stride_set)); 
    cls->defineProperty("count", _SE(js_cc_IFlatBuffer_count_get), _SE(js_cc_IFlatBuffer_count_set)); 
    cls->defineProperty("buffer", _SE(js_cc_IFlatBuffer_buffer_get), _SE(js_cc_IFlatBuffer_buffer_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IFlatBuffer));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IFlatBuffer>(cls);
    
    __jsb_cc_IFlatBuffer_proto = cls->getProto();
    __jsb_cc_IFlatBuffer_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_RenderingSubMesh_class = nullptr;
se::Object* __jsb_cc_RenderingSubMesh_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_RenderingSubMesh) 

static bool js_new_cc_RenderingSubMesh__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::gfx::BufferList *arg1 = 0 ;
    cc::gfx::AttributeList *arg2 = 0 ;
    cc::gfx::PrimitiveMode arg3 ;
    cc::gfx::BufferList temp1 ;
    cc::gfx::AttributeList temp2 ;
    cc::RenderingSubMesh *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = (cc::RenderingSubMesh *)new cc::RenderingSubMesh((cc::gfx::BufferList const &)*arg1,(cc::gfx::AttributeList const &)*arg2,arg3);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_RenderingSubMesh__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::gfx::BufferList *arg1 = 0 ;
    cc::gfx::AttributeList *arg2 = 0 ;
    cc::gfx::PrimitiveMode arg3 ;
    cc::gfx::Buffer *arg4 = (cc::gfx::Buffer *) NULL ;
    cc::gfx::BufferList temp1 ;
    cc::gfx::AttributeList temp2 ;
    cc::RenderingSubMesh *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::RenderingSubMesh *)new cc::RenderingSubMesh((cc::gfx::BufferList const &)*arg1,(cc::gfx::AttributeList const &)*arg2,arg3,arg4);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_RenderingSubMesh__SWIG_2(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::gfx::BufferList *arg1 = 0 ;
    cc::gfx::AttributeList *arg2 = 0 ;
    cc::gfx::PrimitiveMode arg3 ;
    cc::gfx::Buffer *arg4 = (cc::gfx::Buffer *) NULL ;
    cc::gfx::Buffer *arg5 = (cc::gfx::Buffer *) NULL ;
    cc::gfx::BufferList temp1 ;
    cc::gfx::AttributeList temp2 ;
    cc::RenderingSubMesh *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::RenderingSubMesh *)new cc::RenderingSubMesh((cc::gfx::BufferList const &)*arg1,(cc::gfx::AttributeList const &)*arg2,arg3,arg4,arg5);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_RenderingSubMesh__SWIG_3(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::gfx::BufferList *arg1 = 0 ;
    cc::gfx::AttributeList *arg2 = 0 ;
    cc::gfx::PrimitiveMode arg3 ;
    cc::gfx::Buffer *arg4 = (cc::gfx::Buffer *) NULL ;
    cc::gfx::Buffer *arg5 = (cc::gfx::Buffer *) NULL ;
    bool arg6 ;
    cc::gfx::BufferList temp1 ;
    cc::gfx::AttributeList temp2 ;
    cc::RenderingSubMesh *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::RenderingSubMesh *)new cc::RenderingSubMesh((cc::gfx::BufferList const &)*arg1,(cc::gfx::AttributeList const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_RenderingSubMesh(se::State& s) // NOLINT(readability-identifier-naming)
{
    size_t argc = s.args().size();
    bool ret = false;
    
    if(argc == 3) {
        ret = js_new_cc_RenderingSubMesh__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 4) {
        ret = js_new_cc_RenderingSubMesh__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 5) {
        ret = js_new_cc_RenderingSubMesh__SWIG_2(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 6) {
        ret = js_new_cc_RenderingSubMesh__SWIG_3(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    SE_REPORT_ERROR("Illegal arguments for construction of RenderingSubMesh");
    return false;
}
SE_BIND_CTOR(js_new_RenderingSubMesh, __jsb_cc_RenderingSubMesh_class, js_delete_cc_RenderingSubMesh)

static bool js_delete_cc_RenderingSubMesh(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_RenderingSubMesh) 

static bool js_cc_RenderingSubMesh_getAttributes(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    cc::gfx::AttributeList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::AttributeList *) &((cc::RenderingSubMesh const *)arg1)->getAttributes();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderingSubMesh_getAttributes) 

static bool js_cc_RenderingSubMesh_getVertexBuffers(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    cc::gfx::BufferList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::BufferList *) &((cc::RenderingSubMesh const *)arg1)->getVertexBuffers();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderingSubMesh_getVertexBuffers) 

static bool js_cc_RenderingSubMesh_getIndexBuffer(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    cc::gfx::Buffer *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Buffer *)((cc::RenderingSubMesh const *)arg1)->getIndexBuffer();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderingSubMesh_getIndexBuffer) 

static bool js_cc_RenderingSubMesh_indirectBuffer(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    cc::gfx::Buffer *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Buffer *)((cc::RenderingSubMesh const *)arg1)->indirectBuffer();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderingSubMesh_indirectBuffer) 

static bool js_cc_RenderingSubMesh_getGeometricInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    cc::IGeometricInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    if (nullptr == arg1) return true;
    result = (cc::IGeometricInfo *) &(arg1)->getGeometricInfo();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderingSubMesh_getGeometricInfo) 

static bool js_cc_RenderingSubMesh_invalidateGeometricInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    if (nullptr == arg1) return true;
    (arg1)->invalidateGeometricInfo();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderingSubMesh_invalidateGeometricInfo) 

static bool js_cc_RenderingSubMesh_genFlatBuffers(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    if (nullptr == arg1) return true;
    (arg1)->genFlatBuffers();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderingSubMesh_genFlatBuffers) 

static bool js_cc_RenderingSubMesh_setDrawInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    cc::gfx::DrawInfo *arg2 = 0 ;
    cc::gfx::DrawInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setDrawInfo((cc::gfx::DrawInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderingSubMesh_setDrawInfo) 

static bool js_cc_RenderingSubMesh_getDrawInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    ccstd::optional< cc::gfx::DrawInfo > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::optional< cc::gfx::DrawInfo > *) &(arg1)->getDrawInfo();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderingSubMesh_getDrawInfo) 

static bool js_cc_RenderingSubMesh_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->destroy();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderingSubMesh_destroy) 

static bool js_cc_RenderingSubMesh_enableVertexIdChannel(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    cc::gfx::Device *arg2 = (cc::gfx::Device *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->enableVertexIdChannel(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderingSubMesh_enableVertexIdChannel) 

static bool js_cc_RenderingSubMesh_mesh_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    cc::Mesh *arg2 = (cc::Mesh *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_RenderingSubMesh_mesh_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderingSubMesh_mesh_set) 

static bool js_cc_RenderingSubMesh_mesh_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    cc::Mesh *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    if (nullptr == arg1) return true;
    result = (cc::Mesh *)cc_RenderingSubMesh_mesh_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderingSubMesh_mesh_get) 

static bool js_cc_RenderingSubMesh_subMeshIdx_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    ccstd::optional< uint32_t > *arg2 = 0 ;
    ccstd::optional< uint32_t > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_RenderingSubMesh_subMeshIdx_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderingSubMesh_subMeshIdx_set) 

static bool js_cc_RenderingSubMesh_subMeshIdx_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    ccstd::optional< uint32_t > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::optional< uint32_t > *) &cc_RenderingSubMesh_subMeshIdx_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderingSubMesh_subMeshIdx_get) 

static bool js_cc_RenderingSubMesh_flatBuffers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    ccstd::vector< cc::IFlatBuffer > *arg2 = 0 ;
    ccstd::vector< cc::IFlatBuffer > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_RenderingSubMesh_flatBuffers_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderingSubMesh_flatBuffers_set) 

static bool js_cc_RenderingSubMesh_flatBuffers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    ccstd::vector< cc::IFlatBuffer > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::IFlatBuffer > *) &cc_RenderingSubMesh_flatBuffers_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderingSubMesh_flatBuffers_get) 

static bool js_cc_RenderingSubMesh__flatBuffers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    ccstd::vector< cc::IFlatBuffer > *arg2 = 0 ;
    ccstd::vector< cc::IFlatBuffer > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_RenderingSubMesh__flatBuffers_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderingSubMesh__flatBuffers_set) 

static bool js_cc_RenderingSubMesh__flatBuffers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    ccstd::vector< cc::IFlatBuffer > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::IFlatBuffer > *) &cc_RenderingSubMesh__flatBuffers_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderingSubMesh__flatBuffers_get) 

static bool js_cc_RenderingSubMesh_jointMappedBuffers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    cc::gfx::BufferList *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::BufferList *) &cc_RenderingSubMesh_jointMappedBuffers_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderingSubMesh_jointMappedBuffers_get) 

static bool js_cc_RenderingSubMesh_iaInfo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    cc::gfx::InputAssemblerInfo *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::InputAssemblerInfo *) &cc_RenderingSubMesh_iaInfo_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderingSubMesh_iaInfo_get) 

static bool js_cc_RenderingSubMesh__iaInfo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    cc::gfx::InputAssemblerInfo *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::InputAssemblerInfo *) &cc_RenderingSubMesh__iaInfo_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderingSubMesh__iaInfo_get) 

static bool js_cc_RenderingSubMesh_primitiveMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderingSubMesh *arg1 = (cc::RenderingSubMesh *) NULL ;
    cc::gfx::PrimitiveMode result;
    
    arg1 = SE_THIS_OBJECT<cc::RenderingSubMesh>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::PrimitiveMode)cc_RenderingSubMesh_primitiveMode_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderingSubMesh_primitiveMode_get) 

bool js_register_cc_RenderingSubMesh(se::Object* obj) {
    auto* cls = se::Class::create("RenderingSubMesh", obj, nullptr, _SE(js_new_RenderingSubMesh)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("mesh", _SE(js_cc_RenderingSubMesh_mesh_get), _SE(js_cc_RenderingSubMesh_mesh_set)); 
    cls->defineProperty("subMeshIdx", _SE(js_cc_RenderingSubMesh_subMeshIdx_get), _SE(js_cc_RenderingSubMesh_subMeshIdx_set)); 
    cls->defineProperty("flatBuffers", _SE(js_cc_RenderingSubMesh_flatBuffers_get), _SE(js_cc_RenderingSubMesh_flatBuffers_set)); 
    cls->defineProperty("_flatBuffers", _SE(js_cc_RenderingSubMesh__flatBuffers_get), _SE(js_cc_RenderingSubMesh__flatBuffers_set)); 
    cls->defineProperty("jointMappedBuffers", _SE(js_cc_RenderingSubMesh_jointMappedBuffers_get), nullptr); 
    cls->defineProperty("iaInfo", _SE(js_cc_RenderingSubMesh_iaInfo_get), nullptr); 
    cls->defineProperty("_iaInfo", _SE(js_cc_RenderingSubMesh__iaInfo_get), nullptr); 
    cls->defineProperty("primitiveMode", _SE(js_cc_RenderingSubMesh_primitiveMode_get), nullptr); 
    
    cls->defineFunction("getAttributes", _SE(js_cc_RenderingSubMesh_getAttributes)); 
    cls->defineFunction("getVertexBuffers", _SE(js_cc_RenderingSubMesh_getVertexBuffers)); 
    cls->defineFunction("getIndexBuffer", _SE(js_cc_RenderingSubMesh_getIndexBuffer)); 
    cls->defineFunction("indirectBuffer", _SE(js_cc_RenderingSubMesh_indirectBuffer)); 
    cls->defineFunction("getGeometricInfo", _SE(js_cc_RenderingSubMesh_getGeometricInfo)); 
    cls->defineFunction("invalidateGeometricInfo", _SE(js_cc_RenderingSubMesh_invalidateGeometricInfo)); 
    cls->defineFunction("genFlatBuffers", _SE(js_cc_RenderingSubMesh_genFlatBuffers)); 
    cls->defineFunction("setDrawInfo", _SE(js_cc_RenderingSubMesh_setDrawInfo)); 
    cls->defineFunction("getDrawInfo", _SE(js_cc_RenderingSubMesh_getDrawInfo)); 
    cls->defineFunction("destroy", _SE(js_cc_RenderingSubMesh_destroy)); 
    cls->defineFunction("enableVertexIdChannel", _SE(js_cc_RenderingSubMesh_enableVertexIdChannel)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_RenderingSubMesh));
    
    
    cls->install();
    JSBClassType::registerClass<cc::RenderingSubMesh>(cls);
    
    __jsb_cc_RenderingSubMesh_proto = cls->getProto();
    __jsb_cc_RenderingSubMesh_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_BuiltinResMgr_class = nullptr;
se::Object* __jsb_cc_BuiltinResMgr_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_BuiltinResMgr) 

static bool js_cc_BuiltinResMgr_getInstance_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BuiltinResMgr *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::BuiltinResMgr *)cc::BuiltinResMgr::getInstance();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BuiltinResMgr_getInstance_static) 

static bool js_new_cc_BuiltinResMgr(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::BuiltinResMgr *result;
    result = (cc::BuiltinResMgr *)new cc::BuiltinResMgr();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_BuiltinResMgr, __jsb_cc_BuiltinResMgr_class, js_delete_cc_BuiltinResMgr)

static bool js_delete_cc_BuiltinResMgr(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_BuiltinResMgr) 

static bool js_cc_BuiltinResMgr_initBuiltinRes(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BuiltinResMgr *arg1 = (cc::BuiltinResMgr *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BuiltinResMgr>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->initBuiltinRes();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BuiltinResMgr_initBuiltinRes) 

static bool js_cc_BuiltinResMgr_isInitialized(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BuiltinResMgr *arg1 = (cc::BuiltinResMgr *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BuiltinResMgr>(s);
    if (nullptr == arg1) return true;
    result = (bool)((cc::BuiltinResMgr const *)arg1)->isInitialized();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BuiltinResMgr_isInitialized) 

static bool js_cc_BuiltinResMgr_addAsset(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BuiltinResMgr *arg1 = (cc::BuiltinResMgr *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Asset *arg3 = (cc::Asset *) NULL ;
    ccstd::string temp2 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BuiltinResMgr>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addAsset((ccstd::string const &)*arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BuiltinResMgr_addAsset) 

static bool js_cc_BuiltinResMgr_getAsset(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BuiltinResMgr *arg1 = (cc::BuiltinResMgr *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    cc::Asset *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BuiltinResMgr>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::Asset *)(arg1)->getAsset((ccstd::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BuiltinResMgr_getAsset) 

bool js_register_cc_BuiltinResMgr(se::Object* obj) {
    auto* cls = se::Class::create("BuiltinResMgr", obj, nullptr, _SE(js_new_cc_BuiltinResMgr)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("initBuiltinRes", _SE(js_cc_BuiltinResMgr_initBuiltinRes)); 
    cls->defineFunction("isInitialized", _SE(js_cc_BuiltinResMgr_isInitialized)); 
    cls->defineFunction("addAsset", _SE(js_cc_BuiltinResMgr_addAsset)); 
    cls->defineFunction("getAsset", _SE(js_cc_BuiltinResMgr_getAsset)); 
    
    
    cls->defineStaticFunction("getInstance", _SE(js_cc_BuiltinResMgr_getInstance_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_BuiltinResMgr));
    
    
    cls->install();
    JSBClassType::registerClass<cc::BuiltinResMgr>(cls);
    
    __jsb_cc_BuiltinResMgr_proto = cls->getProto();
    __jsb_cc_BuiltinResMgr_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IMeshBufferView_class = nullptr;
se::Object* __jsb_cc_IMeshBufferView_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IMeshBufferView) 

static bool js_cc_IMeshBufferView_offset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMeshBufferView *arg1 = (cc::IMeshBufferView *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMeshBufferView>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->offset, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMeshBufferView_offset_set) 

static bool js_cc_IMeshBufferView_offset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMeshBufferView *arg1 = (cc::IMeshBufferView *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMeshBufferView>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->offset, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMeshBufferView_offset_get) 

static bool js_cc_IMeshBufferView_length_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMeshBufferView *arg1 = (cc::IMeshBufferView *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMeshBufferView>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->length, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMeshBufferView_length_set) 

static bool js_cc_IMeshBufferView_length_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMeshBufferView *arg1 = (cc::IMeshBufferView *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMeshBufferView>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->length, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMeshBufferView_length_get) 

static bool js_cc_IMeshBufferView_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMeshBufferView *arg1 = (cc::IMeshBufferView *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMeshBufferView>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMeshBufferView_count_set) 

static bool js_cc_IMeshBufferView_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMeshBufferView *arg1 = (cc::IMeshBufferView *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMeshBufferView>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMeshBufferView_count_get) 

static bool js_cc_IMeshBufferView_stride_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMeshBufferView *arg1 = (cc::IMeshBufferView *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMeshBufferView>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stride, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMeshBufferView_stride_set) 

static bool js_cc_IMeshBufferView_stride_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMeshBufferView *arg1 = (cc::IMeshBufferView *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMeshBufferView>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stride, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMeshBufferView_stride_get) 

static bool js_new_cc_IMeshBufferView(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IMeshBufferView *result;
    result = (cc::IMeshBufferView *)new cc::IMeshBufferView();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IMeshBufferView, __jsb_cc_IMeshBufferView_class, js_delete_cc_IMeshBufferView)

static bool js_delete_cc_IMeshBufferView(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IMeshBufferView) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IMeshBufferView * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IMeshBufferView*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("offset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->offset), ctx);
    }
    
    
    json->getProperty("length", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->length), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("stride", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stride), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IMeshBufferView(se::Object* obj) {
    auto* cls = se::Class::create("IMeshBufferView", obj, nullptr, _SE(js_new_cc_IMeshBufferView)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("offset", _SE(js_cc_IMeshBufferView_offset_get), _SE(js_cc_IMeshBufferView_offset_set)); 
    cls->defineProperty("length", _SE(js_cc_IMeshBufferView_length_get), _SE(js_cc_IMeshBufferView_length_set)); 
    cls->defineProperty("count", _SE(js_cc_IMeshBufferView_count_get), _SE(js_cc_IMeshBufferView_count_set)); 
    cls->defineProperty("stride", _SE(js_cc_IMeshBufferView_stride_get), _SE(js_cc_IMeshBufferView_stride_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IMeshBufferView));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IMeshBufferView>(cls);
    
    __jsb_cc_IMeshBufferView_proto = cls->getProto();
    __jsb_cc_IMeshBufferView_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_MorphTarget_class = nullptr;
se::Object* __jsb_cc_MorphTarget_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_MorphTarget) 

static bool js_cc_MorphTarget_displacements_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MorphTarget *arg1 = (cc::MorphTarget *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MorphTarget>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->displacements, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_MorphTarget_displacements_set) 

static bool js_cc_MorphTarget_displacements_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::MorphTarget *arg1 = (cc::MorphTarget *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MorphTarget>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->displacements, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->displacements, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_MorphTarget_displacements_get) 

static bool js_new_cc_MorphTarget(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::MorphTarget *result;
    result = (cc::MorphTarget *)new cc::MorphTarget();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_MorphTarget, __jsb_cc_MorphTarget_class, js_delete_cc_MorphTarget)

static bool js_delete_cc_MorphTarget(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_MorphTarget) 

template<>
bool sevalue_to_native(const se::Value &from, cc::MorphTarget * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::MorphTarget*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("displacements", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->displacements), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_MorphTarget(se::Object* obj) {
    auto* cls = se::Class::create("MorphTarget", obj, nullptr, _SE(js_new_cc_MorphTarget)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("displacements", _SE(js_cc_MorphTarget_displacements_get), _SE(js_cc_MorphTarget_displacements_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_MorphTarget));
    
    
    cls->install();
    JSBClassType::registerClass<cc::MorphTarget>(cls);
    
    __jsb_cc_MorphTarget_proto = cls->getProto();
    __jsb_cc_MorphTarget_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_SubMeshMorph_class = nullptr;
se::Object* __jsb_cc_SubMeshMorph_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_SubMeshMorph) 

static bool js_cc_SubMeshMorph_attributes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SubMeshMorph *arg1 = (cc::SubMeshMorph *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::SubMeshMorph>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->attributes, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_SubMeshMorph_attributes_set) 

static bool js_cc_SubMeshMorph_attributes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::SubMeshMorph *arg1 = (cc::SubMeshMorph *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::SubMeshMorph>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->attributes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->attributes, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_SubMeshMorph_attributes_get) 

static bool js_cc_SubMeshMorph_targets_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SubMeshMorph *arg1 = (cc::SubMeshMorph *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::SubMeshMorph>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->targets, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_SubMeshMorph_targets_set) 

static bool js_cc_SubMeshMorph_targets_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::SubMeshMorph *arg1 = (cc::SubMeshMorph *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::SubMeshMorph>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->targets, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->targets, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_SubMeshMorph_targets_get) 

static bool js_cc_SubMeshMorph_weights_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SubMeshMorph *arg1 = (cc::SubMeshMorph *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::SubMeshMorph>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->weights, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_SubMeshMorph_weights_set) 

static bool js_cc_SubMeshMorph_weights_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::SubMeshMorph *arg1 = (cc::SubMeshMorph *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::SubMeshMorph>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->weights, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->weights, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_SubMeshMorph_weights_get) 

static bool js_new_cc_SubMeshMorph(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::SubMeshMorph *result;
    result = (cc::SubMeshMorph *)new cc::SubMeshMorph();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_SubMeshMorph, __jsb_cc_SubMeshMorph_class, js_delete_cc_SubMeshMorph)

static bool js_delete_cc_SubMeshMorph(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_SubMeshMorph) 

template<>
bool sevalue_to_native(const se::Value &from, cc::SubMeshMorph * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::SubMeshMorph*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("attributes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->attributes), ctx);
    }
    
    
    json->getProperty("targets", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->targets), ctx);
    }
    
    
    json->getProperty("weights", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->weights), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_SubMeshMorph(se::Object* obj) {
    auto* cls = se::Class::create("SubMeshMorph", obj, nullptr, _SE(js_new_cc_SubMeshMorph)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("attributes", _SE(js_cc_SubMeshMorph_attributes_get), _SE(js_cc_SubMeshMorph_attributes_set)); 
    cls->defineProperty("targets", _SE(js_cc_SubMeshMorph_targets_get), _SE(js_cc_SubMeshMorph_targets_set)); 
    cls->defineProperty("weights", _SE(js_cc_SubMeshMorph_weights_get), _SE(js_cc_SubMeshMorph_weights_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_SubMeshMorph));
    
    
    cls->install();
    JSBClassType::registerClass<cc::SubMeshMorph>(cls);
    
    __jsb_cc_SubMeshMorph_proto = cls->getProto();
    __jsb_cc_SubMeshMorph_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Morph_class = nullptr;
se::Object* __jsb_cc_Morph_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Morph) 

static bool js_cc_Morph_subMeshMorphs_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Morph *arg1 = (cc::Morph *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Morph>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->subMeshMorphs, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Morph_subMeshMorphs_set) 

static bool js_cc_Morph_subMeshMorphs_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Morph *arg1 = (cc::Morph *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Morph>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->subMeshMorphs, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->subMeshMorphs, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Morph_subMeshMorphs_get) 

static bool js_cc_Morph_weights_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Morph *arg1 = (cc::Morph *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Morph>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->weights, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Morph_weights_set) 

static bool js_cc_Morph_weights_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Morph *arg1 = (cc::Morph *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Morph>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->weights, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->weights, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Morph_weights_get) 

static bool js_cc_Morph_targetNames_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Morph *arg1 = (cc::Morph *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Morph>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->targetNames, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Morph_targetNames_set) 

static bool js_cc_Morph_targetNames_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Morph *arg1 = (cc::Morph *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Morph>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->targetNames, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->targetNames, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Morph_targetNames_get) 

static bool js_new_cc_Morph(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::Morph *result;
    result = (cc::Morph *)new cc::Morph();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Morph, __jsb_cc_Morph_class, js_delete_cc_Morph)

static bool js_delete_cc_Morph(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Morph) 

template<>
bool sevalue_to_native(const se::Value &from, cc::Morph * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::Morph*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("subMeshMorphs", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->subMeshMorphs), ctx);
    }
    
    
    json->getProperty("weights", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->weights), ctx);
    }
    
    
    json->getProperty("targetNames", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->targetNames), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_Morph(se::Object* obj) {
    auto* cls = se::Class::create("Morph", obj, nullptr, _SE(js_new_cc_Morph)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("subMeshMorphs", _SE(js_cc_Morph_subMeshMorphs_get), _SE(js_cc_Morph_subMeshMorphs_set)); 
    cls->defineProperty("weights", _SE(js_cc_Morph_weights_get), _SE(js_cc_Morph_weights_set)); 
    cls->defineProperty("targetNames", _SE(js_cc_Morph_targetNames_get), _SE(js_cc_Morph_targetNames_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Morph));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Morph>(cls);
    
    __jsb_cc_Morph_proto = cls->getProto();
    __jsb_cc_Morph_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_MorphRenderingInstance_class = nullptr;
se::Object* __jsb_cc_MorphRenderingInstance_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_MorphRenderingInstance) 

static bool js_delete_cc_MorphRenderingInstance(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_MorphRenderingInstance) 

static bool js_cc_MorphRenderingInstance_setWeights(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MorphRenderingInstance *arg1 = (cc::MorphRenderingInstance *) NULL ;
    index_t arg2 ;
    cc::MeshWeightsType *arg3 = 0 ;
    cc::MeshWeightsType temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::MorphRenderingInstance>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setWeights(arg2,(cc::MeshWeightsType const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_MorphRenderingInstance_setWeights) 

static bool js_cc_MorphRenderingInstance_adaptPipelineState(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MorphRenderingInstance *arg1 = (cc::MorphRenderingInstance *) NULL ;
    index_t arg2 ;
    cc::gfx::DescriptorSet *arg3 = (cc::gfx::DescriptorSet *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::MorphRenderingInstance>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->adaptPipelineState(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_MorphRenderingInstance_adaptPipelineState) 

static bool js_cc_MorphRenderingInstance_requiredPatches(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MorphRenderingInstance *arg1 = (cc::MorphRenderingInstance *) NULL ;
    index_t arg2 ;
    ccstd::vector< cc::scene::IMacroPatch > result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::MorphRenderingInstance>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (arg1)->requiredPatches(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_MorphRenderingInstance_requiredPatches) 

static bool js_cc_MorphRenderingInstance_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MorphRenderingInstance *arg1 = (cc::MorphRenderingInstance *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::MorphRenderingInstance>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_MorphRenderingInstance_destroy) 

bool js_register_cc_MorphRenderingInstance(se::Object* obj) {
    auto* cls = se::Class::create("MorphRenderingInstance", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("setWeights", _SE(js_cc_MorphRenderingInstance_setWeights)); 
    cls->defineFunction("adaptPipelineState", _SE(js_cc_MorphRenderingInstance_adaptPipelineState)); 
    cls->defineFunction("requiredPatches", _SE(js_cc_MorphRenderingInstance_requiredPatches)); 
    cls->defineFunction("destroy", _SE(js_cc_MorphRenderingInstance_destroy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_MorphRenderingInstance));
    
    
    cls->install();
    JSBClassType::registerClass<cc::MorphRenderingInstance>(cls);
    
    __jsb_cc_MorphRenderingInstance_proto = cls->getProto();
    __jsb_cc_MorphRenderingInstance_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_MorphRendering_class = nullptr;
se::Object* __jsb_cc_MorphRendering_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_MorphRendering) 

static bool js_delete_cc_MorphRendering(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_MorphRendering) 

static bool js_cc_MorphRendering_createInstance(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MorphRendering *arg1 = (cc::MorphRendering *) NULL ;
    cc::MorphRenderingInstance *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::MorphRendering>(s);
    if (nullptr == arg1) return true;
    result = (cc::MorphRenderingInstance *)(arg1)->createInstance();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_MorphRendering_createInstance) 

bool js_register_cc_MorphRendering(se::Object* obj) {
    auto* cls = se::Class::create("MorphRendering", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("createInstance", _SE(js_cc_MorphRendering_createInstance)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_MorphRendering));
    
    
    cls->install();
    JSBClassType::registerClass<cc::MorphRendering>(cls);
    
    __jsb_cc_MorphRendering_proto = cls->getProto();
    __jsb_cc_MorphRendering_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_StdMorphRendering_class = nullptr;
se::Object* __jsb_cc_StdMorphRendering_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_StdMorphRendering) 

static bool js_new_cc_StdMorphRendering(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::gfx::Device *arg2 = (cc::gfx::Device *) NULL ;
    cc::StdMorphRendering *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::StdMorphRendering *)new cc::StdMorphRendering(arg1,arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_StdMorphRendering, __jsb_cc_StdMorphRendering_class, js_delete_cc_StdMorphRendering)

static bool js_delete_cc_StdMorphRendering(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_StdMorphRendering) 

bool js_register_cc_StdMorphRendering(se::Object* obj) {
    auto* cls = se::Class::create("StdMorphRendering", obj, __jsb_cc_MorphRendering_proto, _SE(js_new_cc_StdMorphRendering)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_StdMorphRendering));
    
    
    cls->install();
    JSBClassType::registerClass<cc::StdMorphRendering>(cls);
    
    __jsb_cc_StdMorphRendering_proto = cls->getProto();
    __jsb_cc_StdMorphRendering_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


static bool js_cc_createMorphRendering(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::gfx::Device *arg2 = (cc::gfx::Device *) NULL ;
    cc::MorphRendering *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::MorphRendering *)cc::createMorphRendering(arg1,arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_createMorphRendering) 

se::Class* __jsb_cc_Mesh_class = nullptr;
se::Object* __jsb_cc_Mesh_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Mesh) 

se::Class* __jsb_cc_Mesh_IVertexBundle_class = nullptr;
se::Object* __jsb_cc_Mesh_IVertexBundle_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Mesh_IVertexBundle) 

static bool js_cc_Mesh_IVertexBundle__padding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IVertexBundle *arg1 = (cc::Mesh::IVertexBundle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IVertexBundle>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_padding, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IVertexBundle__padding_set) 

static bool js_cc_Mesh_IVertexBundle__padding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IVertexBundle *arg1 = (cc::Mesh::IVertexBundle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IVertexBundle>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_padding, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_padding, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IVertexBundle__padding_get) 

static bool js_cc_Mesh_IVertexBundle_view_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IVertexBundle *arg1 = (cc::Mesh::IVertexBundle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IVertexBundle>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->view, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IVertexBundle_view_set) 

static bool js_cc_Mesh_IVertexBundle_view_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IVertexBundle *arg1 = (cc::Mesh::IVertexBundle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IVertexBundle>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->view, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->view, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IVertexBundle_view_get) 

static bool js_cc_Mesh_IVertexBundle_attributes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IVertexBundle *arg1 = (cc::Mesh::IVertexBundle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IVertexBundle>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->attributes, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IVertexBundle_attributes_set) 

static bool js_cc_Mesh_IVertexBundle_attributes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IVertexBundle *arg1 = (cc::Mesh::IVertexBundle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IVertexBundle>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->attributes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->attributes, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IVertexBundle_attributes_get) 

static bool js_new_cc_Mesh_IVertexBundle(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::Mesh::IVertexBundle *result;
    result = (cc::Mesh::IVertexBundle *)new cc::Mesh::IVertexBundle();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Mesh_IVertexBundle, __jsb_cc_Mesh_IVertexBundle_class, js_delete_cc_Mesh_IVertexBundle)

static bool js_delete_cc_Mesh_IVertexBundle(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Mesh_IVertexBundle) 

template<>
bool sevalue_to_native(const se::Value &from, cc::Mesh::IVertexBundle * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::Mesh::IVertexBundle*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("_padding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->_padding), ctx);
    }
    
    
    json->getProperty("view", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->view), ctx);
    }
    
    
    json->getProperty("attributes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->attributes), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_Mesh_IVertexBundle(se::Object* obj) {
    auto* cls = se::Class::create({"Mesh", "IVertexBundle"}, obj, nullptr, _SE(js_new_cc_Mesh_IVertexBundle)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("_padding", _SE(js_cc_Mesh_IVertexBundle__padding_get), _SE(js_cc_Mesh_IVertexBundle__padding_set)); 
    cls->defineProperty("view", _SE(js_cc_Mesh_IVertexBundle_view_get), _SE(js_cc_Mesh_IVertexBundle_view_set)); 
    cls->defineProperty("attributes", _SE(js_cc_Mesh_IVertexBundle_attributes_get), _SE(js_cc_Mesh_IVertexBundle_attributes_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Mesh_IVertexBundle));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Mesh::IVertexBundle>(cls);
    
    __jsb_cc_Mesh_IVertexBundle_proto = cls->getProto();
    __jsb_cc_Mesh_IVertexBundle_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Mesh_ISubMesh_class = nullptr;
se::Object* __jsb_cc_Mesh_ISubMesh_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Mesh_ISubMesh) 

static bool js_cc_Mesh_ISubMesh_vertexBundelIndices_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::ISubMesh *arg1 = (cc::Mesh::ISubMesh *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::ISubMesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->vertexBundelIndices, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_ISubMesh_vertexBundelIndices_set) 

static bool js_cc_Mesh_ISubMesh_vertexBundelIndices_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::ISubMesh *arg1 = (cc::Mesh::ISubMesh *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::ISubMesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->vertexBundelIndices, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->vertexBundelIndices, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_ISubMesh_vertexBundelIndices_get) 

static bool js_cc_Mesh_ISubMesh_primitiveMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::ISubMesh *arg1 = (cc::Mesh::ISubMesh *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::ISubMesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->primitiveMode, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_ISubMesh_primitiveMode_set) 

static bool js_cc_Mesh_ISubMesh_primitiveMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::ISubMesh *arg1 = (cc::Mesh::ISubMesh *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::ISubMesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->primitiveMode, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->primitiveMode, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_ISubMesh_primitiveMode_get) 

static bool js_cc_Mesh_ISubMesh_indexView_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::ISubMesh *arg1 = (cc::Mesh::ISubMesh *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::ISubMesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->indexView, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_ISubMesh_indexView_set) 

static bool js_cc_Mesh_ISubMesh_indexView_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::ISubMesh *arg1 = (cc::Mesh::ISubMesh *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::ISubMesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->indexView, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->indexView, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_ISubMesh_indexView_get) 

static bool js_cc_Mesh_ISubMesh_jointMapIndex_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::ISubMesh *arg1 = (cc::Mesh::ISubMesh *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::ISubMesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->jointMapIndex, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_ISubMesh_jointMapIndex_set) 

static bool js_cc_Mesh_ISubMesh_jointMapIndex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::ISubMesh *arg1 = (cc::Mesh::ISubMesh *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::ISubMesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->jointMapIndex, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->jointMapIndex, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_ISubMesh_jointMapIndex_get) 

static bool js_new_cc_Mesh_ISubMesh(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::Mesh::ISubMesh *result;
    result = (cc::Mesh::ISubMesh *)new cc::Mesh::ISubMesh();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Mesh_ISubMesh, __jsb_cc_Mesh_ISubMesh_class, js_delete_cc_Mesh_ISubMesh)

static bool js_delete_cc_Mesh_ISubMesh(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Mesh_ISubMesh) 

template<>
bool sevalue_to_native(const se::Value &from, cc::Mesh::ISubMesh * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::Mesh::ISubMesh*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("vertexBundelIndices", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->vertexBundelIndices), ctx);
    }
    
    
    json->getProperty("primitiveMode", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->primitiveMode), ctx);
    }
    
    
    json->getProperty("indexView", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->indexView), ctx);
    }
    
    
    json->getProperty("jointMapIndex", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->jointMapIndex), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_Mesh_ISubMesh(se::Object* obj) {
    auto* cls = se::Class::create({"Mesh", "ISubMesh"}, obj, nullptr, _SE(js_new_cc_Mesh_ISubMesh)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("vertexBundelIndices", _SE(js_cc_Mesh_ISubMesh_vertexBundelIndices_get), _SE(js_cc_Mesh_ISubMesh_vertexBundelIndices_set)); 
    cls->defineProperty("primitiveMode", _SE(js_cc_Mesh_ISubMesh_primitiveMode_get), _SE(js_cc_Mesh_ISubMesh_primitiveMode_set)); 
    cls->defineProperty("indexView", _SE(js_cc_Mesh_ISubMesh_indexView_get), _SE(js_cc_Mesh_ISubMesh_indexView_set)); 
    cls->defineProperty("jointMapIndex", _SE(js_cc_Mesh_ISubMesh_jointMapIndex_get), _SE(js_cc_Mesh_ISubMesh_jointMapIndex_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Mesh_ISubMesh));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Mesh::ISubMesh>(cls);
    
    __jsb_cc_Mesh_ISubMesh_proto = cls->getProto();
    __jsb_cc_Mesh_ISubMesh_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Mesh_IDynamicInfo_class = nullptr;
se::Object* __jsb_cc_Mesh_IDynamicInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Mesh_IDynamicInfo) 

static bool js_cc_Mesh_IDynamicInfo_maxSubMeshes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IDynamicInfo *arg1 = (cc::Mesh::IDynamicInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IDynamicInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxSubMeshes, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IDynamicInfo_maxSubMeshes_set) 

static bool js_cc_Mesh_IDynamicInfo_maxSubMeshes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IDynamicInfo *arg1 = (cc::Mesh::IDynamicInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IDynamicInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxSubMeshes, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IDynamicInfo_maxSubMeshes_get) 

static bool js_cc_Mesh_IDynamicInfo_maxSubMeshVertices_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IDynamicInfo *arg1 = (cc::Mesh::IDynamicInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IDynamicInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxSubMeshVertices, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IDynamicInfo_maxSubMeshVertices_set) 

static bool js_cc_Mesh_IDynamicInfo_maxSubMeshVertices_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IDynamicInfo *arg1 = (cc::Mesh::IDynamicInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IDynamicInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxSubMeshVertices, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IDynamicInfo_maxSubMeshVertices_get) 

static bool js_cc_Mesh_IDynamicInfo_maxSubMeshIndices_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IDynamicInfo *arg1 = (cc::Mesh::IDynamicInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IDynamicInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxSubMeshIndices, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IDynamicInfo_maxSubMeshIndices_set) 

static bool js_cc_Mesh_IDynamicInfo_maxSubMeshIndices_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IDynamicInfo *arg1 = (cc::Mesh::IDynamicInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IDynamicInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxSubMeshIndices, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IDynamicInfo_maxSubMeshIndices_get) 

static bool js_new_cc_Mesh_IDynamicInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::Mesh::IDynamicInfo *result;
    result = (cc::Mesh::IDynamicInfo *)new cc::Mesh::IDynamicInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Mesh_IDynamicInfo, __jsb_cc_Mesh_IDynamicInfo_class, js_delete_cc_Mesh_IDynamicInfo)

static bool js_delete_cc_Mesh_IDynamicInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Mesh_IDynamicInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::Mesh::IDynamicInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::Mesh::IDynamicInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("maxSubMeshes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxSubMeshes), ctx);
    }
    
    
    json->getProperty("maxSubMeshVertices", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxSubMeshVertices), ctx);
    }
    
    
    json->getProperty("maxSubMeshIndices", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxSubMeshIndices), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_Mesh_IDynamicInfo(se::Object* obj) {
    auto* cls = se::Class::create({"Mesh", "IDynamicInfo"}, obj, nullptr, _SE(js_new_cc_Mesh_IDynamicInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("maxSubMeshes", _SE(js_cc_Mesh_IDynamicInfo_maxSubMeshes_get), _SE(js_cc_Mesh_IDynamicInfo_maxSubMeshes_set)); 
    cls->defineProperty("maxSubMeshVertices", _SE(js_cc_Mesh_IDynamicInfo_maxSubMeshVertices_get), _SE(js_cc_Mesh_IDynamicInfo_maxSubMeshVertices_set)); 
    cls->defineProperty("maxSubMeshIndices", _SE(js_cc_Mesh_IDynamicInfo_maxSubMeshIndices_get), _SE(js_cc_Mesh_IDynamicInfo_maxSubMeshIndices_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Mesh_IDynamicInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Mesh::IDynamicInfo>(cls);
    
    __jsb_cc_Mesh_IDynamicInfo_proto = cls->getProto();
    __jsb_cc_Mesh_IDynamicInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Mesh_IDynamicStruct_class = nullptr;
se::Object* __jsb_cc_Mesh_IDynamicStruct_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Mesh_IDynamicStruct) 

static bool js_cc_Mesh_IDynamicStruct_info_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IDynamicStruct *arg1 = (cc::Mesh::IDynamicStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IDynamicStruct>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->info, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IDynamicStruct_info_set) 

static bool js_cc_Mesh_IDynamicStruct_info_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IDynamicStruct *arg1 = (cc::Mesh::IDynamicStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IDynamicStruct>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->info, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->info, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IDynamicStruct_info_get) 

static bool js_cc_Mesh_IDynamicStruct_bounds_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IDynamicStruct *arg1 = (cc::Mesh::IDynamicStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IDynamicStruct>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->bounds, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IDynamicStruct_bounds_set) 

static bool js_cc_Mesh_IDynamicStruct_bounds_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IDynamicStruct *arg1 = (cc::Mesh::IDynamicStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IDynamicStruct>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->bounds, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->bounds, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IDynamicStruct_bounds_get) 

static bool js_new_cc_Mesh_IDynamicStruct(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::Mesh::IDynamicStruct *result;
    result = (cc::Mesh::IDynamicStruct *)new cc::Mesh::IDynamicStruct();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Mesh_IDynamicStruct, __jsb_cc_Mesh_IDynamicStruct_class, js_delete_cc_Mesh_IDynamicStruct)

static bool js_delete_cc_Mesh_IDynamicStruct(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Mesh_IDynamicStruct) 

template<>
bool sevalue_to_native(const se::Value &from, cc::Mesh::IDynamicStruct * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::Mesh::IDynamicStruct*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("info", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->info), ctx);
    }
    
    
    json->getProperty("bounds", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->bounds), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_Mesh_IDynamicStruct(se::Object* obj) {
    auto* cls = se::Class::create({"Mesh", "IDynamicStruct"}, obj, nullptr, _SE(js_new_cc_Mesh_IDynamicStruct)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("info", _SE(js_cc_Mesh_IDynamicStruct_info_get), _SE(js_cc_Mesh_IDynamicStruct_info_set)); 
    cls->defineProperty("bounds", _SE(js_cc_Mesh_IDynamicStruct_bounds_get), _SE(js_cc_Mesh_IDynamicStruct_bounds_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Mesh_IDynamicStruct));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Mesh::IDynamicStruct>(cls);
    
    __jsb_cc_Mesh_IDynamicStruct_proto = cls->getProto();
    __jsb_cc_Mesh_IDynamicStruct_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Mesh_IStruct_class = nullptr;
se::Object* __jsb_cc_Mesh_IStruct_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Mesh_IStruct) 

static bool js_cc_Mesh_IStruct_vertexBundles_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->vertexBundles, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IStruct_vertexBundles_set) 

static bool js_cc_Mesh_IStruct_vertexBundles_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->vertexBundles, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->vertexBundles, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IStruct_vertexBundles_get) 

static bool js_cc_Mesh_IStruct_primitives_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->primitives, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IStruct_primitives_set) 

static bool js_cc_Mesh_IStruct_primitives_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->primitives, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->primitives, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IStruct_primitives_get) 

static bool js_cc_Mesh_IStruct_minPosition_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->minPosition, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IStruct_minPosition_set) 

static bool js_cc_Mesh_IStruct_minPosition_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->minPosition, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->minPosition, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IStruct_minPosition_get) 

static bool js_cc_Mesh_IStruct_getMinPosition(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    ccstd::optional< cc::Vec3 > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::optional< cc::Vec3 > *) &((cc::Mesh::IStruct const *)arg1)->getMinPosition();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_IStruct_getMinPosition) 

static bool js_cc_Mesh_IStruct_setMinPosition(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    ccstd::optional< cc::Vec3 > *arg2 = 0 ;
    ccstd::optional< cc::Vec3 > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setMinPosition((ccstd::optional< cc::Vec3 > const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_IStruct_setMinPosition) 

static bool js_cc_Mesh_IStruct_maxPosition_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxPosition, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IStruct_maxPosition_set) 

static bool js_cc_Mesh_IStruct_maxPosition_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxPosition, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxPosition, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IStruct_maxPosition_get) 

static bool js_cc_Mesh_IStruct_getMaxPosition(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    ccstd::optional< cc::Vec3 > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::optional< cc::Vec3 > *) &((cc::Mesh::IStruct const *)arg1)->getMaxPosition();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_IStruct_getMaxPosition) 

static bool js_cc_Mesh_IStruct_setMaxPosition(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    ccstd::optional< cc::Vec3 > *arg2 = 0 ;
    ccstd::optional< cc::Vec3 > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setMaxPosition((ccstd::optional< cc::Vec3 > const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_IStruct_setMaxPosition) 

static bool js_cc_Mesh_IStruct_jointMaps_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->jointMaps, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IStruct_jointMaps_set) 

static bool js_cc_Mesh_IStruct_jointMaps_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->jointMaps, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->jointMaps, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IStruct_jointMaps_get) 

static bool js_cc_Mesh_IStruct_morph_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->morph, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IStruct_morph_set) 

static bool js_cc_Mesh_IStruct_morph_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->morph, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->morph, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IStruct_morph_get) 

static bool js_cc_Mesh_IStruct_dynamic_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->dynamic, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_IStruct_dynamic_set) 

static bool js_cc_Mesh_IStruct_dynamic_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::IStruct *arg1 = (cc::Mesh::IStruct *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::IStruct>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->dynamic, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->dynamic, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_IStruct_dynamic_get) 

static bool js_new_cc_Mesh_IStruct(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::Mesh::IStruct *result;
    result = (cc::Mesh::IStruct *)new cc::Mesh::IStruct();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Mesh_IStruct, __jsb_cc_Mesh_IStruct_class, js_delete_cc_Mesh_IStruct)

static bool js_delete_cc_Mesh_IStruct(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Mesh_IStruct) 

template<>
bool sevalue_to_native(const se::Value &from, cc::Mesh::IStruct * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::Mesh::IStruct*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("vertexBundles", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->vertexBundles), ctx);
    }
    
    
    json->getProperty("primitives", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->primitives), ctx);
    }
    
    
    json->getProperty("minPosition", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->minPosition), ctx);
    }
    
    
    json->getProperty("maxPosition", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxPosition), ctx);
    }
    
    
    json->getProperty("jointMaps", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->jointMaps), ctx);
    }
    
    
    json->getProperty("morph", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->morph), ctx);
    }
    
    
    json->getProperty("dynamic", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dynamic), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_Mesh_IStruct(se::Object* obj) {
    auto* cls = se::Class::create({"Mesh", "IStruct"}, obj, nullptr, _SE(js_new_cc_Mesh_IStruct)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("vertexBundles", _SE(js_cc_Mesh_IStruct_vertexBundles_get), _SE(js_cc_Mesh_IStruct_vertexBundles_set)); 
    cls->defineProperty("primitives", _SE(js_cc_Mesh_IStruct_primitives_get), _SE(js_cc_Mesh_IStruct_primitives_set)); 
    cls->defineProperty("minPosition", _SE(js_cc_Mesh_IStruct_minPosition_get), _SE(js_cc_Mesh_IStruct_minPosition_set)); 
    cls->defineProperty("maxPosition", _SE(js_cc_Mesh_IStruct_maxPosition_get), _SE(js_cc_Mesh_IStruct_maxPosition_set)); 
    cls->defineProperty("jointMaps", _SE(js_cc_Mesh_IStruct_jointMaps_get), _SE(js_cc_Mesh_IStruct_jointMaps_set)); 
    cls->defineProperty("morph", _SE(js_cc_Mesh_IStruct_morph_get), _SE(js_cc_Mesh_IStruct_morph_set)); 
    cls->defineProperty("dynamic", _SE(js_cc_Mesh_IStruct_dynamic_get), _SE(js_cc_Mesh_IStruct_dynamic_set)); 
    
    cls->defineFunction("getMinPosition", _SE(js_cc_Mesh_IStruct_getMinPosition)); 
    cls->defineFunction("setMinPosition", _SE(js_cc_Mesh_IStruct_setMinPosition)); 
    cls->defineFunction("getMaxPosition", _SE(js_cc_Mesh_IStruct_getMaxPosition)); 
    cls->defineFunction("setMaxPosition", _SE(js_cc_Mesh_IStruct_setMaxPosition)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Mesh_IStruct));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Mesh::IStruct>(cls);
    
    __jsb_cc_Mesh_IStruct_proto = cls->getProto();
    __jsb_cc_Mesh_IStruct_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Mesh_ICreateInfo_class = nullptr;
se::Object* __jsb_cc_Mesh_ICreateInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Mesh_ICreateInfo) 

static bool js_cc_Mesh_ICreateInfo_cpp_keyword_struct_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::ICreateInfo *arg1 = (cc::Mesh::ICreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::ICreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->structInfo, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_ICreateInfo_cpp_keyword_struct_set) 

static bool js_cc_Mesh_ICreateInfo_cpp_keyword_struct_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::ICreateInfo *arg1 = (cc::Mesh::ICreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::ICreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->structInfo, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->structInfo, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_ICreateInfo_cpp_keyword_struct_get) 

static bool js_cc_Mesh_ICreateInfo_data_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh::ICreateInfo *arg1 = (cc::Mesh::ICreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::ICreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->data, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_ICreateInfo_data_set) 

static bool js_cc_Mesh_ICreateInfo_data_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh::ICreateInfo *arg1 = (cc::Mesh::ICreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh::ICreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->data, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->data, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_ICreateInfo_data_get) 

static bool js_new_cc_Mesh_ICreateInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::Mesh::ICreateInfo *result;
    result = (cc::Mesh::ICreateInfo *)new cc::Mesh::ICreateInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Mesh_ICreateInfo, __jsb_cc_Mesh_ICreateInfo_class, js_delete_cc_Mesh_ICreateInfo)

static bool js_delete_cc_Mesh_ICreateInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Mesh_ICreateInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::Mesh::ICreateInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::Mesh::ICreateInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("struct", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->structInfo), ctx);
    }
    
    
    json->getProperty("data", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->data), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_Mesh_ICreateInfo(se::Object* obj) {
    auto* cls = se::Class::create({"Mesh", "ICreateInfo"}, obj, nullptr, _SE(js_new_cc_Mesh_ICreateInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("struct", _SE(js_cc_Mesh_ICreateInfo_cpp_keyword_struct_get), _SE(js_cc_Mesh_ICreateInfo_cpp_keyword_struct_set)); 
    cls->defineProperty("data", _SE(js_cc_Mesh_ICreateInfo_data_get), _SE(js_cc_Mesh_ICreateInfo_data_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Mesh_ICreateInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Mesh::ICreateInfo>(cls);
    
    __jsb_cc_Mesh_ICreateInfo_proto = cls->getProto();
    __jsb_cc_Mesh_ICreateInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


static bool js_new_cc_Mesh(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::Mesh *result;
    result = (cc::Mesh *)new cc::Mesh();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Mesh, __jsb_cc_Mesh_class, js_delete_cc_Mesh)

static bool js_delete_cc_Mesh(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Mesh) 

static bool js_cc_Mesh_getMinPosition(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Vec3 *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    result = (cc::Vec3 *)((cc::Mesh const *)arg1)->getMinPosition();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_getMinPosition) 

static bool js_cc_Mesh_getMaxPosition(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Vec3 *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    result = (cc::Vec3 *)((cc::Mesh const *)arg1)->getMaxPosition();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_getMaxPosition) 

static bool js_cc_Mesh_getStruct(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Mesh::IStruct *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    result = (cc::Mesh::IStruct *) &((cc::Mesh const *)arg1)->getStruct();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_getStruct) 

static bool js_cc_Mesh_setStruct(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Mesh::IStruct *arg2 = 0 ;
    cc::Mesh::IStruct temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setStruct((cc::Mesh::IStruct const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_setStruct) 

static bool js_cc_Mesh_setData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Uint8Array *arg2 = 0 ;
    cc::Uint8Array temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setData((cc::Uint8Array const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_setData) 

static bool js_cc_Mesh_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    (arg1)->initialize();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_initialize) 

static bool js_cc_Mesh_destroyRenderingMesh(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroyRenderingMesh();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_destroyRenderingMesh) 

static bool js_cc_Mesh_assign(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Mesh::IStruct *arg2 = 0 ;
    cc::Uint8Array *arg3 = 0 ;
    cc::Mesh::IStruct temp2 ;
    cc::Uint8Array temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->assign((cc::Mesh::IStruct const &)*arg2,(cc::Uint8Array const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_assign) 

static bool js_cc_Mesh_reset(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Mesh::ICreateInfo *arg2 = 0 ;
    cc::Mesh::ICreateInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->reset((cc::Mesh::ICreateInfo &&)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_reset) 

static bool js_cc_Mesh_getBoneSpaceBounds(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Skeleton *arg2 = (cc::Skeleton *) NULL ;
    cc::Mesh::BoneSpaceBounds result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (arg1)->getBoneSpaceBounds(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_getBoneSpaceBounds) 

static bool js_cc_Mesh_merge__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Mesh *arg2 = (cc::Mesh *) NULL ;
    cc::Mat4 *arg3 = (cc::Mat4 *) NULL ;
    bool arg4 ;
    cc::Mat4 temp3 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = (cc::Mat4 *) &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (bool)(arg1)->merge(arg2,(cc::Mat4 const *)arg3,arg4);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}

static bool js_cc_Mesh_merge__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Mesh *arg2 = (cc::Mesh *) NULL ;
    cc::Mat4 *arg3 = (cc::Mat4 *) NULL ;
    cc::Mat4 temp3 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = (cc::Mat4 *) &temp3;
    
    result = (bool)(arg1)->merge(arg2,(cc::Mat4 const *)arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}

static bool js_cc_Mesh_merge__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Mesh *arg2 = (cc::Mesh *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (bool)(arg1)->merge(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}

static bool js_cc_Mesh_merge(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_Mesh_merge__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_Mesh_merge__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_Mesh_merge__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Mesh_merge) 

static bool js_cc_Mesh_validateMergingMesh(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Mesh *arg2 = (cc::Mesh *) NULL ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (bool)(arg1)->validateMergingMesh(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_validateMergingMesh) 

static bool js_cc_Mesh_readAttribute(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    index_t arg2 ;
    char *arg3 = (char *) NULL ;
    ccstd::string temp3 ;
    cc::TypedArray result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = (char *) temp3.c_str(); 
    result = (arg1)->readAttribute(arg2,(char const *)arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_readAttribute) 

static bool js_cc_Mesh_copyAttribute(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    index_t arg2 ;
    char *arg3 = (char *) NULL ;
    cc::ArrayBuffer *arg4 = (cc::ArrayBuffer *) NULL ;
    uint32_t arg5 ;
    uint32_t arg6 ;
    ccstd::string temp3 ;
    bool result;
    
    if(argc != 5) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = (char *) temp3.c_str(); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (bool)(arg1)->copyAttribute(arg2,(char const *)arg3,arg4,arg5,arg6);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_copyAttribute) 

static bool js_cc_Mesh_readIndices(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    index_t arg2 ;
    cc::IBArray result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (arg1)->readIndices(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_readIndices) 

static bool js_cc_Mesh_copyIndices(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    index_t arg2 ;
    cc::TypedArray *arg3 = 0 ;
    cc::TypedArray temp3 ;
    bool result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    result = (bool)(arg1)->copyIndices(arg2,*arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_copyIndices) 

static bool js_cc_Mesh_readAttributeFormat(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    index_t arg2 ;
    char *arg3 = (char *) NULL ;
    ccstd::string temp3 ;
    cc::gfx::FormatInfo *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = (char *) temp3.c_str(); 
    result = (cc::gfx::FormatInfo *)(arg1)->readAttributeFormat(arg2,(char const *)arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_readAttributeFormat) 

static bool js_cc_Mesh_updateSubMesh(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    index_t arg2 ;
    cc::IDynamicGeometry *arg3 = 0 ;
    cc::IDynamicGeometry temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->updateSubMesh(arg2,(cc::IDynamicGeometry const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Mesh_updateSubMesh) 

static bool js_cc_Mesh_morphRendering_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->morphRendering, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_morphRendering_set) 

static bool js_cc_Mesh_morphRendering_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->morphRendering, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->morphRendering, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_morphRendering_get) 

static bool js_cc_Mesh__hash_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    ccstd::hash_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_Mesh__hash_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh__hash_set) 

static bool js_cc_Mesh__hash_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    ccstd::hash_t result;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    result = cc_Mesh__hash_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh__hash_get) 

static bool js_cc_Mesh_hash_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    ccstd::hash_t result;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    result = cc_Mesh_hash_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_hash_get) 

static bool js_cc_Mesh_data_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Uint8Array *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    result = (cc::Uint8Array *) &cc_Mesh_data_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_data_get) 

static bool js_cc_Mesh__data_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Uint8Array *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    result = (cc::Uint8Array *) &cc_Mesh__data_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh__data_get) 

static bool js_cc_Mesh_jointBufferIndices_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Mesh::JointBufferIndicesType *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    result = (cc::Mesh::JointBufferIndicesType *) &cc_Mesh_jointBufferIndices_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_jointBufferIndices_get) 

static bool js_cc_Mesh_renderingSubMeshes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::Mesh::RenderingSubMeshList *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    result = (cc::Mesh::RenderingSubMeshList *) &cc_Mesh_renderingSubMeshes_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_renderingSubMeshes_get) 

static bool js_cc_Mesh_subMeshCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    result = cc_Mesh_subMeshCount_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_subMeshCount_get) 

static bool js_cc_Mesh__nativeAsset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::ArrayBuffer *arg2 = (cc::ArrayBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_Mesh__nativeAsset_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh__nativeAsset_set) 

static bool js_cc_Mesh__nativeAsset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    cc::ArrayBuffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    result = (cc::ArrayBuffer *)cc_Mesh__nativeAsset_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh__nativeAsset_get) 

static bool js_cc_Mesh__allowDataAccess_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_Mesh__allowDataAccess_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh__allowDataAccess_set) 

static bool js_cc_Mesh__allowDataAccess_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_Mesh__allowDataAccess_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh__allowDataAccess_get) 

static bool js_cc_Mesh_allowDataAccess_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_Mesh_allowDataAccess_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Mesh_allowDataAccess_set) 

static bool js_cc_Mesh_allowDataAccess_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Mesh *arg1 = (cc::Mesh *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::Mesh>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_Mesh_allowDataAccess_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Mesh_allowDataAccess_get) 

bool js_register_cc_Mesh(se::Object* obj) {
    auto* cls = se::Class::create("Mesh", obj, __jsb_cc_Asset_proto, _SE(js_new_cc_Mesh)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("morphRendering", _SE(js_cc_Mesh_morphRendering_get), _SE(js_cc_Mesh_morphRendering_set)); 
    cls->defineProperty("_hash", _SE(js_cc_Mesh__hash_get), _SE(js_cc_Mesh__hash_set)); 
    cls->defineProperty("hash", _SE(js_cc_Mesh_hash_get), nullptr); 
    cls->defineProperty("data", _SE(js_cc_Mesh_data_get), nullptr); 
    cls->defineProperty("_data", _SE(js_cc_Mesh__data_get), nullptr); 
    cls->defineProperty("jointBufferIndices", _SE(js_cc_Mesh_jointBufferIndices_get), nullptr); 
    cls->defineProperty("renderingSubMeshes", _SE(js_cc_Mesh_renderingSubMeshes_get), nullptr); 
    cls->defineProperty("subMeshCount", _SE(js_cc_Mesh_subMeshCount_get), nullptr); 
    cls->defineProperty("_nativeAsset", _SE(js_cc_Mesh__nativeAsset_get), _SE(js_cc_Mesh__nativeAsset_set)); 
    cls->defineProperty("_allowDataAccess", _SE(js_cc_Mesh__allowDataAccess_get), _SE(js_cc_Mesh__allowDataAccess_set)); 
    cls->defineProperty("allowDataAccess", _SE(js_cc_Mesh_allowDataAccess_get), _SE(js_cc_Mesh_allowDataAccess_set)); 
    
    cls->defineFunction("getMinPosition", _SE(js_cc_Mesh_getMinPosition)); 
    cls->defineFunction("getMaxPosition", _SE(js_cc_Mesh_getMaxPosition)); 
    cls->defineFunction("getStruct", _SE(js_cc_Mesh_getStruct)); 
    cls->defineFunction("setStruct", _SE(js_cc_Mesh_setStruct)); 
    cls->defineFunction("setData", _SE(js_cc_Mesh_setData)); 
    cls->defineFunction("initialize", _SE(js_cc_Mesh_initialize)); 
    cls->defineFunction("destroyRenderingMesh", _SE(js_cc_Mesh_destroyRenderingMesh)); 
    cls->defineFunction("assign", _SE(js_cc_Mesh_assign)); 
    cls->defineFunction("reset", _SE(js_cc_Mesh_reset)); 
    cls->defineFunction("getBoneSpaceBounds", _SE(js_cc_Mesh_getBoneSpaceBounds)); 
    cls->defineFunction("merge", _SE(js_cc_Mesh_merge)); 
    cls->defineFunction("validateMergingMesh", _SE(js_cc_Mesh_validateMergingMesh)); 
    cls->defineFunction("readAttribute", _SE(js_cc_Mesh_readAttribute)); 
    cls->defineFunction("copyAttribute", _SE(js_cc_Mesh_copyAttribute)); 
    cls->defineFunction("readIndices", _SE(js_cc_Mesh_readIndices)); 
    cls->defineFunction("copyIndices", _SE(js_cc_Mesh_copyIndices)); 
    cls->defineFunction("readAttributeFormat", _SE(js_cc_Mesh_readAttributeFormat)); 
    cls->defineFunction("updateSubMesh", _SE(js_cc_Mesh_updateSubMesh)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Mesh));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Mesh>(cls);
    
    __jsb_cc_Mesh_proto = cls->getProto();
    __jsb_cc_Mesh_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Skeleton_class = nullptr;
se::Object* __jsb_cc_Skeleton_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Skeleton) 

static bool js_new_cc_Skeleton(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::Skeleton *result;
    result = (cc::Skeleton *)new cc::Skeleton();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Skeleton, __jsb_cc_Skeleton_class, js_delete_cc_Skeleton)

static bool js_delete_cc_Skeleton(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Skeleton) 

static bool js_cc_Skeleton__getBindposes(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Skeleton *arg1 = (cc::Skeleton *) NULL ;
    ccstd::vector< cc::Mat4 > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Skeleton>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::Mat4 > *) &((cc::Skeleton const *)arg1)->getBindposes();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Skeleton__getBindposes) 

static bool js_cc_Skeleton__setBindposes(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Skeleton *arg1 = (cc::Skeleton *) NULL ;
    ccstd::vector< cc::Mat4 > *arg2 = 0 ;
    ccstd::vector< cc::Mat4 > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Skeleton>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setBindposes((ccstd::vector< cc::Mat4 > const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Skeleton__setBindposes) 

static bool js_cc_Skeleton_joints_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Skeleton *arg1 = (cc::Skeleton *) NULL ;
    ccstd::vector< ccstd::string > *arg2 = 0 ;
    ccstd::vector< ccstd::string > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Skeleton>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_Skeleton_joints_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Skeleton_joints_set) 

static bool js_cc_Skeleton_joints_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Skeleton *arg1 = (cc::Skeleton *) NULL ;
    ccstd::vector< ccstd::string > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Skeleton>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< ccstd::string > *) &cc_Skeleton_joints_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Skeleton_joints_get) 

static bool js_cc_Skeleton__joints_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Skeleton *arg1 = (cc::Skeleton *) NULL ;
    ccstd::vector< ccstd::string > *arg2 = 0 ;
    ccstd::vector< ccstd::string > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Skeleton>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_Skeleton__joints_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Skeleton__joints_set) 

static bool js_cc_Skeleton__joints_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Skeleton *arg1 = (cc::Skeleton *) NULL ;
    ccstd::vector< ccstd::string > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Skeleton>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< ccstd::string > *) &cc_Skeleton__joints_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Skeleton__joints_get) 

static bool js_cc_Skeleton_hash_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Skeleton *arg1 = (cc::Skeleton *) NULL ;
    ccstd::hash_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Skeleton>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_Skeleton_hash_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Skeleton_hash_set) 

static bool js_cc_Skeleton_hash_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Skeleton *arg1 = (cc::Skeleton *) NULL ;
    ccstd::hash_t result;
    
    arg1 = SE_THIS_OBJECT<cc::Skeleton>(s);
    if (nullptr == arg1) return true;
    result = cc_Skeleton_hash_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Skeleton_hash_get) 

static bool js_cc_Skeleton__hash_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Skeleton *arg1 = (cc::Skeleton *) NULL ;
    ccstd::hash_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Skeleton>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_Skeleton__hash_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Skeleton__hash_set) 

static bool js_cc_Skeleton__hash_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Skeleton *arg1 = (cc::Skeleton *) NULL ;
    ccstd::hash_t result;
    
    arg1 = SE_THIS_OBJECT<cc::Skeleton>(s);
    if (nullptr == arg1) return true;
    result = cc_Skeleton__hash_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Skeleton__hash_get) 

static bool js_cc_Skeleton__invBindposes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Skeleton *arg1 = (cc::Skeleton *) NULL ;
    ccstd::vector< cc::Mat4 > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Skeleton>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::Mat4 > *) &cc_Skeleton__invBindposes_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Skeleton__invBindposes_get) 

static bool js_cc_Skeleton_inverseBindposes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Skeleton *arg1 = (cc::Skeleton *) NULL ;
    ccstd::vector< cc::Mat4 > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Skeleton>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::Mat4 > *) &cc_Skeleton_inverseBindposes_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Skeleton_inverseBindposes_get) 

bool js_register_cc_Skeleton(se::Object* obj) {
    auto* cls = se::Class::create("Skeleton", obj, __jsb_cc_Asset_proto, _SE(js_new_cc_Skeleton)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("joints", _SE(js_cc_Skeleton_joints_get), _SE(js_cc_Skeleton_joints_set)); 
    cls->defineProperty("_joints", _SE(js_cc_Skeleton__joints_get), _SE(js_cc_Skeleton__joints_set)); 
    cls->defineProperty("hash", _SE(js_cc_Skeleton_hash_get), _SE(js_cc_Skeleton_hash_set)); 
    cls->defineProperty("_hash", _SE(js_cc_Skeleton__hash_get), _SE(js_cc_Skeleton__hash_set)); 
    cls->defineProperty("_invBindposes", _SE(js_cc_Skeleton__invBindposes_get), nullptr); 
    cls->defineProperty("inverseBindposes", _SE(js_cc_Skeleton_inverseBindposes_get), nullptr); 
    
    cls->defineFunction("_getBindposes", _SE(js_cc_Skeleton__getBindposes)); 
    cls->defineFunction("_setBindposes", _SE(js_cc_Skeleton__setBindposes)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Skeleton));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Skeleton>(cls);
    
    __jsb_cc_Skeleton_proto = cls->getProto();
    __jsb_cc_Skeleton_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_ICreateMeshOptions_class = nullptr;
se::Object* __jsb_cc_ICreateMeshOptions_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_ICreateMeshOptions) 

static bool js_cc_ICreateMeshOptions_calculateBounds_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICreateMeshOptions *arg1 = (cc::ICreateMeshOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ICreateMeshOptions>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->calculateBounds, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ICreateMeshOptions_calculateBounds_set) 

static bool js_cc_ICreateMeshOptions_calculateBounds_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ICreateMeshOptions *arg1 = (cc::ICreateMeshOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ICreateMeshOptions>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->calculateBounds, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->calculateBounds, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ICreateMeshOptions_calculateBounds_get) 

static bool js_new_cc_ICreateMeshOptions(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::ICreateMeshOptions *result;
    result = (cc::ICreateMeshOptions *)new cc::ICreateMeshOptions();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_ICreateMeshOptions, __jsb_cc_ICreateMeshOptions_class, js_delete_cc_ICreateMeshOptions)

static bool js_delete_cc_ICreateMeshOptions(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_ICreateMeshOptions) 

template<>
bool sevalue_to_native(const se::Value &from, cc::ICreateMeshOptions * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::ICreateMeshOptions*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("calculateBounds", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->calculateBounds), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_ICreateMeshOptions(se::Object* obj) {
    auto* cls = se::Class::create("ICreateMeshOptions", obj, nullptr, _SE(js_new_cc_ICreateMeshOptions)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("calculateBounds", _SE(js_cc_ICreateMeshOptions_calculateBounds_get), _SE(js_cc_ICreateMeshOptions_calculateBounds_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_ICreateMeshOptions));
    
    
    cls->install();
    JSBClassType::registerClass<cc::ICreateMeshOptions>(cls);
    
    __jsb_cc_ICreateMeshOptions_proto = cls->getProto();
    __jsb_cc_ICreateMeshOptions_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_ICreateDynamicMeshOptions_class = nullptr;
se::Object* __jsb_cc_ICreateDynamicMeshOptions_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_ICreateDynamicMeshOptions) 

static bool js_cc_ICreateDynamicMeshOptions_maxSubMeshes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICreateDynamicMeshOptions *arg1 = (cc::ICreateDynamicMeshOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ICreateDynamicMeshOptions>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxSubMeshes, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ICreateDynamicMeshOptions_maxSubMeshes_set) 

static bool js_cc_ICreateDynamicMeshOptions_maxSubMeshes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ICreateDynamicMeshOptions *arg1 = (cc::ICreateDynamicMeshOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ICreateDynamicMeshOptions>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxSubMeshes, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ICreateDynamicMeshOptions_maxSubMeshes_get) 

static bool js_cc_ICreateDynamicMeshOptions_maxSubMeshVertices_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICreateDynamicMeshOptions *arg1 = (cc::ICreateDynamicMeshOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ICreateDynamicMeshOptions>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxSubMeshVertices, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ICreateDynamicMeshOptions_maxSubMeshVertices_set) 

static bool js_cc_ICreateDynamicMeshOptions_maxSubMeshVertices_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ICreateDynamicMeshOptions *arg1 = (cc::ICreateDynamicMeshOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ICreateDynamicMeshOptions>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxSubMeshVertices, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ICreateDynamicMeshOptions_maxSubMeshVertices_get) 

static bool js_cc_ICreateDynamicMeshOptions_maxSubMeshIndices_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICreateDynamicMeshOptions *arg1 = (cc::ICreateDynamicMeshOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ICreateDynamicMeshOptions>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxSubMeshIndices, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ICreateDynamicMeshOptions_maxSubMeshIndices_set) 

static bool js_cc_ICreateDynamicMeshOptions_maxSubMeshIndices_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::ICreateDynamicMeshOptions *arg1 = (cc::ICreateDynamicMeshOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::ICreateDynamicMeshOptions>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxSubMeshIndices, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_ICreateDynamicMeshOptions_maxSubMeshIndices_get) 

static bool js_new_cc_ICreateDynamicMeshOptions(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::ICreateDynamicMeshOptions *result;
    result = (cc::ICreateDynamicMeshOptions *)new cc::ICreateDynamicMeshOptions();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_ICreateDynamicMeshOptions, __jsb_cc_ICreateDynamicMeshOptions_class, js_delete_cc_ICreateDynamicMeshOptions)

static bool js_delete_cc_ICreateDynamicMeshOptions(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_ICreateDynamicMeshOptions) 

template<>
bool sevalue_to_native(const se::Value &from, cc::ICreateDynamicMeshOptions * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::ICreateDynamicMeshOptions*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("maxSubMeshes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxSubMeshes), ctx);
    }
    
    
    json->getProperty("maxSubMeshVertices", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxSubMeshVertices), ctx);
    }
    
    
    json->getProperty("maxSubMeshIndices", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxSubMeshIndices), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_ICreateDynamicMeshOptions(se::Object* obj) {
    auto* cls = se::Class::create("ICreateDynamicMeshOptions", obj, nullptr, _SE(js_new_cc_ICreateDynamicMeshOptions)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("maxSubMeshes", _SE(js_cc_ICreateDynamicMeshOptions_maxSubMeshes_get), _SE(js_cc_ICreateDynamicMeshOptions_maxSubMeshes_set)); 
    cls->defineProperty("maxSubMeshVertices", _SE(js_cc_ICreateDynamicMeshOptions_maxSubMeshVertices_get), _SE(js_cc_ICreateDynamicMeshOptions_maxSubMeshVertices_set)); 
    cls->defineProperty("maxSubMeshIndices", _SE(js_cc_ICreateDynamicMeshOptions_maxSubMeshIndices_get), _SE(js_cc_ICreateDynamicMeshOptions_maxSubMeshIndices_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_ICreateDynamicMeshOptions));
    
    
    cls->install();
    JSBClassType::registerClass<cc::ICreateDynamicMeshOptions>(cls);
    
    __jsb_cc_ICreateDynamicMeshOptions_proto = cls->getProto();
    __jsb_cc_ICreateDynamicMeshOptions_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_MeshUtils_class = nullptr;
se::Object* __jsb_cc_MeshUtils_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_MeshUtils) 

static bool js_cc_MeshUtils_createMesh_static__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::IGeometry *arg1 = 0 ;
    cc::Mesh *arg2 = (cc::Mesh *) NULL ;
    cc::ICreateMeshOptions *arg3 = 0 ;
    cc::IGeometry temp1 ;
    cc::ICreateMeshOptions temp3 ;
    cc::Mesh *result = 0 ;
    
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    result = (cc::Mesh *)cc::MeshUtils::createMesh((cc::IGeometry const &)*arg1,arg2,(cc::ICreateMeshOptions const &)*arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_MeshUtils_createMesh_static__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::IGeometry *arg1 = 0 ;
    cc::Mesh *arg2 = (cc::Mesh *) NULL ;
    cc::IGeometry temp1 ;
    cc::Mesh *result = 0 ;
    
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::Mesh *)cc::MeshUtils::createMesh((cc::IGeometry const &)*arg1,arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_MeshUtils_createMesh_static__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::IGeometry *arg1 = 0 ;
    cc::IGeometry temp1 ;
    cc::Mesh *result = 0 ;
    
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = (cc::Mesh *)cc::MeshUtils::createMesh((cc::IGeometry const &)*arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_MeshUtils_createMesh_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_MeshUtils_createMesh_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_MeshUtils_createMesh_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_MeshUtils_createMesh_static__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_MeshUtils_createMesh_static) 

static bool js_cc_MeshUtils_createMeshInfo_static__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::IGeometry *arg1 = 0 ;
    cc::ICreateMeshOptions *arg2 = 0 ;
    cc::IGeometry temp1 ;
    cc::ICreateMeshOptions temp2 ;
    cc::Mesh::ICreateInfo result;
    
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = cc::MeshUtils::createMeshInfo((cc::IGeometry const &)*arg1,(cc::ICreateMeshOptions const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_MeshUtils_createMeshInfo_static__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::IGeometry *arg1 = 0 ;
    cc::IGeometry temp1 ;
    cc::Mesh::ICreateInfo result;
    
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = cc::MeshUtils::createMeshInfo((cc::IGeometry const &)*arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_MeshUtils_createMeshInfo_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_cc_MeshUtils_createMeshInfo_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_MeshUtils_createMeshInfo_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_MeshUtils_createMeshInfo_static) 

static bool js_cc_MeshUtils_createDynamicMesh_static__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    index_t arg1 ;
    cc::IDynamicGeometry *arg2 = 0 ;
    cc::Mesh *arg3 = (cc::Mesh *) NULL ;
    cc::ICreateDynamicMeshOptions *arg4 = 0 ;
    cc::IDynamicGeometry temp2 ;
    cc::ICreateDynamicMeshOptions temp4 ;
    cc::Mesh *result = 0 ;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    result = (cc::Mesh *)cc::MeshUtils::createDynamicMesh(SWIG_STD_MOVE(arg1),(cc::IDynamicGeometry const &)*arg2,arg3,(cc::ICreateDynamicMeshOptions const &)*arg4);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_MeshUtils_createDynamicMesh_static__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    index_t arg1 ;
    cc::IDynamicGeometry *arg2 = 0 ;
    cc::Mesh *arg3 = (cc::Mesh *) NULL ;
    cc::IDynamicGeometry temp2 ;
    cc::Mesh *result = 0 ;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::Mesh *)cc::MeshUtils::createDynamicMesh(SWIG_STD_MOVE(arg1),(cc::IDynamicGeometry const &)*arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_MeshUtils_createDynamicMesh_static__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    index_t arg1 ;
    cc::IDynamicGeometry *arg2 = 0 ;
    cc::IDynamicGeometry temp2 ;
    cc::Mesh *result = 0 ;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::Mesh *)cc::MeshUtils::createDynamicMesh(SWIG_STD_MOVE(arg1),(cc::IDynamicGeometry const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_MeshUtils_createDynamicMesh_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 4) {
        ok = js_cc_MeshUtils_createDynamicMesh_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 3) {
        ok = js_cc_MeshUtils_createDynamicMesh_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_MeshUtils_createDynamicMesh_static__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_MeshUtils_createDynamicMesh_static) 

static bool js_cc_MeshUtils_createDynamicMeshInfo_static__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::IDynamicGeometry *arg1 = 0 ;
    cc::ICreateDynamicMeshOptions *arg2 = 0 ;
    cc::IDynamicGeometry temp1 ;
    cc::ICreateDynamicMeshOptions temp2 ;
    cc::Mesh::ICreateInfo result;
    
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = cc::MeshUtils::createDynamicMeshInfo((cc::IDynamicGeometry const &)*arg1,(cc::ICreateDynamicMeshOptions const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_MeshUtils_createDynamicMeshInfo_static__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::IDynamicGeometry *arg1 = 0 ;
    cc::IDynamicGeometry temp1 ;
    cc::Mesh::ICreateInfo result;
    
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = cc::MeshUtils::createDynamicMeshInfo((cc::IDynamicGeometry const &)*arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_MeshUtils_createDynamicMeshInfo_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_cc_MeshUtils_createDynamicMeshInfo_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_MeshUtils_createDynamicMeshInfo_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_MeshUtils_createDynamicMeshInfo_static) 

static bool js_new_cc_MeshUtils(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::MeshUtils *result;
    result = (cc::MeshUtils *)new cc::MeshUtils();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_MeshUtils, __jsb_cc_MeshUtils_class, js_delete_cc_MeshUtils)

static bool js_delete_cc_MeshUtils(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_MeshUtils) 

bool js_register_cc_MeshUtils(se::Object* obj) {
    auto* cls = se::Class::create("MeshUtils", obj, nullptr, _SE(js_new_cc_MeshUtils)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    
    cls->defineStaticFunction("createMesh", _SE(js_cc_MeshUtils_createMesh_static)); 
    cls->defineStaticFunction("createMeshInfo", _SE(js_cc_MeshUtils_createMeshInfo_static)); 
    cls->defineStaticFunction("createDynamicMesh", _SE(js_cc_MeshUtils_createDynamicMesh_static)); 
    cls->defineStaticFunction("createDynamicMeshInfo", _SE(js_cc_MeshUtils_createDynamicMeshInfo_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_MeshUtils));
    
    
    cls->install();
    JSBClassType::registerClass<cc::MeshUtils>(cls);
    
    __jsb_cc_MeshUtils_proto = cls->getProto();
    __jsb_cc_MeshUtils_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}




bool register_all_assets(se::Object* obj) {
    // Get the ns
    se::Value nsVal;
    if (!obj->getProperty("jsb", &nsVal, true))
    {
        se::HandleObject jsobj(se::Object::createPlainObject());
        nsVal.setObject(jsobj);
        obj->setProperty("jsb", nsVal);
    }
    se::Object* ns = nsVal.toObject();
    /* Register classes */
    js_register_cc_Error(ns); 
    js_register_cc_BoundingBox(ns); 
    js_register_cc_VertexIdChannel(ns); 
    js_register_cc_NativeDep(ns); 
    js_register_cc_IGeometryOptions(ns); 
    js_register_cc_CustomAttribute(ns); 
    js_register_cc_IGeometry(ns); 
    js_register_cc_DynamicCustomAttribute(ns); 
    js_register_cc_IDynamicGeometry(ns); 
    js_register_cc_Asset(ns); 
    js_register_cc_TextureBase(ns); 
    js_register_cc_SimpleTexture(ns); 
    js_register_cc_ITexture2DSerializeData(ns); 
    js_register_cc_ITexture2DCreateInfo(ns); 
    js_register_cc_Texture2D(ns); 
    js_register_cc_ITextureCubeMipmap(ns); 
    js_register_cc_ITextureCubeSerializeMipmapData(ns); 
    js_register_cc_MipmapAtlasLayoutInfo(ns); 
    js_register_cc_TextureCubeMipmapAtlasInfo(ns); 
    js_register_cc_TextureCubeSerializeData(ns); 
    js_register_cc_TextureCube(ns); 
    js_register_cc_IRenderTextureCreateInfo(ns); 
    js_register_cc_RenderTexture(ns); 
    js_register_cc_BufferAsset(ns); 
    js_register_cc_IPropertyInfo(ns); 
    js_register_cc_RasterizerStateInfo(ns); 
    js_register_cc_DepthStencilStateInfo(ns); 
    js_register_cc_BlendTargetInfo(ns); 
    js_register_cc_BlendStateInfo(ns); 
    js_register_cc_IPassStates(ns); 
    js_register_cc_IPassInfoFull(ns); 
    js_register_cc_ITechniqueInfo(ns); 
    js_register_cc_IBlockInfo(ns); 
    js_register_cc_ISamplerTextureInfo(ns); 
    js_register_cc_ITextureInfo(ns); 
    js_register_cc_ISamplerInfo(ns); 
    js_register_cc_IBufferInfo(ns); 
    js_register_cc_IImageInfo(ns); 
    js_register_cc_IInputAttachmentInfo(ns); 
    js_register_cc_IAttributeInfo(ns); 
    js_register_cc_IDefineInfo(ns); 
    js_register_cc_IBuiltin(ns); 
    js_register_cc_IBuiltinInfo(ns); 
    js_register_cc_IBuiltins(ns); 
    js_register_cc_IDescriptorInfo(ns); 
    js_register_cc_IShaderSource(ns); 
    js_register_cc_IShaderInfo(ns); 
    js_register_cc_EffectAsset(ns); 
    js_register_cc_IMemoryImageSource(ns); 
    js_register_cc_ImageAsset(ns); 
    js_register_cc_SceneAsset(ns); 
    js_register_cc_TextAsset(ns); 
    js_register_cc_IMaterialInfo(ns); 
    js_register_cc_Material(ns); 
    js_register_cc_IGeometricInfo(ns); 
    js_register_cc_IFlatBuffer(ns); 
    js_register_cc_RenderingSubMesh(ns); 
    js_register_cc_BuiltinResMgr(ns); 
    js_register_cc_IMeshBufferView(ns); 
    js_register_cc_MorphTarget(ns); 
    js_register_cc_SubMeshMorph(ns); 
    js_register_cc_Morph(ns); 
    js_register_cc_MorphRenderingInstance(ns); 
    js_register_cc_MorphRendering(ns); 
    js_register_cc_StdMorphRendering(ns); 
    js_register_cc_Mesh(ns); 
    js_register_cc_Mesh_IVertexBundle(ns); 
    js_register_cc_Mesh_ISubMesh(ns); 
    js_register_cc_Mesh_IDynamicInfo(ns); 
    js_register_cc_Mesh_IDynamicStruct(ns); 
    js_register_cc_Mesh_IStruct(ns); 
    js_register_cc_Mesh_ICreateInfo(ns); 
    js_register_cc_Skeleton(ns); 
    js_register_cc_ICreateMeshOptions(ns); 
    js_register_cc_ICreateDynamicMeshOptions(ns); 
    js_register_cc_MeshUtils(ns); 
    
    /* Register global variables & global functions */
    
    
    
    return true;
}


#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif
// clang-format on
