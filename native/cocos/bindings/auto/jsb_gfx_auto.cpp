// clang-format off

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.1.0
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

/****************************************************************************
 Copyright (c) 2022 Xiamen Yaji Software Co., Ltd.

 http://www.cocos.com

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated engine source code (the "Software"), a limited,
 worldwide, royalty-free, non-assignable, revocable and non-exclusive license
 to use Cocos Creator solely to develop games on your target platforms. You shall
 not use Cocos Creator software for developing other software or tools that's
 used for developing games. You are not granted to publish, distribute,
 sublicense, and/or sell copies of Cocos Creator.

 The software or tools in this License Agreement are licensed, not sold.
 Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
****************************************************************************/

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static 
#endif



#include <stdio.h>


#include "bindings/jswrapper/SeApi.h"
#include "bindings/manual/jsb_conversions.h"
#include "bindings/manual/jsb_global.h"


#include "bindings/auto/jsb_gfx_auto.h"


#define cc_gfx_Device_gfxAPI_get(self_) self_->getGfxAPI()
  

#define cc_gfx_Device_deviceName_get(self_) self_->getDeviceName()
  

#define cc_gfx_Device_memoryStatus_get(self_) self_->getMemoryStatus()
  

#define cc_gfx_Device_queue_get(self_) self_->getQueue()
  

#define cc_gfx_Device_commandBuffer_get(self_) self_->getCommandBuffer()
  

#define cc_gfx_Device_renderer_get(self_) self_->getRenderer()
  

#define cc_gfx_Device_vendor_get(self_) self_->getVendor()
  

#define cc_gfx_Device_numDrawCalls_get(self_) self_->getNumDrawCalls()
  

#define cc_gfx_Device_numInstances_get(self_) self_->getNumInstances()
  

#define cc_gfx_Device_numTris_get(self_) self_->getNumTris()
  

#define cc_gfx_Device_capabilities_get(self_) self_->getCapabilities()
  

#define cc_gfx_Shader_name_get(self_) self_->getName()
  

#define cc_gfx_Shader_stages_get(self_) self_->getStages()
  

#define cc_gfx_Shader_attributes_get(self_) self_->getAttributes()
  

#define cc_gfx_Shader_blocks_get(self_) self_->getBlocks()
  

#define cc_gfx_Shader_samplers_get(self_) self_->getSamplers()
  

#define cc_gfx_Texture_info_get(self_) self_->getInfo()
  

#define cc_gfx_Texture_viewInfo_get(self_) self_->getViewInfo()
  

#define cc_gfx_Texture_width_get(self_) self_->getWidth()
  

#define cc_gfx_Texture_height_get(self_) self_->getHeight()
  

#define cc_gfx_Texture_format_get(self_) self_->getFormat()
  

#define cc_gfx_Texture_size_get(self_) self_->getSize()
  

#define cc_gfx_Texture_hash_get(self_) self_->getHash()
  

#define cc_gfx_Queue_type_get(self_) self_->getType()
  

#define cc_gfx_RenderPass_hash_get(self_) self_->getHash()
  

#define cc_gfx_DescriptorSet_layout_get(self_) self_->getLayout()
  

#define cc_gfx_PipelineState_shader_get(self_) self_->getShader()
  

#define cc_gfx_PipelineState_primitive_get(self_) self_->getPrimitive()
  

#define cc_gfx_PipelineState_bindPoint_get(self_) self_->getBindPoint()
  

#define cc_gfx_PipelineState_inputState_get(self_) self_->getInputState()
  

#define cc_gfx_PipelineState_rasterizerState_get(self_) self_->getRasterizerState()
  

#define cc_gfx_PipelineState_depthStencilState_get(self_) self_->getDepthStencilState()
  

#define cc_gfx_PipelineState_blendState_get(self_) self_->getBlendState()
  

#define cc_gfx_PipelineState_renderPass_get(self_) self_->getRenderPass()
  

#define cc_gfx_InputAssembler_vertexBuffers_get(self_) self_->getVertexBuffers()
  

#define cc_gfx_InputAssembler_attributes_get(self_) self_->getAttributes()
  

#define cc_gfx_InputAssembler_indexBuffer_get(self_) self_->getIndexBuffer()
  

#define cc_gfx_InputAssembler_indirectBuffer_get(self_) self_->getIndirectBuffer()
  

#define cc_gfx_InputAssembler_attributesHash_get(self_) self_->getAttributesHash()
  

#define cc_gfx_InputAssembler_drawInfo_get(self_) self_->getDrawInfo()
#define cc_gfx_InputAssembler_drawInfo_set(self_, val_) self_->setDrawInfo(val_)
  

#define cc_gfx_InputAssembler_vertexCount_get(self_) self_->getVertexCount()
#define cc_gfx_InputAssembler_vertexCount_set(self_, val_) self_->setVertexCount(val_)
  

#define cc_gfx_InputAssembler_firstVertex_get(self_) self_->getFirstVertex()
#define cc_gfx_InputAssembler_firstVertex_set(self_, val_) self_->setFirstVertex(val_)
  

#define cc_gfx_InputAssembler_indexCount_get(self_) self_->getIndexCount()
#define cc_gfx_InputAssembler_indexCount_set(self_, val_) self_->setIndexCount(val_)
  

#define cc_gfx_InputAssembler_firstIndex_get(self_) self_->getFirstIndex()
#define cc_gfx_InputAssembler_firstIndex_set(self_, val_) self_->setFirstIndex(val_)
  

#define cc_gfx_InputAssembler_vertexOffset_get(self_) self_->getVertexOffset()
#define cc_gfx_InputAssembler_vertexOffset_set(self_, val_) self_->setVertexOffset(val_)
  

#define cc_gfx_InputAssembler_instanceCount_get(self_) self_->getInstanceCount()
#define cc_gfx_InputAssembler_instanceCount_set(self_, val_) self_->setInstanceCount(val_)
  

#define cc_gfx_CommandBuffer_type_get(self_) self_->getType()
  

#define cc_gfx_CommandBuffer_queue_get(self_) self_->getQueue()
  

#define cc_gfx_CommandBuffer_numDrawCalls_get(self_) self_->getNumDrawCalls()
  

#define cc_gfx_CommandBuffer_numInstances_get(self_) self_->getNumInstances()
  

#define cc_gfx_CommandBuffer_numTris_get(self_) self_->getNumTris()
  

#define cc_gfx_Framebuffer_renderPass_get(self_) self_->getRenderPass()
  

#define cc_gfx_Framebuffer_colorTextures_get(self_) self_->getColorTextures()
  

#define cc_gfx_Framebuffer_depthStencilTexture_get(self_) self_->getDepthStencilTexture()
  

#define cc_gfx_Buffer_usage_get(self_) self_->getUsage()
  

#define cc_gfx_Buffer_memUsage_get(self_) self_->getMemUsage()
  

#define cc_gfx_Buffer_stride_get(self_) self_->getStride()
  

#define cc_gfx_Buffer_count_get(self_) self_->getCount()
  

#define cc_gfx_Buffer_size_get(self_) self_->getSize()
  

#define cc_gfx_Buffer_flags_get(self_) self_->getFlags()
  

#define cc_gfx_Sampler_info_get(self_) self_->getInfo()
  

#define cc_gfx_Sampler_hash_get(self_) self_->getHash()
  

#define cc_gfx_Swapchain_width_get(self_) self_->getWidth()
  

#define cc_gfx_Swapchain_height_get(self_) self_->getHeight()
  

#define cc_gfx_Swapchain_surfaceTransform_get(self_) self_->getSurfaceTransform()
  

#define cc_gfx_Swapchain_colorTexture_get(self_) self_->getColorTexture()
  

#define cc_gfx_Swapchain_depthStencilTexture_get(self_) self_->getDepthStencilTexture()
  

#define cc_gfx_GFXObject_objectType_get(self_) self_->getObjectType()
  

#define cc_gfx_GFXObject_objectID_get(self_) self_->getObjectID()
  

#define cc_gfx_GFXObject_typedID_get(self_) self_->getTypedID()
  


static bool js_cc_gfx_isCombinedImageSampler(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Type arg1 ;
    int32_t temp1 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "isCombinedImageSampler,1,SWIGTYPE_cc__gfx__Type");
    arg1 = (cc::gfx::Type)temp1;
    result = (bool)cc::gfx::isCombinedImageSampler(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_isCombinedImageSampler) 

static bool js_cc_gfx_isSampledImage(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Type arg1 ;
    int32_t temp1 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "isSampledImage,1,SWIGTYPE_cc__gfx__Type");
    arg1 = (cc::gfx::Type)temp1;
    result = (bool)cc::gfx::isSampledImage(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_isSampledImage) 

static bool js_cc_gfx_isStorageImage(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Type arg1 ;
    int32_t temp1 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "isStorageImage,1,SWIGTYPE_cc__gfx__Type");
    arg1 = (cc::gfx::Type)temp1;
    result = (bool)cc::gfx::isStorageImage(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_isStorageImage) 

se::Class* __jsb_cc_gfx_Size_class = nullptr;
se::Object* __jsb_cc_gfx_Size_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Size) 

static bool js_cc_gfx_Size_x_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Size *arg1 = (cc::gfx::Size *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Size>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->x, s.thisObject());
    SE_PRECONDITION2(ok, false, "Size_x_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Size_x_set) 

static bool js_cc_gfx_Size_x_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Size *arg1 = (cc::gfx::Size *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Size>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->x, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Size_x_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->x, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Size_x_get) 

static bool js_cc_gfx_Size_y_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Size *arg1 = (cc::gfx::Size *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Size>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->y, s.thisObject());
    SE_PRECONDITION2(ok, false, "Size_y_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Size_y_set) 

static bool js_cc_gfx_Size_y_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Size *arg1 = (cc::gfx::Size *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Size>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->y, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Size_y_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->y, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Size_y_get) 

static bool js_cc_gfx_Size_z_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Size *arg1 = (cc::gfx::Size *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Size>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->z, s.thisObject());
    SE_PRECONDITION2(ok, false, "Size_z_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Size_z_set) 

static bool js_cc_gfx_Size_z_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Size *arg1 = (cc::gfx::Size *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Size>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->z, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Size_z_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->z, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Size_z_get) 

static bool js_cc_gfx_Size_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Size *arg1 = (cc::gfx::Size *) NULL ;
    cc::gfx::Size *arg2 = 0 ;
    cc::gfx::Size temp2 ;
    cc::gfx::Size *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Size>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Size_copy,2,SWIGTYPE_p_cc__gfx__Size");
    arg2 = &temp2;
    
    result = (cc::gfx::Size *) &(arg1)->copy((cc::gfx::Size const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Size_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Size_copy) 

// js_ctor
static bool js_new_cc_gfx_Size(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::Size *result;
    result = (cc::gfx::Size *)new cc::gfx::Size();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_Size, __jsb_cc_gfx_Size_class, js_delete_cc_gfx_Size)

static bool js_delete_cc_gfx_Size(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Size) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::Size * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::Size*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("x", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->x), ctx);
    }
    
    
    json->getProperty("y", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->y), ctx);
    }
    
    
    json->getProperty("z", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->z), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_Size(se::Object* obj) {
    auto* cls = se::Class::create("Size", obj, nullptr, _SE(js_new_cc_gfx_Size)); 
    
    cls->defineProperty("x", _SE(js_cc_gfx_Size_x_get), _SE(js_cc_gfx_Size_x_set)); 
    cls->defineProperty("y", _SE(js_cc_gfx_Size_y_get), _SE(js_cc_gfx_Size_y_set)); 
    cls->defineProperty("z", _SE(js_cc_gfx_Size_z_get), _SE(js_cc_gfx_Size_z_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_Size_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Size));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Size>(cls);
    
    __jsb_cc_gfx_Size_proto = cls->getProto();
    __jsb_cc_gfx_Size_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DeviceCaps_class = nullptr;
se::Object* __jsb_cc_gfx_DeviceCaps_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DeviceCaps) 

static bool js_cc_gfx_DeviceCaps_maxVertexAttributes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxVertexAttributes, s.thisObject());
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxVertexAttributes_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxVertexAttributes_set) 

static bool js_cc_gfx_DeviceCaps_maxVertexAttributes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxVertexAttributes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxVertexAttributes_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxVertexAttributes, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxVertexAttributes_get) 

static bool js_cc_gfx_DeviceCaps_maxVertexUniformVectors_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxVertexUniformVectors, s.thisObject());
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxVertexUniformVectors_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxVertexUniformVectors_set) 

static bool js_cc_gfx_DeviceCaps_maxVertexUniformVectors_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxVertexUniformVectors, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxVertexUniformVectors_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxVertexUniformVectors, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxVertexUniformVectors_get) 

static bool js_cc_gfx_DeviceCaps_maxFragmentUniformVectors_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxFragmentUniformVectors, s.thisObject());
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxFragmentUniformVectors_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxFragmentUniformVectors_set) 

static bool js_cc_gfx_DeviceCaps_maxFragmentUniformVectors_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxFragmentUniformVectors, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxFragmentUniformVectors_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxFragmentUniformVectors, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxFragmentUniformVectors_get) 

static bool js_cc_gfx_DeviceCaps_maxTextureUnits_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxTextureUnits, s.thisObject());
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxTextureUnits_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxTextureUnits_set) 

static bool js_cc_gfx_DeviceCaps_maxTextureUnits_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxTextureUnits, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxTextureUnits_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxTextureUnits, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxTextureUnits_get) 

static bool js_cc_gfx_DeviceCaps_maxImageUnits_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxImageUnits, s.thisObject());
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxImageUnits_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxImageUnits_set) 

static bool js_cc_gfx_DeviceCaps_maxImageUnits_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxImageUnits, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxImageUnits_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxImageUnits, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxImageUnits_get) 

static bool js_cc_gfx_DeviceCaps_maxVertexTextureUnits_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxVertexTextureUnits, s.thisObject());
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxVertexTextureUnits_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxVertexTextureUnits_set) 

static bool js_cc_gfx_DeviceCaps_maxVertexTextureUnits_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxVertexTextureUnits, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxVertexTextureUnits_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxVertexTextureUnits, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxVertexTextureUnits_get) 

static bool js_cc_gfx_DeviceCaps_maxColorRenderTargets_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxColorRenderTargets, s.thisObject());
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxColorRenderTargets_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxColorRenderTargets_set) 

static bool js_cc_gfx_DeviceCaps_maxColorRenderTargets_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxColorRenderTargets, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxColorRenderTargets_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxColorRenderTargets, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxColorRenderTargets_get) 

static bool js_cc_gfx_DeviceCaps_maxShaderStorageBufferBindings_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxShaderStorageBufferBindings, s.thisObject());
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxShaderStorageBufferBindings_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxShaderStorageBufferBindings_set) 

static bool js_cc_gfx_DeviceCaps_maxShaderStorageBufferBindings_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxShaderStorageBufferBindings, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxShaderStorageBufferBindings_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxShaderStorageBufferBindings, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxShaderStorageBufferBindings_get) 

static bool js_cc_gfx_DeviceCaps_maxShaderStorageBlockSize_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxShaderStorageBlockSize, s.thisObject());
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxShaderStorageBlockSize_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxShaderStorageBlockSize_set) 

static bool js_cc_gfx_DeviceCaps_maxShaderStorageBlockSize_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxShaderStorageBlockSize, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxShaderStorageBlockSize_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxShaderStorageBlockSize, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxShaderStorageBlockSize_get) 

static bool js_cc_gfx_DeviceCaps_maxUniformBufferBindings_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxUniformBufferBindings, s.thisObject());
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxUniformBufferBindings_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxUniformBufferBindings_set) 

static bool js_cc_gfx_DeviceCaps_maxUniformBufferBindings_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxUniformBufferBindings, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxUniformBufferBindings_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxUniformBufferBindings, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxUniformBufferBindings_get) 

static bool js_cc_gfx_DeviceCaps_maxUniformBlockSize_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxUniformBlockSize, s.thisObject());
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxUniformBlockSize_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxUniformBlockSize_set) 

static bool js_cc_gfx_DeviceCaps_maxUniformBlockSize_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxUniformBlockSize, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxUniformBlockSize_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxUniformBlockSize, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxUniformBlockSize_get) 

static bool js_cc_gfx_DeviceCaps_maxTextureSize_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxTextureSize, s.thisObject());
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxTextureSize_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxTextureSize_set) 

static bool js_cc_gfx_DeviceCaps_maxTextureSize_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxTextureSize, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxTextureSize_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxTextureSize, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxTextureSize_get) 

static bool js_cc_gfx_DeviceCaps_maxCubeMapTextureSize_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxCubeMapTextureSize, s.thisObject());
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxCubeMapTextureSize_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxCubeMapTextureSize_set) 

static bool js_cc_gfx_DeviceCaps_maxCubeMapTextureSize_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxCubeMapTextureSize, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxCubeMapTextureSize_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxCubeMapTextureSize, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxCubeMapTextureSize_get) 

static bool js_cc_gfx_DeviceCaps_uboOffsetAlignment_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->uboOffsetAlignment, s.thisObject());
    SE_PRECONDITION2(ok, false, "DeviceCaps_uboOffsetAlignment_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_uboOffsetAlignment_set) 

static bool js_cc_gfx_DeviceCaps_uboOffsetAlignment_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->uboOffsetAlignment, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeviceCaps_uboOffsetAlignment_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->uboOffsetAlignment, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_uboOffsetAlignment_get) 

static bool js_cc_gfx_DeviceCaps_maxComputeSharedMemorySize_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxComputeSharedMemorySize, s.thisObject());
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxComputeSharedMemorySize_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxComputeSharedMemorySize_set) 

static bool js_cc_gfx_DeviceCaps_maxComputeSharedMemorySize_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxComputeSharedMemorySize, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxComputeSharedMemorySize_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxComputeSharedMemorySize, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxComputeSharedMemorySize_get) 

static bool js_cc_gfx_DeviceCaps_maxComputeWorkGroupInvocations_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxComputeWorkGroupInvocations, s.thisObject());
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxComputeWorkGroupInvocations_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxComputeWorkGroupInvocations_set) 

static bool js_cc_gfx_DeviceCaps_maxComputeWorkGroupInvocations_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxComputeWorkGroupInvocations, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxComputeWorkGroupInvocations_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxComputeWorkGroupInvocations, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxComputeWorkGroupInvocations_get) 

static bool js_cc_gfx_DeviceCaps_maxComputeWorkGroupSize_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxComputeWorkGroupSize, s.thisObject());
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxComputeWorkGroupSize_set,2,SWIGTYPE_cc__gfx__Size"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxComputeWorkGroupSize_set) 

static bool js_cc_gfx_DeviceCaps_maxComputeWorkGroupSize_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxComputeWorkGroupSize, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxComputeWorkGroupSize_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxComputeWorkGroupSize, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxComputeWorkGroupSize_get) 

static bool js_cc_gfx_DeviceCaps_maxComputeWorkGroupCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxComputeWorkGroupCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxComputeWorkGroupCount_set,2,SWIGTYPE_cc__gfx__Size"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxComputeWorkGroupCount_set) 

static bool js_cc_gfx_DeviceCaps_maxComputeWorkGroupCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxComputeWorkGroupCount, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeviceCaps_maxComputeWorkGroupCount_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxComputeWorkGroupCount, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxComputeWorkGroupCount_get) 

static bool js_cc_gfx_DeviceCaps_supportQuery_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->supportQuery);
    SE_PRECONDITION2(ok, false, "DeviceCaps_supportQuery_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_supportQuery_set) 

static bool js_cc_gfx_DeviceCaps_supportQuery_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->supportQuery, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_supportQuery_get) 

static bool js_cc_gfx_DeviceCaps_clipSpaceMinZ_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->clipSpaceMinZ, nullptr);
    SE_PRECONDITION2(ok, false, "DeviceCaps_clipSpaceMinZ_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_clipSpaceMinZ_set) 

static bool js_cc_gfx_DeviceCaps_clipSpaceMinZ_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->clipSpaceMinZ, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_clipSpaceMinZ_get) 

static bool js_cc_gfx_DeviceCaps_screenSpaceSignY_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->screenSpaceSignY, nullptr);
    SE_PRECONDITION2(ok, false, "DeviceCaps_screenSpaceSignY_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_screenSpaceSignY_set) 

static bool js_cc_gfx_DeviceCaps_screenSpaceSignY_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->screenSpaceSignY, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_screenSpaceSignY_get) 

static bool js_cc_gfx_DeviceCaps_clipSpaceSignY_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->clipSpaceSignY, nullptr);
    SE_PRECONDITION2(ok, false, "DeviceCaps_clipSpaceSignY_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_clipSpaceSignY_set) 

static bool js_cc_gfx_DeviceCaps_clipSpaceSignY_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->clipSpaceSignY, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_clipSpaceSignY_get) 

static bool js_cc_gfx_DeviceCaps_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    cc::gfx::DeviceCaps *arg2 = 0 ;
    cc::gfx::DeviceCaps temp2 ;
    cc::gfx::DeviceCaps *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DeviceCaps_copy,2,SWIGTYPE_p_cc__gfx__DeviceCaps");
    arg2 = &temp2;
    
    result = (cc::gfx::DeviceCaps *) &(arg1)->copy((cc::gfx::DeviceCaps const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeviceCaps_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DeviceCaps_copy) 

// js_ctor
static bool js_new_cc_gfx_DeviceCaps(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::DeviceCaps *result;
    result = (cc::gfx::DeviceCaps *)new cc::gfx::DeviceCaps();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_DeviceCaps, __jsb_cc_gfx_DeviceCaps_class, js_delete_cc_gfx_DeviceCaps)

static bool js_delete_cc_gfx_DeviceCaps(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DeviceCaps) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::DeviceCaps * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::DeviceCaps*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("maxVertexAttributes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxVertexAttributes), ctx);
    }
    
    
    json->getProperty("maxVertexUniformVectors", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxVertexUniformVectors), ctx);
    }
    
    
    json->getProperty("maxFragmentUniformVectors", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxFragmentUniformVectors), ctx);
    }
    
    
    json->getProperty("maxTextureUnits", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxTextureUnits), ctx);
    }
    
    
    json->getProperty("maxImageUnits", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxImageUnits), ctx);
    }
    
    
    json->getProperty("maxVertexTextureUnits", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxVertexTextureUnits), ctx);
    }
    
    
    json->getProperty("maxColorRenderTargets", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxColorRenderTargets), ctx);
    }
    
    
    json->getProperty("maxShaderStorageBufferBindings", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxShaderStorageBufferBindings), ctx);
    }
    
    
    json->getProperty("maxShaderStorageBlockSize", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxShaderStorageBlockSize), ctx);
    }
    
    
    json->getProperty("maxUniformBufferBindings", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxUniformBufferBindings), ctx);
    }
    
    
    json->getProperty("maxUniformBlockSize", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxUniformBlockSize), ctx);
    }
    
    
    json->getProperty("maxTextureSize", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxTextureSize), ctx);
    }
    
    
    json->getProperty("maxCubeMapTextureSize", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxCubeMapTextureSize), ctx);
    }
    
    
    json->getProperty("uboOffsetAlignment", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->uboOffsetAlignment), ctx);
    }
    
    
    json->getProperty("maxComputeSharedMemorySize", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxComputeSharedMemorySize), ctx);
    }
    
    
    json->getProperty("maxComputeWorkGroupInvocations", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxComputeWorkGroupInvocations), ctx);
    }
    
    
    json->getProperty("maxComputeWorkGroupSize", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxComputeWorkGroupSize), ctx);
    }
    
    
    json->getProperty("maxComputeWorkGroupCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxComputeWorkGroupCount), ctx);
    }
    
    
    json->getProperty("supportQuery", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->supportQuery), ctx);
    }
    
    
    json->getProperty("clipSpaceMinZ", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->clipSpaceMinZ), ctx);
    }
    
    
    json->getProperty("screenSpaceSignY", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->screenSpaceSignY), ctx);
    }
    
    
    json->getProperty("clipSpaceSignY", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->clipSpaceSignY), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_DeviceCaps(se::Object* obj) {
    auto* cls = se::Class::create("DeviceCaps", obj, nullptr, _SE(js_new_cc_gfx_DeviceCaps)); 
    
    cls->defineProperty("maxVertexAttributes", _SE(js_cc_gfx_DeviceCaps_maxVertexAttributes_get), _SE(js_cc_gfx_DeviceCaps_maxVertexAttributes_set)); 
    cls->defineProperty("maxVertexUniformVectors", _SE(js_cc_gfx_DeviceCaps_maxVertexUniformVectors_get), _SE(js_cc_gfx_DeviceCaps_maxVertexUniformVectors_set)); 
    cls->defineProperty("maxFragmentUniformVectors", _SE(js_cc_gfx_DeviceCaps_maxFragmentUniformVectors_get), _SE(js_cc_gfx_DeviceCaps_maxFragmentUniformVectors_set)); 
    cls->defineProperty("maxTextureUnits", _SE(js_cc_gfx_DeviceCaps_maxTextureUnits_get), _SE(js_cc_gfx_DeviceCaps_maxTextureUnits_set)); 
    cls->defineProperty("maxImageUnits", _SE(js_cc_gfx_DeviceCaps_maxImageUnits_get), _SE(js_cc_gfx_DeviceCaps_maxImageUnits_set)); 
    cls->defineProperty("maxVertexTextureUnits", _SE(js_cc_gfx_DeviceCaps_maxVertexTextureUnits_get), _SE(js_cc_gfx_DeviceCaps_maxVertexTextureUnits_set)); 
    cls->defineProperty("maxColorRenderTargets", _SE(js_cc_gfx_DeviceCaps_maxColorRenderTargets_get), _SE(js_cc_gfx_DeviceCaps_maxColorRenderTargets_set)); 
    cls->defineProperty("maxShaderStorageBufferBindings", _SE(js_cc_gfx_DeviceCaps_maxShaderStorageBufferBindings_get), _SE(js_cc_gfx_DeviceCaps_maxShaderStorageBufferBindings_set)); 
    cls->defineProperty("maxShaderStorageBlockSize", _SE(js_cc_gfx_DeviceCaps_maxShaderStorageBlockSize_get), _SE(js_cc_gfx_DeviceCaps_maxShaderStorageBlockSize_set)); 
    cls->defineProperty("maxUniformBufferBindings", _SE(js_cc_gfx_DeviceCaps_maxUniformBufferBindings_get), _SE(js_cc_gfx_DeviceCaps_maxUniformBufferBindings_set)); 
    cls->defineProperty("maxUniformBlockSize", _SE(js_cc_gfx_DeviceCaps_maxUniformBlockSize_get), _SE(js_cc_gfx_DeviceCaps_maxUniformBlockSize_set)); 
    cls->defineProperty("maxTextureSize", _SE(js_cc_gfx_DeviceCaps_maxTextureSize_get), _SE(js_cc_gfx_DeviceCaps_maxTextureSize_set)); 
    cls->defineProperty("maxCubeMapTextureSize", _SE(js_cc_gfx_DeviceCaps_maxCubeMapTextureSize_get), _SE(js_cc_gfx_DeviceCaps_maxCubeMapTextureSize_set)); 
    cls->defineProperty("uboOffsetAlignment", _SE(js_cc_gfx_DeviceCaps_uboOffsetAlignment_get), _SE(js_cc_gfx_DeviceCaps_uboOffsetAlignment_set)); 
    cls->defineProperty("maxComputeSharedMemorySize", _SE(js_cc_gfx_DeviceCaps_maxComputeSharedMemorySize_get), _SE(js_cc_gfx_DeviceCaps_maxComputeSharedMemorySize_set)); 
    cls->defineProperty("maxComputeWorkGroupInvocations", _SE(js_cc_gfx_DeviceCaps_maxComputeWorkGroupInvocations_get), _SE(js_cc_gfx_DeviceCaps_maxComputeWorkGroupInvocations_set)); 
    cls->defineProperty("maxComputeWorkGroupSize", _SE(js_cc_gfx_DeviceCaps_maxComputeWorkGroupSize_get), _SE(js_cc_gfx_DeviceCaps_maxComputeWorkGroupSize_set)); 
    cls->defineProperty("maxComputeWorkGroupCount", _SE(js_cc_gfx_DeviceCaps_maxComputeWorkGroupCount_get), _SE(js_cc_gfx_DeviceCaps_maxComputeWorkGroupCount_set)); 
    cls->defineProperty("supportQuery", _SE(js_cc_gfx_DeviceCaps_supportQuery_get), _SE(js_cc_gfx_DeviceCaps_supportQuery_set)); 
    cls->defineProperty("clipSpaceMinZ", _SE(js_cc_gfx_DeviceCaps_clipSpaceMinZ_get), _SE(js_cc_gfx_DeviceCaps_clipSpaceMinZ_set)); 
    cls->defineProperty("screenSpaceSignY", _SE(js_cc_gfx_DeviceCaps_screenSpaceSignY_get), _SE(js_cc_gfx_DeviceCaps_screenSpaceSignY_set)); 
    cls->defineProperty("clipSpaceSignY", _SE(js_cc_gfx_DeviceCaps_clipSpaceSignY_get), _SE(js_cc_gfx_DeviceCaps_clipSpaceSignY_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_DeviceCaps_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DeviceCaps));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DeviceCaps>(cls);
    
    __jsb_cc_gfx_DeviceCaps_proto = cls->getProto();
    __jsb_cc_gfx_DeviceCaps_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DeviceOptions_class = nullptr;
se::Object* __jsb_cc_gfx_DeviceOptions_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DeviceOptions) 

static bool js_cc_gfx_DeviceOptions_enableBarrierDeduce_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceOptions *arg1 = (cc::gfx::DeviceOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceOptions>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->enableBarrierDeduce);
    SE_PRECONDITION2(ok, false, "DeviceOptions_enableBarrierDeduce_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceOptions_enableBarrierDeduce_set) 

static bool js_cc_gfx_DeviceOptions_enableBarrierDeduce_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceOptions *arg1 = (cc::gfx::DeviceOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceOptions>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->enableBarrierDeduce, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceOptions_enableBarrierDeduce_get) 

// js_ctor
static bool js_new_cc_gfx_DeviceOptions(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::DeviceOptions *result;
    result = (cc::gfx::DeviceOptions *)new cc::gfx::DeviceOptions();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_DeviceOptions, __jsb_cc_gfx_DeviceOptions_class, js_delete_cc_gfx_DeviceOptions)

static bool js_delete_cc_gfx_DeviceOptions(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DeviceOptions) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::DeviceOptions * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::DeviceOptions*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("enableBarrierDeduce", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->enableBarrierDeduce), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_DeviceOptions(se::Object* obj) {
    auto* cls = se::Class::create("DeviceOptions", obj, nullptr, _SE(js_new_cc_gfx_DeviceOptions)); 
    
    cls->defineProperty("enableBarrierDeduce", _SE(js_cc_gfx_DeviceOptions_enableBarrierDeduce_get), _SE(js_cc_gfx_DeviceOptions_enableBarrierDeduce_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DeviceOptions));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DeviceOptions>(cls);
    
    __jsb_cc_gfx_DeviceOptions_proto = cls->getProto();
    __jsb_cc_gfx_DeviceOptions_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Offset_class = nullptr;
se::Object* __jsb_cc_gfx_Offset_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Offset) 

static bool js_cc_gfx_Offset_x_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Offset *arg1 = (cc::gfx::Offset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Offset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->x, s.thisObject());
    SE_PRECONDITION2(ok, false, "Offset_x_set,2,SWIGTYPE_int32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Offset_x_set) 

static bool js_cc_gfx_Offset_x_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Offset *arg1 = (cc::gfx::Offset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Offset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->x, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Offset_x_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->x, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Offset_x_get) 

static bool js_cc_gfx_Offset_y_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Offset *arg1 = (cc::gfx::Offset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Offset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->y, s.thisObject());
    SE_PRECONDITION2(ok, false, "Offset_y_set,2,SWIGTYPE_int32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Offset_y_set) 

static bool js_cc_gfx_Offset_y_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Offset *arg1 = (cc::gfx::Offset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Offset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->y, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Offset_y_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->y, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Offset_y_get) 

static bool js_cc_gfx_Offset_z_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Offset *arg1 = (cc::gfx::Offset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Offset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->z, s.thisObject());
    SE_PRECONDITION2(ok, false, "Offset_z_set,2,SWIGTYPE_int32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Offset_z_set) 

static bool js_cc_gfx_Offset_z_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Offset *arg1 = (cc::gfx::Offset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Offset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->z, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Offset_z_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->z, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Offset_z_get) 

static bool js_cc_gfx_Offset_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Offset *arg1 = (cc::gfx::Offset *) NULL ;
    cc::gfx::Offset *arg2 = 0 ;
    cc::gfx::Offset temp2 ;
    cc::gfx::Offset *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Offset>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Offset_copy,2,SWIGTYPE_p_cc__gfx__Offset");
    arg2 = &temp2;
    
    result = (cc::gfx::Offset *) &(arg1)->copy((cc::gfx::Offset const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Offset_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Offset_copy) 

// js_ctor
static bool js_new_cc_gfx_Offset(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::Offset *result;
    result = (cc::gfx::Offset *)new cc::gfx::Offset();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_Offset, __jsb_cc_gfx_Offset_class, js_delete_cc_gfx_Offset)

static bool js_delete_cc_gfx_Offset(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Offset) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::Offset * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::Offset*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("x", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->x), ctx);
    }
    
    
    json->getProperty("y", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->y), ctx);
    }
    
    
    json->getProperty("z", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->z), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_Offset(se::Object* obj) {
    auto* cls = se::Class::create("Offset", obj, nullptr, _SE(js_new_cc_gfx_Offset)); 
    
    cls->defineProperty("x", _SE(js_cc_gfx_Offset_x_get), _SE(js_cc_gfx_Offset_x_set)); 
    cls->defineProperty("y", _SE(js_cc_gfx_Offset_y_get), _SE(js_cc_gfx_Offset_y_set)); 
    cls->defineProperty("z", _SE(js_cc_gfx_Offset_z_get), _SE(js_cc_gfx_Offset_z_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_Offset_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Offset));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Offset>(cls);
    
    __jsb_cc_gfx_Offset_proto = cls->getProto();
    __jsb_cc_gfx_Offset_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Rect_class = nullptr;
se::Object* __jsb_cc_gfx_Rect_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Rect) 

static bool js_cc_gfx_Rect_x_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Rect *arg1 = (cc::gfx::Rect *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Rect>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->x, s.thisObject());
    SE_PRECONDITION2(ok, false, "Rect_x_set,2,SWIGTYPE_int32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Rect_x_set) 

static bool js_cc_gfx_Rect_x_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Rect *arg1 = (cc::gfx::Rect *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Rect>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->x, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Rect_x_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->x, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Rect_x_get) 

static bool js_cc_gfx_Rect_y_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Rect *arg1 = (cc::gfx::Rect *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Rect>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->y, s.thisObject());
    SE_PRECONDITION2(ok, false, "Rect_y_set,2,SWIGTYPE_int32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Rect_y_set) 

static bool js_cc_gfx_Rect_y_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Rect *arg1 = (cc::gfx::Rect *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Rect>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->y, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Rect_y_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->y, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Rect_y_get) 

static bool js_cc_gfx_Rect_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Rect *arg1 = (cc::gfx::Rect *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Rect>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->width, s.thisObject());
    SE_PRECONDITION2(ok, false, "Rect_width_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Rect_width_set) 

static bool js_cc_gfx_Rect_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Rect *arg1 = (cc::gfx::Rect *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Rect>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->width, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Rect_width_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->width, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Rect_width_get) 

static bool js_cc_gfx_Rect_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Rect *arg1 = (cc::gfx::Rect *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Rect>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->height, s.thisObject());
    SE_PRECONDITION2(ok, false, "Rect_height_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Rect_height_set) 

static bool js_cc_gfx_Rect_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Rect *arg1 = (cc::gfx::Rect *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Rect>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->height, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Rect_height_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->height, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Rect_height_get) 

static bool js_cc_gfx_Rect_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Rect *arg1 = (cc::gfx::Rect *) NULL ;
    cc::gfx::Rect *arg2 = 0 ;
    cc::gfx::Rect temp2 ;
    cc::gfx::Rect *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Rect>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Rect_copy,2,SWIGTYPE_p_cc__gfx__Rect");
    arg2 = &temp2;
    
    result = (cc::gfx::Rect *) &(arg1)->copy((cc::gfx::Rect const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Rect_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Rect_copy) 

// js_ctor
static bool js_new_cc_gfx_Rect(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::Rect *result;
    result = (cc::gfx::Rect *)new cc::gfx::Rect();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_Rect, __jsb_cc_gfx_Rect_class, js_delete_cc_gfx_Rect)

static bool js_delete_cc_gfx_Rect(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Rect) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::Rect * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::Rect*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("x", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->x), ctx);
    }
    
    
    json->getProperty("y", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->y), ctx);
    }
    
    
    json->getProperty("width", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->width), ctx);
    }
    
    
    json->getProperty("height", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->height), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_Rect(se::Object* obj) {
    auto* cls = se::Class::create("Rect", obj, nullptr, _SE(js_new_cc_gfx_Rect)); 
    
    cls->defineProperty("x", _SE(js_cc_gfx_Rect_x_get), _SE(js_cc_gfx_Rect_x_set)); 
    cls->defineProperty("y", _SE(js_cc_gfx_Rect_y_get), _SE(js_cc_gfx_Rect_y_set)); 
    cls->defineProperty("width", _SE(js_cc_gfx_Rect_width_get), _SE(js_cc_gfx_Rect_width_set)); 
    cls->defineProperty("height", _SE(js_cc_gfx_Rect_height_get), _SE(js_cc_gfx_Rect_height_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_Rect_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Rect));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Rect>(cls);
    
    __jsb_cc_gfx_Rect_proto = cls->getProto();
    __jsb_cc_gfx_Rect_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Extent_class = nullptr;
se::Object* __jsb_cc_gfx_Extent_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Extent) 

static bool js_cc_gfx_Extent_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Extent *arg1 = (cc::gfx::Extent *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Extent>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->width, s.thisObject());
    SE_PRECONDITION2(ok, false, "Extent_width_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Extent_width_set) 

static bool js_cc_gfx_Extent_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Extent *arg1 = (cc::gfx::Extent *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Extent>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->width, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Extent_width_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->width, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Extent_width_get) 

static bool js_cc_gfx_Extent_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Extent *arg1 = (cc::gfx::Extent *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Extent>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->height, s.thisObject());
    SE_PRECONDITION2(ok, false, "Extent_height_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Extent_height_set) 

static bool js_cc_gfx_Extent_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Extent *arg1 = (cc::gfx::Extent *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Extent>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->height, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Extent_height_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->height, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Extent_height_get) 

static bool js_cc_gfx_Extent_depth_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Extent *arg1 = (cc::gfx::Extent *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Extent>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->depth, s.thisObject());
    SE_PRECONDITION2(ok, false, "Extent_depth_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Extent_depth_set) 

static bool js_cc_gfx_Extent_depth_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Extent *arg1 = (cc::gfx::Extent *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Extent>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->depth, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Extent_depth_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depth, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Extent_depth_get) 

static bool js_cc_gfx_Extent_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Extent *arg1 = (cc::gfx::Extent *) NULL ;
    cc::gfx::Extent *arg2 = 0 ;
    cc::gfx::Extent temp2 ;
    cc::gfx::Extent *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Extent>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Extent_copy,2,SWIGTYPE_p_cc__gfx__Extent");
    arg2 = &temp2;
    
    result = (cc::gfx::Extent *) &(arg1)->copy((cc::gfx::Extent const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Extent_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Extent_copy) 

// js_ctor
static bool js_new_cc_gfx_Extent(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::Extent *result;
    result = (cc::gfx::Extent *)new cc::gfx::Extent();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_Extent, __jsb_cc_gfx_Extent_class, js_delete_cc_gfx_Extent)

static bool js_delete_cc_gfx_Extent(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Extent) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::Extent * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::Extent*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("width", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->width), ctx);
    }
    
    
    json->getProperty("height", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->height), ctx);
    }
    
    
    json->getProperty("depth", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depth), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_Extent(se::Object* obj) {
    auto* cls = se::Class::create("Extent", obj, nullptr, _SE(js_new_cc_gfx_Extent)); 
    
    cls->defineProperty("width", _SE(js_cc_gfx_Extent_width_get), _SE(js_cc_gfx_Extent_width_set)); 
    cls->defineProperty("height", _SE(js_cc_gfx_Extent_height_get), _SE(js_cc_gfx_Extent_height_set)); 
    cls->defineProperty("depth", _SE(js_cc_gfx_Extent_depth_get), _SE(js_cc_gfx_Extent_depth_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_Extent_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Extent));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Extent>(cls);
    
    __jsb_cc_gfx_Extent_proto = cls->getProto();
    __jsb_cc_gfx_Extent_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_TextureSubresLayers_class = nullptr;
se::Object* __jsb_cc_gfx_TextureSubresLayers_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_TextureSubresLayers) 

static bool js_cc_gfx_TextureSubresLayers_mipLevel_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureSubresLayers *arg1 = (cc::gfx::TextureSubresLayers *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresLayers>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->mipLevel, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureSubresLayers_mipLevel_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureSubresLayers_mipLevel_set) 

static bool js_cc_gfx_TextureSubresLayers_mipLevel_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureSubresLayers *arg1 = (cc::gfx::TextureSubresLayers *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresLayers>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->mipLevel, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureSubresLayers_mipLevel_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->mipLevel, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureSubresLayers_mipLevel_get) 

static bool js_cc_gfx_TextureSubresLayers_baseArrayLayer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureSubresLayers *arg1 = (cc::gfx::TextureSubresLayers *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresLayers>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->baseArrayLayer, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureSubresLayers_baseArrayLayer_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureSubresLayers_baseArrayLayer_set) 

static bool js_cc_gfx_TextureSubresLayers_baseArrayLayer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureSubresLayers *arg1 = (cc::gfx::TextureSubresLayers *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresLayers>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->baseArrayLayer, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureSubresLayers_baseArrayLayer_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->baseArrayLayer, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureSubresLayers_baseArrayLayer_get) 

static bool js_cc_gfx_TextureSubresLayers_layerCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureSubresLayers *arg1 = (cc::gfx::TextureSubresLayers *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresLayers>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->layerCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureSubresLayers_layerCount_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureSubresLayers_layerCount_set) 

static bool js_cc_gfx_TextureSubresLayers_layerCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureSubresLayers *arg1 = (cc::gfx::TextureSubresLayers *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresLayers>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->layerCount, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureSubresLayers_layerCount_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->layerCount, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureSubresLayers_layerCount_get) 

static bool js_cc_gfx_TextureSubresLayers_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureSubresLayers *arg1 = (cc::gfx::TextureSubresLayers *) NULL ;
    cc::gfx::TextureSubresLayers *arg2 = 0 ;
    cc::gfx::TextureSubresLayers temp2 ;
    cc::gfx::TextureSubresLayers *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresLayers>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureSubresLayers_copy,2,SWIGTYPE_p_cc__gfx__TextureSubresLayers");
    arg2 = &temp2;
    
    result = (cc::gfx::TextureSubresLayers *) &(arg1)->copy((cc::gfx::TextureSubresLayers const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureSubresLayers_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_TextureSubresLayers_copy) 

// js_ctor
static bool js_new_cc_gfx_TextureSubresLayers(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::TextureSubresLayers *result;
    result = (cc::gfx::TextureSubresLayers *)new cc::gfx::TextureSubresLayers();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_TextureSubresLayers, __jsb_cc_gfx_TextureSubresLayers_class, js_delete_cc_gfx_TextureSubresLayers)

static bool js_delete_cc_gfx_TextureSubresLayers(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_TextureSubresLayers) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::TextureSubresLayers * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::TextureSubresLayers*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("mipLevel", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->mipLevel), ctx);
    }
    
    
    json->getProperty("baseArrayLayer", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->baseArrayLayer), ctx);
    }
    
    
    json->getProperty("layerCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->layerCount), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_TextureSubresLayers(se::Object* obj) {
    auto* cls = se::Class::create("TextureSubresLayers", obj, nullptr, _SE(js_new_cc_gfx_TextureSubresLayers)); 
    
    cls->defineProperty("mipLevel", _SE(js_cc_gfx_TextureSubresLayers_mipLevel_get), _SE(js_cc_gfx_TextureSubresLayers_mipLevel_set)); 
    cls->defineProperty("baseArrayLayer", _SE(js_cc_gfx_TextureSubresLayers_baseArrayLayer_get), _SE(js_cc_gfx_TextureSubresLayers_baseArrayLayer_set)); 
    cls->defineProperty("layerCount", _SE(js_cc_gfx_TextureSubresLayers_layerCount_get), _SE(js_cc_gfx_TextureSubresLayers_layerCount_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_TextureSubresLayers_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_TextureSubresLayers));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::TextureSubresLayers>(cls);
    
    __jsb_cc_gfx_TextureSubresLayers_proto = cls->getProto();
    __jsb_cc_gfx_TextureSubresLayers_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_TextureSubresRange_class = nullptr;
se::Object* __jsb_cc_gfx_TextureSubresRange_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_TextureSubresRange) 

static bool js_cc_gfx_TextureSubresRange_baseMipLevel_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureSubresRange *arg1 = (cc::gfx::TextureSubresRange *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresRange>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->baseMipLevel, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureSubresRange_baseMipLevel_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureSubresRange_baseMipLevel_set) 

static bool js_cc_gfx_TextureSubresRange_baseMipLevel_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureSubresRange *arg1 = (cc::gfx::TextureSubresRange *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresRange>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->baseMipLevel, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureSubresRange_baseMipLevel_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->baseMipLevel, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureSubresRange_baseMipLevel_get) 

static bool js_cc_gfx_TextureSubresRange_levelCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureSubresRange *arg1 = (cc::gfx::TextureSubresRange *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresRange>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->levelCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureSubresRange_levelCount_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureSubresRange_levelCount_set) 

static bool js_cc_gfx_TextureSubresRange_levelCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureSubresRange *arg1 = (cc::gfx::TextureSubresRange *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresRange>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->levelCount, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureSubresRange_levelCount_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->levelCount, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureSubresRange_levelCount_get) 

static bool js_cc_gfx_TextureSubresRange_baseArrayLayer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureSubresRange *arg1 = (cc::gfx::TextureSubresRange *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresRange>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->baseArrayLayer, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureSubresRange_baseArrayLayer_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureSubresRange_baseArrayLayer_set) 

static bool js_cc_gfx_TextureSubresRange_baseArrayLayer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureSubresRange *arg1 = (cc::gfx::TextureSubresRange *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresRange>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->baseArrayLayer, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureSubresRange_baseArrayLayer_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->baseArrayLayer, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureSubresRange_baseArrayLayer_get) 

static bool js_cc_gfx_TextureSubresRange_layerCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureSubresRange *arg1 = (cc::gfx::TextureSubresRange *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresRange>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->layerCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureSubresRange_layerCount_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureSubresRange_layerCount_set) 

static bool js_cc_gfx_TextureSubresRange_layerCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureSubresRange *arg1 = (cc::gfx::TextureSubresRange *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresRange>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->layerCount, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureSubresRange_layerCount_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->layerCount, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureSubresRange_layerCount_get) 

static bool js_cc_gfx_TextureSubresRange_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureSubresRange *arg1 = (cc::gfx::TextureSubresRange *) NULL ;
    cc::gfx::TextureSubresRange *arg2 = 0 ;
    cc::gfx::TextureSubresRange temp2 ;
    cc::gfx::TextureSubresRange *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresRange>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureSubresRange_copy,2,SWIGTYPE_p_cc__gfx__TextureSubresRange");
    arg2 = &temp2;
    
    result = (cc::gfx::TextureSubresRange *) &(arg1)->copy((cc::gfx::TextureSubresRange const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureSubresRange_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_TextureSubresRange_copy) 

// js_ctor
static bool js_new_cc_gfx_TextureSubresRange(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::TextureSubresRange *result;
    result = (cc::gfx::TextureSubresRange *)new cc::gfx::TextureSubresRange();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_TextureSubresRange, __jsb_cc_gfx_TextureSubresRange_class, js_delete_cc_gfx_TextureSubresRange)

static bool js_delete_cc_gfx_TextureSubresRange(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_TextureSubresRange) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::TextureSubresRange * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::TextureSubresRange*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("baseMipLevel", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->baseMipLevel), ctx);
    }
    
    
    json->getProperty("levelCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->levelCount), ctx);
    }
    
    
    json->getProperty("baseArrayLayer", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->baseArrayLayer), ctx);
    }
    
    
    json->getProperty("layerCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->layerCount), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_TextureSubresRange(se::Object* obj) {
    auto* cls = se::Class::create("TextureSubresRange", obj, nullptr, _SE(js_new_cc_gfx_TextureSubresRange)); 
    
    cls->defineProperty("baseMipLevel", _SE(js_cc_gfx_TextureSubresRange_baseMipLevel_get), _SE(js_cc_gfx_TextureSubresRange_baseMipLevel_set)); 
    cls->defineProperty("levelCount", _SE(js_cc_gfx_TextureSubresRange_levelCount_get), _SE(js_cc_gfx_TextureSubresRange_levelCount_set)); 
    cls->defineProperty("baseArrayLayer", _SE(js_cc_gfx_TextureSubresRange_baseArrayLayer_get), _SE(js_cc_gfx_TextureSubresRange_baseArrayLayer_set)); 
    cls->defineProperty("layerCount", _SE(js_cc_gfx_TextureSubresRange_layerCount_get), _SE(js_cc_gfx_TextureSubresRange_layerCount_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_TextureSubresRange_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_TextureSubresRange));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::TextureSubresRange>(cls);
    
    __jsb_cc_gfx_TextureSubresRange_proto = cls->getProto();
    __jsb_cc_gfx_TextureSubresRange_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_TextureCopy_class = nullptr;
se::Object* __jsb_cc_gfx_TextureCopy_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_TextureCopy) 

static bool js_cc_gfx_TextureCopy_srcSubres_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureCopy *arg1 = (cc::gfx::TextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureCopy>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->srcSubres, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureCopy_srcSubres_set,2,SWIGTYPE_cc__gfx__TextureSubresLayers"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureCopy_srcSubres_set) 

static bool js_cc_gfx_TextureCopy_srcSubres_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureCopy *arg1 = (cc::gfx::TextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureCopy>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->srcSubres, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureCopy_srcSubres_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->srcSubres, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureCopy_srcSubres_get) 

static bool js_cc_gfx_TextureCopy_srcOffset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureCopy *arg1 = (cc::gfx::TextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureCopy>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->srcOffset, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureCopy_srcOffset_set,2,SWIGTYPE_cc__gfx__Offset"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureCopy_srcOffset_set) 

static bool js_cc_gfx_TextureCopy_srcOffset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureCopy *arg1 = (cc::gfx::TextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureCopy>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->srcOffset, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureCopy_srcOffset_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->srcOffset, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureCopy_srcOffset_get) 

static bool js_cc_gfx_TextureCopy_dstSubres_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureCopy *arg1 = (cc::gfx::TextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureCopy>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->dstSubres, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureCopy_dstSubres_set,2,SWIGTYPE_cc__gfx__TextureSubresLayers"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureCopy_dstSubres_set) 

static bool js_cc_gfx_TextureCopy_dstSubres_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureCopy *arg1 = (cc::gfx::TextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureCopy>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->dstSubres, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureCopy_dstSubres_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->dstSubres, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureCopy_dstSubres_get) 

static bool js_cc_gfx_TextureCopy_dstOffset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureCopy *arg1 = (cc::gfx::TextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureCopy>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->dstOffset, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureCopy_dstOffset_set,2,SWIGTYPE_cc__gfx__Offset"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureCopy_dstOffset_set) 

static bool js_cc_gfx_TextureCopy_dstOffset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureCopy *arg1 = (cc::gfx::TextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureCopy>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->dstOffset, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureCopy_dstOffset_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->dstOffset, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureCopy_dstOffset_get) 

static bool js_cc_gfx_TextureCopy_extent_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureCopy *arg1 = (cc::gfx::TextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureCopy>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->extent, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureCopy_extent_set,2,SWIGTYPE_cc__gfx__Extent"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureCopy_extent_set) 

static bool js_cc_gfx_TextureCopy_extent_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureCopy *arg1 = (cc::gfx::TextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureCopy>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->extent, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureCopy_extent_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->extent, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureCopy_extent_get) 

static bool js_cc_gfx_TextureCopy_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureCopy *arg1 = (cc::gfx::TextureCopy *) NULL ;
    cc::gfx::TextureCopy *arg2 = 0 ;
    cc::gfx::TextureCopy temp2 ;
    cc::gfx::TextureCopy *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureCopy>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureCopy_copy,2,SWIGTYPE_p_cc__gfx__TextureCopy");
    arg2 = &temp2;
    
    result = (cc::gfx::TextureCopy *) &(arg1)->copy((cc::gfx::TextureCopy const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureCopy_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_TextureCopy_copy) 

// js_ctor
static bool js_new_cc_gfx_TextureCopy(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::TextureCopy *result;
    result = (cc::gfx::TextureCopy *)new cc::gfx::TextureCopy();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_TextureCopy, __jsb_cc_gfx_TextureCopy_class, js_delete_cc_gfx_TextureCopy)

static bool js_delete_cc_gfx_TextureCopy(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_TextureCopy) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::TextureCopy * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::TextureCopy*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("srcSubres", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->srcSubres), ctx);
    }
    
    
    json->getProperty("srcOffset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->srcOffset), ctx);
    }
    
    
    json->getProperty("dstSubres", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dstSubres), ctx);
    }
    
    
    json->getProperty("dstOffset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dstOffset), ctx);
    }
    
    
    json->getProperty("extent", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->extent), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_TextureCopy(se::Object* obj) {
    auto* cls = se::Class::create("TextureCopy", obj, nullptr, _SE(js_new_cc_gfx_TextureCopy)); 
    
    cls->defineProperty("srcSubres", _SE(js_cc_gfx_TextureCopy_srcSubres_get), _SE(js_cc_gfx_TextureCopy_srcSubres_set)); 
    cls->defineProperty("srcOffset", _SE(js_cc_gfx_TextureCopy_srcOffset_get), _SE(js_cc_gfx_TextureCopy_srcOffset_set)); 
    cls->defineProperty("dstSubres", _SE(js_cc_gfx_TextureCopy_dstSubres_get), _SE(js_cc_gfx_TextureCopy_dstSubres_set)); 
    cls->defineProperty("dstOffset", _SE(js_cc_gfx_TextureCopy_dstOffset_get), _SE(js_cc_gfx_TextureCopy_dstOffset_set)); 
    cls->defineProperty("extent", _SE(js_cc_gfx_TextureCopy_extent_get), _SE(js_cc_gfx_TextureCopy_extent_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_TextureCopy_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_TextureCopy));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::TextureCopy>(cls);
    
    __jsb_cc_gfx_TextureCopy_proto = cls->getProto();
    __jsb_cc_gfx_TextureCopy_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_TextureBlit_class = nullptr;
se::Object* __jsb_cc_gfx_TextureBlit_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_TextureBlit) 

static bool js_cc_gfx_TextureBlit_srcSubres_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBlit *arg1 = (cc::gfx::TextureBlit *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBlit>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->srcSubres, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureBlit_srcSubres_set,2,SWIGTYPE_cc__gfx__TextureSubresLayers"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBlit_srcSubres_set) 

static bool js_cc_gfx_TextureBlit_srcSubres_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBlit *arg1 = (cc::gfx::TextureBlit *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBlit>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->srcSubres, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBlit_srcSubres_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->srcSubres, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBlit_srcSubres_get) 

static bool js_cc_gfx_TextureBlit_srcOffset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBlit *arg1 = (cc::gfx::TextureBlit *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBlit>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->srcOffset, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureBlit_srcOffset_set,2,SWIGTYPE_cc__gfx__Offset"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBlit_srcOffset_set) 

static bool js_cc_gfx_TextureBlit_srcOffset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBlit *arg1 = (cc::gfx::TextureBlit *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBlit>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->srcOffset, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBlit_srcOffset_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->srcOffset, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBlit_srcOffset_get) 

static bool js_cc_gfx_TextureBlit_srcExtent_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBlit *arg1 = (cc::gfx::TextureBlit *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBlit>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->srcExtent, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureBlit_srcExtent_set,2,SWIGTYPE_cc__gfx__Extent"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBlit_srcExtent_set) 

static bool js_cc_gfx_TextureBlit_srcExtent_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBlit *arg1 = (cc::gfx::TextureBlit *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBlit>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->srcExtent, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBlit_srcExtent_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->srcExtent, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBlit_srcExtent_get) 

static bool js_cc_gfx_TextureBlit_dstSubres_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBlit *arg1 = (cc::gfx::TextureBlit *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBlit>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->dstSubres, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureBlit_dstSubres_set,2,SWIGTYPE_cc__gfx__TextureSubresLayers"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBlit_dstSubres_set) 

static bool js_cc_gfx_TextureBlit_dstSubres_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBlit *arg1 = (cc::gfx::TextureBlit *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBlit>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->dstSubres, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBlit_dstSubres_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->dstSubres, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBlit_dstSubres_get) 

static bool js_cc_gfx_TextureBlit_dstOffset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBlit *arg1 = (cc::gfx::TextureBlit *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBlit>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->dstOffset, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureBlit_dstOffset_set,2,SWIGTYPE_cc__gfx__Offset"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBlit_dstOffset_set) 

static bool js_cc_gfx_TextureBlit_dstOffset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBlit *arg1 = (cc::gfx::TextureBlit *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBlit>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->dstOffset, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBlit_dstOffset_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->dstOffset, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBlit_dstOffset_get) 

static bool js_cc_gfx_TextureBlit_dstExtent_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBlit *arg1 = (cc::gfx::TextureBlit *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBlit>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->dstExtent, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureBlit_dstExtent_set,2,SWIGTYPE_cc__gfx__Extent"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBlit_dstExtent_set) 

static bool js_cc_gfx_TextureBlit_dstExtent_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBlit *arg1 = (cc::gfx::TextureBlit *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBlit>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->dstExtent, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBlit_dstExtent_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->dstExtent, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBlit_dstExtent_get) 

static bool js_cc_gfx_TextureBlit_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBlit *arg1 = (cc::gfx::TextureBlit *) NULL ;
    cc::gfx::TextureBlit *arg2 = 0 ;
    cc::gfx::TextureBlit temp2 ;
    cc::gfx::TextureBlit *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBlit>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureBlit_copy,2,SWIGTYPE_p_cc__gfx__TextureBlit");
    arg2 = &temp2;
    
    result = (cc::gfx::TextureBlit *) &(arg1)->copy((cc::gfx::TextureBlit const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBlit_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_TextureBlit_copy) 

// js_ctor
static bool js_new_cc_gfx_TextureBlit(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::TextureBlit *result;
    result = (cc::gfx::TextureBlit *)new cc::gfx::TextureBlit();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_TextureBlit, __jsb_cc_gfx_TextureBlit_class, js_delete_cc_gfx_TextureBlit)

static bool js_delete_cc_gfx_TextureBlit(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_TextureBlit) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::TextureBlit * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::TextureBlit*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("srcSubres", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->srcSubres), ctx);
    }
    
    
    json->getProperty("srcOffset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->srcOffset), ctx);
    }
    
    
    json->getProperty("srcExtent", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->srcExtent), ctx);
    }
    
    
    json->getProperty("dstSubres", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dstSubres), ctx);
    }
    
    
    json->getProperty("dstOffset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dstOffset), ctx);
    }
    
    
    json->getProperty("dstExtent", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dstExtent), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_TextureBlit(se::Object* obj) {
    auto* cls = se::Class::create("TextureBlit", obj, nullptr, _SE(js_new_cc_gfx_TextureBlit)); 
    
    cls->defineProperty("srcSubres", _SE(js_cc_gfx_TextureBlit_srcSubres_get), _SE(js_cc_gfx_TextureBlit_srcSubres_set)); 
    cls->defineProperty("srcOffset", _SE(js_cc_gfx_TextureBlit_srcOffset_get), _SE(js_cc_gfx_TextureBlit_srcOffset_set)); 
    cls->defineProperty("srcExtent", _SE(js_cc_gfx_TextureBlit_srcExtent_get), _SE(js_cc_gfx_TextureBlit_srcExtent_set)); 
    cls->defineProperty("dstSubres", _SE(js_cc_gfx_TextureBlit_dstSubres_get), _SE(js_cc_gfx_TextureBlit_dstSubres_set)); 
    cls->defineProperty("dstOffset", _SE(js_cc_gfx_TextureBlit_dstOffset_get), _SE(js_cc_gfx_TextureBlit_dstOffset_set)); 
    cls->defineProperty("dstExtent", _SE(js_cc_gfx_TextureBlit_dstExtent_get), _SE(js_cc_gfx_TextureBlit_dstExtent_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_TextureBlit_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_TextureBlit));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::TextureBlit>(cls);
    
    __jsb_cc_gfx_TextureBlit_proto = cls->getProto();
    __jsb_cc_gfx_TextureBlit_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_BufferTextureCopy_class = nullptr;
se::Object* __jsb_cc_gfx_BufferTextureCopy_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_BufferTextureCopy) 

static bool js_cc_gfx_BufferTextureCopy_buffOffset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferTextureCopy *arg1 = (cc::gfx::BufferTextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferTextureCopy>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->buffOffset, s.thisObject());
    SE_PRECONDITION2(ok, false, "BufferTextureCopy_buffOffset_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferTextureCopy_buffOffset_set) 

static bool js_cc_gfx_BufferTextureCopy_buffOffset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferTextureCopy *arg1 = (cc::gfx::BufferTextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferTextureCopy>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->buffOffset, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BufferTextureCopy_buffOffset_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->buffOffset, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferTextureCopy_buffOffset_get) 

static bool js_cc_gfx_BufferTextureCopy_buffStride_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferTextureCopy *arg1 = (cc::gfx::BufferTextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferTextureCopy>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->buffStride, s.thisObject());
    SE_PRECONDITION2(ok, false, "BufferTextureCopy_buffStride_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferTextureCopy_buffStride_set) 

static bool js_cc_gfx_BufferTextureCopy_buffStride_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferTextureCopy *arg1 = (cc::gfx::BufferTextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferTextureCopy>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->buffStride, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BufferTextureCopy_buffStride_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->buffStride, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferTextureCopy_buffStride_get) 

static bool js_cc_gfx_BufferTextureCopy_buffTexHeight_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferTextureCopy *arg1 = (cc::gfx::BufferTextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferTextureCopy>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->buffTexHeight, s.thisObject());
    SE_PRECONDITION2(ok, false, "BufferTextureCopy_buffTexHeight_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferTextureCopy_buffTexHeight_set) 

static bool js_cc_gfx_BufferTextureCopy_buffTexHeight_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferTextureCopy *arg1 = (cc::gfx::BufferTextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferTextureCopy>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->buffTexHeight, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BufferTextureCopy_buffTexHeight_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->buffTexHeight, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferTextureCopy_buffTexHeight_get) 

static bool js_cc_gfx_BufferTextureCopy_texOffset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferTextureCopy *arg1 = (cc::gfx::BufferTextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferTextureCopy>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->texOffset, s.thisObject());
    SE_PRECONDITION2(ok, false, "BufferTextureCopy_texOffset_set,2,SWIGTYPE_cc__gfx__Offset"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferTextureCopy_texOffset_set) 

static bool js_cc_gfx_BufferTextureCopy_texOffset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferTextureCopy *arg1 = (cc::gfx::BufferTextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferTextureCopy>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->texOffset, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BufferTextureCopy_texOffset_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->texOffset, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferTextureCopy_texOffset_get) 

static bool js_cc_gfx_BufferTextureCopy_texExtent_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferTextureCopy *arg1 = (cc::gfx::BufferTextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferTextureCopy>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->texExtent, s.thisObject());
    SE_PRECONDITION2(ok, false, "BufferTextureCopy_texExtent_set,2,SWIGTYPE_cc__gfx__Extent"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferTextureCopy_texExtent_set) 

static bool js_cc_gfx_BufferTextureCopy_texExtent_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferTextureCopy *arg1 = (cc::gfx::BufferTextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferTextureCopy>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->texExtent, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BufferTextureCopy_texExtent_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->texExtent, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferTextureCopy_texExtent_get) 

static bool js_cc_gfx_BufferTextureCopy_texSubres_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferTextureCopy *arg1 = (cc::gfx::BufferTextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferTextureCopy>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->texSubres, s.thisObject());
    SE_PRECONDITION2(ok, false, "BufferTextureCopy_texSubres_set,2,SWIGTYPE_cc__gfx__TextureSubresLayers"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferTextureCopy_texSubres_set) 

static bool js_cc_gfx_BufferTextureCopy_texSubres_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferTextureCopy *arg1 = (cc::gfx::BufferTextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferTextureCopy>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->texSubres, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BufferTextureCopy_texSubres_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->texSubres, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferTextureCopy_texSubres_get) 

static bool js_cc_gfx_BufferTextureCopy_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferTextureCopy *arg1 = (cc::gfx::BufferTextureCopy *) NULL ;
    cc::gfx::BufferTextureCopy *arg2 = 0 ;
    cc::gfx::BufferTextureCopy temp2 ;
    cc::gfx::BufferTextureCopy *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferTextureCopy>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BufferTextureCopy_copy,2,SWIGTYPE_p_cc__gfx__BufferTextureCopy");
    arg2 = &temp2;
    
    result = (cc::gfx::BufferTextureCopy *) &(arg1)->copy((cc::gfx::BufferTextureCopy const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BufferTextureCopy_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BufferTextureCopy_copy) 

// js_ctor
static bool js_new_cc_gfx_BufferTextureCopy(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::BufferTextureCopy *result;
    result = (cc::gfx::BufferTextureCopy *)new cc::gfx::BufferTextureCopy();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_BufferTextureCopy, __jsb_cc_gfx_BufferTextureCopy_class, js_delete_cc_gfx_BufferTextureCopy)

static bool js_delete_cc_gfx_BufferTextureCopy(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_BufferTextureCopy) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::BufferTextureCopy * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::BufferTextureCopy*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("buffOffset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->buffOffset), ctx);
    }
    
    
    json->getProperty("buffStride", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->buffStride), ctx);
    }
    
    
    json->getProperty("buffTexHeight", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->buffTexHeight), ctx);
    }
    
    
    json->getProperty("texOffset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->texOffset), ctx);
    }
    
    
    json->getProperty("texExtent", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->texExtent), ctx);
    }
    
    
    json->getProperty("texSubres", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->texSubres), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_BufferTextureCopy(se::Object* obj) {
    auto* cls = se::Class::create("BufferTextureCopy", obj, nullptr, _SE(js_new_cc_gfx_BufferTextureCopy)); 
    
    cls->defineProperty("buffOffset", _SE(js_cc_gfx_BufferTextureCopy_buffOffset_get), _SE(js_cc_gfx_BufferTextureCopy_buffOffset_set)); 
    cls->defineProperty("buffStride", _SE(js_cc_gfx_BufferTextureCopy_buffStride_get), _SE(js_cc_gfx_BufferTextureCopy_buffStride_set)); 
    cls->defineProperty("buffTexHeight", _SE(js_cc_gfx_BufferTextureCopy_buffTexHeight_get), _SE(js_cc_gfx_BufferTextureCopy_buffTexHeight_set)); 
    cls->defineProperty("texOffset", _SE(js_cc_gfx_BufferTextureCopy_texOffset_get), _SE(js_cc_gfx_BufferTextureCopy_texOffset_set)); 
    cls->defineProperty("texExtent", _SE(js_cc_gfx_BufferTextureCopy_texExtent_get), _SE(js_cc_gfx_BufferTextureCopy_texExtent_set)); 
    cls->defineProperty("texSubres", _SE(js_cc_gfx_BufferTextureCopy_texSubres_get), _SE(js_cc_gfx_BufferTextureCopy_texSubres_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_BufferTextureCopy_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_BufferTextureCopy));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::BufferTextureCopy>(cls);
    
    __jsb_cc_gfx_BufferTextureCopy_proto = cls->getProto();
    __jsb_cc_gfx_BufferTextureCopy_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Viewport_class = nullptr;
se::Object* __jsb_cc_gfx_Viewport_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Viewport) 

static bool js_cc_gfx_Viewport_left_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Viewport *arg1 = (cc::gfx::Viewport *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Viewport>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->left, s.thisObject());
    SE_PRECONDITION2(ok, false, "Viewport_left_set,2,SWIGTYPE_int32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Viewport_left_set) 

static bool js_cc_gfx_Viewport_left_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Viewport *arg1 = (cc::gfx::Viewport *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Viewport>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->left, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Viewport_left_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->left, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Viewport_left_get) 

static bool js_cc_gfx_Viewport_top_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Viewport *arg1 = (cc::gfx::Viewport *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Viewport>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->top, s.thisObject());
    SE_PRECONDITION2(ok, false, "Viewport_top_set,2,SWIGTYPE_int32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Viewport_top_set) 

static bool js_cc_gfx_Viewport_top_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Viewport *arg1 = (cc::gfx::Viewport *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Viewport>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->top, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Viewport_top_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->top, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Viewport_top_get) 

static bool js_cc_gfx_Viewport_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Viewport *arg1 = (cc::gfx::Viewport *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Viewport>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->width, s.thisObject());
    SE_PRECONDITION2(ok, false, "Viewport_width_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Viewport_width_set) 

static bool js_cc_gfx_Viewport_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Viewport *arg1 = (cc::gfx::Viewport *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Viewport>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->width, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Viewport_width_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->width, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Viewport_width_get) 

static bool js_cc_gfx_Viewport_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Viewport *arg1 = (cc::gfx::Viewport *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Viewport>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->height, s.thisObject());
    SE_PRECONDITION2(ok, false, "Viewport_height_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Viewport_height_set) 

static bool js_cc_gfx_Viewport_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Viewport *arg1 = (cc::gfx::Viewport *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Viewport>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->height, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Viewport_height_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->height, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Viewport_height_get) 

static bool js_cc_gfx_Viewport_minDepth_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Viewport *arg1 = (cc::gfx::Viewport *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Viewport>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->minDepth, nullptr);
    SE_PRECONDITION2(ok, false, "Viewport_minDepth_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Viewport_minDepth_set) 

static bool js_cc_gfx_Viewport_minDepth_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Viewport *arg1 = (cc::gfx::Viewport *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Viewport>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->minDepth, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Viewport_minDepth_get) 

static bool js_cc_gfx_Viewport_maxDepth_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Viewport *arg1 = (cc::gfx::Viewport *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Viewport>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->maxDepth, nullptr);
    SE_PRECONDITION2(ok, false, "Viewport_maxDepth_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Viewport_maxDepth_set) 

static bool js_cc_gfx_Viewport_maxDepth_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Viewport *arg1 = (cc::gfx::Viewport *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Viewport>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->maxDepth, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Viewport_maxDepth_get) 

static bool js_cc_gfx_Viewport_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Viewport *arg1 = (cc::gfx::Viewport *) NULL ;
    cc::gfx::Viewport *arg2 = 0 ;
    cc::gfx::Viewport temp2 ;
    cc::gfx::Viewport *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Viewport>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Viewport_copy,2,SWIGTYPE_p_cc__gfx__Viewport");
    arg2 = &temp2;
    
    result = (cc::gfx::Viewport *) &(arg1)->copy((cc::gfx::Viewport const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Viewport_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Viewport_copy) 

// js_ctor
static bool js_new_cc_gfx_Viewport(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::Viewport *result;
    result = (cc::gfx::Viewport *)new cc::gfx::Viewport();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_Viewport, __jsb_cc_gfx_Viewport_class, js_delete_cc_gfx_Viewport)

static bool js_delete_cc_gfx_Viewport(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Viewport) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::Viewport * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::Viewport*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("left", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->left), ctx);
    }
    
    
    json->getProperty("top", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->top), ctx);
    }
    
    
    json->getProperty("width", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->width), ctx);
    }
    
    
    json->getProperty("height", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->height), ctx);
    }
    
    
    json->getProperty("minDepth", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->minDepth), ctx);
    }
    
    
    json->getProperty("maxDepth", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxDepth), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_Viewport(se::Object* obj) {
    auto* cls = se::Class::create("Viewport", obj, nullptr, _SE(js_new_cc_gfx_Viewport)); 
    
    cls->defineProperty("left", _SE(js_cc_gfx_Viewport_left_get), _SE(js_cc_gfx_Viewport_left_set)); 
    cls->defineProperty("top", _SE(js_cc_gfx_Viewport_top_get), _SE(js_cc_gfx_Viewport_top_set)); 
    cls->defineProperty("width", _SE(js_cc_gfx_Viewport_width_get), _SE(js_cc_gfx_Viewport_width_set)); 
    cls->defineProperty("height", _SE(js_cc_gfx_Viewport_height_get), _SE(js_cc_gfx_Viewport_height_set)); 
    cls->defineProperty("minDepth", _SE(js_cc_gfx_Viewport_minDepth_get), _SE(js_cc_gfx_Viewport_minDepth_set)); 
    cls->defineProperty("maxDepth", _SE(js_cc_gfx_Viewport_maxDepth_get), _SE(js_cc_gfx_Viewport_maxDepth_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_Viewport_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Viewport));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Viewport>(cls);
    
    __jsb_cc_gfx_Viewport_proto = cls->getProto();
    __jsb_cc_gfx_Viewport_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Color_class = nullptr;
se::Object* __jsb_cc_gfx_Color_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Color) 

static bool js_cc_gfx_Color_x_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Color *arg1 = (cc::gfx::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->x, nullptr);
    SE_PRECONDITION2(ok, false, "Color_x_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Color_x_set) 

static bool js_cc_gfx_Color_x_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Color *arg1 = (cc::gfx::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->x, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Color_x_get) 

static bool js_cc_gfx_Color_y_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Color *arg1 = (cc::gfx::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->y, nullptr);
    SE_PRECONDITION2(ok, false, "Color_y_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Color_y_set) 

static bool js_cc_gfx_Color_y_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Color *arg1 = (cc::gfx::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->y, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Color_y_get) 

static bool js_cc_gfx_Color_z_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Color *arg1 = (cc::gfx::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->z, nullptr);
    SE_PRECONDITION2(ok, false, "Color_z_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Color_z_set) 

static bool js_cc_gfx_Color_z_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Color *arg1 = (cc::gfx::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->z, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Color_z_get) 

static bool js_cc_gfx_Color_w_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Color *arg1 = (cc::gfx::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->w, nullptr);
    SE_PRECONDITION2(ok, false, "Color_w_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Color_w_set) 

static bool js_cc_gfx_Color_w_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Color *arg1 = (cc::gfx::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->w, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Color_w_get) 

static bool js_cc_gfx_Color_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Color *arg1 = (cc::gfx::Color *) NULL ;
    cc::gfx::Color *arg2 = 0 ;
    cc::gfx::Color temp2 ;
    cc::gfx::Color *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Color_copy,2,SWIGTYPE_p_cc__gfx__Color");
    arg2 = &temp2;
    
    result = (cc::gfx::Color *) &(arg1)->copy((cc::gfx::Color const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Color_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Color_copy) 

// js_ctor
static bool js_new_cc_gfx_Color(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::Color *result;
    result = (cc::gfx::Color *)new cc::gfx::Color();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_Color, __jsb_cc_gfx_Color_class, js_delete_cc_gfx_Color)

static bool js_delete_cc_gfx_Color(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Color) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::Color * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::Color*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("x", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->x), ctx);
    }
    
    
    json->getProperty("y", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->y), ctx);
    }
    
    
    json->getProperty("z", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->z), ctx);
    }
    
    
    json->getProperty("w", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->w), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_Color(se::Object* obj) {
    auto* cls = se::Class::create("Color", obj, nullptr, _SE(js_new_cc_gfx_Color)); 
    
    cls->defineProperty("x", _SE(js_cc_gfx_Color_x_get), _SE(js_cc_gfx_Color_x_set)); 
    cls->defineProperty("y", _SE(js_cc_gfx_Color_y_get), _SE(js_cc_gfx_Color_y_set)); 
    cls->defineProperty("z", _SE(js_cc_gfx_Color_z_get), _SE(js_cc_gfx_Color_z_set)); 
    cls->defineProperty("w", _SE(js_cc_gfx_Color_w_get), _SE(js_cc_gfx_Color_w_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_Color_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Color));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Color>(cls);
    
    __jsb_cc_gfx_Color_proto = cls->getProto();
    __jsb_cc_gfx_Color_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_BindingMappingInfo_class = nullptr;
se::Object* __jsb_cc_gfx_BindingMappingInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_BindingMappingInfo) 

static bool js_cc_gfx_BindingMappingInfo_maxBlockCounts_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxBlockCounts, s.thisObject());
    SE_PRECONDITION2(ok, false, "BindingMappingInfo_maxBlockCounts_set,2,SWIGTYPE_ccstd__vectorT_uint32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BindingMappingInfo_maxBlockCounts_set) 

static bool js_cc_gfx_BindingMappingInfo_maxBlockCounts_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxBlockCounts, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BindingMappingInfo_maxBlockCounts_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxBlockCounts, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BindingMappingInfo_maxBlockCounts_get) 

static bool js_cc_gfx_BindingMappingInfo_maxSamplerTextureCounts_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxSamplerTextureCounts, s.thisObject());
    SE_PRECONDITION2(ok, false, "BindingMappingInfo_maxSamplerTextureCounts_set,2,SWIGTYPE_ccstd__vectorT_uint32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BindingMappingInfo_maxSamplerTextureCounts_set) 

static bool js_cc_gfx_BindingMappingInfo_maxSamplerTextureCounts_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxSamplerTextureCounts, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BindingMappingInfo_maxSamplerTextureCounts_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxSamplerTextureCounts, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BindingMappingInfo_maxSamplerTextureCounts_get) 

static bool js_cc_gfx_BindingMappingInfo_maxSamplerCounts_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxSamplerCounts, s.thisObject());
    SE_PRECONDITION2(ok, false, "BindingMappingInfo_maxSamplerCounts_set,2,SWIGTYPE_ccstd__vectorT_uint32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BindingMappingInfo_maxSamplerCounts_set) 

static bool js_cc_gfx_BindingMappingInfo_maxSamplerCounts_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxSamplerCounts, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BindingMappingInfo_maxSamplerCounts_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxSamplerCounts, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BindingMappingInfo_maxSamplerCounts_get) 

static bool js_cc_gfx_BindingMappingInfo_maxTextureCounts_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxTextureCounts, s.thisObject());
    SE_PRECONDITION2(ok, false, "BindingMappingInfo_maxTextureCounts_set,2,SWIGTYPE_ccstd__vectorT_uint32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BindingMappingInfo_maxTextureCounts_set) 

static bool js_cc_gfx_BindingMappingInfo_maxTextureCounts_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxTextureCounts, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BindingMappingInfo_maxTextureCounts_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxTextureCounts, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BindingMappingInfo_maxTextureCounts_get) 

static bool js_cc_gfx_BindingMappingInfo_maxBufferCounts_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxBufferCounts, s.thisObject());
    SE_PRECONDITION2(ok, false, "BindingMappingInfo_maxBufferCounts_set,2,SWIGTYPE_ccstd__vectorT_uint32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BindingMappingInfo_maxBufferCounts_set) 

static bool js_cc_gfx_BindingMappingInfo_maxBufferCounts_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxBufferCounts, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BindingMappingInfo_maxBufferCounts_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxBufferCounts, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BindingMappingInfo_maxBufferCounts_get) 

static bool js_cc_gfx_BindingMappingInfo_maxImageCounts_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxImageCounts, s.thisObject());
    SE_PRECONDITION2(ok, false, "BindingMappingInfo_maxImageCounts_set,2,SWIGTYPE_ccstd__vectorT_uint32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BindingMappingInfo_maxImageCounts_set) 

static bool js_cc_gfx_BindingMappingInfo_maxImageCounts_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxImageCounts, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BindingMappingInfo_maxImageCounts_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxImageCounts, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BindingMappingInfo_maxImageCounts_get) 

static bool js_cc_gfx_BindingMappingInfo_maxSubpassInputCounts_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxSubpassInputCounts, s.thisObject());
    SE_PRECONDITION2(ok, false, "BindingMappingInfo_maxSubpassInputCounts_set,2,SWIGTYPE_ccstd__vectorT_uint32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BindingMappingInfo_maxSubpassInputCounts_set) 

static bool js_cc_gfx_BindingMappingInfo_maxSubpassInputCounts_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxSubpassInputCounts, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BindingMappingInfo_maxSubpassInputCounts_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxSubpassInputCounts, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BindingMappingInfo_maxSubpassInputCounts_get) 

static bool js_cc_gfx_BindingMappingInfo_setIndices_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->setIndices, s.thisObject());
    SE_PRECONDITION2(ok, false, "BindingMappingInfo_setIndices_set,2,SWIGTYPE_ccstd__vectorT_uint32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BindingMappingInfo_setIndices_set) 

static bool js_cc_gfx_BindingMappingInfo_setIndices_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->setIndices, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BindingMappingInfo_setIndices_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->setIndices, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BindingMappingInfo_setIndices_get) 

static bool js_cc_gfx_BindingMappingInfo_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    cc::gfx::BindingMappingInfo *arg2 = 0 ;
    cc::gfx::BindingMappingInfo temp2 ;
    cc::gfx::BindingMappingInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BindingMappingInfo_copy,2,SWIGTYPE_p_cc__gfx__BindingMappingInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::BindingMappingInfo *) &(arg1)->copy((cc::gfx::BindingMappingInfo const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BindingMappingInfo_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BindingMappingInfo_copy) 

// js_ctor
static bool js_new_cc_gfx_BindingMappingInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::BindingMappingInfo *result;
    result = (cc::gfx::BindingMappingInfo *)new cc::gfx::BindingMappingInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_BindingMappingInfo, __jsb_cc_gfx_BindingMappingInfo_class, js_delete_cc_gfx_BindingMappingInfo)

static bool js_delete_cc_gfx_BindingMappingInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_BindingMappingInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::BindingMappingInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::BindingMappingInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("maxBlockCounts", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxBlockCounts), ctx);
    }
    
    
    json->getProperty("maxSamplerTextureCounts", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxSamplerTextureCounts), ctx);
    }
    
    
    json->getProperty("maxSamplerCounts", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxSamplerCounts), ctx);
    }
    
    
    json->getProperty("maxTextureCounts", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxTextureCounts), ctx);
    }
    
    
    json->getProperty("maxBufferCounts", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxBufferCounts), ctx);
    }
    
    
    json->getProperty("maxImageCounts", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxImageCounts), ctx);
    }
    
    
    json->getProperty("maxSubpassInputCounts", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxSubpassInputCounts), ctx);
    }
    
    
    json->getProperty("setIndices", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->setIndices), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_BindingMappingInfo(se::Object* obj) {
    auto* cls = se::Class::create("BindingMappingInfo", obj, nullptr, _SE(js_new_cc_gfx_BindingMappingInfo)); 
    
    cls->defineProperty("maxBlockCounts", _SE(js_cc_gfx_BindingMappingInfo_maxBlockCounts_get), _SE(js_cc_gfx_BindingMappingInfo_maxBlockCounts_set)); 
    cls->defineProperty("maxSamplerTextureCounts", _SE(js_cc_gfx_BindingMappingInfo_maxSamplerTextureCounts_get), _SE(js_cc_gfx_BindingMappingInfo_maxSamplerTextureCounts_set)); 
    cls->defineProperty("maxSamplerCounts", _SE(js_cc_gfx_BindingMappingInfo_maxSamplerCounts_get), _SE(js_cc_gfx_BindingMappingInfo_maxSamplerCounts_set)); 
    cls->defineProperty("maxTextureCounts", _SE(js_cc_gfx_BindingMappingInfo_maxTextureCounts_get), _SE(js_cc_gfx_BindingMappingInfo_maxTextureCounts_set)); 
    cls->defineProperty("maxBufferCounts", _SE(js_cc_gfx_BindingMappingInfo_maxBufferCounts_get), _SE(js_cc_gfx_BindingMappingInfo_maxBufferCounts_set)); 
    cls->defineProperty("maxImageCounts", _SE(js_cc_gfx_BindingMappingInfo_maxImageCounts_get), _SE(js_cc_gfx_BindingMappingInfo_maxImageCounts_set)); 
    cls->defineProperty("maxSubpassInputCounts", _SE(js_cc_gfx_BindingMappingInfo_maxSubpassInputCounts_get), _SE(js_cc_gfx_BindingMappingInfo_maxSubpassInputCounts_set)); 
    cls->defineProperty("setIndices", _SE(js_cc_gfx_BindingMappingInfo_setIndices_get), _SE(js_cc_gfx_BindingMappingInfo_setIndices_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_BindingMappingInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_BindingMappingInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::BindingMappingInfo>(cls);
    
    __jsb_cc_gfx_BindingMappingInfo_proto = cls->getProto();
    __jsb_cc_gfx_BindingMappingInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_SwapchainInfo_class = nullptr;
se::Object* __jsb_cc_gfx_SwapchainInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_SwapchainInfo) 

static bool js_cc_gfx_SwapchainInfo_windowHandle_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SwapchainInfo *arg1 = (cc::gfx::SwapchainInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SwapchainInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    ok &= sevalue_to_native(args[0], &arg1->windowHandle);
    SE_PRECONDITION2(ok, false, "SwapchainInfo_windowHandle_set,2,SWIGTYPE_p_void");
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SwapchainInfo_windowHandle_set) 

static bool js_cc_gfx_SwapchainInfo_windowHandle_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SwapchainInfo *arg1 = (cc::gfx::SwapchainInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SwapchainInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->windowHandle, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SwapchainInfo_windowHandle_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->windowHandle, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SwapchainInfo_windowHandle_get) 

static bool js_cc_gfx_SwapchainInfo_vsyncMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SwapchainInfo *arg1 = (cc::gfx::SwapchainInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SwapchainInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "SwapchainInfo_vsyncMode_set,2,SWIGTYPE_cc__gfx__VsyncMode");
    arg1->vsyncMode = (cc::gfx::VsyncMode)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SwapchainInfo_vsyncMode_set) 

static bool js_cc_gfx_SwapchainInfo_vsyncMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SwapchainInfo *arg1 = (cc::gfx::SwapchainInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SwapchainInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->vsyncMode));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SwapchainInfo_vsyncMode_get) 

static bool js_cc_gfx_SwapchainInfo_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SwapchainInfo *arg1 = (cc::gfx::SwapchainInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SwapchainInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->width, s.thisObject());
    SE_PRECONDITION2(ok, false, "SwapchainInfo_width_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SwapchainInfo_width_set) 

static bool js_cc_gfx_SwapchainInfo_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SwapchainInfo *arg1 = (cc::gfx::SwapchainInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SwapchainInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->width, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SwapchainInfo_width_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->width, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SwapchainInfo_width_get) 

static bool js_cc_gfx_SwapchainInfo_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SwapchainInfo *arg1 = (cc::gfx::SwapchainInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SwapchainInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->height, s.thisObject());
    SE_PRECONDITION2(ok, false, "SwapchainInfo_height_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SwapchainInfo_height_set) 

static bool js_cc_gfx_SwapchainInfo_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SwapchainInfo *arg1 = (cc::gfx::SwapchainInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SwapchainInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->height, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SwapchainInfo_height_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->height, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SwapchainInfo_height_get) 

static bool js_cc_gfx_SwapchainInfo_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SwapchainInfo *arg1 = (cc::gfx::SwapchainInfo *) NULL ;
    cc::gfx::SwapchainInfo *arg2 = 0 ;
    cc::gfx::SwapchainInfo temp2 ;
    cc::gfx::SwapchainInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::SwapchainInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SwapchainInfo_copy,2,SWIGTYPE_p_cc__gfx__SwapchainInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::SwapchainInfo *) &(arg1)->copy((cc::gfx::SwapchainInfo const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SwapchainInfo_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_SwapchainInfo_copy) 

// js_ctor
static bool js_new_cc_gfx_SwapchainInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::SwapchainInfo *result;
    result = (cc::gfx::SwapchainInfo *)new cc::gfx::SwapchainInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_SwapchainInfo, __jsb_cc_gfx_SwapchainInfo_class, js_delete_cc_gfx_SwapchainInfo)

static bool js_delete_cc_gfx_SwapchainInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_SwapchainInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::SwapchainInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::SwapchainInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("windowHandle", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->windowHandle), ctx);
    }
    
    
    json->getProperty("vsyncMode", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->vsyncMode), ctx);
    }
    
    
    json->getProperty("width", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->width), ctx);
    }
    
    
    json->getProperty("height", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->height), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_SwapchainInfo(se::Object* obj) {
    auto* cls = se::Class::create("SwapchainInfo", obj, nullptr, _SE(js_new_cc_gfx_SwapchainInfo)); 
    
    cls->defineProperty("windowHandle", _SE(js_cc_gfx_SwapchainInfo_windowHandle_get), _SE(js_cc_gfx_SwapchainInfo_windowHandle_set)); 
    cls->defineProperty("vsyncMode", _SE(js_cc_gfx_SwapchainInfo_vsyncMode_get), _SE(js_cc_gfx_SwapchainInfo_vsyncMode_set)); 
    cls->defineProperty("width", _SE(js_cc_gfx_SwapchainInfo_width_get), _SE(js_cc_gfx_SwapchainInfo_width_set)); 
    cls->defineProperty("height", _SE(js_cc_gfx_SwapchainInfo_height_get), _SE(js_cc_gfx_SwapchainInfo_height_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_SwapchainInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_SwapchainInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::SwapchainInfo>(cls);
    
    __jsb_cc_gfx_SwapchainInfo_proto = cls->getProto();
    __jsb_cc_gfx_SwapchainInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DeviceInfo_class = nullptr;
se::Object* __jsb_cc_gfx_DeviceInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DeviceInfo) 

static bool js_cc_gfx_DeviceInfo_bindingMappingInfo_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceInfo *arg1 = (cc::gfx::DeviceInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->bindingMappingInfo, s.thisObject());
    SE_PRECONDITION2(ok, false, "DeviceInfo_bindingMappingInfo_set,2,SWIGTYPE_cc__gfx__BindingMappingInfo"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceInfo_bindingMappingInfo_set) 

static bool js_cc_gfx_DeviceInfo_bindingMappingInfo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceInfo *arg1 = (cc::gfx::DeviceInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->bindingMappingInfo, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeviceInfo_bindingMappingInfo_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->bindingMappingInfo, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceInfo_bindingMappingInfo_get) 

static bool js_cc_gfx_DeviceInfo_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceInfo *arg1 = (cc::gfx::DeviceInfo *) NULL ;
    cc::gfx::DeviceInfo *arg2 = 0 ;
    cc::gfx::DeviceInfo temp2 ;
    cc::gfx::DeviceInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DeviceInfo_copy,2,SWIGTYPE_p_cc__gfx__DeviceInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::DeviceInfo *) &(arg1)->copy((cc::gfx::DeviceInfo const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeviceInfo_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DeviceInfo_copy) 

// js_ctor
static bool js_new_cc_gfx_DeviceInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::DeviceInfo *result;
    result = (cc::gfx::DeviceInfo *)new cc::gfx::DeviceInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_DeviceInfo, __jsb_cc_gfx_DeviceInfo_class, js_delete_cc_gfx_DeviceInfo)

static bool js_delete_cc_gfx_DeviceInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DeviceInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::DeviceInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::DeviceInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("bindingMappingInfo", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->bindingMappingInfo), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_DeviceInfo(se::Object* obj) {
    auto* cls = se::Class::create("DeviceInfo", obj, nullptr, _SE(js_new_cc_gfx_DeviceInfo)); 
    
    cls->defineProperty("bindingMappingInfo", _SE(js_cc_gfx_DeviceInfo_bindingMappingInfo_get), _SE(js_cc_gfx_DeviceInfo_bindingMappingInfo_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_DeviceInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DeviceInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DeviceInfo>(cls);
    
    __jsb_cc_gfx_DeviceInfo_proto = cls->getProto();
    __jsb_cc_gfx_DeviceInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_BufferInfo_class = nullptr;
se::Object* __jsb_cc_gfx_BufferInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_BufferInfo) 

static bool js_cc_gfx_BufferInfo_usage_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferInfo *arg1 = (cc::gfx::BufferInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "BufferInfo_usage_set,2,SWIGTYPE_cc__gfx__BufferUsageBit");
    arg1->usage = (cc::gfx::BufferUsage)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferInfo_usage_set) 

static bool js_cc_gfx_BufferInfo_usage_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferInfo *arg1 = (cc::gfx::BufferInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->usage));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferInfo_usage_get) 

static bool js_cc_gfx_BufferInfo_memUsage_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferInfo *arg1 = (cc::gfx::BufferInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "BufferInfo_memUsage_set,2,SWIGTYPE_cc__gfx__MemoryUsageBit");
    arg1->memUsage = (cc::gfx::MemoryUsage)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferInfo_memUsage_set) 

static bool js_cc_gfx_BufferInfo_memUsage_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferInfo *arg1 = (cc::gfx::BufferInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->memUsage));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferInfo_memUsage_get) 

static bool js_cc_gfx_BufferInfo_size_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferInfo *arg1 = (cc::gfx::BufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->size, s.thisObject());
    SE_PRECONDITION2(ok, false, "BufferInfo_size_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferInfo_size_set) 

static bool js_cc_gfx_BufferInfo_size_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferInfo *arg1 = (cc::gfx::BufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->size, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BufferInfo_size_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->size, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferInfo_size_get) 

static bool js_cc_gfx_BufferInfo_stride_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferInfo *arg1 = (cc::gfx::BufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stride, s.thisObject());
    SE_PRECONDITION2(ok, false, "BufferInfo_stride_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferInfo_stride_set) 

static bool js_cc_gfx_BufferInfo_stride_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferInfo *arg1 = (cc::gfx::BufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stride, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BufferInfo_stride_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stride, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferInfo_stride_get) 

static bool js_cc_gfx_BufferInfo_flags_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferInfo *arg1 = (cc::gfx::BufferInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "BufferInfo_flags_set,2,SWIGTYPE_cc__gfx__BufferFlagBit");
    arg1->flags = (cc::gfx::BufferFlags)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferInfo_flags_set) 

static bool js_cc_gfx_BufferInfo_flags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferInfo *arg1 = (cc::gfx::BufferInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->flags));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferInfo_flags_get) 

static bool js_cc_gfx_BufferInfo_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferInfo *arg1 = (cc::gfx::BufferInfo *) NULL ;
    cc::gfx::BufferInfo *arg2 = 0 ;
    cc::gfx::BufferInfo temp2 ;
    cc::gfx::BufferInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BufferInfo_copy,2,SWIGTYPE_p_cc__gfx__BufferInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::BufferInfo *) &(arg1)->copy((cc::gfx::BufferInfo const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BufferInfo_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BufferInfo_copy) 

// js_ctor
static bool js_new_cc_gfx_BufferInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::BufferInfo *result;
    result = (cc::gfx::BufferInfo *)new cc::gfx::BufferInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_BufferInfo, __jsb_cc_gfx_BufferInfo_class, js_delete_cc_gfx_BufferInfo)

static bool js_delete_cc_gfx_BufferInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_BufferInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::BufferInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::BufferInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("usage", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->usage), ctx);
    }
    
    
    json->getProperty("memUsage", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->memUsage), ctx);
    }
    
    
    json->getProperty("size", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->size), ctx);
    }
    
    
    json->getProperty("stride", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stride), ctx);
    }
    
    
    json->getProperty("flags", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->flags), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_BufferInfo(se::Object* obj) {
    auto* cls = se::Class::create("BufferInfo", obj, nullptr, _SE(js_new_cc_gfx_BufferInfo)); 
    
    cls->defineProperty("usage", _SE(js_cc_gfx_BufferInfo_usage_get), _SE(js_cc_gfx_BufferInfo_usage_set)); 
    cls->defineProperty("memUsage", _SE(js_cc_gfx_BufferInfo_memUsage_get), _SE(js_cc_gfx_BufferInfo_memUsage_set)); 
    cls->defineProperty("size", _SE(js_cc_gfx_BufferInfo_size_get), _SE(js_cc_gfx_BufferInfo_size_set)); 
    cls->defineProperty("stride", _SE(js_cc_gfx_BufferInfo_stride_get), _SE(js_cc_gfx_BufferInfo_stride_set)); 
    cls->defineProperty("flags", _SE(js_cc_gfx_BufferInfo_flags_get), _SE(js_cc_gfx_BufferInfo_flags_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_BufferInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_BufferInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::BufferInfo>(cls);
    
    __jsb_cc_gfx_BufferInfo_proto = cls->getProto();
    __jsb_cc_gfx_BufferInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_BufferViewInfo_class = nullptr;
se::Object* __jsb_cc_gfx_BufferViewInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_BufferViewInfo) 

static bool js_cc_gfx_BufferViewInfo_buffer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferViewInfo *arg1 = (cc::gfx::BufferViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferViewInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->buffer, s.thisObject());
    SE_PRECONDITION2(ok, false, "BufferViewInfo_buffer_set,2,SWIGTYPE_p_cc__gfx__Buffer"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferViewInfo_buffer_set) 

static bool js_cc_gfx_BufferViewInfo_buffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferViewInfo *arg1 = (cc::gfx::BufferViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferViewInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->buffer, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BufferViewInfo_buffer_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->buffer, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferViewInfo_buffer_get) 

static bool js_cc_gfx_BufferViewInfo_offset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferViewInfo *arg1 = (cc::gfx::BufferViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferViewInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->offset, s.thisObject());
    SE_PRECONDITION2(ok, false, "BufferViewInfo_offset_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferViewInfo_offset_set) 

static bool js_cc_gfx_BufferViewInfo_offset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferViewInfo *arg1 = (cc::gfx::BufferViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferViewInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->offset, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BufferViewInfo_offset_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->offset, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferViewInfo_offset_get) 

static bool js_cc_gfx_BufferViewInfo_range_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferViewInfo *arg1 = (cc::gfx::BufferViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferViewInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->range, s.thisObject());
    SE_PRECONDITION2(ok, false, "BufferViewInfo_range_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferViewInfo_range_set) 

static bool js_cc_gfx_BufferViewInfo_range_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferViewInfo *arg1 = (cc::gfx::BufferViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferViewInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->range, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BufferViewInfo_range_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->range, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferViewInfo_range_get) 

static bool js_cc_gfx_BufferViewInfo_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferViewInfo *arg1 = (cc::gfx::BufferViewInfo *) NULL ;
    cc::gfx::BufferViewInfo *arg2 = 0 ;
    cc::gfx::BufferViewInfo temp2 ;
    cc::gfx::BufferViewInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferViewInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BufferViewInfo_copy,2,SWIGTYPE_p_cc__gfx__BufferViewInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::BufferViewInfo *) &(arg1)->copy((cc::gfx::BufferViewInfo const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BufferViewInfo_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BufferViewInfo_copy) 

// js_ctor
static bool js_new_cc_gfx_BufferViewInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::BufferViewInfo *result;
    result = (cc::gfx::BufferViewInfo *)new cc::gfx::BufferViewInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_BufferViewInfo, __jsb_cc_gfx_BufferViewInfo_class, js_delete_cc_gfx_BufferViewInfo)

static bool js_delete_cc_gfx_BufferViewInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_BufferViewInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::BufferViewInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::BufferViewInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("buffer", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->buffer), ctx);
    }
    
    
    json->getProperty("offset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->offset), ctx);
    }
    
    
    json->getProperty("range", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->range), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_BufferViewInfo(se::Object* obj) {
    auto* cls = se::Class::create("BufferViewInfo", obj, nullptr, _SE(js_new_cc_gfx_BufferViewInfo)); 
    
    cls->defineProperty("buffer", _SE(js_cc_gfx_BufferViewInfo_buffer_get), _SE(js_cc_gfx_BufferViewInfo_buffer_set)); 
    cls->defineProperty("offset", _SE(js_cc_gfx_BufferViewInfo_offset_get), _SE(js_cc_gfx_BufferViewInfo_offset_set)); 
    cls->defineProperty("range", _SE(js_cc_gfx_BufferViewInfo_range_get), _SE(js_cc_gfx_BufferViewInfo_range_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_BufferViewInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_BufferViewInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::BufferViewInfo>(cls);
    
    __jsb_cc_gfx_BufferViewInfo_proto = cls->getProto();
    __jsb_cc_gfx_BufferViewInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DrawInfo_class = nullptr;
se::Object* __jsb_cc_gfx_DrawInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DrawInfo) 

static bool js_cc_gfx_DrawInfo_vertexCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->vertexCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "DrawInfo_vertexCount_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DrawInfo_vertexCount_set) 

static bool js_cc_gfx_DrawInfo_vertexCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->vertexCount, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DrawInfo_vertexCount_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->vertexCount, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DrawInfo_vertexCount_get) 

static bool js_cc_gfx_DrawInfo_firstVertex_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->firstVertex, s.thisObject());
    SE_PRECONDITION2(ok, false, "DrawInfo_firstVertex_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DrawInfo_firstVertex_set) 

static bool js_cc_gfx_DrawInfo_firstVertex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->firstVertex, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DrawInfo_firstVertex_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->firstVertex, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DrawInfo_firstVertex_get) 

static bool js_cc_gfx_DrawInfo_indexCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->indexCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "DrawInfo_indexCount_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DrawInfo_indexCount_set) 

static bool js_cc_gfx_DrawInfo_indexCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->indexCount, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DrawInfo_indexCount_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->indexCount, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DrawInfo_indexCount_get) 

static bool js_cc_gfx_DrawInfo_firstIndex_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->firstIndex, s.thisObject());
    SE_PRECONDITION2(ok, false, "DrawInfo_firstIndex_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DrawInfo_firstIndex_set) 

static bool js_cc_gfx_DrawInfo_firstIndex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->firstIndex, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DrawInfo_firstIndex_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->firstIndex, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DrawInfo_firstIndex_get) 

static bool js_cc_gfx_DrawInfo_vertexOffset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->vertexOffset, s.thisObject());
    SE_PRECONDITION2(ok, false, "DrawInfo_vertexOffset_set,2,SWIGTYPE_int32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DrawInfo_vertexOffset_set) 

static bool js_cc_gfx_DrawInfo_vertexOffset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->vertexOffset, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DrawInfo_vertexOffset_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->vertexOffset, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DrawInfo_vertexOffset_get) 

static bool js_cc_gfx_DrawInfo_instanceCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->instanceCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "DrawInfo_instanceCount_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DrawInfo_instanceCount_set) 

static bool js_cc_gfx_DrawInfo_instanceCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->instanceCount, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DrawInfo_instanceCount_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->instanceCount, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DrawInfo_instanceCount_get) 

static bool js_cc_gfx_DrawInfo_firstInstance_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->firstInstance, s.thisObject());
    SE_PRECONDITION2(ok, false, "DrawInfo_firstInstance_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DrawInfo_firstInstance_set) 

static bool js_cc_gfx_DrawInfo_firstInstance_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->firstInstance, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DrawInfo_firstInstance_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->firstInstance, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DrawInfo_firstInstance_get) 

static bool js_cc_gfx_DrawInfo_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    cc::gfx::DrawInfo *arg2 = 0 ;
    cc::gfx::DrawInfo temp2 ;
    cc::gfx::DrawInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DrawInfo_copy,2,SWIGTYPE_p_cc__gfx__DrawInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::DrawInfo *) &(arg1)->copy((cc::gfx::DrawInfo const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DrawInfo_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DrawInfo_copy) 

// js_ctor
static bool js_new_cc_gfx_DrawInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::DrawInfo *result;
    result = (cc::gfx::DrawInfo *)new cc::gfx::DrawInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_DrawInfo, __jsb_cc_gfx_DrawInfo_class, js_delete_cc_gfx_DrawInfo)

static bool js_delete_cc_gfx_DrawInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DrawInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::DrawInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::DrawInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("vertexCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->vertexCount), ctx);
    }
    
    
    json->getProperty("firstVertex", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->firstVertex), ctx);
    }
    
    
    json->getProperty("indexCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->indexCount), ctx);
    }
    
    
    json->getProperty("firstIndex", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->firstIndex), ctx);
    }
    
    
    json->getProperty("vertexOffset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->vertexOffset), ctx);
    }
    
    
    json->getProperty("instanceCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->instanceCount), ctx);
    }
    
    
    json->getProperty("firstInstance", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->firstInstance), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_DrawInfo(se::Object* obj) {
    auto* cls = se::Class::create("DrawInfo", obj, nullptr, _SE(js_new_cc_gfx_DrawInfo)); 
    
    cls->defineProperty("vertexCount", _SE(js_cc_gfx_DrawInfo_vertexCount_get), _SE(js_cc_gfx_DrawInfo_vertexCount_set)); 
    cls->defineProperty("firstVertex", _SE(js_cc_gfx_DrawInfo_firstVertex_get), _SE(js_cc_gfx_DrawInfo_firstVertex_set)); 
    cls->defineProperty("indexCount", _SE(js_cc_gfx_DrawInfo_indexCount_get), _SE(js_cc_gfx_DrawInfo_indexCount_set)); 
    cls->defineProperty("firstIndex", _SE(js_cc_gfx_DrawInfo_firstIndex_get), _SE(js_cc_gfx_DrawInfo_firstIndex_set)); 
    cls->defineProperty("vertexOffset", _SE(js_cc_gfx_DrawInfo_vertexOffset_get), _SE(js_cc_gfx_DrawInfo_vertexOffset_set)); 
    cls->defineProperty("instanceCount", _SE(js_cc_gfx_DrawInfo_instanceCount_get), _SE(js_cc_gfx_DrawInfo_instanceCount_set)); 
    cls->defineProperty("firstInstance", _SE(js_cc_gfx_DrawInfo_firstInstance_get), _SE(js_cc_gfx_DrawInfo_firstInstance_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_DrawInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DrawInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DrawInfo>(cls);
    
    __jsb_cc_gfx_DrawInfo_proto = cls->getProto();
    __jsb_cc_gfx_DrawInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DispatchInfo_class = nullptr;
se::Object* __jsb_cc_gfx_DispatchInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DispatchInfo) 

static bool js_cc_gfx_DispatchInfo_groupCountX_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DispatchInfo *arg1 = (cc::gfx::DispatchInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DispatchInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->groupCountX, s.thisObject());
    SE_PRECONDITION2(ok, false, "DispatchInfo_groupCountX_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DispatchInfo_groupCountX_set) 

static bool js_cc_gfx_DispatchInfo_groupCountX_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DispatchInfo *arg1 = (cc::gfx::DispatchInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DispatchInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->groupCountX, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DispatchInfo_groupCountX_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->groupCountX, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DispatchInfo_groupCountX_get) 

static bool js_cc_gfx_DispatchInfo_groupCountY_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DispatchInfo *arg1 = (cc::gfx::DispatchInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DispatchInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->groupCountY, s.thisObject());
    SE_PRECONDITION2(ok, false, "DispatchInfo_groupCountY_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DispatchInfo_groupCountY_set) 

static bool js_cc_gfx_DispatchInfo_groupCountY_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DispatchInfo *arg1 = (cc::gfx::DispatchInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DispatchInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->groupCountY, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DispatchInfo_groupCountY_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->groupCountY, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DispatchInfo_groupCountY_get) 

static bool js_cc_gfx_DispatchInfo_groupCountZ_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DispatchInfo *arg1 = (cc::gfx::DispatchInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DispatchInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->groupCountZ, s.thisObject());
    SE_PRECONDITION2(ok, false, "DispatchInfo_groupCountZ_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DispatchInfo_groupCountZ_set) 

static bool js_cc_gfx_DispatchInfo_groupCountZ_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DispatchInfo *arg1 = (cc::gfx::DispatchInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DispatchInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->groupCountZ, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DispatchInfo_groupCountZ_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->groupCountZ, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DispatchInfo_groupCountZ_get) 

static bool js_cc_gfx_DispatchInfo_indirectBuffer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DispatchInfo *arg1 = (cc::gfx::DispatchInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DispatchInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->indirectBuffer, s.thisObject());
    SE_PRECONDITION2(ok, false, "DispatchInfo_indirectBuffer_set,2,SWIGTYPE_p_cc__gfx__Buffer"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DispatchInfo_indirectBuffer_set) 

static bool js_cc_gfx_DispatchInfo_indirectBuffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DispatchInfo *arg1 = (cc::gfx::DispatchInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DispatchInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->indirectBuffer, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DispatchInfo_indirectBuffer_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->indirectBuffer, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DispatchInfo_indirectBuffer_get) 

static bool js_cc_gfx_DispatchInfo_indirectOffset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DispatchInfo *arg1 = (cc::gfx::DispatchInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DispatchInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->indirectOffset, s.thisObject());
    SE_PRECONDITION2(ok, false, "DispatchInfo_indirectOffset_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DispatchInfo_indirectOffset_set) 

static bool js_cc_gfx_DispatchInfo_indirectOffset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DispatchInfo *arg1 = (cc::gfx::DispatchInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DispatchInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->indirectOffset, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DispatchInfo_indirectOffset_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->indirectOffset, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DispatchInfo_indirectOffset_get) 

static bool js_cc_gfx_DispatchInfo_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DispatchInfo *arg1 = (cc::gfx::DispatchInfo *) NULL ;
    cc::gfx::DispatchInfo *arg2 = 0 ;
    cc::gfx::DispatchInfo temp2 ;
    cc::gfx::DispatchInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DispatchInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DispatchInfo_copy,2,SWIGTYPE_p_cc__gfx__DispatchInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::DispatchInfo *) &(arg1)->copy((cc::gfx::DispatchInfo const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DispatchInfo_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DispatchInfo_copy) 

// js_ctor
static bool js_new_cc_gfx_DispatchInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::DispatchInfo *result;
    result = (cc::gfx::DispatchInfo *)new cc::gfx::DispatchInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_DispatchInfo, __jsb_cc_gfx_DispatchInfo_class, js_delete_cc_gfx_DispatchInfo)

static bool js_delete_cc_gfx_DispatchInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DispatchInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::DispatchInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::DispatchInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("groupCountX", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->groupCountX), ctx);
    }
    
    
    json->getProperty("groupCountY", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->groupCountY), ctx);
    }
    
    
    json->getProperty("groupCountZ", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->groupCountZ), ctx);
    }
    
    
    json->getProperty("indirectBuffer", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->indirectBuffer), ctx);
    }
    
    
    json->getProperty("indirectOffset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->indirectOffset), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_DispatchInfo(se::Object* obj) {
    auto* cls = se::Class::create("DispatchInfo", obj, nullptr, _SE(js_new_cc_gfx_DispatchInfo)); 
    
    cls->defineProperty("groupCountX", _SE(js_cc_gfx_DispatchInfo_groupCountX_get), _SE(js_cc_gfx_DispatchInfo_groupCountX_set)); 
    cls->defineProperty("groupCountY", _SE(js_cc_gfx_DispatchInfo_groupCountY_get), _SE(js_cc_gfx_DispatchInfo_groupCountY_set)); 
    cls->defineProperty("groupCountZ", _SE(js_cc_gfx_DispatchInfo_groupCountZ_get), _SE(js_cc_gfx_DispatchInfo_groupCountZ_set)); 
    cls->defineProperty("indirectBuffer", _SE(js_cc_gfx_DispatchInfo_indirectBuffer_get), _SE(js_cc_gfx_DispatchInfo_indirectBuffer_set)); 
    cls->defineProperty("indirectOffset", _SE(js_cc_gfx_DispatchInfo_indirectOffset_get), _SE(js_cc_gfx_DispatchInfo_indirectOffset_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_DispatchInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DispatchInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DispatchInfo>(cls);
    
    __jsb_cc_gfx_DispatchInfo_proto = cls->getProto();
    __jsb_cc_gfx_DispatchInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_IndirectBuffer_class = nullptr;
se::Object* __jsb_cc_gfx_IndirectBuffer_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_IndirectBuffer) 

static bool js_cc_gfx_IndirectBuffer_drawInfos_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::IndirectBuffer *arg1 = (cc::gfx::IndirectBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::IndirectBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->drawInfos, s.thisObject());
    SE_PRECONDITION2(ok, false, "IndirectBuffer_drawInfos_set,2,SWIGTYPE_ccstd__vectorT_cc__gfx__DrawInfo_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_IndirectBuffer_drawInfos_set) 

static bool js_cc_gfx_IndirectBuffer_drawInfos_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::IndirectBuffer *arg1 = (cc::gfx::IndirectBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::IndirectBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->drawInfos, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IndirectBuffer_drawInfos_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->drawInfos, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_IndirectBuffer_drawInfos_get) 

static bool js_cc_gfx_IndirectBuffer_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::IndirectBuffer *arg1 = (cc::gfx::IndirectBuffer *) NULL ;
    cc::gfx::IndirectBuffer *arg2 = 0 ;
    cc::gfx::IndirectBuffer temp2 ;
    cc::gfx::IndirectBuffer *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::IndirectBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "IndirectBuffer_copy,2,SWIGTYPE_p_cc__gfx__IndirectBuffer");
    arg2 = &temp2;
    
    result = (cc::gfx::IndirectBuffer *) &(arg1)->copy((cc::gfx::IndirectBuffer const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IndirectBuffer_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_IndirectBuffer_copy) 

// js_ctor
static bool js_new_cc_gfx_IndirectBuffer(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::IndirectBuffer *result;
    result = (cc::gfx::IndirectBuffer *)new cc::gfx::IndirectBuffer();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_IndirectBuffer, __jsb_cc_gfx_IndirectBuffer_class, js_delete_cc_gfx_IndirectBuffer)

static bool js_delete_cc_gfx_IndirectBuffer(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_IndirectBuffer) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::IndirectBuffer * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::IndirectBuffer*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("drawInfos", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->drawInfos), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_IndirectBuffer(se::Object* obj) {
    auto* cls = se::Class::create("IndirectBuffer", obj, nullptr, _SE(js_new_cc_gfx_IndirectBuffer)); 
    
    cls->defineProperty("drawInfos", _SE(js_cc_gfx_IndirectBuffer_drawInfos_get), _SE(js_cc_gfx_IndirectBuffer_drawInfos_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_IndirectBuffer_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_IndirectBuffer));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::IndirectBuffer>(cls);
    
    __jsb_cc_gfx_IndirectBuffer_proto = cls->getProto();
    __jsb_cc_gfx_IndirectBuffer_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_TextureInfo_class = nullptr;
se::Object* __jsb_cc_gfx_TextureInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_TextureInfo) 

static bool js_cc_gfx_TextureInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TextureInfo_type_set,2,SWIGTYPE_cc__gfx__TextureType");
    arg1->type = (cc::gfx::TextureType)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureInfo_type_set) 

static bool js_cc_gfx_TextureInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->type));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureInfo_type_get) 

static bool js_cc_gfx_TextureInfo_usage_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TextureInfo_usage_set,2,SWIGTYPE_cc__gfx__TextureUsageBit");
    arg1->usage = (cc::gfx::TextureUsage)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureInfo_usage_set) 

static bool js_cc_gfx_TextureInfo_usage_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->usage));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureInfo_usage_get) 

static bool js_cc_gfx_TextureInfo_format_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TextureInfo_format_set,2,SWIGTYPE_cc__gfx__Format");
    arg1->format = (cc::gfx::Format)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureInfo_format_set) 

static bool js_cc_gfx_TextureInfo_format_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->format));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureInfo_format_get) 

static bool js_cc_gfx_TextureInfo_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->width, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureInfo_width_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureInfo_width_set) 

static bool js_cc_gfx_TextureInfo_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->width, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureInfo_width_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->width, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureInfo_width_get) 

static bool js_cc_gfx_TextureInfo_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->height, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureInfo_height_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureInfo_height_set) 

static bool js_cc_gfx_TextureInfo_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->height, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureInfo_height_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->height, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureInfo_height_get) 

static bool js_cc_gfx_TextureInfo_flags_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TextureInfo_flags_set,2,SWIGTYPE_cc__gfx__TextureFlagBit");
    arg1->flags = (cc::gfx::TextureFlags)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureInfo_flags_set) 

static bool js_cc_gfx_TextureInfo_flags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->flags));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureInfo_flags_get) 

static bool js_cc_gfx_TextureInfo_layerCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->layerCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureInfo_layerCount_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureInfo_layerCount_set) 

static bool js_cc_gfx_TextureInfo_layerCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->layerCount, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureInfo_layerCount_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->layerCount, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureInfo_layerCount_get) 

static bool js_cc_gfx_TextureInfo_levelCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->levelCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureInfo_levelCount_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureInfo_levelCount_set) 

static bool js_cc_gfx_TextureInfo_levelCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->levelCount, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureInfo_levelCount_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->levelCount, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureInfo_levelCount_get) 

static bool js_cc_gfx_TextureInfo_samples_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TextureInfo_samples_set,2,SWIGTYPE_cc__gfx__SampleCount");
    arg1->samples = (cc::gfx::SampleCount)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureInfo_samples_set) 

static bool js_cc_gfx_TextureInfo_samples_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->samples));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureInfo_samples_get) 

static bool js_cc_gfx_TextureInfo_depth_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->depth, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureInfo_depth_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureInfo_depth_set) 

static bool js_cc_gfx_TextureInfo_depth_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->depth, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureInfo_depth_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depth, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureInfo_depth_get) 

static bool js_cc_gfx_TextureInfo_externalRes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    ok &= sevalue_to_native(args[0], &arg1->externalRes);
    SE_PRECONDITION2(ok, false, "TextureInfo_externalRes_set,2,SWIGTYPE_p_void");
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureInfo_externalRes_set) 

static bool js_cc_gfx_TextureInfo_externalRes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->externalRes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureInfo_externalRes_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->externalRes, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureInfo_externalRes_get) 

static bool js_cc_gfx_TextureInfo_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    cc::gfx::TextureInfo *arg2 = 0 ;
    cc::gfx::TextureInfo temp2 ;
    cc::gfx::TextureInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureInfo_copy,2,SWIGTYPE_p_cc__gfx__TextureInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::TextureInfo *) &(arg1)->copy((cc::gfx::TextureInfo const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureInfo_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_TextureInfo_copy) 

// js_ctor
static bool js_new_cc_gfx_TextureInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::TextureInfo *result;
    result = (cc::gfx::TextureInfo *)new cc::gfx::TextureInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_TextureInfo, __jsb_cc_gfx_TextureInfo_class, js_delete_cc_gfx_TextureInfo)

static bool js_delete_cc_gfx_TextureInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_TextureInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::TextureInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::TextureInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("usage", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->usage), ctx);
    }
    
    
    json->getProperty("format", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->format), ctx);
    }
    
    
    json->getProperty("width", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->width), ctx);
    }
    
    
    json->getProperty("height", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->height), ctx);
    }
    
    
    json->getProperty("flags", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->flags), ctx);
    }
    
    
    json->getProperty("layerCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->layerCount), ctx);
    }
    
    
    json->getProperty("levelCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->levelCount), ctx);
    }
    
    
    json->getProperty("samples", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->samples), ctx);
    }
    
    
    json->getProperty("depth", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depth), ctx);
    }
    
    
    json->getProperty("externalRes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->externalRes), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_TextureInfo(se::Object* obj) {
    auto* cls = se::Class::create("TextureInfo", obj, nullptr, _SE(js_new_cc_gfx_TextureInfo)); 
    
    cls->defineProperty("type", _SE(js_cc_gfx_TextureInfo_type_get), _SE(js_cc_gfx_TextureInfo_type_set)); 
    cls->defineProperty("usage", _SE(js_cc_gfx_TextureInfo_usage_get), _SE(js_cc_gfx_TextureInfo_usage_set)); 
    cls->defineProperty("format", _SE(js_cc_gfx_TextureInfo_format_get), _SE(js_cc_gfx_TextureInfo_format_set)); 
    cls->defineProperty("width", _SE(js_cc_gfx_TextureInfo_width_get), _SE(js_cc_gfx_TextureInfo_width_set)); 
    cls->defineProperty("height", _SE(js_cc_gfx_TextureInfo_height_get), _SE(js_cc_gfx_TextureInfo_height_set)); 
    cls->defineProperty("flags", _SE(js_cc_gfx_TextureInfo_flags_get), _SE(js_cc_gfx_TextureInfo_flags_set)); 
    cls->defineProperty("layerCount", _SE(js_cc_gfx_TextureInfo_layerCount_get), _SE(js_cc_gfx_TextureInfo_layerCount_set)); 
    cls->defineProperty("levelCount", _SE(js_cc_gfx_TextureInfo_levelCount_get), _SE(js_cc_gfx_TextureInfo_levelCount_set)); 
    cls->defineProperty("samples", _SE(js_cc_gfx_TextureInfo_samples_get), _SE(js_cc_gfx_TextureInfo_samples_set)); 
    cls->defineProperty("depth", _SE(js_cc_gfx_TextureInfo_depth_get), _SE(js_cc_gfx_TextureInfo_depth_set)); 
    cls->defineProperty("externalRes", _SE(js_cc_gfx_TextureInfo_externalRes_get), _SE(js_cc_gfx_TextureInfo_externalRes_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_TextureInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_TextureInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::TextureInfo>(cls);
    
    __jsb_cc_gfx_TextureInfo_proto = cls->getProto();
    __jsb_cc_gfx_TextureInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_TextureViewInfo_class = nullptr;
se::Object* __jsb_cc_gfx_TextureViewInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_TextureViewInfo) 

static bool js_cc_gfx_TextureViewInfo_texture_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->texture, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureViewInfo_texture_set,2,SWIGTYPE_p_cc__gfx__Texture"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureViewInfo_texture_set) 

static bool js_cc_gfx_TextureViewInfo_texture_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->texture, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureViewInfo_texture_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->texture, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureViewInfo_texture_get) 

static bool js_cc_gfx_TextureViewInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TextureViewInfo_type_set,2,SWIGTYPE_cc__gfx__TextureType");
    arg1->type = (cc::gfx::TextureType)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureViewInfo_type_set) 

static bool js_cc_gfx_TextureViewInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->type));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureViewInfo_type_get) 

static bool js_cc_gfx_TextureViewInfo_format_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TextureViewInfo_format_set,2,SWIGTYPE_cc__gfx__Format");
    arg1->format = (cc::gfx::Format)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureViewInfo_format_set) 

static bool js_cc_gfx_TextureViewInfo_format_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->format));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureViewInfo_format_get) 

static bool js_cc_gfx_TextureViewInfo_baseLevel_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->baseLevel, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureViewInfo_baseLevel_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureViewInfo_baseLevel_set) 

static bool js_cc_gfx_TextureViewInfo_baseLevel_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->baseLevel, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureViewInfo_baseLevel_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->baseLevel, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureViewInfo_baseLevel_get) 

static bool js_cc_gfx_TextureViewInfo_levelCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->levelCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureViewInfo_levelCount_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureViewInfo_levelCount_set) 

static bool js_cc_gfx_TextureViewInfo_levelCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->levelCount, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureViewInfo_levelCount_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->levelCount, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureViewInfo_levelCount_get) 

static bool js_cc_gfx_TextureViewInfo_baseLayer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->baseLayer, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureViewInfo_baseLayer_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureViewInfo_baseLayer_set) 

static bool js_cc_gfx_TextureViewInfo_baseLayer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->baseLayer, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureViewInfo_baseLayer_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->baseLayer, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureViewInfo_baseLayer_get) 

static bool js_cc_gfx_TextureViewInfo_layerCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->layerCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureViewInfo_layerCount_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureViewInfo_layerCount_set) 

static bool js_cc_gfx_TextureViewInfo_layerCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->layerCount, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureViewInfo_layerCount_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->layerCount, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureViewInfo_layerCount_get) 

static bool js_cc_gfx_TextureViewInfo_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    cc::gfx::TextureViewInfo *arg2 = 0 ;
    cc::gfx::TextureViewInfo temp2 ;
    cc::gfx::TextureViewInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureViewInfo_copy,2,SWIGTYPE_p_cc__gfx__TextureViewInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::TextureViewInfo *) &(arg1)->copy((cc::gfx::TextureViewInfo const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureViewInfo_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_TextureViewInfo_copy) 

// js_ctor
static bool js_new_cc_gfx_TextureViewInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::TextureViewInfo *result;
    result = (cc::gfx::TextureViewInfo *)new cc::gfx::TextureViewInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_TextureViewInfo, __jsb_cc_gfx_TextureViewInfo_class, js_delete_cc_gfx_TextureViewInfo)

static bool js_delete_cc_gfx_TextureViewInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_TextureViewInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::TextureViewInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::TextureViewInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("texture", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->texture), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("format", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->format), ctx);
    }
    
    
    json->getProperty("baseLevel", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->baseLevel), ctx);
    }
    
    
    json->getProperty("levelCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->levelCount), ctx);
    }
    
    
    json->getProperty("baseLayer", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->baseLayer), ctx);
    }
    
    
    json->getProperty("layerCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->layerCount), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_TextureViewInfo(se::Object* obj) {
    auto* cls = se::Class::create("TextureViewInfo", obj, nullptr, _SE(js_new_cc_gfx_TextureViewInfo)); 
    
    cls->defineProperty("texture", _SE(js_cc_gfx_TextureViewInfo_texture_get), _SE(js_cc_gfx_TextureViewInfo_texture_set)); 
    cls->defineProperty("type", _SE(js_cc_gfx_TextureViewInfo_type_get), _SE(js_cc_gfx_TextureViewInfo_type_set)); 
    cls->defineProperty("format", _SE(js_cc_gfx_TextureViewInfo_format_get), _SE(js_cc_gfx_TextureViewInfo_format_set)); 
    cls->defineProperty("baseLevel", _SE(js_cc_gfx_TextureViewInfo_baseLevel_get), _SE(js_cc_gfx_TextureViewInfo_baseLevel_set)); 
    cls->defineProperty("levelCount", _SE(js_cc_gfx_TextureViewInfo_levelCount_get), _SE(js_cc_gfx_TextureViewInfo_levelCount_set)); 
    cls->defineProperty("baseLayer", _SE(js_cc_gfx_TextureViewInfo_baseLayer_get), _SE(js_cc_gfx_TextureViewInfo_baseLayer_set)); 
    cls->defineProperty("layerCount", _SE(js_cc_gfx_TextureViewInfo_layerCount_get), _SE(js_cc_gfx_TextureViewInfo_layerCount_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_TextureViewInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_TextureViewInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::TextureViewInfo>(cls);
    
    __jsb_cc_gfx_TextureViewInfo_proto = cls->getProto();
    __jsb_cc_gfx_TextureViewInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_SamplerInfo_class = nullptr;
se::Object* __jsb_cc_gfx_SamplerInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_SamplerInfo) 

static bool js_cc_gfx_SamplerInfo_minFilter_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "SamplerInfo_minFilter_set,2,SWIGTYPE_cc__gfx__Filter");
    arg1->minFilter = (cc::gfx::Filter)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SamplerInfo_minFilter_set) 

static bool js_cc_gfx_SamplerInfo_minFilter_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->minFilter));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SamplerInfo_minFilter_get) 

static bool js_cc_gfx_SamplerInfo_magFilter_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "SamplerInfo_magFilter_set,2,SWIGTYPE_cc__gfx__Filter");
    arg1->magFilter = (cc::gfx::Filter)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SamplerInfo_magFilter_set) 

static bool js_cc_gfx_SamplerInfo_magFilter_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->magFilter));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SamplerInfo_magFilter_get) 

static bool js_cc_gfx_SamplerInfo_mipFilter_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "SamplerInfo_mipFilter_set,2,SWIGTYPE_cc__gfx__Filter");
    arg1->mipFilter = (cc::gfx::Filter)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SamplerInfo_mipFilter_set) 

static bool js_cc_gfx_SamplerInfo_mipFilter_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->mipFilter));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SamplerInfo_mipFilter_get) 

static bool js_cc_gfx_SamplerInfo_addressU_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "SamplerInfo_addressU_set,2,SWIGTYPE_cc__gfx__Address");
    arg1->addressU = (cc::gfx::Address)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SamplerInfo_addressU_set) 

static bool js_cc_gfx_SamplerInfo_addressU_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->addressU));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SamplerInfo_addressU_get) 

static bool js_cc_gfx_SamplerInfo_addressV_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "SamplerInfo_addressV_set,2,SWIGTYPE_cc__gfx__Address");
    arg1->addressV = (cc::gfx::Address)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SamplerInfo_addressV_set) 

static bool js_cc_gfx_SamplerInfo_addressV_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->addressV));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SamplerInfo_addressV_get) 

static bool js_cc_gfx_SamplerInfo_addressW_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "SamplerInfo_addressW_set,2,SWIGTYPE_cc__gfx__Address");
    arg1->addressW = (cc::gfx::Address)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SamplerInfo_addressW_set) 

static bool js_cc_gfx_SamplerInfo_addressW_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->addressW));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SamplerInfo_addressW_get) 

static bool js_cc_gfx_SamplerInfo_maxAnisotropy_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxAnisotropy, s.thisObject());
    SE_PRECONDITION2(ok, false, "SamplerInfo_maxAnisotropy_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SamplerInfo_maxAnisotropy_set) 

static bool js_cc_gfx_SamplerInfo_maxAnisotropy_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxAnisotropy, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SamplerInfo_maxAnisotropy_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxAnisotropy, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SamplerInfo_maxAnisotropy_get) 

static bool js_cc_gfx_SamplerInfo_cmpFunc_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "SamplerInfo_cmpFunc_set,2,SWIGTYPE_cc__gfx__ComparisonFunc");
    arg1->cmpFunc = (cc::gfx::ComparisonFunc)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SamplerInfo_cmpFunc_set) 

static bool js_cc_gfx_SamplerInfo_cmpFunc_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->cmpFunc));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SamplerInfo_cmpFunc_get) 

static bool js_cc_gfx_SamplerInfo_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    cc::gfx::SamplerInfo *arg2 = 0 ;
    cc::gfx::SamplerInfo temp2 ;
    cc::gfx::SamplerInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SamplerInfo_copy,2,SWIGTYPE_p_cc__gfx__SamplerInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::SamplerInfo *) &(arg1)->copy((cc::gfx::SamplerInfo const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SamplerInfo_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_SamplerInfo_copy) 

// js_ctor
static bool js_new_cc_gfx_SamplerInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::SamplerInfo *result;
    result = (cc::gfx::SamplerInfo *)new cc::gfx::SamplerInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_SamplerInfo, __jsb_cc_gfx_SamplerInfo_class, js_delete_cc_gfx_SamplerInfo)

static bool js_delete_cc_gfx_SamplerInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_SamplerInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::SamplerInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::SamplerInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("minFilter", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->minFilter), ctx);
    }
    
    
    json->getProperty("magFilter", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->magFilter), ctx);
    }
    
    
    json->getProperty("mipFilter", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->mipFilter), ctx);
    }
    
    
    json->getProperty("addressU", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->addressU), ctx);
    }
    
    
    json->getProperty("addressV", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->addressV), ctx);
    }
    
    
    json->getProperty("addressW", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->addressW), ctx);
    }
    
    
    json->getProperty("maxAnisotropy", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxAnisotropy), ctx);
    }
    
    
    json->getProperty("cmpFunc", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->cmpFunc), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_SamplerInfo(se::Object* obj) {
    auto* cls = se::Class::create("SamplerInfo", obj, nullptr, _SE(js_new_cc_gfx_SamplerInfo)); 
    
    cls->defineProperty("minFilter", _SE(js_cc_gfx_SamplerInfo_minFilter_get), _SE(js_cc_gfx_SamplerInfo_minFilter_set)); 
    cls->defineProperty("magFilter", _SE(js_cc_gfx_SamplerInfo_magFilter_get), _SE(js_cc_gfx_SamplerInfo_magFilter_set)); 
    cls->defineProperty("mipFilter", _SE(js_cc_gfx_SamplerInfo_mipFilter_get), _SE(js_cc_gfx_SamplerInfo_mipFilter_set)); 
    cls->defineProperty("addressU", _SE(js_cc_gfx_SamplerInfo_addressU_get), _SE(js_cc_gfx_SamplerInfo_addressU_set)); 
    cls->defineProperty("addressV", _SE(js_cc_gfx_SamplerInfo_addressV_get), _SE(js_cc_gfx_SamplerInfo_addressV_set)); 
    cls->defineProperty("addressW", _SE(js_cc_gfx_SamplerInfo_addressW_get), _SE(js_cc_gfx_SamplerInfo_addressW_set)); 
    cls->defineProperty("maxAnisotropy", _SE(js_cc_gfx_SamplerInfo_maxAnisotropy_get), _SE(js_cc_gfx_SamplerInfo_maxAnisotropy_set)); 
    cls->defineProperty("cmpFunc", _SE(js_cc_gfx_SamplerInfo_cmpFunc_get), _SE(js_cc_gfx_SamplerInfo_cmpFunc_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_SamplerInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_SamplerInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::SamplerInfo>(cls);
    
    __jsb_cc_gfx_SamplerInfo_proto = cls->getProto();
    __jsb_cc_gfx_SamplerInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Uniform_class = nullptr;
se::Object* __jsb_cc_gfx_Uniform_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Uniform) 

static bool js_cc_gfx_Uniform_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Uniform *arg1 = (cc::gfx::Uniform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Uniform>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Uniform_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Uniform_name_set) 

static bool js_cc_gfx_Uniform_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Uniform *arg1 = (cc::gfx::Uniform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Uniform>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Uniform_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Uniform_name_get) 

static bool js_cc_gfx_Uniform_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Uniform *arg1 = (cc::gfx::Uniform *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Uniform>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "Uniform_type_set,2,SWIGTYPE_cc__gfx__Type");
    arg1->type = (cc::gfx::Type)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Uniform_type_set) 

static bool js_cc_gfx_Uniform_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Uniform *arg1 = (cc::gfx::Uniform *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Uniform>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->type));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Uniform_type_get) 

static bool js_cc_gfx_Uniform_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Uniform *arg1 = (cc::gfx::Uniform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Uniform>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "Uniform_count_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Uniform_count_set) 

static bool js_cc_gfx_Uniform_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Uniform *arg1 = (cc::gfx::Uniform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Uniform>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Uniform_count_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->count, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Uniform_count_get) 

static bool js_cc_gfx_Uniform_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Uniform *arg1 = (cc::gfx::Uniform *) NULL ;
    cc::gfx::Uniform *arg2 = 0 ;
    cc::gfx::Uniform temp2 ;
    cc::gfx::Uniform *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Uniform>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Uniform_copy,2,SWIGTYPE_p_cc__gfx__Uniform");
    arg2 = &temp2;
    
    result = (cc::gfx::Uniform *) &(arg1)->copy((cc::gfx::Uniform const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Uniform_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Uniform_copy) 

// js_ctor
static bool js_new_cc_gfx_Uniform(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::Uniform *result;
    result = (cc::gfx::Uniform *)new cc::gfx::Uniform();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_Uniform, __jsb_cc_gfx_Uniform_class, js_delete_cc_gfx_Uniform)

static bool js_delete_cc_gfx_Uniform(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Uniform) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::Uniform * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::Uniform*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_Uniform(se::Object* obj) {
    auto* cls = se::Class::create("Uniform", obj, nullptr, _SE(js_new_cc_gfx_Uniform)); 
    
    cls->defineProperty("name", _SE(js_cc_gfx_Uniform_name_get), _SE(js_cc_gfx_Uniform_name_set)); 
    cls->defineProperty("type", _SE(js_cc_gfx_Uniform_type_get), _SE(js_cc_gfx_Uniform_type_set)); 
    cls->defineProperty("count", _SE(js_cc_gfx_Uniform_count_get), _SE(js_cc_gfx_Uniform_count_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_Uniform_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Uniform));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Uniform>(cls);
    
    __jsb_cc_gfx_Uniform_proto = cls->getProto();
    __jsb_cc_gfx_Uniform_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_UniformBlock_class = nullptr;
se::Object* __jsb_cc_gfx_UniformBlock_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_UniformBlock) 

static bool js_cc_gfx_UniformBlock_set_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformBlock *arg1 = (cc::gfx::UniformBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformBlock>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->set, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformBlock_set_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformBlock_set_set) 

static bool js_cc_gfx_UniformBlock_set_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock *arg1 = (cc::gfx::UniformBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformBlock>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->set, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformBlock_set_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->set, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformBlock_set_get) 

static bool js_cc_gfx_UniformBlock_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformBlock *arg1 = (cc::gfx::UniformBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformBlock>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformBlock_binding_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformBlock_binding_set) 

static bool js_cc_gfx_UniformBlock_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock *arg1 = (cc::gfx::UniformBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformBlock>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformBlock_binding_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->binding, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformBlock_binding_get) 

static bool js_cc_gfx_UniformBlock_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformBlock *arg1 = (cc::gfx::UniformBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformBlock>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformBlock_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformBlock_name_set) 

static bool js_cc_gfx_UniformBlock_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock *arg1 = (cc::gfx::UniformBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformBlock>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformBlock_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformBlock_name_get) 

static bool js_cc_gfx_UniformBlock_members_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformBlock *arg1 = (cc::gfx::UniformBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformBlock>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->members, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformBlock_members_set,2,SWIGTYPE_ccstd__vectorT_cc__gfx__Uniform_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformBlock_members_set) 

static bool js_cc_gfx_UniformBlock_members_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock *arg1 = (cc::gfx::UniformBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformBlock>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->members, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformBlock_members_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->members, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformBlock_members_get) 

static bool js_cc_gfx_UniformBlock_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformBlock *arg1 = (cc::gfx::UniformBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformBlock>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformBlock_count_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformBlock_count_set) 

static bool js_cc_gfx_UniformBlock_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock *arg1 = (cc::gfx::UniformBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformBlock>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformBlock_count_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->count, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformBlock_count_get) 

static bool js_cc_gfx_UniformBlock_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformBlock *arg1 = (cc::gfx::UniformBlock *) NULL ;
    cc::gfx::UniformBlock *arg2 = 0 ;
    cc::gfx::UniformBlock temp2 ;
    cc::gfx::UniformBlock *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformBlock>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformBlock_copy,2,SWIGTYPE_p_cc__gfx__UniformBlock");
    arg2 = &temp2;
    
    result = (cc::gfx::UniformBlock *) &(arg1)->copy((cc::gfx::UniformBlock const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformBlock_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_UniformBlock_copy) 

// js_ctor
static bool js_new_cc_gfx_UniformBlock(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::UniformBlock *result;
    result = (cc::gfx::UniformBlock *)new cc::gfx::UniformBlock();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_UniformBlock, __jsb_cc_gfx_UniformBlock_class, js_delete_cc_gfx_UniformBlock)

static bool js_delete_cc_gfx_UniformBlock(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_UniformBlock) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::UniformBlock * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::UniformBlock*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("set", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->set), ctx);
    }
    
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("members", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->members), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_UniformBlock(se::Object* obj) {
    auto* cls = se::Class::create("UniformBlock", obj, nullptr, _SE(js_new_cc_gfx_UniformBlock)); 
    
    cls->defineProperty("set", _SE(js_cc_gfx_UniformBlock_set_get), _SE(js_cc_gfx_UniformBlock_set_set)); 
    cls->defineProperty("binding", _SE(js_cc_gfx_UniformBlock_binding_get), _SE(js_cc_gfx_UniformBlock_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_gfx_UniformBlock_name_get), _SE(js_cc_gfx_UniformBlock_name_set)); 
    cls->defineProperty("members", _SE(js_cc_gfx_UniformBlock_members_get), _SE(js_cc_gfx_UniformBlock_members_set)); 
    cls->defineProperty("count", _SE(js_cc_gfx_UniformBlock_count_get), _SE(js_cc_gfx_UniformBlock_count_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_UniformBlock_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_UniformBlock));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::UniformBlock>(cls);
    
    __jsb_cc_gfx_UniformBlock_proto = cls->getProto();
    __jsb_cc_gfx_UniformBlock_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_UniformSamplerTexture_class = nullptr;
se::Object* __jsb_cc_gfx_UniformSamplerTexture_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_UniformSamplerTexture) 

static bool js_cc_gfx_UniformSamplerTexture_set_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformSamplerTexture *arg1 = (cc::gfx::UniformSamplerTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSamplerTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->set, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformSamplerTexture_set_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformSamplerTexture_set_set) 

static bool js_cc_gfx_UniformSamplerTexture_set_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture *arg1 = (cc::gfx::UniformSamplerTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSamplerTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->set, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformSamplerTexture_set_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->set, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformSamplerTexture_set_get) 

static bool js_cc_gfx_UniformSamplerTexture_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformSamplerTexture *arg1 = (cc::gfx::UniformSamplerTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSamplerTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformSamplerTexture_binding_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformSamplerTexture_binding_set) 

static bool js_cc_gfx_UniformSamplerTexture_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture *arg1 = (cc::gfx::UniformSamplerTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSamplerTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformSamplerTexture_binding_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->binding, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformSamplerTexture_binding_get) 

static bool js_cc_gfx_UniformSamplerTexture_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformSamplerTexture *arg1 = (cc::gfx::UniformSamplerTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSamplerTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformSamplerTexture_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformSamplerTexture_name_set) 

static bool js_cc_gfx_UniformSamplerTexture_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture *arg1 = (cc::gfx::UniformSamplerTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSamplerTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformSamplerTexture_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformSamplerTexture_name_get) 

static bool js_cc_gfx_UniformSamplerTexture_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformSamplerTexture *arg1 = (cc::gfx::UniformSamplerTexture *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSamplerTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "UniformSamplerTexture_type_set,2,SWIGTYPE_cc__gfx__Type");
    arg1->type = (cc::gfx::Type)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformSamplerTexture_type_set) 

static bool js_cc_gfx_UniformSamplerTexture_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture *arg1 = (cc::gfx::UniformSamplerTexture *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSamplerTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->type));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformSamplerTexture_type_get) 

static bool js_cc_gfx_UniformSamplerTexture_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformSamplerTexture *arg1 = (cc::gfx::UniformSamplerTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSamplerTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformSamplerTexture_count_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformSamplerTexture_count_set) 

static bool js_cc_gfx_UniformSamplerTexture_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture *arg1 = (cc::gfx::UniformSamplerTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSamplerTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformSamplerTexture_count_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->count, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformSamplerTexture_count_get) 

static bool js_cc_gfx_UniformSamplerTexture_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformSamplerTexture *arg1 = (cc::gfx::UniformSamplerTexture *) NULL ;
    cc::gfx::UniformSamplerTexture *arg2 = 0 ;
    cc::gfx::UniformSamplerTexture temp2 ;
    cc::gfx::UniformSamplerTexture *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSamplerTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformSamplerTexture_copy,2,SWIGTYPE_p_cc__gfx__UniformSamplerTexture");
    arg2 = &temp2;
    
    result = (cc::gfx::UniformSamplerTexture *) &(arg1)->copy((cc::gfx::UniformSamplerTexture const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformSamplerTexture_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_UniformSamplerTexture_copy) 

// js_ctor
static bool js_new_cc_gfx_UniformSamplerTexture(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::UniformSamplerTexture *result;
    result = (cc::gfx::UniformSamplerTexture *)new cc::gfx::UniformSamplerTexture();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_UniformSamplerTexture, __jsb_cc_gfx_UniformSamplerTexture_class, js_delete_cc_gfx_UniformSamplerTexture)

static bool js_delete_cc_gfx_UniformSamplerTexture(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_UniformSamplerTexture) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::UniformSamplerTexture * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::UniformSamplerTexture*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("set", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->set), ctx);
    }
    
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_UniformSamplerTexture(se::Object* obj) {
    auto* cls = se::Class::create("UniformSamplerTexture", obj, nullptr, _SE(js_new_cc_gfx_UniformSamplerTexture)); 
    
    cls->defineProperty("set", _SE(js_cc_gfx_UniformSamplerTexture_set_get), _SE(js_cc_gfx_UniformSamplerTexture_set_set)); 
    cls->defineProperty("binding", _SE(js_cc_gfx_UniformSamplerTexture_binding_get), _SE(js_cc_gfx_UniformSamplerTexture_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_gfx_UniformSamplerTexture_name_get), _SE(js_cc_gfx_UniformSamplerTexture_name_set)); 
    cls->defineProperty("type", _SE(js_cc_gfx_UniformSamplerTexture_type_get), _SE(js_cc_gfx_UniformSamplerTexture_type_set)); 
    cls->defineProperty("count", _SE(js_cc_gfx_UniformSamplerTexture_count_get), _SE(js_cc_gfx_UniformSamplerTexture_count_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_UniformSamplerTexture_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_UniformSamplerTexture));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::UniformSamplerTexture>(cls);
    
    __jsb_cc_gfx_UniformSamplerTexture_proto = cls->getProto();
    __jsb_cc_gfx_UniformSamplerTexture_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_UniformSampler_class = nullptr;
se::Object* __jsb_cc_gfx_UniformSampler_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_UniformSampler) 

static bool js_cc_gfx_UniformSampler_set_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformSampler *arg1 = (cc::gfx::UniformSampler *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSampler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->set, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformSampler_set_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformSampler_set_set) 

static bool js_cc_gfx_UniformSampler_set_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSampler *arg1 = (cc::gfx::UniformSampler *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSampler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->set, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformSampler_set_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->set, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformSampler_set_get) 

static bool js_cc_gfx_UniformSampler_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformSampler *arg1 = (cc::gfx::UniformSampler *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSampler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformSampler_binding_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformSampler_binding_set) 

static bool js_cc_gfx_UniformSampler_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSampler *arg1 = (cc::gfx::UniformSampler *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSampler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformSampler_binding_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->binding, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformSampler_binding_get) 

static bool js_cc_gfx_UniformSampler_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformSampler *arg1 = (cc::gfx::UniformSampler *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSampler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformSampler_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformSampler_name_set) 

static bool js_cc_gfx_UniformSampler_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSampler *arg1 = (cc::gfx::UniformSampler *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSampler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformSampler_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformSampler_name_get) 

static bool js_cc_gfx_UniformSampler_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformSampler *arg1 = (cc::gfx::UniformSampler *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSampler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformSampler_count_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformSampler_count_set) 

static bool js_cc_gfx_UniformSampler_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSampler *arg1 = (cc::gfx::UniformSampler *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSampler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformSampler_count_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->count, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformSampler_count_get) 

static bool js_cc_gfx_UniformSampler_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformSampler *arg1 = (cc::gfx::UniformSampler *) NULL ;
    cc::gfx::UniformSampler *arg2 = 0 ;
    cc::gfx::UniformSampler temp2 ;
    cc::gfx::UniformSampler *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSampler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformSampler_copy,2,SWIGTYPE_p_cc__gfx__UniformSampler");
    arg2 = &temp2;
    
    result = (cc::gfx::UniformSampler *) &(arg1)->copy((cc::gfx::UniformSampler const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformSampler_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_UniformSampler_copy) 

// js_ctor
static bool js_new_cc_gfx_UniformSampler(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::UniformSampler *result;
    result = (cc::gfx::UniformSampler *)new cc::gfx::UniformSampler();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_UniformSampler, __jsb_cc_gfx_UniformSampler_class, js_delete_cc_gfx_UniformSampler)

static bool js_delete_cc_gfx_UniformSampler(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_UniformSampler) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::UniformSampler * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::UniformSampler*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("set", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->set), ctx);
    }
    
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_UniformSampler(se::Object* obj) {
    auto* cls = se::Class::create("UniformSampler", obj, nullptr, _SE(js_new_cc_gfx_UniformSampler)); 
    
    cls->defineProperty("set", _SE(js_cc_gfx_UniformSampler_set_get), _SE(js_cc_gfx_UniformSampler_set_set)); 
    cls->defineProperty("binding", _SE(js_cc_gfx_UniformSampler_binding_get), _SE(js_cc_gfx_UniformSampler_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_gfx_UniformSampler_name_get), _SE(js_cc_gfx_UniformSampler_name_set)); 
    cls->defineProperty("count", _SE(js_cc_gfx_UniformSampler_count_get), _SE(js_cc_gfx_UniformSampler_count_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_UniformSampler_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_UniformSampler));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::UniformSampler>(cls);
    
    __jsb_cc_gfx_UniformSampler_proto = cls->getProto();
    __jsb_cc_gfx_UniformSampler_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_UniformTexture_class = nullptr;
se::Object* __jsb_cc_gfx_UniformTexture_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_UniformTexture) 

static bool js_cc_gfx_UniformTexture_set_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformTexture *arg1 = (cc::gfx::UniformTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->set, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformTexture_set_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformTexture_set_set) 

static bool js_cc_gfx_UniformTexture_set_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformTexture *arg1 = (cc::gfx::UniformTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->set, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformTexture_set_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->set, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformTexture_set_get) 

static bool js_cc_gfx_UniformTexture_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformTexture *arg1 = (cc::gfx::UniformTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformTexture_binding_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformTexture_binding_set) 

static bool js_cc_gfx_UniformTexture_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformTexture *arg1 = (cc::gfx::UniformTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformTexture_binding_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->binding, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformTexture_binding_get) 

static bool js_cc_gfx_UniformTexture_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformTexture *arg1 = (cc::gfx::UniformTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformTexture_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformTexture_name_set) 

static bool js_cc_gfx_UniformTexture_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformTexture *arg1 = (cc::gfx::UniformTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformTexture_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformTexture_name_get) 

static bool js_cc_gfx_UniformTexture_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformTexture *arg1 = (cc::gfx::UniformTexture *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "UniformTexture_type_set,2,SWIGTYPE_cc__gfx__Type");
    arg1->type = (cc::gfx::Type)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformTexture_type_set) 

static bool js_cc_gfx_UniformTexture_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformTexture *arg1 = (cc::gfx::UniformTexture *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->type));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformTexture_type_get) 

static bool js_cc_gfx_UniformTexture_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformTexture *arg1 = (cc::gfx::UniformTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformTexture_count_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformTexture_count_set) 

static bool js_cc_gfx_UniformTexture_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformTexture *arg1 = (cc::gfx::UniformTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformTexture_count_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->count, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformTexture_count_get) 

static bool js_cc_gfx_UniformTexture_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformTexture *arg1 = (cc::gfx::UniformTexture *) NULL ;
    cc::gfx::UniformTexture *arg2 = 0 ;
    cc::gfx::UniformTexture temp2 ;
    cc::gfx::UniformTexture *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformTexture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformTexture_copy,2,SWIGTYPE_p_cc__gfx__UniformTexture");
    arg2 = &temp2;
    
    result = (cc::gfx::UniformTexture *) &(arg1)->copy((cc::gfx::UniformTexture const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformTexture_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_UniformTexture_copy) 

// js_ctor
static bool js_new_cc_gfx_UniformTexture(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::UniformTexture *result;
    result = (cc::gfx::UniformTexture *)new cc::gfx::UniformTexture();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_UniformTexture, __jsb_cc_gfx_UniformTexture_class, js_delete_cc_gfx_UniformTexture)

static bool js_delete_cc_gfx_UniformTexture(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_UniformTexture) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::UniformTexture * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::UniformTexture*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("set", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->set), ctx);
    }
    
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_UniformTexture(se::Object* obj) {
    auto* cls = se::Class::create("UniformTexture", obj, nullptr, _SE(js_new_cc_gfx_UniformTexture)); 
    
    cls->defineProperty("set", _SE(js_cc_gfx_UniformTexture_set_get), _SE(js_cc_gfx_UniformTexture_set_set)); 
    cls->defineProperty("binding", _SE(js_cc_gfx_UniformTexture_binding_get), _SE(js_cc_gfx_UniformTexture_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_gfx_UniformTexture_name_get), _SE(js_cc_gfx_UniformTexture_name_set)); 
    cls->defineProperty("type", _SE(js_cc_gfx_UniformTexture_type_get), _SE(js_cc_gfx_UniformTexture_type_set)); 
    cls->defineProperty("count", _SE(js_cc_gfx_UniformTexture_count_get), _SE(js_cc_gfx_UniformTexture_count_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_UniformTexture_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_UniformTexture));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::UniformTexture>(cls);
    
    __jsb_cc_gfx_UniformTexture_proto = cls->getProto();
    __jsb_cc_gfx_UniformTexture_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_UniformStorageImage_class = nullptr;
se::Object* __jsb_cc_gfx_UniformStorageImage_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_UniformStorageImage) 

static bool js_cc_gfx_UniformStorageImage_set_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->set, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformStorageImage_set_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformStorageImage_set_set) 

static bool js_cc_gfx_UniformStorageImage_set_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->set, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformStorageImage_set_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->set, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformStorageImage_set_get) 

static bool js_cc_gfx_UniformStorageImage_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformStorageImage_binding_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformStorageImage_binding_set) 

static bool js_cc_gfx_UniformStorageImage_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformStorageImage_binding_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->binding, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformStorageImage_binding_get) 

static bool js_cc_gfx_UniformStorageImage_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformStorageImage_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformStorageImage_name_set) 

static bool js_cc_gfx_UniformStorageImage_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformStorageImage_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformStorageImage_name_get) 

static bool js_cc_gfx_UniformStorageImage_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "UniformStorageImage_type_set,2,SWIGTYPE_cc__gfx__Type");
    arg1->type = (cc::gfx::Type)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformStorageImage_type_set) 

static bool js_cc_gfx_UniformStorageImage_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->type));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformStorageImage_type_get) 

static bool js_cc_gfx_UniformStorageImage_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformStorageImage_count_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformStorageImage_count_set) 

static bool js_cc_gfx_UniformStorageImage_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformStorageImage_count_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->count, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformStorageImage_count_get) 

static bool js_cc_gfx_UniformStorageImage_memoryAccess_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "UniformStorageImage_memoryAccess_set,2,SWIGTYPE_cc__gfx__MemoryAccessBit");
    arg1->memoryAccess = (cc::gfx::MemoryAccess)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformStorageImage_memoryAccess_set) 

static bool js_cc_gfx_UniformStorageImage_memoryAccess_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->memoryAccess));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformStorageImage_memoryAccess_get) 

static bool js_cc_gfx_UniformStorageImage_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    cc::gfx::UniformStorageImage *arg2 = 0 ;
    cc::gfx::UniformStorageImage temp2 ;
    cc::gfx::UniformStorageImage *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformStorageImage_copy,2,SWIGTYPE_p_cc__gfx__UniformStorageImage");
    arg2 = &temp2;
    
    result = (cc::gfx::UniformStorageImage *) &(arg1)->copy((cc::gfx::UniformStorageImage const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformStorageImage_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_UniformStorageImage_copy) 

// js_ctor
static bool js_new_cc_gfx_UniformStorageImage(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::UniformStorageImage *result;
    result = (cc::gfx::UniformStorageImage *)new cc::gfx::UniformStorageImage();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_UniformStorageImage, __jsb_cc_gfx_UniformStorageImage_class, js_delete_cc_gfx_UniformStorageImage)

static bool js_delete_cc_gfx_UniformStorageImage(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_UniformStorageImage) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::UniformStorageImage * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::UniformStorageImage*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("set", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->set), ctx);
    }
    
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("memoryAccess", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->memoryAccess), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_UniformStorageImage(se::Object* obj) {
    auto* cls = se::Class::create("UniformStorageImage", obj, nullptr, _SE(js_new_cc_gfx_UniformStorageImage)); 
    
    cls->defineProperty("set", _SE(js_cc_gfx_UniformStorageImage_set_get), _SE(js_cc_gfx_UniformStorageImage_set_set)); 
    cls->defineProperty("binding", _SE(js_cc_gfx_UniformStorageImage_binding_get), _SE(js_cc_gfx_UniformStorageImage_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_gfx_UniformStorageImage_name_get), _SE(js_cc_gfx_UniformStorageImage_name_set)); 
    cls->defineProperty("type", _SE(js_cc_gfx_UniformStorageImage_type_get), _SE(js_cc_gfx_UniformStorageImage_type_set)); 
    cls->defineProperty("count", _SE(js_cc_gfx_UniformStorageImage_count_get), _SE(js_cc_gfx_UniformStorageImage_count_set)); 
    cls->defineProperty("memoryAccess", _SE(js_cc_gfx_UniformStorageImage_memoryAccess_get), _SE(js_cc_gfx_UniformStorageImage_memoryAccess_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_UniformStorageImage_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_UniformStorageImage));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::UniformStorageImage>(cls);
    
    __jsb_cc_gfx_UniformStorageImage_proto = cls->getProto();
    __jsb_cc_gfx_UniformStorageImage_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_UniformStorageBuffer_class = nullptr;
se::Object* __jsb_cc_gfx_UniformStorageBuffer_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_UniformStorageBuffer) 

static bool js_cc_gfx_UniformStorageBuffer_set_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageBuffer *arg1 = (cc::gfx::UniformStorageBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->set, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformStorageBuffer_set_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformStorageBuffer_set_set) 

static bool js_cc_gfx_UniformStorageBuffer_set_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformStorageBuffer *arg1 = (cc::gfx::UniformStorageBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->set, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformStorageBuffer_set_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->set, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformStorageBuffer_set_get) 

static bool js_cc_gfx_UniformStorageBuffer_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageBuffer *arg1 = (cc::gfx::UniformStorageBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformStorageBuffer_binding_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformStorageBuffer_binding_set) 

static bool js_cc_gfx_UniformStorageBuffer_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformStorageBuffer *arg1 = (cc::gfx::UniformStorageBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformStorageBuffer_binding_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->binding, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformStorageBuffer_binding_get) 

static bool js_cc_gfx_UniformStorageBuffer_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageBuffer *arg1 = (cc::gfx::UniformStorageBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformStorageBuffer_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformStorageBuffer_name_set) 

static bool js_cc_gfx_UniformStorageBuffer_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformStorageBuffer *arg1 = (cc::gfx::UniformStorageBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformStorageBuffer_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformStorageBuffer_name_get) 

static bool js_cc_gfx_UniformStorageBuffer_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageBuffer *arg1 = (cc::gfx::UniformStorageBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformStorageBuffer_count_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformStorageBuffer_count_set) 

static bool js_cc_gfx_UniformStorageBuffer_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformStorageBuffer *arg1 = (cc::gfx::UniformStorageBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformStorageBuffer_count_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->count, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformStorageBuffer_count_get) 

static bool js_cc_gfx_UniformStorageBuffer_memoryAccess_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageBuffer *arg1 = (cc::gfx::UniformStorageBuffer *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "UniformStorageBuffer_memoryAccess_set,2,SWIGTYPE_cc__gfx__MemoryAccessBit");
    arg1->memoryAccess = (cc::gfx::MemoryAccess)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformStorageBuffer_memoryAccess_set) 

static bool js_cc_gfx_UniformStorageBuffer_memoryAccess_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformStorageBuffer *arg1 = (cc::gfx::UniformStorageBuffer *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->memoryAccess));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformStorageBuffer_memoryAccess_get) 

static bool js_cc_gfx_UniformStorageBuffer_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageBuffer *arg1 = (cc::gfx::UniformStorageBuffer *) NULL ;
    cc::gfx::UniformStorageBuffer *arg2 = 0 ;
    cc::gfx::UniformStorageBuffer temp2 ;
    cc::gfx::UniformStorageBuffer *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformStorageBuffer_copy,2,SWIGTYPE_p_cc__gfx__UniformStorageBuffer");
    arg2 = &temp2;
    
    result = (cc::gfx::UniformStorageBuffer *) &(arg1)->copy((cc::gfx::UniformStorageBuffer const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformStorageBuffer_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_UniformStorageBuffer_copy) 

// js_ctor
static bool js_new_cc_gfx_UniformStorageBuffer(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::UniformStorageBuffer *result;
    result = (cc::gfx::UniformStorageBuffer *)new cc::gfx::UniformStorageBuffer();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_UniformStorageBuffer, __jsb_cc_gfx_UniformStorageBuffer_class, js_delete_cc_gfx_UniformStorageBuffer)

static bool js_delete_cc_gfx_UniformStorageBuffer(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_UniformStorageBuffer) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::UniformStorageBuffer * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::UniformStorageBuffer*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("set", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->set), ctx);
    }
    
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("memoryAccess", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->memoryAccess), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_UniformStorageBuffer(se::Object* obj) {
    auto* cls = se::Class::create("UniformStorageBuffer", obj, nullptr, _SE(js_new_cc_gfx_UniformStorageBuffer)); 
    
    cls->defineProperty("set", _SE(js_cc_gfx_UniformStorageBuffer_set_get), _SE(js_cc_gfx_UniformStorageBuffer_set_set)); 
    cls->defineProperty("binding", _SE(js_cc_gfx_UniformStorageBuffer_binding_get), _SE(js_cc_gfx_UniformStorageBuffer_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_gfx_UniformStorageBuffer_name_get), _SE(js_cc_gfx_UniformStorageBuffer_name_set)); 
    cls->defineProperty("count", _SE(js_cc_gfx_UniformStorageBuffer_count_get), _SE(js_cc_gfx_UniformStorageBuffer_count_set)); 
    cls->defineProperty("memoryAccess", _SE(js_cc_gfx_UniformStorageBuffer_memoryAccess_get), _SE(js_cc_gfx_UniformStorageBuffer_memoryAccess_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_UniformStorageBuffer_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_UniformStorageBuffer));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::UniformStorageBuffer>(cls);
    
    __jsb_cc_gfx_UniformStorageBuffer_proto = cls->getProto();
    __jsb_cc_gfx_UniformStorageBuffer_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_UniformInputAttachment_class = nullptr;
se::Object* __jsb_cc_gfx_UniformInputAttachment_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_UniformInputAttachment) 

static bool js_cc_gfx_UniformInputAttachment_set_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformInputAttachment *arg1 = (cc::gfx::UniformInputAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformInputAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->set, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformInputAttachment_set_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformInputAttachment_set_set) 

static bool js_cc_gfx_UniformInputAttachment_set_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformInputAttachment *arg1 = (cc::gfx::UniformInputAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformInputAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->set, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformInputAttachment_set_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->set, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformInputAttachment_set_get) 

static bool js_cc_gfx_UniformInputAttachment_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformInputAttachment *arg1 = (cc::gfx::UniformInputAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformInputAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformInputAttachment_binding_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformInputAttachment_binding_set) 

static bool js_cc_gfx_UniformInputAttachment_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformInputAttachment *arg1 = (cc::gfx::UniformInputAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformInputAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformInputAttachment_binding_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->binding, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformInputAttachment_binding_get) 

static bool js_cc_gfx_UniformInputAttachment_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformInputAttachment *arg1 = (cc::gfx::UniformInputAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformInputAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformInputAttachment_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformInputAttachment_name_set) 

static bool js_cc_gfx_UniformInputAttachment_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformInputAttachment *arg1 = (cc::gfx::UniformInputAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformInputAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformInputAttachment_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformInputAttachment_name_get) 

static bool js_cc_gfx_UniformInputAttachment_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformInputAttachment *arg1 = (cc::gfx::UniformInputAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformInputAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformInputAttachment_count_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformInputAttachment_count_set) 

static bool js_cc_gfx_UniformInputAttachment_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformInputAttachment *arg1 = (cc::gfx::UniformInputAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformInputAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformInputAttachment_count_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->count, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformInputAttachment_count_get) 

static bool js_cc_gfx_UniformInputAttachment_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformInputAttachment *arg1 = (cc::gfx::UniformInputAttachment *) NULL ;
    cc::gfx::UniformInputAttachment *arg2 = 0 ;
    cc::gfx::UniformInputAttachment temp2 ;
    cc::gfx::UniformInputAttachment *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformInputAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "UniformInputAttachment_copy,2,SWIGTYPE_p_cc__gfx__UniformInputAttachment");
    arg2 = &temp2;
    
    result = (cc::gfx::UniformInputAttachment *) &(arg1)->copy((cc::gfx::UniformInputAttachment const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UniformInputAttachment_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_UniformInputAttachment_copy) 

// js_ctor
static bool js_new_cc_gfx_UniformInputAttachment(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::UniformInputAttachment *result;
    result = (cc::gfx::UniformInputAttachment *)new cc::gfx::UniformInputAttachment();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_UniformInputAttachment, __jsb_cc_gfx_UniformInputAttachment_class, js_delete_cc_gfx_UniformInputAttachment)

static bool js_delete_cc_gfx_UniformInputAttachment(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_UniformInputAttachment) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::UniformInputAttachment * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::UniformInputAttachment*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("set", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->set), ctx);
    }
    
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_UniformInputAttachment(se::Object* obj) {
    auto* cls = se::Class::create("UniformInputAttachment", obj, nullptr, _SE(js_new_cc_gfx_UniformInputAttachment)); 
    
    cls->defineProperty("set", _SE(js_cc_gfx_UniformInputAttachment_set_get), _SE(js_cc_gfx_UniformInputAttachment_set_set)); 
    cls->defineProperty("binding", _SE(js_cc_gfx_UniformInputAttachment_binding_get), _SE(js_cc_gfx_UniformInputAttachment_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_gfx_UniformInputAttachment_name_get), _SE(js_cc_gfx_UniformInputAttachment_name_set)); 
    cls->defineProperty("count", _SE(js_cc_gfx_UniformInputAttachment_count_get), _SE(js_cc_gfx_UniformInputAttachment_count_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_UniformInputAttachment_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_UniformInputAttachment));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::UniformInputAttachment>(cls);
    
    __jsb_cc_gfx_UniformInputAttachment_proto = cls->getProto();
    __jsb_cc_gfx_UniformInputAttachment_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_ShaderStage_class = nullptr;
se::Object* __jsb_cc_gfx_ShaderStage_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_ShaderStage) 

static bool js_cc_gfx_ShaderStage_stage_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderStage *arg1 = (cc::gfx::ShaderStage *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "ShaderStage_stage_set,2,SWIGTYPE_cc__gfx__ShaderStageFlagBit");
    arg1->stage = (cc::gfx::ShaderStageFlagBit)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ShaderStage_stage_set) 

static bool js_cc_gfx_ShaderStage_stage_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ShaderStage *arg1 = (cc::gfx::ShaderStage *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->stage));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ShaderStage_stage_get) 

static bool js_cc_gfx_ShaderStage_source_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderStage *arg1 = (cc::gfx::ShaderStage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->source, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShaderStage_source_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ShaderStage_source_set) 

static bool js_cc_gfx_ShaderStage_source_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ShaderStage *arg1 = (cc::gfx::ShaderStage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->source, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShaderStage_source_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->source, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ShaderStage_source_get) 

static bool js_cc_gfx_ShaderStage_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderStage *arg1 = (cc::gfx::ShaderStage *) NULL ;
    cc::gfx::ShaderStage *arg2 = 0 ;
    cc::gfx::ShaderStage temp2 ;
    cc::gfx::ShaderStage *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShaderStage_copy,2,SWIGTYPE_p_cc__gfx__ShaderStage");
    arg2 = &temp2;
    
    result = (cc::gfx::ShaderStage *) &(arg1)->copy((cc::gfx::ShaderStage const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShaderStage_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_ShaderStage_copy) 

// js_ctor
static bool js_new_cc_gfx_ShaderStage(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::ShaderStage *result;
    result = (cc::gfx::ShaderStage *)new cc::gfx::ShaderStage();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_ShaderStage, __jsb_cc_gfx_ShaderStage_class, js_delete_cc_gfx_ShaderStage)

static bool js_delete_cc_gfx_ShaderStage(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_ShaderStage) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::ShaderStage * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::ShaderStage*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("stage", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stage), ctx);
    }
    
    
    json->getProperty("source", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->source), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_ShaderStage(se::Object* obj) {
    auto* cls = se::Class::create("ShaderStage", obj, nullptr, _SE(js_new_cc_gfx_ShaderStage)); 
    
    cls->defineProperty("stage", _SE(js_cc_gfx_ShaderStage_stage_get), _SE(js_cc_gfx_ShaderStage_stage_set)); 
    cls->defineProperty("source", _SE(js_cc_gfx_ShaderStage_source_get), _SE(js_cc_gfx_ShaderStage_source_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_ShaderStage_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_ShaderStage));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::ShaderStage>(cls);
    
    __jsb_cc_gfx_ShaderStage_proto = cls->getProto();
    __jsb_cc_gfx_ShaderStage_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Attribute_class = nullptr;
se::Object* __jsb_cc_gfx_Attribute_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Attribute) 

static bool js_cc_gfx_Attribute_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Attribute *arg1 = (cc::gfx::Attribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Attribute>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Attribute_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Attribute_name_set) 

static bool js_cc_gfx_Attribute_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Attribute *arg1 = (cc::gfx::Attribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Attribute>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Attribute_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Attribute_name_get) 

static bool js_cc_gfx_Attribute_format_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Attribute *arg1 = (cc::gfx::Attribute *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Attribute>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "Attribute_format_set,2,SWIGTYPE_cc__gfx__Format");
    arg1->format = (cc::gfx::Format)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Attribute_format_set) 

static bool js_cc_gfx_Attribute_format_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Attribute *arg1 = (cc::gfx::Attribute *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Attribute>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->format));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Attribute_format_get) 

static bool js_cc_gfx_Attribute_isNormalized_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Attribute *arg1 = (cc::gfx::Attribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Attribute>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->isNormalized);
    SE_PRECONDITION2(ok, false, "Attribute_isNormalized_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Attribute_isNormalized_set) 

static bool js_cc_gfx_Attribute_isNormalized_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Attribute *arg1 = (cc::gfx::Attribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Attribute>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->isNormalized, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Attribute_isNormalized_get) 

static bool js_cc_gfx_Attribute_stream_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Attribute *arg1 = (cc::gfx::Attribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Attribute>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stream, s.thisObject());
    SE_PRECONDITION2(ok, false, "Attribute_stream_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Attribute_stream_set) 

static bool js_cc_gfx_Attribute_stream_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Attribute *arg1 = (cc::gfx::Attribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Attribute>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stream, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Attribute_stream_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stream, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Attribute_stream_get) 

static bool js_cc_gfx_Attribute_isInstanced_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Attribute *arg1 = (cc::gfx::Attribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Attribute>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->isInstanced);
    SE_PRECONDITION2(ok, false, "Attribute_isInstanced_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Attribute_isInstanced_set) 

static bool js_cc_gfx_Attribute_isInstanced_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Attribute *arg1 = (cc::gfx::Attribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Attribute>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->isInstanced, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Attribute_isInstanced_get) 

static bool js_cc_gfx_Attribute_location_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Attribute *arg1 = (cc::gfx::Attribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Attribute>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->location, s.thisObject());
    SE_PRECONDITION2(ok, false, "Attribute_location_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Attribute_location_set) 

static bool js_cc_gfx_Attribute_location_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Attribute *arg1 = (cc::gfx::Attribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Attribute>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->location, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Attribute_location_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->location, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Attribute_location_get) 

static bool js_cc_gfx_Attribute_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Attribute *arg1 = (cc::gfx::Attribute *) NULL ;
    cc::gfx::Attribute *arg2 = 0 ;
    cc::gfx::Attribute temp2 ;
    cc::gfx::Attribute *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Attribute>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Attribute_copy,2,SWIGTYPE_p_cc__gfx__Attribute");
    arg2 = &temp2;
    
    result = (cc::gfx::Attribute *) &(arg1)->copy((cc::gfx::Attribute const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Attribute_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Attribute_copy) 

// js_ctor
static bool js_new_cc_gfx_Attribute(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::Attribute *result;
    result = (cc::gfx::Attribute *)new cc::gfx::Attribute();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_Attribute, __jsb_cc_gfx_Attribute_class, js_delete_cc_gfx_Attribute)

static bool js_delete_cc_gfx_Attribute(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Attribute) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::Attribute * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::Attribute*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("format", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->format), ctx);
    }
    
    
    json->getProperty("isNormalized", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isNormalized), ctx);
    }
    
    
    json->getProperty("stream", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stream), ctx);
    }
    
    
    json->getProperty("isInstanced", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isInstanced), ctx);
    }
    
    
    json->getProperty("location", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->location), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_Attribute(se::Object* obj) {
    auto* cls = se::Class::create("Attribute", obj, nullptr, _SE(js_new_cc_gfx_Attribute)); 
    
    cls->defineProperty("name", _SE(js_cc_gfx_Attribute_name_get), _SE(js_cc_gfx_Attribute_name_set)); 
    cls->defineProperty("format", _SE(js_cc_gfx_Attribute_format_get), _SE(js_cc_gfx_Attribute_format_set)); 
    cls->defineProperty("isNormalized", _SE(js_cc_gfx_Attribute_isNormalized_get), _SE(js_cc_gfx_Attribute_isNormalized_set)); 
    cls->defineProperty("stream", _SE(js_cc_gfx_Attribute_stream_get), _SE(js_cc_gfx_Attribute_stream_set)); 
    cls->defineProperty("isInstanced", _SE(js_cc_gfx_Attribute_isInstanced_get), _SE(js_cc_gfx_Attribute_isInstanced_set)); 
    cls->defineProperty("location", _SE(js_cc_gfx_Attribute_location_get), _SE(js_cc_gfx_Attribute_location_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_Attribute_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Attribute));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Attribute>(cls);
    
    __jsb_cc_gfx_Attribute_proto = cls->getProto();
    __jsb_cc_gfx_Attribute_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_ShaderInfo_class = nullptr;
se::Object* __jsb_cc_gfx_ShaderInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_ShaderInfo) 

static bool js_cc_gfx_ShaderInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShaderInfo_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ShaderInfo_name_set) 

static bool js_cc_gfx_ShaderInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShaderInfo_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ShaderInfo_name_get) 

static bool js_cc_gfx_ShaderInfo_stages_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stages, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShaderInfo_stages_set,2,SWIGTYPE_ccstd__vectorT_cc__gfx__ShaderStage_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ShaderInfo_stages_set) 

static bool js_cc_gfx_ShaderInfo_stages_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stages, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShaderInfo_stages_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stages, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ShaderInfo_stages_get) 

static bool js_cc_gfx_ShaderInfo_attributes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->attributes, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShaderInfo_attributes_set,2,SWIGTYPE_ccstd__vectorT_cc__gfx__Attribute_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ShaderInfo_attributes_set) 

static bool js_cc_gfx_ShaderInfo_attributes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->attributes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShaderInfo_attributes_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->attributes, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ShaderInfo_attributes_get) 

static bool js_cc_gfx_ShaderInfo_blocks_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->blocks, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShaderInfo_blocks_set,2,SWIGTYPE_ccstd__vectorT_cc__gfx__UniformBlock_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ShaderInfo_blocks_set) 

static bool js_cc_gfx_ShaderInfo_blocks_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->blocks, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShaderInfo_blocks_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blocks, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ShaderInfo_blocks_get) 

static bool js_cc_gfx_ShaderInfo_buffers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->buffers, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShaderInfo_buffers_set,2,SWIGTYPE_ccstd__vectorT_cc__gfx__UniformStorageBuffer_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ShaderInfo_buffers_set) 

static bool js_cc_gfx_ShaderInfo_buffers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->buffers, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShaderInfo_buffers_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->buffers, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ShaderInfo_buffers_get) 

static bool js_cc_gfx_ShaderInfo_samplerTextures_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->samplerTextures, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShaderInfo_samplerTextures_set,2,SWIGTYPE_ccstd__vectorT_cc__gfx__UniformSamplerTexture_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ShaderInfo_samplerTextures_set) 

static bool js_cc_gfx_ShaderInfo_samplerTextures_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->samplerTextures, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShaderInfo_samplerTextures_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->samplerTextures, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ShaderInfo_samplerTextures_get) 

static bool js_cc_gfx_ShaderInfo_samplers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->samplers, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShaderInfo_samplers_set,2,SWIGTYPE_ccstd__vectorT_cc__gfx__UniformSampler_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ShaderInfo_samplers_set) 

static bool js_cc_gfx_ShaderInfo_samplers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->samplers, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShaderInfo_samplers_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->samplers, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ShaderInfo_samplers_get) 

static bool js_cc_gfx_ShaderInfo_textures_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->textures, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShaderInfo_textures_set,2,SWIGTYPE_ccstd__vectorT_cc__gfx__UniformTexture_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ShaderInfo_textures_set) 

static bool js_cc_gfx_ShaderInfo_textures_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->textures, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShaderInfo_textures_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->textures, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ShaderInfo_textures_get) 

static bool js_cc_gfx_ShaderInfo_images_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->images, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShaderInfo_images_set,2,SWIGTYPE_ccstd__vectorT_cc__gfx__UniformStorageImage_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ShaderInfo_images_set) 

static bool js_cc_gfx_ShaderInfo_images_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->images, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShaderInfo_images_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->images, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ShaderInfo_images_get) 

static bool js_cc_gfx_ShaderInfo_subpassInputs_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->subpassInputs, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShaderInfo_subpassInputs_set,2,SWIGTYPE_ccstd__vectorT_cc__gfx__UniformInputAttachment_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ShaderInfo_subpassInputs_set) 

static bool js_cc_gfx_ShaderInfo_subpassInputs_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->subpassInputs, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShaderInfo_subpassInputs_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->subpassInputs, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ShaderInfo_subpassInputs_get) 

static bool js_cc_gfx_ShaderInfo_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    cc::gfx::ShaderInfo *arg2 = 0 ;
    cc::gfx::ShaderInfo temp2 ;
    cc::gfx::ShaderInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShaderInfo_copy,2,SWIGTYPE_p_cc__gfx__ShaderInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::ShaderInfo *) &(arg1)->copy((cc::gfx::ShaderInfo const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShaderInfo_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_ShaderInfo_copy) 

// js_ctor
static bool js_new_cc_gfx_ShaderInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::ShaderInfo *result;
    result = (cc::gfx::ShaderInfo *)new cc::gfx::ShaderInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_ShaderInfo, __jsb_cc_gfx_ShaderInfo_class, js_delete_cc_gfx_ShaderInfo)

static bool js_delete_cc_gfx_ShaderInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_ShaderInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::ShaderInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::ShaderInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("stages", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stages), ctx);
    }
    
    
    json->getProperty("attributes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->attributes), ctx);
    }
    
    
    json->getProperty("blocks", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blocks), ctx);
    }
    
    
    json->getProperty("buffers", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->buffers), ctx);
    }
    
    
    json->getProperty("samplerTextures", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->samplerTextures), ctx);
    }
    
    
    json->getProperty("samplers", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->samplers), ctx);
    }
    
    
    json->getProperty("textures", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->textures), ctx);
    }
    
    
    json->getProperty("images", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->images), ctx);
    }
    
    
    json->getProperty("subpassInputs", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->subpassInputs), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_ShaderInfo(se::Object* obj) {
    auto* cls = se::Class::create("ShaderInfo", obj, nullptr, _SE(js_new_cc_gfx_ShaderInfo)); 
    
    cls->defineProperty("name", _SE(js_cc_gfx_ShaderInfo_name_get), _SE(js_cc_gfx_ShaderInfo_name_set)); 
    cls->defineProperty("stages", _SE(js_cc_gfx_ShaderInfo_stages_get), _SE(js_cc_gfx_ShaderInfo_stages_set)); 
    cls->defineProperty("attributes", _SE(js_cc_gfx_ShaderInfo_attributes_get), _SE(js_cc_gfx_ShaderInfo_attributes_set)); 
    cls->defineProperty("blocks", _SE(js_cc_gfx_ShaderInfo_blocks_get), _SE(js_cc_gfx_ShaderInfo_blocks_set)); 
    cls->defineProperty("buffers", _SE(js_cc_gfx_ShaderInfo_buffers_get), _SE(js_cc_gfx_ShaderInfo_buffers_set)); 
    cls->defineProperty("samplerTextures", _SE(js_cc_gfx_ShaderInfo_samplerTextures_get), _SE(js_cc_gfx_ShaderInfo_samplerTextures_set)); 
    cls->defineProperty("samplers", _SE(js_cc_gfx_ShaderInfo_samplers_get), _SE(js_cc_gfx_ShaderInfo_samplers_set)); 
    cls->defineProperty("textures", _SE(js_cc_gfx_ShaderInfo_textures_get), _SE(js_cc_gfx_ShaderInfo_textures_set)); 
    cls->defineProperty("images", _SE(js_cc_gfx_ShaderInfo_images_get), _SE(js_cc_gfx_ShaderInfo_images_set)); 
    cls->defineProperty("subpassInputs", _SE(js_cc_gfx_ShaderInfo_subpassInputs_get), _SE(js_cc_gfx_ShaderInfo_subpassInputs_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_ShaderInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_ShaderInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::ShaderInfo>(cls);
    
    __jsb_cc_gfx_ShaderInfo_proto = cls->getProto();
    __jsb_cc_gfx_ShaderInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_InputAssemblerInfo_class = nullptr;
se::Object* __jsb_cc_gfx_InputAssemblerInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_InputAssemblerInfo) 

static bool js_cc_gfx_InputAssemblerInfo_attributes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssemblerInfo *arg1 = (cc::gfx::InputAssemblerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssemblerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->attributes, s.thisObject());
    SE_PRECONDITION2(ok, false, "InputAssemblerInfo_attributes_set,2,SWIGTYPE_ccstd__vectorT_cc__gfx__Attribute_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_InputAssemblerInfo_attributes_set) 

static bool js_cc_gfx_InputAssemblerInfo_attributes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssemblerInfo *arg1 = (cc::gfx::InputAssemblerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssemblerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->attributes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InputAssemblerInfo_attributes_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->attributes, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssemblerInfo_attributes_get) 

static bool js_cc_gfx_InputAssemblerInfo_vertexBuffers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssemblerInfo *arg1 = (cc::gfx::InputAssemblerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssemblerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->vertexBuffers, s.thisObject());
    SE_PRECONDITION2(ok, false, "InputAssemblerInfo_vertexBuffers_set,2,SWIGTYPE_ccstd__vectorT_cc__gfx__Buffer_p_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_InputAssemblerInfo_vertexBuffers_set) 

static bool js_cc_gfx_InputAssemblerInfo_vertexBuffers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssemblerInfo *arg1 = (cc::gfx::InputAssemblerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssemblerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->vertexBuffers, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InputAssemblerInfo_vertexBuffers_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->vertexBuffers, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssemblerInfo_vertexBuffers_get) 

static bool js_cc_gfx_InputAssemblerInfo_indexBuffer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssemblerInfo *arg1 = (cc::gfx::InputAssemblerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssemblerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->indexBuffer, s.thisObject());
    SE_PRECONDITION2(ok, false, "InputAssemblerInfo_indexBuffer_set,2,SWIGTYPE_p_cc__gfx__Buffer"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_InputAssemblerInfo_indexBuffer_set) 

static bool js_cc_gfx_InputAssemblerInfo_indexBuffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssemblerInfo *arg1 = (cc::gfx::InputAssemblerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssemblerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->indexBuffer, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InputAssemblerInfo_indexBuffer_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->indexBuffer, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssemblerInfo_indexBuffer_get) 

static bool js_cc_gfx_InputAssemblerInfo_indirectBuffer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssemblerInfo *arg1 = (cc::gfx::InputAssemblerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssemblerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->indirectBuffer, s.thisObject());
    SE_PRECONDITION2(ok, false, "InputAssemblerInfo_indirectBuffer_set,2,SWIGTYPE_p_cc__gfx__Buffer"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_InputAssemblerInfo_indirectBuffer_set) 

static bool js_cc_gfx_InputAssemblerInfo_indirectBuffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssemblerInfo *arg1 = (cc::gfx::InputAssemblerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssemblerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->indirectBuffer, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InputAssemblerInfo_indirectBuffer_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->indirectBuffer, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssemblerInfo_indirectBuffer_get) 

static bool js_cc_gfx_InputAssemblerInfo_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssemblerInfo *arg1 = (cc::gfx::InputAssemblerInfo *) NULL ;
    cc::gfx::InputAssemblerInfo *arg2 = 0 ;
    cc::gfx::InputAssemblerInfo temp2 ;
    cc::gfx::InputAssemblerInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssemblerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "InputAssemblerInfo_copy,2,SWIGTYPE_p_cc__gfx__InputAssemblerInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::InputAssemblerInfo *) &(arg1)->copy((cc::gfx::InputAssemblerInfo const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InputAssemblerInfo_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_InputAssemblerInfo_copy) 

// js_ctor
static bool js_new_cc_gfx_InputAssemblerInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::InputAssemblerInfo *result;
    result = (cc::gfx::InputAssemblerInfo *)new cc::gfx::InputAssemblerInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_InputAssemblerInfo, __jsb_cc_gfx_InputAssemblerInfo_class, js_delete_cc_gfx_InputAssemblerInfo)

static bool js_delete_cc_gfx_InputAssemblerInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_InputAssemblerInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::InputAssemblerInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::InputAssemblerInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("attributes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->attributes), ctx);
    }
    
    
    json->getProperty("vertexBuffers", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->vertexBuffers), ctx);
    }
    
    
    json->getProperty("indexBuffer", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->indexBuffer), ctx);
    }
    
    
    json->getProperty("indirectBuffer", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->indirectBuffer), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_InputAssemblerInfo(se::Object* obj) {
    auto* cls = se::Class::create("InputAssemblerInfo", obj, nullptr, _SE(js_new_cc_gfx_InputAssemblerInfo)); 
    
    cls->defineProperty("attributes", _SE(js_cc_gfx_InputAssemblerInfo_attributes_get), _SE(js_cc_gfx_InputAssemblerInfo_attributes_set)); 
    cls->defineProperty("vertexBuffers", _SE(js_cc_gfx_InputAssemblerInfo_vertexBuffers_get), _SE(js_cc_gfx_InputAssemblerInfo_vertexBuffers_set)); 
    cls->defineProperty("indexBuffer", _SE(js_cc_gfx_InputAssemblerInfo_indexBuffer_get), _SE(js_cc_gfx_InputAssemblerInfo_indexBuffer_set)); 
    cls->defineProperty("indirectBuffer", _SE(js_cc_gfx_InputAssemblerInfo_indirectBuffer_get), _SE(js_cc_gfx_InputAssemblerInfo_indirectBuffer_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_InputAssemblerInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_InputAssemblerInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::InputAssemblerInfo>(cls);
    
    __jsb_cc_gfx_InputAssemblerInfo_proto = cls->getProto();
    __jsb_cc_gfx_InputAssemblerInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_ColorAttachment_class = nullptr;
se::Object* __jsb_cc_gfx_ColorAttachment_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_ColorAttachment) 

static bool js_cc_gfx_ColorAttachment_format_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ColorAttachment *arg1 = (cc::gfx::ColorAttachment *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ColorAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "ColorAttachment_format_set,2,SWIGTYPE_cc__gfx__Format");
    arg1->format = (cc::gfx::Format)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ColorAttachment_format_set) 

static bool js_cc_gfx_ColorAttachment_format_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ColorAttachment *arg1 = (cc::gfx::ColorAttachment *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ColorAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->format));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ColorAttachment_format_get) 

static bool js_cc_gfx_ColorAttachment_sampleCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ColorAttachment *arg1 = (cc::gfx::ColorAttachment *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ColorAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "ColorAttachment_sampleCount_set,2,SWIGTYPE_cc__gfx__SampleCount");
    arg1->sampleCount = (cc::gfx::SampleCount)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ColorAttachment_sampleCount_set) 

static bool js_cc_gfx_ColorAttachment_sampleCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ColorAttachment *arg1 = (cc::gfx::ColorAttachment *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ColorAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->sampleCount));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ColorAttachment_sampleCount_get) 

static bool js_cc_gfx_ColorAttachment_loadOp_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ColorAttachment *arg1 = (cc::gfx::ColorAttachment *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ColorAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "ColorAttachment_loadOp_set,2,SWIGTYPE_cc__gfx__LoadOp");
    arg1->loadOp = (cc::gfx::LoadOp)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ColorAttachment_loadOp_set) 

static bool js_cc_gfx_ColorAttachment_loadOp_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ColorAttachment *arg1 = (cc::gfx::ColorAttachment *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ColorAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->loadOp));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ColorAttachment_loadOp_get) 

static bool js_cc_gfx_ColorAttachment_storeOp_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ColorAttachment *arg1 = (cc::gfx::ColorAttachment *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ColorAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "ColorAttachment_storeOp_set,2,SWIGTYPE_cc__gfx__StoreOp");
    arg1->storeOp = (cc::gfx::StoreOp)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ColorAttachment_storeOp_set) 

static bool js_cc_gfx_ColorAttachment_storeOp_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ColorAttachment *arg1 = (cc::gfx::ColorAttachment *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ColorAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->storeOp));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ColorAttachment_storeOp_get) 

static bool js_cc_gfx_ColorAttachment_barrier_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ColorAttachment *arg1 = (cc::gfx::ColorAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ColorAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->barrier, s.thisObject());
    SE_PRECONDITION2(ok, false, "ColorAttachment_barrier_set,2,SWIGTYPE_p_cc__gfx__GeneralBarrier"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ColorAttachment_barrier_set) 

static bool js_cc_gfx_ColorAttachment_barrier_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ColorAttachment *arg1 = (cc::gfx::ColorAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ColorAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->barrier, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ColorAttachment_barrier_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->barrier, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ColorAttachment_barrier_get) 

static bool js_cc_gfx_ColorAttachment_isGeneralLayout_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ColorAttachment *arg1 = (cc::gfx::ColorAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ColorAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->isGeneralLayout, s.thisObject());
    SE_PRECONDITION2(ok, false, "ColorAttachment_isGeneralLayout_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ColorAttachment_isGeneralLayout_set) 

static bool js_cc_gfx_ColorAttachment_isGeneralLayout_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ColorAttachment *arg1 = (cc::gfx::ColorAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ColorAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->isGeneralLayout, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ColorAttachment_isGeneralLayout_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->isGeneralLayout, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ColorAttachment_isGeneralLayout_get) 

static bool js_cc_gfx_ColorAttachment_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ColorAttachment *arg1 = (cc::gfx::ColorAttachment *) NULL ;
    cc::gfx::ColorAttachment *arg2 = 0 ;
    cc::gfx::ColorAttachment temp2 ;
    cc::gfx::ColorAttachment *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::ColorAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ColorAttachment_copy,2,SWIGTYPE_p_cc__gfx__ColorAttachment");
    arg2 = &temp2;
    
    result = (cc::gfx::ColorAttachment *) &(arg1)->copy((cc::gfx::ColorAttachment const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ColorAttachment_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_ColorAttachment_copy) 

// js_ctor
static bool js_new_cc_gfx_ColorAttachment(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::ColorAttachment *result;
    result = (cc::gfx::ColorAttachment *)new cc::gfx::ColorAttachment();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_ColorAttachment, __jsb_cc_gfx_ColorAttachment_class, js_delete_cc_gfx_ColorAttachment)

static bool js_delete_cc_gfx_ColorAttachment(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_ColorAttachment) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::ColorAttachment * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::ColorAttachment*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("format", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->format), ctx);
    }
    
    
    json->getProperty("sampleCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->sampleCount), ctx);
    }
    
    
    json->getProperty("loadOp", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->loadOp), ctx);
    }
    
    
    json->getProperty("storeOp", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->storeOp), ctx);
    }
    
    
    json->getProperty("barrier", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->barrier), ctx);
    }
    
    
    json->getProperty("isGeneralLayout", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isGeneralLayout), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_ColorAttachment(se::Object* obj) {
    auto* cls = se::Class::create("ColorAttachment", obj, nullptr, _SE(js_new_cc_gfx_ColorAttachment)); 
    
    cls->defineProperty("format", _SE(js_cc_gfx_ColorAttachment_format_get), _SE(js_cc_gfx_ColorAttachment_format_set)); 
    cls->defineProperty("sampleCount", _SE(js_cc_gfx_ColorAttachment_sampleCount_get), _SE(js_cc_gfx_ColorAttachment_sampleCount_set)); 
    cls->defineProperty("loadOp", _SE(js_cc_gfx_ColorAttachment_loadOp_get), _SE(js_cc_gfx_ColorAttachment_loadOp_set)); 
    cls->defineProperty("storeOp", _SE(js_cc_gfx_ColorAttachment_storeOp_get), _SE(js_cc_gfx_ColorAttachment_storeOp_set)); 
    cls->defineProperty("barrier", _SE(js_cc_gfx_ColorAttachment_barrier_get), _SE(js_cc_gfx_ColorAttachment_barrier_set)); 
    cls->defineProperty("isGeneralLayout", _SE(js_cc_gfx_ColorAttachment_isGeneralLayout_get), _SE(js_cc_gfx_ColorAttachment_isGeneralLayout_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_ColorAttachment_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_ColorAttachment));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::ColorAttachment>(cls);
    
    __jsb_cc_gfx_ColorAttachment_proto = cls->getProto();
    __jsb_cc_gfx_ColorAttachment_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DepthStencilAttachment_class = nullptr;
se::Object* __jsb_cc_gfx_DepthStencilAttachment_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DepthStencilAttachment) 

static bool js_cc_gfx_DepthStencilAttachment_format_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "DepthStencilAttachment_format_set,2,SWIGTYPE_cc__gfx__Format");
    arg1->format = (cc::gfx::Format)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilAttachment_format_set) 

static bool js_cc_gfx_DepthStencilAttachment_format_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->format));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilAttachment_format_get) 

static bool js_cc_gfx_DepthStencilAttachment_sampleCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "DepthStencilAttachment_sampleCount_set,2,SWIGTYPE_cc__gfx__SampleCount");
    arg1->sampleCount = (cc::gfx::SampleCount)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilAttachment_sampleCount_set) 

static bool js_cc_gfx_DepthStencilAttachment_sampleCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->sampleCount));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilAttachment_sampleCount_get) 

static bool js_cc_gfx_DepthStencilAttachment_depthLoadOp_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "DepthStencilAttachment_depthLoadOp_set,2,SWIGTYPE_cc__gfx__LoadOp");
    arg1->depthLoadOp = (cc::gfx::LoadOp)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilAttachment_depthLoadOp_set) 

static bool js_cc_gfx_DepthStencilAttachment_depthLoadOp_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->depthLoadOp));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilAttachment_depthLoadOp_get) 

static bool js_cc_gfx_DepthStencilAttachment_depthStoreOp_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "DepthStencilAttachment_depthStoreOp_set,2,SWIGTYPE_cc__gfx__StoreOp");
    arg1->depthStoreOp = (cc::gfx::StoreOp)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilAttachment_depthStoreOp_set) 

static bool js_cc_gfx_DepthStencilAttachment_depthStoreOp_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->depthStoreOp));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilAttachment_depthStoreOp_get) 

static bool js_cc_gfx_DepthStencilAttachment_stencilLoadOp_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "DepthStencilAttachment_stencilLoadOp_set,2,SWIGTYPE_cc__gfx__LoadOp");
    arg1->stencilLoadOp = (cc::gfx::LoadOp)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilAttachment_stencilLoadOp_set) 

static bool js_cc_gfx_DepthStencilAttachment_stencilLoadOp_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->stencilLoadOp));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilAttachment_stencilLoadOp_get) 

static bool js_cc_gfx_DepthStencilAttachment_stencilStoreOp_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "DepthStencilAttachment_stencilStoreOp_set,2,SWIGTYPE_cc__gfx__StoreOp");
    arg1->stencilStoreOp = (cc::gfx::StoreOp)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilAttachment_stencilStoreOp_set) 

static bool js_cc_gfx_DepthStencilAttachment_stencilStoreOp_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->stencilStoreOp));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilAttachment_stencilStoreOp_get) 

static bool js_cc_gfx_DepthStencilAttachment_barrier_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->barrier, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilAttachment_barrier_set,2,SWIGTYPE_p_cc__gfx__GeneralBarrier"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilAttachment_barrier_set) 

static bool js_cc_gfx_DepthStencilAttachment_barrier_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->barrier, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilAttachment_barrier_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->barrier, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilAttachment_barrier_get) 

static bool js_cc_gfx_DepthStencilAttachment_isGeneralLayout_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->isGeneralLayout, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilAttachment_isGeneralLayout_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilAttachment_isGeneralLayout_set) 

static bool js_cc_gfx_DepthStencilAttachment_isGeneralLayout_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->isGeneralLayout, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilAttachment_isGeneralLayout_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->isGeneralLayout, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilAttachment_isGeneralLayout_get) 

static bool js_cc_gfx_DepthStencilAttachment_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    cc::gfx::DepthStencilAttachment *arg2 = 0 ;
    cc::gfx::DepthStencilAttachment temp2 ;
    cc::gfx::DepthStencilAttachment *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilAttachment_copy,2,SWIGTYPE_p_cc__gfx__DepthStencilAttachment");
    arg2 = &temp2;
    
    result = (cc::gfx::DepthStencilAttachment *) &(arg1)->copy((cc::gfx::DepthStencilAttachment const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilAttachment_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DepthStencilAttachment_copy) 

// js_ctor
static bool js_new_cc_gfx_DepthStencilAttachment(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::DepthStencilAttachment *result;
    result = (cc::gfx::DepthStencilAttachment *)new cc::gfx::DepthStencilAttachment();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_DepthStencilAttachment, __jsb_cc_gfx_DepthStencilAttachment_class, js_delete_cc_gfx_DepthStencilAttachment)

static bool js_delete_cc_gfx_DepthStencilAttachment(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DepthStencilAttachment) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::DepthStencilAttachment * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::DepthStencilAttachment*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("format", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->format), ctx);
    }
    
    
    json->getProperty("sampleCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->sampleCount), ctx);
    }
    
    
    json->getProperty("depthLoadOp", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthLoadOp), ctx);
    }
    
    
    json->getProperty("depthStoreOp", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthStoreOp), ctx);
    }
    
    
    json->getProperty("stencilLoadOp", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilLoadOp), ctx);
    }
    
    
    json->getProperty("stencilStoreOp", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilStoreOp), ctx);
    }
    
    
    json->getProperty("barrier", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->barrier), ctx);
    }
    
    
    json->getProperty("isGeneralLayout", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isGeneralLayout), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_DepthStencilAttachment(se::Object* obj) {
    auto* cls = se::Class::create("DepthStencilAttachment", obj, nullptr, _SE(js_new_cc_gfx_DepthStencilAttachment)); 
    
    cls->defineProperty("format", _SE(js_cc_gfx_DepthStencilAttachment_format_get), _SE(js_cc_gfx_DepthStencilAttachment_format_set)); 
    cls->defineProperty("sampleCount", _SE(js_cc_gfx_DepthStencilAttachment_sampleCount_get), _SE(js_cc_gfx_DepthStencilAttachment_sampleCount_set)); 
    cls->defineProperty("depthLoadOp", _SE(js_cc_gfx_DepthStencilAttachment_depthLoadOp_get), _SE(js_cc_gfx_DepthStencilAttachment_depthLoadOp_set)); 
    cls->defineProperty("depthStoreOp", _SE(js_cc_gfx_DepthStencilAttachment_depthStoreOp_get), _SE(js_cc_gfx_DepthStencilAttachment_depthStoreOp_set)); 
    cls->defineProperty("stencilLoadOp", _SE(js_cc_gfx_DepthStencilAttachment_stencilLoadOp_get), _SE(js_cc_gfx_DepthStencilAttachment_stencilLoadOp_set)); 
    cls->defineProperty("stencilStoreOp", _SE(js_cc_gfx_DepthStencilAttachment_stencilStoreOp_get), _SE(js_cc_gfx_DepthStencilAttachment_stencilStoreOp_set)); 
    cls->defineProperty("barrier", _SE(js_cc_gfx_DepthStencilAttachment_barrier_get), _SE(js_cc_gfx_DepthStencilAttachment_barrier_set)); 
    cls->defineProperty("isGeneralLayout", _SE(js_cc_gfx_DepthStencilAttachment_isGeneralLayout_get), _SE(js_cc_gfx_DepthStencilAttachment_isGeneralLayout_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_DepthStencilAttachment_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DepthStencilAttachment));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DepthStencilAttachment>(cls);
    
    __jsb_cc_gfx_DepthStencilAttachment_proto = cls->getProto();
    __jsb_cc_gfx_DepthStencilAttachment_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_SubpassInfo_class = nullptr;
se::Object* __jsb_cc_gfx_SubpassInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_SubpassInfo) 

static bool js_cc_gfx_SubpassInfo_inputs_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->inputs, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubpassInfo_inputs_set,2,SWIGTYPE_ccstd__vectorT_uint32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassInfo_inputs_set) 

static bool js_cc_gfx_SubpassInfo_inputs_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->inputs, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubpassInfo_inputs_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->inputs, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassInfo_inputs_get) 

static bool js_cc_gfx_SubpassInfo_colors_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->colors, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubpassInfo_colors_set,2,SWIGTYPE_ccstd__vectorT_uint32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassInfo_colors_set) 

static bool js_cc_gfx_SubpassInfo_colors_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->colors, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubpassInfo_colors_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->colors, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassInfo_colors_get) 

static bool js_cc_gfx_SubpassInfo_resolves_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->resolves, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubpassInfo_resolves_set,2,SWIGTYPE_ccstd__vectorT_uint32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassInfo_resolves_set) 

static bool js_cc_gfx_SubpassInfo_resolves_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->resolves, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubpassInfo_resolves_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->resolves, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassInfo_resolves_get) 

static bool js_cc_gfx_SubpassInfo_preserves_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->preserves, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubpassInfo_preserves_set,2,SWIGTYPE_ccstd__vectorT_uint32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassInfo_preserves_set) 

static bool js_cc_gfx_SubpassInfo_preserves_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->preserves, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubpassInfo_preserves_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->preserves, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassInfo_preserves_get) 

static bool js_cc_gfx_SubpassInfo_depthStencil_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->depthStencil, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubpassInfo_depthStencil_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassInfo_depthStencil_set) 

static bool js_cc_gfx_SubpassInfo_depthStencil_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->depthStencil, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubpassInfo_depthStencil_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthStencil, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassInfo_depthStencil_get) 

static bool js_cc_gfx_SubpassInfo_depthStencilResolve_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->depthStencilResolve, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubpassInfo_depthStencilResolve_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassInfo_depthStencilResolve_set) 

static bool js_cc_gfx_SubpassInfo_depthStencilResolve_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->depthStencilResolve, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubpassInfo_depthStencilResolve_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthStencilResolve, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassInfo_depthStencilResolve_get) 

static bool js_cc_gfx_SubpassInfo_depthResolveMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "SubpassInfo_depthResolveMode_set,2,SWIGTYPE_cc__gfx__ResolveMode");
    arg1->depthResolveMode = (cc::gfx::ResolveMode)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassInfo_depthResolveMode_set) 

static bool js_cc_gfx_SubpassInfo_depthResolveMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->depthResolveMode));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassInfo_depthResolveMode_get) 

static bool js_cc_gfx_SubpassInfo_stencilResolveMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "SubpassInfo_stencilResolveMode_set,2,SWIGTYPE_cc__gfx__ResolveMode");
    arg1->stencilResolveMode = (cc::gfx::ResolveMode)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassInfo_stencilResolveMode_set) 

static bool js_cc_gfx_SubpassInfo_stencilResolveMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->stencilResolveMode));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassInfo_stencilResolveMode_get) 

static bool js_cc_gfx_SubpassInfo_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    cc::gfx::SubpassInfo *arg2 = 0 ;
    cc::gfx::SubpassInfo temp2 ;
    cc::gfx::SubpassInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubpassInfo_copy,2,SWIGTYPE_p_cc__gfx__SubpassInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::SubpassInfo *) &(arg1)->copy((cc::gfx::SubpassInfo const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubpassInfo_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_SubpassInfo_copy) 

// js_ctor
static bool js_new_cc_gfx_SubpassInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::SubpassInfo *result;
    result = (cc::gfx::SubpassInfo *)new cc::gfx::SubpassInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_SubpassInfo, __jsb_cc_gfx_SubpassInfo_class, js_delete_cc_gfx_SubpassInfo)

static bool js_delete_cc_gfx_SubpassInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_SubpassInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::SubpassInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::SubpassInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("inputs", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->inputs), ctx);
    }
    
    
    json->getProperty("colors", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->colors), ctx);
    }
    
    
    json->getProperty("resolves", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->resolves), ctx);
    }
    
    
    json->getProperty("preserves", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->preserves), ctx);
    }
    
    
    json->getProperty("depthStencil", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthStencil), ctx);
    }
    
    
    json->getProperty("depthStencilResolve", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthStencilResolve), ctx);
    }
    
    
    json->getProperty("depthResolveMode", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthResolveMode), ctx);
    }
    
    
    json->getProperty("stencilResolveMode", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilResolveMode), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_SubpassInfo(se::Object* obj) {
    auto* cls = se::Class::create("SubpassInfo", obj, nullptr, _SE(js_new_cc_gfx_SubpassInfo)); 
    
    cls->defineProperty("inputs", _SE(js_cc_gfx_SubpassInfo_inputs_get), _SE(js_cc_gfx_SubpassInfo_inputs_set)); 
    cls->defineProperty("colors", _SE(js_cc_gfx_SubpassInfo_colors_get), _SE(js_cc_gfx_SubpassInfo_colors_set)); 
    cls->defineProperty("resolves", _SE(js_cc_gfx_SubpassInfo_resolves_get), _SE(js_cc_gfx_SubpassInfo_resolves_set)); 
    cls->defineProperty("preserves", _SE(js_cc_gfx_SubpassInfo_preserves_get), _SE(js_cc_gfx_SubpassInfo_preserves_set)); 
    cls->defineProperty("depthStencil", _SE(js_cc_gfx_SubpassInfo_depthStencil_get), _SE(js_cc_gfx_SubpassInfo_depthStencil_set)); 
    cls->defineProperty("depthStencilResolve", _SE(js_cc_gfx_SubpassInfo_depthStencilResolve_get), _SE(js_cc_gfx_SubpassInfo_depthStencilResolve_set)); 
    cls->defineProperty("depthResolveMode", _SE(js_cc_gfx_SubpassInfo_depthResolveMode_get), _SE(js_cc_gfx_SubpassInfo_depthResolveMode_set)); 
    cls->defineProperty("stencilResolveMode", _SE(js_cc_gfx_SubpassInfo_stencilResolveMode_get), _SE(js_cc_gfx_SubpassInfo_stencilResolveMode_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_SubpassInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_SubpassInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::SubpassInfo>(cls);
    
    __jsb_cc_gfx_SubpassInfo_proto = cls->getProto();
    __jsb_cc_gfx_SubpassInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_SubpassDependency_class = nullptr;
se::Object* __jsb_cc_gfx_SubpassDependency_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_SubpassDependency) 

static bool js_cc_gfx_SubpassDependency_srcSubpass_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->srcSubpass, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubpassDependency_srcSubpass_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassDependency_srcSubpass_set) 

static bool js_cc_gfx_SubpassDependency_srcSubpass_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->srcSubpass, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubpassDependency_srcSubpass_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->srcSubpass, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassDependency_srcSubpass_get) 

static bool js_cc_gfx_SubpassDependency_dstSubpass_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->dstSubpass, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubpassDependency_dstSubpass_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassDependency_dstSubpass_set) 

static bool js_cc_gfx_SubpassDependency_dstSubpass_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->dstSubpass, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubpassDependency_dstSubpass_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->dstSubpass, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassDependency_dstSubpass_get) 

static bool js_cc_gfx_SubpassDependency_generalBarrier_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->generalBarrier, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubpassDependency_generalBarrier_set,2,SWIGTYPE_p_cc__gfx__GeneralBarrier"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassDependency_generalBarrier_set) 

static bool js_cc_gfx_SubpassDependency_generalBarrier_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->generalBarrier, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubpassDependency_generalBarrier_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->generalBarrier, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassDependency_generalBarrier_get) 

static bool js_cc_gfx_SubpassDependency_bufferBarriers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->bufferBarriers, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubpassDependency_bufferBarriers_set,2,SWIGTYPE_p_p_cc__gfx__BufferBarrier"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassDependency_bufferBarriers_set) 

static bool js_cc_gfx_SubpassDependency_bufferBarriers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->bufferBarriers, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubpassDependency_bufferBarriers_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->bufferBarriers, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassDependency_bufferBarriers_get) 

static bool js_cc_gfx_SubpassDependency_buffers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->buffers, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubpassDependency_buffers_set,2,SWIGTYPE_p_p_cc__gfx__Buffer"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassDependency_buffers_set) 

static bool js_cc_gfx_SubpassDependency_buffers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->buffers, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubpassDependency_buffers_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->buffers, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassDependency_buffers_get) 

static bool js_cc_gfx_SubpassDependency_bufferBarrierCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->bufferBarrierCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubpassDependency_bufferBarrierCount_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassDependency_bufferBarrierCount_set) 

static bool js_cc_gfx_SubpassDependency_bufferBarrierCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->bufferBarrierCount, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubpassDependency_bufferBarrierCount_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->bufferBarrierCount, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassDependency_bufferBarrierCount_get) 

static bool js_cc_gfx_SubpassDependency_textureBarriers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->textureBarriers, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubpassDependency_textureBarriers_set,2,SWIGTYPE_p_p_cc__gfx__TextureBarrier"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassDependency_textureBarriers_set) 

static bool js_cc_gfx_SubpassDependency_textureBarriers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->textureBarriers, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubpassDependency_textureBarriers_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->textureBarriers, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassDependency_textureBarriers_get) 

static bool js_cc_gfx_SubpassDependency_textures_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->textures, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubpassDependency_textures_set,2,SWIGTYPE_p_p_cc__gfx__Texture"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassDependency_textures_set) 

static bool js_cc_gfx_SubpassDependency_textures_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->textures, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubpassDependency_textures_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->textures, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassDependency_textures_get) 

static bool js_cc_gfx_SubpassDependency_textureBarrierCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->textureBarrierCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubpassDependency_textureBarrierCount_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassDependency_textureBarrierCount_set) 

static bool js_cc_gfx_SubpassDependency_textureBarrierCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->textureBarrierCount, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubpassDependency_textureBarrierCount_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->textureBarrierCount, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassDependency_textureBarrierCount_get) 

static bool js_cc_gfx_SubpassDependency_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    cc::gfx::SubpassDependency *arg2 = 0 ;
    cc::gfx::SubpassDependency temp2 ;
    cc::gfx::SubpassDependency *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubpassDependency_copy,2,SWIGTYPE_p_cc__gfx__SubpassDependency");
    arg2 = &temp2;
    
    result = (cc::gfx::SubpassDependency *) &(arg1)->copy((cc::gfx::SubpassDependency const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubpassDependency_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_SubpassDependency_copy) 

// js_ctor
static bool js_new_cc_gfx_SubpassDependency(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::SubpassDependency *result;
    result = (cc::gfx::SubpassDependency *)new cc::gfx::SubpassDependency();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_SubpassDependency, __jsb_cc_gfx_SubpassDependency_class, js_delete_cc_gfx_SubpassDependency)

static bool js_delete_cc_gfx_SubpassDependency(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_SubpassDependency) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::SubpassDependency * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::SubpassDependency*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("srcSubpass", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->srcSubpass), ctx);
    }
    
    
    json->getProperty("dstSubpass", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dstSubpass), ctx);
    }
    
    
    json->getProperty("generalBarrier", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->generalBarrier), ctx);
    }
    
    
    json->getProperty("bufferBarriers", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->bufferBarriers), ctx);
    }
    
    
    json->getProperty("buffers", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->buffers), ctx);
    }
    
    
    json->getProperty("bufferBarrierCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->bufferBarrierCount), ctx);
    }
    
    
    json->getProperty("textureBarriers", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->textureBarriers), ctx);
    }
    
    
    json->getProperty("textures", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->textures), ctx);
    }
    
    
    json->getProperty("textureBarrierCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->textureBarrierCount), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_SubpassDependency(se::Object* obj) {
    auto* cls = se::Class::create("SubpassDependency", obj, nullptr, _SE(js_new_cc_gfx_SubpassDependency)); 
    
    cls->defineProperty("srcSubpass", _SE(js_cc_gfx_SubpassDependency_srcSubpass_get), _SE(js_cc_gfx_SubpassDependency_srcSubpass_set)); 
    cls->defineProperty("dstSubpass", _SE(js_cc_gfx_SubpassDependency_dstSubpass_get), _SE(js_cc_gfx_SubpassDependency_dstSubpass_set)); 
    cls->defineProperty("generalBarrier", _SE(js_cc_gfx_SubpassDependency_generalBarrier_get), _SE(js_cc_gfx_SubpassDependency_generalBarrier_set)); 
    cls->defineProperty("bufferBarriers", _SE(js_cc_gfx_SubpassDependency_bufferBarriers_get), _SE(js_cc_gfx_SubpassDependency_bufferBarriers_set)); 
    cls->defineProperty("buffers", _SE(js_cc_gfx_SubpassDependency_buffers_get), _SE(js_cc_gfx_SubpassDependency_buffers_set)); 
    cls->defineProperty("bufferBarrierCount", _SE(js_cc_gfx_SubpassDependency_bufferBarrierCount_get), _SE(js_cc_gfx_SubpassDependency_bufferBarrierCount_set)); 
    cls->defineProperty("textureBarriers", _SE(js_cc_gfx_SubpassDependency_textureBarriers_get), _SE(js_cc_gfx_SubpassDependency_textureBarriers_set)); 
    cls->defineProperty("textures", _SE(js_cc_gfx_SubpassDependency_textures_get), _SE(js_cc_gfx_SubpassDependency_textures_set)); 
    cls->defineProperty("textureBarrierCount", _SE(js_cc_gfx_SubpassDependency_textureBarrierCount_get), _SE(js_cc_gfx_SubpassDependency_textureBarrierCount_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_SubpassDependency_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_SubpassDependency));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::SubpassDependency>(cls);
    
    __jsb_cc_gfx_SubpassDependency_proto = cls->getProto();
    __jsb_cc_gfx_SubpassDependency_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_RenderPassInfo_class = nullptr;
se::Object* __jsb_cc_gfx_RenderPassInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_RenderPassInfo) 

static bool js_cc_gfx_RenderPassInfo_colorAttachments_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RenderPassInfo *arg1 = (cc::gfx::RenderPassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPassInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->colorAttachments, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPassInfo_colorAttachments_set,2,SWIGTYPE_ccstd__vectorT_cc__gfx__ColorAttachment_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RenderPassInfo_colorAttachments_set) 

static bool js_cc_gfx_RenderPassInfo_colorAttachments_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RenderPassInfo *arg1 = (cc::gfx::RenderPassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPassInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->colorAttachments, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPassInfo_colorAttachments_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->colorAttachments, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RenderPassInfo_colorAttachments_get) 

static bool js_cc_gfx_RenderPassInfo_depthStencilAttachment_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RenderPassInfo *arg1 = (cc::gfx::RenderPassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPassInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->depthStencilAttachment, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPassInfo_depthStencilAttachment_set,2,SWIGTYPE_cc__gfx__DepthStencilAttachment"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RenderPassInfo_depthStencilAttachment_set) 

static bool js_cc_gfx_RenderPassInfo_depthStencilAttachment_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RenderPassInfo *arg1 = (cc::gfx::RenderPassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPassInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->depthStencilAttachment, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPassInfo_depthStencilAttachment_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthStencilAttachment, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RenderPassInfo_depthStencilAttachment_get) 

static bool js_cc_gfx_RenderPassInfo_subpasses_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RenderPassInfo *arg1 = (cc::gfx::RenderPassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPassInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->subpasses, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPassInfo_subpasses_set,2,SWIGTYPE_ccstd__vectorT_cc__gfx__SubpassInfo_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RenderPassInfo_subpasses_set) 

static bool js_cc_gfx_RenderPassInfo_subpasses_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RenderPassInfo *arg1 = (cc::gfx::RenderPassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPassInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->subpasses, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPassInfo_subpasses_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->subpasses, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RenderPassInfo_subpasses_get) 

static bool js_cc_gfx_RenderPassInfo_dependencies_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RenderPassInfo *arg1 = (cc::gfx::RenderPassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPassInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->dependencies, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPassInfo_dependencies_set,2,SWIGTYPE_ccstd__vectorT_cc__gfx__SubpassDependency_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RenderPassInfo_dependencies_set) 

static bool js_cc_gfx_RenderPassInfo_dependencies_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RenderPassInfo *arg1 = (cc::gfx::RenderPassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPassInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->dependencies, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPassInfo_dependencies_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->dependencies, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RenderPassInfo_dependencies_get) 

static bool js_cc_gfx_RenderPassInfo_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RenderPassInfo *arg1 = (cc::gfx::RenderPassInfo *) NULL ;
    cc::gfx::RenderPassInfo *arg2 = 0 ;
    cc::gfx::RenderPassInfo temp2 ;
    cc::gfx::RenderPassInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPassInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPassInfo_copy,2,SWIGTYPE_p_cc__gfx__RenderPassInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::RenderPassInfo *) &(arg1)->copy((cc::gfx::RenderPassInfo const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPassInfo_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_RenderPassInfo_copy) 

// js_ctor
static bool js_new_cc_gfx_RenderPassInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::RenderPassInfo *result;
    result = (cc::gfx::RenderPassInfo *)new cc::gfx::RenderPassInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_RenderPassInfo, __jsb_cc_gfx_RenderPassInfo_class, js_delete_cc_gfx_RenderPassInfo)

static bool js_delete_cc_gfx_RenderPassInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_RenderPassInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::RenderPassInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::RenderPassInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("colorAttachments", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->colorAttachments), ctx);
    }
    
    
    json->getProperty("depthStencilAttachment", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthStencilAttachment), ctx);
    }
    
    
    json->getProperty("subpasses", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->subpasses), ctx);
    }
    
    
    json->getProperty("dependencies", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dependencies), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_RenderPassInfo(se::Object* obj) {
    auto* cls = se::Class::create("RenderPassInfo", obj, nullptr, _SE(js_new_cc_gfx_RenderPassInfo)); 
    
    cls->defineProperty("colorAttachments", _SE(js_cc_gfx_RenderPassInfo_colorAttachments_get), _SE(js_cc_gfx_RenderPassInfo_colorAttachments_set)); 
    cls->defineProperty("depthStencilAttachment", _SE(js_cc_gfx_RenderPassInfo_depthStencilAttachment_get), _SE(js_cc_gfx_RenderPassInfo_depthStencilAttachment_set)); 
    cls->defineProperty("subpasses", _SE(js_cc_gfx_RenderPassInfo_subpasses_get), _SE(js_cc_gfx_RenderPassInfo_subpasses_set)); 
    cls->defineProperty("dependencies", _SE(js_cc_gfx_RenderPassInfo_dependencies_get), _SE(js_cc_gfx_RenderPassInfo_dependencies_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_RenderPassInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_RenderPassInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::RenderPassInfo>(cls);
    
    __jsb_cc_gfx_RenderPassInfo_proto = cls->getProto();
    __jsb_cc_gfx_RenderPassInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_GeneralBarrierInfo_class = nullptr;
se::Object* __jsb_cc_gfx_GeneralBarrierInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_GeneralBarrierInfo) 

static bool js_cc_gfx_GeneralBarrierInfo_prevAccesses_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::GeneralBarrierInfo *arg1 = (cc::gfx::GeneralBarrierInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::GeneralBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "GeneralBarrierInfo_prevAccesses_set,2,SWIGTYPE_cc__gfx__AccessFlagBit");
    arg1->prevAccesses = (cc::gfx::AccessFlags)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_GeneralBarrierInfo_prevAccesses_set) 

static bool js_cc_gfx_GeneralBarrierInfo_prevAccesses_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::GeneralBarrierInfo *arg1 = (cc::gfx::GeneralBarrierInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::GeneralBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->prevAccesses));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_GeneralBarrierInfo_prevAccesses_get) 

static bool js_cc_gfx_GeneralBarrierInfo_nextAccesses_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::GeneralBarrierInfo *arg1 = (cc::gfx::GeneralBarrierInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::GeneralBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "GeneralBarrierInfo_nextAccesses_set,2,SWIGTYPE_cc__gfx__AccessFlagBit");
    arg1->nextAccesses = (cc::gfx::AccessFlags)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_GeneralBarrierInfo_nextAccesses_set) 

static bool js_cc_gfx_GeneralBarrierInfo_nextAccesses_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::GeneralBarrierInfo *arg1 = (cc::gfx::GeneralBarrierInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::GeneralBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->nextAccesses));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_GeneralBarrierInfo_nextAccesses_get) 

static bool js_cc_gfx_GeneralBarrierInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::GeneralBarrierInfo *arg1 = (cc::gfx::GeneralBarrierInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::GeneralBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "GeneralBarrierInfo_type_set,2,SWIGTYPE_cc__gfx__BarrierType");
    arg1->type = (cc::gfx::BarrierType)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_GeneralBarrierInfo_type_set) 

static bool js_cc_gfx_GeneralBarrierInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::GeneralBarrierInfo *arg1 = (cc::gfx::GeneralBarrierInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::GeneralBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->type));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_GeneralBarrierInfo_type_get) 

static bool js_cc_gfx_GeneralBarrierInfo__padding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::GeneralBarrierInfo *arg1 = (cc::gfx::GeneralBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::GeneralBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_padding, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeneralBarrierInfo__padding_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_GeneralBarrierInfo__padding_set) 

static bool js_cc_gfx_GeneralBarrierInfo__padding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::GeneralBarrierInfo *arg1 = (cc::gfx::GeneralBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::GeneralBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_padding, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "GeneralBarrierInfo__padding_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_padding, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_GeneralBarrierInfo__padding_get) 

static bool js_cc_gfx_GeneralBarrierInfo_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::GeneralBarrierInfo *arg1 = (cc::gfx::GeneralBarrierInfo *) NULL ;
    cc::gfx::GeneralBarrierInfo *arg2 = 0 ;
    cc::gfx::GeneralBarrierInfo temp2 ;
    cc::gfx::GeneralBarrierInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::GeneralBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeneralBarrierInfo_copy,2,SWIGTYPE_p_cc__gfx__GeneralBarrierInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::GeneralBarrierInfo *) &(arg1)->copy((cc::gfx::GeneralBarrierInfo const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "GeneralBarrierInfo_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_GeneralBarrierInfo_copy) 

// js_ctor
static bool js_new_cc_gfx_GeneralBarrierInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::GeneralBarrierInfo *result;
    result = (cc::gfx::GeneralBarrierInfo *)new cc::gfx::GeneralBarrierInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_GeneralBarrierInfo, __jsb_cc_gfx_GeneralBarrierInfo_class, js_delete_cc_gfx_GeneralBarrierInfo)

static bool js_delete_cc_gfx_GeneralBarrierInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_GeneralBarrierInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::GeneralBarrierInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::GeneralBarrierInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("prevAccesses", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->prevAccesses), ctx);
    }
    
    
    json->getProperty("nextAccesses", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->nextAccesses), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("_padding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->_padding), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_GeneralBarrierInfo(se::Object* obj) {
    auto* cls = se::Class::create("GeneralBarrierInfo", obj, nullptr, _SE(js_new_cc_gfx_GeneralBarrierInfo)); 
    
    cls->defineProperty("prevAccesses", _SE(js_cc_gfx_GeneralBarrierInfo_prevAccesses_get), _SE(js_cc_gfx_GeneralBarrierInfo_prevAccesses_set)); 
    cls->defineProperty("nextAccesses", _SE(js_cc_gfx_GeneralBarrierInfo_nextAccesses_get), _SE(js_cc_gfx_GeneralBarrierInfo_nextAccesses_set)); 
    cls->defineProperty("type", _SE(js_cc_gfx_GeneralBarrierInfo_type_get), _SE(js_cc_gfx_GeneralBarrierInfo_type_set)); 
    cls->defineProperty("_padding", _SE(js_cc_gfx_GeneralBarrierInfo__padding_get), _SE(js_cc_gfx_GeneralBarrierInfo__padding_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_GeneralBarrierInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_GeneralBarrierInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::GeneralBarrierInfo>(cls);
    
    __jsb_cc_gfx_GeneralBarrierInfo_proto = cls->getProto();
    __jsb_cc_gfx_GeneralBarrierInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_TextureBarrierInfo_class = nullptr;
se::Object* __jsb_cc_gfx_TextureBarrierInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_TextureBarrierInfo) 

static bool js_cc_gfx_TextureBarrierInfo_prevAccesses_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TextureBarrierInfo_prevAccesses_set,2,SWIGTYPE_cc__gfx__AccessFlagBit");
    arg1->prevAccesses = (cc::gfx::AccessFlags)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBarrierInfo_prevAccesses_set) 

static bool js_cc_gfx_TextureBarrierInfo_prevAccesses_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->prevAccesses));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBarrierInfo_prevAccesses_get) 

static bool js_cc_gfx_TextureBarrierInfo_nextAccesses_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TextureBarrierInfo_nextAccesses_set,2,SWIGTYPE_cc__gfx__AccessFlagBit");
    arg1->nextAccesses = (cc::gfx::AccessFlags)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBarrierInfo_nextAccesses_set) 

static bool js_cc_gfx_TextureBarrierInfo_nextAccesses_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->nextAccesses));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBarrierInfo_nextAccesses_get) 

static bool js_cc_gfx_TextureBarrierInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "TextureBarrierInfo_type_set,2,SWIGTYPE_cc__gfx__BarrierType");
    arg1->type = (cc::gfx::BarrierType)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBarrierInfo_type_set) 

static bool js_cc_gfx_TextureBarrierInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->type));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBarrierInfo_type_get) 

static bool js_cc_gfx_TextureBarrierInfo_baseMipLevel_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->baseMipLevel, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureBarrierInfo_baseMipLevel_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBarrierInfo_baseMipLevel_set) 

static bool js_cc_gfx_TextureBarrierInfo_baseMipLevel_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->baseMipLevel, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBarrierInfo_baseMipLevel_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->baseMipLevel, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBarrierInfo_baseMipLevel_get) 

static bool js_cc_gfx_TextureBarrierInfo_levelCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->levelCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureBarrierInfo_levelCount_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBarrierInfo_levelCount_set) 

static bool js_cc_gfx_TextureBarrierInfo_levelCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->levelCount, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBarrierInfo_levelCount_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->levelCount, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBarrierInfo_levelCount_get) 

static bool js_cc_gfx_TextureBarrierInfo_baseSlice_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->baseSlice, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureBarrierInfo_baseSlice_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBarrierInfo_baseSlice_set) 

static bool js_cc_gfx_TextureBarrierInfo_baseSlice_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->baseSlice, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBarrierInfo_baseSlice_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->baseSlice, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBarrierInfo_baseSlice_get) 

static bool js_cc_gfx_TextureBarrierInfo_sliceCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->sliceCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureBarrierInfo_sliceCount_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBarrierInfo_sliceCount_set) 

static bool js_cc_gfx_TextureBarrierInfo_sliceCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->sliceCount, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBarrierInfo_sliceCount_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->sliceCount, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBarrierInfo_sliceCount_get) 

static bool js_cc_gfx_TextureBarrierInfo_discardContents_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->discardContents, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureBarrierInfo_discardContents_set,2,SWIGTYPE_uint64_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBarrierInfo_discardContents_set) 

static bool js_cc_gfx_TextureBarrierInfo_discardContents_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->discardContents, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBarrierInfo_discardContents_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->discardContents, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBarrierInfo_discardContents_get) 

static bool js_cc_gfx_TextureBarrierInfo_srcQueue_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->srcQueue, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureBarrierInfo_srcQueue_set,2,SWIGTYPE_p_cc__gfx__Queue"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBarrierInfo_srcQueue_set) 

static bool js_cc_gfx_TextureBarrierInfo_srcQueue_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->srcQueue, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBarrierInfo_srcQueue_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->srcQueue, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBarrierInfo_srcQueue_get) 

static bool js_cc_gfx_TextureBarrierInfo_dstQueue_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->dstQueue, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureBarrierInfo_dstQueue_set,2,SWIGTYPE_p_cc__gfx__Queue"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBarrierInfo_dstQueue_set) 

static bool js_cc_gfx_TextureBarrierInfo_dstQueue_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->dstQueue, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBarrierInfo_dstQueue_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->dstQueue, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBarrierInfo_dstQueue_get) 

static bool js_cc_gfx_TextureBarrierInfo_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    cc::gfx::TextureBarrierInfo *arg2 = 0 ;
    cc::gfx::TextureBarrierInfo temp2 ;
    cc::gfx::TextureBarrierInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureBarrierInfo_copy,2,SWIGTYPE_p_cc__gfx__TextureBarrierInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::TextureBarrierInfo *) &(arg1)->copy((cc::gfx::TextureBarrierInfo const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBarrierInfo_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_TextureBarrierInfo_copy) 

// js_ctor
static bool js_new_cc_gfx_TextureBarrierInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::TextureBarrierInfo *result;
    result = (cc::gfx::TextureBarrierInfo *)new cc::gfx::TextureBarrierInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_TextureBarrierInfo, __jsb_cc_gfx_TextureBarrierInfo_class, js_delete_cc_gfx_TextureBarrierInfo)

static bool js_delete_cc_gfx_TextureBarrierInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_TextureBarrierInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::TextureBarrierInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::TextureBarrierInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("prevAccesses", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->prevAccesses), ctx);
    }
    
    
    json->getProperty("nextAccesses", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->nextAccesses), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("baseMipLevel", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->baseMipLevel), ctx);
    }
    
    
    json->getProperty("levelCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->levelCount), ctx);
    }
    
    
    json->getProperty("baseSlice", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->baseSlice), ctx);
    }
    
    
    json->getProperty("sliceCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->sliceCount), ctx);
    }
    
    
    json->getProperty("discardContents", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->discardContents), ctx);
    }
    
    
    json->getProperty("srcQueue", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->srcQueue), ctx);
    }
    
    
    json->getProperty("dstQueue", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dstQueue), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_TextureBarrierInfo(se::Object* obj) {
    auto* cls = se::Class::create("TextureBarrierInfo", obj, nullptr, _SE(js_new_cc_gfx_TextureBarrierInfo)); 
    
    cls->defineProperty("prevAccesses", _SE(js_cc_gfx_TextureBarrierInfo_prevAccesses_get), _SE(js_cc_gfx_TextureBarrierInfo_prevAccesses_set)); 
    cls->defineProperty("nextAccesses", _SE(js_cc_gfx_TextureBarrierInfo_nextAccesses_get), _SE(js_cc_gfx_TextureBarrierInfo_nextAccesses_set)); 
    cls->defineProperty("type", _SE(js_cc_gfx_TextureBarrierInfo_type_get), _SE(js_cc_gfx_TextureBarrierInfo_type_set)); 
    cls->defineProperty("baseMipLevel", _SE(js_cc_gfx_TextureBarrierInfo_baseMipLevel_get), _SE(js_cc_gfx_TextureBarrierInfo_baseMipLevel_set)); 
    cls->defineProperty("levelCount", _SE(js_cc_gfx_TextureBarrierInfo_levelCount_get), _SE(js_cc_gfx_TextureBarrierInfo_levelCount_set)); 
    cls->defineProperty("baseSlice", _SE(js_cc_gfx_TextureBarrierInfo_baseSlice_get), _SE(js_cc_gfx_TextureBarrierInfo_baseSlice_set)); 
    cls->defineProperty("sliceCount", _SE(js_cc_gfx_TextureBarrierInfo_sliceCount_get), _SE(js_cc_gfx_TextureBarrierInfo_sliceCount_set)); 
    cls->defineProperty("discardContents", _SE(js_cc_gfx_TextureBarrierInfo_discardContents_get), _SE(js_cc_gfx_TextureBarrierInfo_discardContents_set)); 
    cls->defineProperty("srcQueue", _SE(js_cc_gfx_TextureBarrierInfo_srcQueue_get), _SE(js_cc_gfx_TextureBarrierInfo_srcQueue_set)); 
    cls->defineProperty("dstQueue", _SE(js_cc_gfx_TextureBarrierInfo_dstQueue_get), _SE(js_cc_gfx_TextureBarrierInfo_dstQueue_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_TextureBarrierInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_TextureBarrierInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::TextureBarrierInfo>(cls);
    
    __jsb_cc_gfx_TextureBarrierInfo_proto = cls->getProto();
    __jsb_cc_gfx_TextureBarrierInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_BufferBarrierInfo_class = nullptr;
se::Object* __jsb_cc_gfx_BufferBarrierInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_BufferBarrierInfo) 

static bool js_cc_gfx_BufferBarrierInfo_prevAccesses_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "BufferBarrierInfo_prevAccesses_set,2,SWIGTYPE_cc__gfx__AccessFlagBit");
    arg1->prevAccesses = (cc::gfx::AccessFlags)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferBarrierInfo_prevAccesses_set) 

static bool js_cc_gfx_BufferBarrierInfo_prevAccesses_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->prevAccesses));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferBarrierInfo_prevAccesses_get) 

static bool js_cc_gfx_BufferBarrierInfo_nextAccesses_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "BufferBarrierInfo_nextAccesses_set,2,SWIGTYPE_cc__gfx__AccessFlagBit");
    arg1->nextAccesses = (cc::gfx::AccessFlags)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferBarrierInfo_nextAccesses_set) 

static bool js_cc_gfx_BufferBarrierInfo_nextAccesses_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->nextAccesses));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferBarrierInfo_nextAccesses_get) 

static bool js_cc_gfx_BufferBarrierInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "BufferBarrierInfo_type_set,2,SWIGTYPE_cc__gfx__BarrierType");
    arg1->type = (cc::gfx::BarrierType)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferBarrierInfo_type_set) 

static bool js_cc_gfx_BufferBarrierInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->type));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferBarrierInfo_type_get) 

static bool js_cc_gfx_BufferBarrierInfo_offset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->offset, s.thisObject());
    SE_PRECONDITION2(ok, false, "BufferBarrierInfo_offset_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferBarrierInfo_offset_set) 

static bool js_cc_gfx_BufferBarrierInfo_offset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->offset, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BufferBarrierInfo_offset_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->offset, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferBarrierInfo_offset_get) 

static bool js_cc_gfx_BufferBarrierInfo_size_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->size, s.thisObject());
    SE_PRECONDITION2(ok, false, "BufferBarrierInfo_size_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferBarrierInfo_size_set) 

static bool js_cc_gfx_BufferBarrierInfo_size_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->size, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BufferBarrierInfo_size_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->size, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferBarrierInfo_size_get) 

static bool js_cc_gfx_BufferBarrierInfo_discardContents_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->discardContents, s.thisObject());
    SE_PRECONDITION2(ok, false, "BufferBarrierInfo_discardContents_set,2,SWIGTYPE_uint64_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferBarrierInfo_discardContents_set) 

static bool js_cc_gfx_BufferBarrierInfo_discardContents_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->discardContents, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BufferBarrierInfo_discardContents_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->discardContents, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferBarrierInfo_discardContents_get) 

static bool js_cc_gfx_BufferBarrierInfo_srcQueue_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->srcQueue, s.thisObject());
    SE_PRECONDITION2(ok, false, "BufferBarrierInfo_srcQueue_set,2,SWIGTYPE_p_cc__gfx__Queue"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferBarrierInfo_srcQueue_set) 

static bool js_cc_gfx_BufferBarrierInfo_srcQueue_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->srcQueue, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BufferBarrierInfo_srcQueue_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->srcQueue, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferBarrierInfo_srcQueue_get) 

static bool js_cc_gfx_BufferBarrierInfo_dstQueue_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->dstQueue, s.thisObject());
    SE_PRECONDITION2(ok, false, "BufferBarrierInfo_dstQueue_set,2,SWIGTYPE_p_cc__gfx__Queue"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferBarrierInfo_dstQueue_set) 

static bool js_cc_gfx_BufferBarrierInfo_dstQueue_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->dstQueue, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BufferBarrierInfo_dstQueue_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->dstQueue, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferBarrierInfo_dstQueue_get) 

static bool js_cc_gfx_BufferBarrierInfo_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    cc::gfx::BufferBarrierInfo *arg2 = 0 ;
    cc::gfx::BufferBarrierInfo temp2 ;
    cc::gfx::BufferBarrierInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BufferBarrierInfo_copy,2,SWIGTYPE_p_cc__gfx__BufferBarrierInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::BufferBarrierInfo *) &(arg1)->copy((cc::gfx::BufferBarrierInfo const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BufferBarrierInfo_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BufferBarrierInfo_copy) 

// js_ctor
static bool js_new_cc_gfx_BufferBarrierInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::BufferBarrierInfo *result;
    result = (cc::gfx::BufferBarrierInfo *)new cc::gfx::BufferBarrierInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_BufferBarrierInfo, __jsb_cc_gfx_BufferBarrierInfo_class, js_delete_cc_gfx_BufferBarrierInfo)

static bool js_delete_cc_gfx_BufferBarrierInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_BufferBarrierInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::BufferBarrierInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::BufferBarrierInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("prevAccesses", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->prevAccesses), ctx);
    }
    
    
    json->getProperty("nextAccesses", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->nextAccesses), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("offset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->offset), ctx);
    }
    
    
    json->getProperty("size", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->size), ctx);
    }
    
    
    json->getProperty("discardContents", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->discardContents), ctx);
    }
    
    
    json->getProperty("srcQueue", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->srcQueue), ctx);
    }
    
    
    json->getProperty("dstQueue", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dstQueue), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_BufferBarrierInfo(se::Object* obj) {
    auto* cls = se::Class::create("BufferBarrierInfo", obj, nullptr, _SE(js_new_cc_gfx_BufferBarrierInfo)); 
    
    cls->defineProperty("prevAccesses", _SE(js_cc_gfx_BufferBarrierInfo_prevAccesses_get), _SE(js_cc_gfx_BufferBarrierInfo_prevAccesses_set)); 
    cls->defineProperty("nextAccesses", _SE(js_cc_gfx_BufferBarrierInfo_nextAccesses_get), _SE(js_cc_gfx_BufferBarrierInfo_nextAccesses_set)); 
    cls->defineProperty("type", _SE(js_cc_gfx_BufferBarrierInfo_type_get), _SE(js_cc_gfx_BufferBarrierInfo_type_set)); 
    cls->defineProperty("offset", _SE(js_cc_gfx_BufferBarrierInfo_offset_get), _SE(js_cc_gfx_BufferBarrierInfo_offset_set)); 
    cls->defineProperty("size", _SE(js_cc_gfx_BufferBarrierInfo_size_get), _SE(js_cc_gfx_BufferBarrierInfo_size_set)); 
    cls->defineProperty("discardContents", _SE(js_cc_gfx_BufferBarrierInfo_discardContents_get), _SE(js_cc_gfx_BufferBarrierInfo_discardContents_set)); 
    cls->defineProperty("srcQueue", _SE(js_cc_gfx_BufferBarrierInfo_srcQueue_get), _SE(js_cc_gfx_BufferBarrierInfo_srcQueue_set)); 
    cls->defineProperty("dstQueue", _SE(js_cc_gfx_BufferBarrierInfo_dstQueue_get), _SE(js_cc_gfx_BufferBarrierInfo_dstQueue_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_BufferBarrierInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_BufferBarrierInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::BufferBarrierInfo>(cls);
    
    __jsb_cc_gfx_BufferBarrierInfo_proto = cls->getProto();
    __jsb_cc_gfx_BufferBarrierInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_FramebufferInfo_class = nullptr;
se::Object* __jsb_cc_gfx_FramebufferInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_FramebufferInfo) 

static bool js_cc_gfx_FramebufferInfo_renderPass_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::FramebufferInfo *arg1 = (cc::gfx::FramebufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FramebufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->renderPass, s.thisObject());
    SE_PRECONDITION2(ok, false, "FramebufferInfo_renderPass_set,2,SWIGTYPE_p_cc__gfx__RenderPass"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_FramebufferInfo_renderPass_set) 

static bool js_cc_gfx_FramebufferInfo_renderPass_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::FramebufferInfo *arg1 = (cc::gfx::FramebufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FramebufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->renderPass, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FramebufferInfo_renderPass_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->renderPass, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_FramebufferInfo_renderPass_get) 

static bool js_cc_gfx_FramebufferInfo_colorTextures_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::FramebufferInfo *arg1 = (cc::gfx::FramebufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FramebufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->colorTextures, s.thisObject());
    SE_PRECONDITION2(ok, false, "FramebufferInfo_colorTextures_set,2,SWIGTYPE_ccstd__vectorT_cc__gfx__Texture_p_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_FramebufferInfo_colorTextures_set) 

static bool js_cc_gfx_FramebufferInfo_colorTextures_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::FramebufferInfo *arg1 = (cc::gfx::FramebufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FramebufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->colorTextures, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FramebufferInfo_colorTextures_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->colorTextures, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_FramebufferInfo_colorTextures_get) 

static bool js_cc_gfx_FramebufferInfo_depthStencilTexture_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::FramebufferInfo *arg1 = (cc::gfx::FramebufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FramebufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->depthStencilTexture, s.thisObject());
    SE_PRECONDITION2(ok, false, "FramebufferInfo_depthStencilTexture_set,2,SWIGTYPE_p_cc__gfx__Texture"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_FramebufferInfo_depthStencilTexture_set) 

static bool js_cc_gfx_FramebufferInfo_depthStencilTexture_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::FramebufferInfo *arg1 = (cc::gfx::FramebufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FramebufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->depthStencilTexture, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FramebufferInfo_depthStencilTexture_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthStencilTexture, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_FramebufferInfo_depthStencilTexture_get) 

static bool js_cc_gfx_FramebufferInfo_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::FramebufferInfo *arg1 = (cc::gfx::FramebufferInfo *) NULL ;
    cc::gfx::FramebufferInfo *arg2 = 0 ;
    cc::gfx::FramebufferInfo temp2 ;
    cc::gfx::FramebufferInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::FramebufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FramebufferInfo_copy,2,SWIGTYPE_p_cc__gfx__FramebufferInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::FramebufferInfo *) &(arg1)->copy((cc::gfx::FramebufferInfo const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FramebufferInfo_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_FramebufferInfo_copy) 

// js_ctor
static bool js_new_cc_gfx_FramebufferInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::FramebufferInfo *result;
    result = (cc::gfx::FramebufferInfo *)new cc::gfx::FramebufferInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_FramebufferInfo, __jsb_cc_gfx_FramebufferInfo_class, js_delete_cc_gfx_FramebufferInfo)

static bool js_delete_cc_gfx_FramebufferInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_FramebufferInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::FramebufferInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::FramebufferInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("renderPass", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->renderPass), ctx);
    }
    
    
    json->getProperty("colorTextures", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->colorTextures), ctx);
    }
    
    
    json->getProperty("depthStencilTexture", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthStencilTexture), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_FramebufferInfo(se::Object* obj) {
    auto* cls = se::Class::create("FramebufferInfo", obj, nullptr, _SE(js_new_cc_gfx_FramebufferInfo)); 
    
    cls->defineProperty("renderPass", _SE(js_cc_gfx_FramebufferInfo_renderPass_get), _SE(js_cc_gfx_FramebufferInfo_renderPass_set)); 
    cls->defineProperty("colorTextures", _SE(js_cc_gfx_FramebufferInfo_colorTextures_get), _SE(js_cc_gfx_FramebufferInfo_colorTextures_set)); 
    cls->defineProperty("depthStencilTexture", _SE(js_cc_gfx_FramebufferInfo_depthStencilTexture_get), _SE(js_cc_gfx_FramebufferInfo_depthStencilTexture_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_FramebufferInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_FramebufferInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::FramebufferInfo>(cls);
    
    __jsb_cc_gfx_FramebufferInfo_proto = cls->getProto();
    __jsb_cc_gfx_FramebufferInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DescriptorSetLayoutBinding_class = nullptr;
se::Object* __jsb_cc_gfx_DescriptorSetLayoutBinding_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DescriptorSetLayoutBinding) 

static bool js_cc_gfx_DescriptorSetLayoutBinding_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetLayoutBinding *arg1 = (cc::gfx::DescriptorSetLayoutBinding *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutBinding>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSetLayoutBinding_binding_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DescriptorSetLayoutBinding_binding_set) 

static bool js_cc_gfx_DescriptorSetLayoutBinding_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding *arg1 = (cc::gfx::DescriptorSetLayoutBinding *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutBinding>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DescriptorSetLayoutBinding_binding_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->binding, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DescriptorSetLayoutBinding_binding_get) 

static bool js_cc_gfx_DescriptorSetLayoutBinding_descriptorType_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetLayoutBinding *arg1 = (cc::gfx::DescriptorSetLayoutBinding *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutBinding>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "DescriptorSetLayoutBinding_descriptorType_set,2,SWIGTYPE_cc__gfx__DescriptorType");
    arg1->descriptorType = (cc::gfx::DescriptorType)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DescriptorSetLayoutBinding_descriptorType_set) 

static bool js_cc_gfx_DescriptorSetLayoutBinding_descriptorType_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding *arg1 = (cc::gfx::DescriptorSetLayoutBinding *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutBinding>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->descriptorType));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DescriptorSetLayoutBinding_descriptorType_get) 

static bool js_cc_gfx_DescriptorSetLayoutBinding_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetLayoutBinding *arg1 = (cc::gfx::DescriptorSetLayoutBinding *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutBinding>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSetLayoutBinding_count_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DescriptorSetLayoutBinding_count_set) 

static bool js_cc_gfx_DescriptorSetLayoutBinding_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding *arg1 = (cc::gfx::DescriptorSetLayoutBinding *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutBinding>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DescriptorSetLayoutBinding_count_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->count, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DescriptorSetLayoutBinding_count_get) 

static bool js_cc_gfx_DescriptorSetLayoutBinding_stageFlags_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetLayoutBinding *arg1 = (cc::gfx::DescriptorSetLayoutBinding *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutBinding>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "DescriptorSetLayoutBinding_stageFlags_set,2,SWIGTYPE_cc__gfx__ShaderStageFlagBit");
    arg1->stageFlags = (cc::gfx::ShaderStageFlags)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DescriptorSetLayoutBinding_stageFlags_set) 

static bool js_cc_gfx_DescriptorSetLayoutBinding_stageFlags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding *arg1 = (cc::gfx::DescriptorSetLayoutBinding *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutBinding>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->stageFlags));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DescriptorSetLayoutBinding_stageFlags_get) 

static bool js_cc_gfx_DescriptorSetLayoutBinding_immutableSamplers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetLayoutBinding *arg1 = (cc::gfx::DescriptorSetLayoutBinding *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutBinding>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->immutableSamplers, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSetLayoutBinding_immutableSamplers_set,2,SWIGTYPE_ccstd__vectorT_cc__gfx__Sampler_p_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DescriptorSetLayoutBinding_immutableSamplers_set) 

static bool js_cc_gfx_DescriptorSetLayoutBinding_immutableSamplers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding *arg1 = (cc::gfx::DescriptorSetLayoutBinding *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutBinding>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->immutableSamplers, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DescriptorSetLayoutBinding_immutableSamplers_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->immutableSamplers, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DescriptorSetLayoutBinding_immutableSamplers_get) 

static bool js_cc_gfx_DescriptorSetLayoutBinding_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetLayoutBinding *arg1 = (cc::gfx::DescriptorSetLayoutBinding *) NULL ;
    cc::gfx::DescriptorSetLayoutBinding *arg2 = 0 ;
    cc::gfx::DescriptorSetLayoutBinding temp2 ;
    cc::gfx::DescriptorSetLayoutBinding *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutBinding>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSetLayoutBinding_copy,2,SWIGTYPE_p_cc__gfx__DescriptorSetLayoutBinding");
    arg2 = &temp2;
    
    result = (cc::gfx::DescriptorSetLayoutBinding *) &(arg1)->copy((cc::gfx::DescriptorSetLayoutBinding const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DescriptorSetLayoutBinding_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSetLayoutBinding_copy) 

// js_ctor
static bool js_new_cc_gfx_DescriptorSetLayoutBinding(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::DescriptorSetLayoutBinding *result;
    result = (cc::gfx::DescriptorSetLayoutBinding *)new cc::gfx::DescriptorSetLayoutBinding();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_DescriptorSetLayoutBinding, __jsb_cc_gfx_DescriptorSetLayoutBinding_class, js_delete_cc_gfx_DescriptorSetLayoutBinding)

static bool js_delete_cc_gfx_DescriptorSetLayoutBinding(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DescriptorSetLayoutBinding) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::DescriptorSetLayoutBinding * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::DescriptorSetLayoutBinding*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("descriptorType", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->descriptorType), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("stageFlags", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stageFlags), ctx);
    }
    
    
    json->getProperty("immutableSamplers", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->immutableSamplers), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_DescriptorSetLayoutBinding(se::Object* obj) {
    auto* cls = se::Class::create("DescriptorSetLayoutBinding", obj, nullptr, _SE(js_new_cc_gfx_DescriptorSetLayoutBinding)); 
    
    cls->defineProperty("binding", _SE(js_cc_gfx_DescriptorSetLayoutBinding_binding_get), _SE(js_cc_gfx_DescriptorSetLayoutBinding_binding_set)); 
    cls->defineProperty("descriptorType", _SE(js_cc_gfx_DescriptorSetLayoutBinding_descriptorType_get), _SE(js_cc_gfx_DescriptorSetLayoutBinding_descriptorType_set)); 
    cls->defineProperty("count", _SE(js_cc_gfx_DescriptorSetLayoutBinding_count_get), _SE(js_cc_gfx_DescriptorSetLayoutBinding_count_set)); 
    cls->defineProperty("stageFlags", _SE(js_cc_gfx_DescriptorSetLayoutBinding_stageFlags_get), _SE(js_cc_gfx_DescriptorSetLayoutBinding_stageFlags_set)); 
    cls->defineProperty("immutableSamplers", _SE(js_cc_gfx_DescriptorSetLayoutBinding_immutableSamplers_get), _SE(js_cc_gfx_DescriptorSetLayoutBinding_immutableSamplers_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_DescriptorSetLayoutBinding_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DescriptorSetLayoutBinding));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DescriptorSetLayoutBinding>(cls);
    
    __jsb_cc_gfx_DescriptorSetLayoutBinding_proto = cls->getProto();
    __jsb_cc_gfx_DescriptorSetLayoutBinding_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DescriptorSetLayoutInfo_class = nullptr;
se::Object* __jsb_cc_gfx_DescriptorSetLayoutInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DescriptorSetLayoutInfo) 

static bool js_cc_gfx_DescriptorSetLayoutInfo_bindings_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetLayoutInfo *arg1 = (cc::gfx::DescriptorSetLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->bindings, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSetLayoutInfo_bindings_set,2,SWIGTYPE_ccstd__vectorT_cc__gfx__DescriptorSetLayoutBinding_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DescriptorSetLayoutInfo_bindings_set) 

static bool js_cc_gfx_DescriptorSetLayoutInfo_bindings_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutInfo *arg1 = (cc::gfx::DescriptorSetLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->bindings, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DescriptorSetLayoutInfo_bindings_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->bindings, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DescriptorSetLayoutInfo_bindings_get) 

static bool js_cc_gfx_DescriptorSetLayoutInfo_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetLayoutInfo *arg1 = (cc::gfx::DescriptorSetLayoutInfo *) NULL ;
    cc::gfx::DescriptorSetLayoutInfo *arg2 = 0 ;
    cc::gfx::DescriptorSetLayoutInfo temp2 ;
    cc::gfx::DescriptorSetLayoutInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSetLayoutInfo_copy,2,SWIGTYPE_p_cc__gfx__DescriptorSetLayoutInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::DescriptorSetLayoutInfo *) &(arg1)->copy((cc::gfx::DescriptorSetLayoutInfo const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DescriptorSetLayoutInfo_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSetLayoutInfo_copy) 

// js_ctor
static bool js_new_cc_gfx_DescriptorSetLayoutInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::DescriptorSetLayoutInfo *result;
    result = (cc::gfx::DescriptorSetLayoutInfo *)new cc::gfx::DescriptorSetLayoutInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_DescriptorSetLayoutInfo, __jsb_cc_gfx_DescriptorSetLayoutInfo_class, js_delete_cc_gfx_DescriptorSetLayoutInfo)

static bool js_delete_cc_gfx_DescriptorSetLayoutInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DescriptorSetLayoutInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::DescriptorSetLayoutInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::DescriptorSetLayoutInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("bindings", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->bindings), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_DescriptorSetLayoutInfo(se::Object* obj) {
    auto* cls = se::Class::create("DescriptorSetLayoutInfo", obj, nullptr, _SE(js_new_cc_gfx_DescriptorSetLayoutInfo)); 
    
    cls->defineProperty("bindings", _SE(js_cc_gfx_DescriptorSetLayoutInfo_bindings_get), _SE(js_cc_gfx_DescriptorSetLayoutInfo_bindings_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_DescriptorSetLayoutInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DescriptorSetLayoutInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DescriptorSetLayoutInfo>(cls);
    
    __jsb_cc_gfx_DescriptorSetLayoutInfo_proto = cls->getProto();
    __jsb_cc_gfx_DescriptorSetLayoutInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DescriptorSetInfo_class = nullptr;
se::Object* __jsb_cc_gfx_DescriptorSetInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DescriptorSetInfo) 

static bool js_cc_gfx_DescriptorSetInfo_layout_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetInfo *arg1 = (cc::gfx::DescriptorSetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->layout, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSetInfo_layout_set,2,SWIGTYPE_p_cc__gfx__DescriptorSetLayout"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DescriptorSetInfo_layout_set) 

static bool js_cc_gfx_DescriptorSetInfo_layout_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetInfo *arg1 = (cc::gfx::DescriptorSetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->layout, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DescriptorSetInfo_layout_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->layout, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DescriptorSetInfo_layout_get) 

static bool js_cc_gfx_DescriptorSetInfo_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetInfo *arg1 = (cc::gfx::DescriptorSetInfo *) NULL ;
    cc::gfx::DescriptorSetInfo *arg2 = 0 ;
    cc::gfx::DescriptorSetInfo temp2 ;
    cc::gfx::DescriptorSetInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSetInfo_copy,2,SWIGTYPE_p_cc__gfx__DescriptorSetInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::DescriptorSetInfo *) &(arg1)->copy((cc::gfx::DescriptorSetInfo const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DescriptorSetInfo_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSetInfo_copy) 

// js_ctor
static bool js_new_cc_gfx_DescriptorSetInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::DescriptorSetInfo *result;
    result = (cc::gfx::DescriptorSetInfo *)new cc::gfx::DescriptorSetInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_DescriptorSetInfo, __jsb_cc_gfx_DescriptorSetInfo_class, js_delete_cc_gfx_DescriptorSetInfo)

static bool js_delete_cc_gfx_DescriptorSetInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DescriptorSetInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::DescriptorSetInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::DescriptorSetInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("layout", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->layout), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_DescriptorSetInfo(se::Object* obj) {
    auto* cls = se::Class::create("DescriptorSetInfo", obj, nullptr, _SE(js_new_cc_gfx_DescriptorSetInfo)); 
    
    cls->defineProperty("layout", _SE(js_cc_gfx_DescriptorSetInfo_layout_get), _SE(js_cc_gfx_DescriptorSetInfo_layout_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_DescriptorSetInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DescriptorSetInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DescriptorSetInfo>(cls);
    
    __jsb_cc_gfx_DescriptorSetInfo_proto = cls->getProto();
    __jsb_cc_gfx_DescriptorSetInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_PipelineLayoutInfo_class = nullptr;
se::Object* __jsb_cc_gfx_PipelineLayoutInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_PipelineLayoutInfo) 

static bool js_cc_gfx_PipelineLayoutInfo_setLayouts_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineLayoutInfo *arg1 = (cc::gfx::PipelineLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineLayoutInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->setLayouts, s.thisObject());
    SE_PRECONDITION2(ok, false, "PipelineLayoutInfo_setLayouts_set,2,SWIGTYPE_ccstd__vectorT_cc__gfx__DescriptorSetLayout_p_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_PipelineLayoutInfo_setLayouts_set) 

static bool js_cc_gfx_PipelineLayoutInfo_setLayouts_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineLayoutInfo *arg1 = (cc::gfx::PipelineLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineLayoutInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->setLayouts, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineLayoutInfo_setLayouts_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->setLayouts, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineLayoutInfo_setLayouts_get) 

static bool js_cc_gfx_PipelineLayoutInfo_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineLayoutInfo *arg1 = (cc::gfx::PipelineLayoutInfo *) NULL ;
    cc::gfx::PipelineLayoutInfo *arg2 = 0 ;
    cc::gfx::PipelineLayoutInfo temp2 ;
    cc::gfx::PipelineLayoutInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineLayoutInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "PipelineLayoutInfo_copy,2,SWIGTYPE_p_cc__gfx__PipelineLayoutInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::PipelineLayoutInfo *) &(arg1)->copy((cc::gfx::PipelineLayoutInfo const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineLayoutInfo_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_PipelineLayoutInfo_copy) 

// js_ctor
static bool js_new_cc_gfx_PipelineLayoutInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::PipelineLayoutInfo *result;
    result = (cc::gfx::PipelineLayoutInfo *)new cc::gfx::PipelineLayoutInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_PipelineLayoutInfo, __jsb_cc_gfx_PipelineLayoutInfo_class, js_delete_cc_gfx_PipelineLayoutInfo)

static bool js_delete_cc_gfx_PipelineLayoutInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_PipelineLayoutInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::PipelineLayoutInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::PipelineLayoutInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("setLayouts", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->setLayouts), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_PipelineLayoutInfo(se::Object* obj) {
    auto* cls = se::Class::create("PipelineLayoutInfo", obj, nullptr, _SE(js_new_cc_gfx_PipelineLayoutInfo)); 
    
    cls->defineProperty("setLayouts", _SE(js_cc_gfx_PipelineLayoutInfo_setLayouts_get), _SE(js_cc_gfx_PipelineLayoutInfo_setLayouts_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_PipelineLayoutInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_PipelineLayoutInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::PipelineLayoutInfo>(cls);
    
    __jsb_cc_gfx_PipelineLayoutInfo_proto = cls->getProto();
    __jsb_cc_gfx_PipelineLayoutInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_InputState_class = nullptr;
se::Object* __jsb_cc_gfx_InputState_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_InputState) 

static bool js_cc_gfx_InputState_attributes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputState *arg1 = (cc::gfx::InputState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->attributes, s.thisObject());
    SE_PRECONDITION2(ok, false, "InputState_attributes_set,2,SWIGTYPE_ccstd__vectorT_cc__gfx__Attribute_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_InputState_attributes_set) 

static bool js_cc_gfx_InputState_attributes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputState *arg1 = (cc::gfx::InputState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->attributes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InputState_attributes_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->attributes, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputState_attributes_get) 

static bool js_cc_gfx_InputState_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputState *arg1 = (cc::gfx::InputState *) NULL ;
    cc::gfx::InputState *arg2 = 0 ;
    cc::gfx::InputState temp2 ;
    cc::gfx::InputState *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::InputState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "InputState_copy,2,SWIGTYPE_p_cc__gfx__InputState");
    arg2 = &temp2;
    
    result = (cc::gfx::InputState *) &(arg1)->copy((cc::gfx::InputState const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InputState_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_InputState_copy) 

// js_ctor
static bool js_new_cc_gfx_InputState(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::InputState *result;
    result = (cc::gfx::InputState *)new cc::gfx::InputState();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_InputState, __jsb_cc_gfx_InputState_class, js_delete_cc_gfx_InputState)

static bool js_delete_cc_gfx_InputState(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_InputState) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::InputState * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::InputState*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("attributes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->attributes), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_InputState(se::Object* obj) {
    auto* cls = se::Class::create("InputState", obj, nullptr, _SE(js_new_cc_gfx_InputState)); 
    
    cls->defineProperty("attributes", _SE(js_cc_gfx_InputState_attributes_get), _SE(js_cc_gfx_InputState_attributes_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_InputState_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_InputState));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::InputState>(cls);
    
    __jsb_cc_gfx_InputState_proto = cls->getProto();
    __jsb_cc_gfx_InputState_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_RasterizerState_class = nullptr;
se::Object* __jsb_cc_gfx_RasterizerState_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_RasterizerState) 

static bool js_cc_gfx_RasterizerState_isDiscard_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->isDiscard, s.thisObject());
    SE_PRECONDITION2(ok, false, "RasterizerState_isDiscard_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RasterizerState_isDiscard_set) 

static bool js_cc_gfx_RasterizerState_isDiscard_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->isDiscard, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RasterizerState_isDiscard_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->isDiscard, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RasterizerState_isDiscard_get) 

static bool js_cc_gfx_RasterizerState_polygonMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "RasterizerState_polygonMode_set,2,SWIGTYPE_cc__gfx__PolygonMode");
    arg1->polygonMode = (cc::gfx::PolygonMode)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RasterizerState_polygonMode_set) 

static bool js_cc_gfx_RasterizerState_polygonMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->polygonMode));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RasterizerState_polygonMode_get) 

static bool js_cc_gfx_RasterizerState_shadeModel_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "RasterizerState_shadeModel_set,2,SWIGTYPE_cc__gfx__ShadeModel");
    arg1->shadeModel = (cc::gfx::ShadeModel)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RasterizerState_shadeModel_set) 

static bool js_cc_gfx_RasterizerState_shadeModel_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->shadeModel));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RasterizerState_shadeModel_get) 

static bool js_cc_gfx_RasterizerState_cullMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "RasterizerState_cullMode_set,2,SWIGTYPE_cc__gfx__CullMode");
    arg1->cullMode = (cc::gfx::CullMode)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RasterizerState_cullMode_set) 

static bool js_cc_gfx_RasterizerState_cullMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->cullMode));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RasterizerState_cullMode_get) 

static bool js_cc_gfx_RasterizerState_isFrontFaceCCW_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->isFrontFaceCCW, s.thisObject());
    SE_PRECONDITION2(ok, false, "RasterizerState_isFrontFaceCCW_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RasterizerState_isFrontFaceCCW_set) 

static bool js_cc_gfx_RasterizerState_isFrontFaceCCW_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->isFrontFaceCCW, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RasterizerState_isFrontFaceCCW_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->isFrontFaceCCW, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RasterizerState_isFrontFaceCCW_get) 

static bool js_cc_gfx_RasterizerState_depthBiasEnabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->depthBiasEnabled, s.thisObject());
    SE_PRECONDITION2(ok, false, "RasterizerState_depthBiasEnabled_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RasterizerState_depthBiasEnabled_set) 

static bool js_cc_gfx_RasterizerState_depthBiasEnabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->depthBiasEnabled, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RasterizerState_depthBiasEnabled_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthBiasEnabled, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RasterizerState_depthBiasEnabled_get) 

static bool js_cc_gfx_RasterizerState_depthBias_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->depthBias, nullptr);
    SE_PRECONDITION2(ok, false, "RasterizerState_depthBias_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RasterizerState_depthBias_set) 

static bool js_cc_gfx_RasterizerState_depthBias_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->depthBias, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RasterizerState_depthBias_get) 

static bool js_cc_gfx_RasterizerState_depthBiasClamp_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->depthBiasClamp, nullptr);
    SE_PRECONDITION2(ok, false, "RasterizerState_depthBiasClamp_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RasterizerState_depthBiasClamp_set) 

static bool js_cc_gfx_RasterizerState_depthBiasClamp_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->depthBiasClamp, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RasterizerState_depthBiasClamp_get) 

static bool js_cc_gfx_RasterizerState_depthBiasSlop_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->depthBiasSlop, nullptr);
    SE_PRECONDITION2(ok, false, "RasterizerState_depthBiasSlop_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RasterizerState_depthBiasSlop_set) 

static bool js_cc_gfx_RasterizerState_depthBiasSlop_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->depthBiasSlop, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RasterizerState_depthBiasSlop_get) 

static bool js_cc_gfx_RasterizerState_isDepthClip_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->isDepthClip, s.thisObject());
    SE_PRECONDITION2(ok, false, "RasterizerState_isDepthClip_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RasterizerState_isDepthClip_set) 

static bool js_cc_gfx_RasterizerState_isDepthClip_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->isDepthClip, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RasterizerState_isDepthClip_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->isDepthClip, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RasterizerState_isDepthClip_get) 

static bool js_cc_gfx_RasterizerState_isMultisample_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->isMultisample, s.thisObject());
    SE_PRECONDITION2(ok, false, "RasterizerState_isMultisample_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RasterizerState_isMultisample_set) 

static bool js_cc_gfx_RasterizerState_isMultisample_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->isMultisample, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RasterizerState_isMultisample_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->isMultisample, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RasterizerState_isMultisample_get) 

static bool js_cc_gfx_RasterizerState_lineWidth_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->lineWidth, nullptr);
    SE_PRECONDITION2(ok, false, "RasterizerState_lineWidth_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RasterizerState_lineWidth_set) 

static bool js_cc_gfx_RasterizerState_lineWidth_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->lineWidth, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RasterizerState_lineWidth_get) 

static bool js_cc_gfx_RasterizerState_reset(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->reset();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_RasterizerState_reset) 

static bool js_cc_gfx_RasterizerState_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    cc::gfx::RasterizerState *arg2 = 0 ;
    cc::gfx::RasterizerState temp2 ;
    cc::gfx::RasterizerState *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RasterizerState_copy,2,SWIGTYPE_p_cc__gfx__RasterizerState");
    arg2 = &temp2;
    
    result = (cc::gfx::RasterizerState *) &(arg1)->copy((cc::gfx::RasterizerState const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RasterizerState_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_RasterizerState_copy) 

// js_ctor
static bool js_new_cc_gfx_RasterizerState(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::RasterizerState *result;
    result = (cc::gfx::RasterizerState *)new cc::gfx::RasterizerState();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_RasterizerState, __jsb_cc_gfx_RasterizerState_class, js_delete_cc_gfx_RasterizerState)

static bool js_delete_cc_gfx_RasterizerState(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_RasterizerState) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::RasterizerState * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::RasterizerState*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("isDiscard", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isDiscard), ctx);
    }
    
    
    json->getProperty("polygonMode", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->polygonMode), ctx);
    }
    
    
    json->getProperty("shadeModel", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->shadeModel), ctx);
    }
    
    
    json->getProperty("cullMode", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->cullMode), ctx);
    }
    
    
    json->getProperty("isFrontFaceCCW", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isFrontFaceCCW), ctx);
    }
    
    
    json->getProperty("depthBiasEnabled", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthBiasEnabled), ctx);
    }
    
    
    json->getProperty("depthBias", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthBias), ctx);
    }
    
    
    json->getProperty("depthBiasClamp", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthBiasClamp), ctx);
    }
    
    
    json->getProperty("depthBiasSlop", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthBiasSlop), ctx);
    }
    
    
    json->getProperty("isDepthClip", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isDepthClip), ctx);
    }
    
    
    json->getProperty("isMultisample", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isMultisample), ctx);
    }
    
    
    json->getProperty("lineWidth", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->lineWidth), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_RasterizerState(se::Object* obj) {
    auto* cls = se::Class::create("RasterizerState", obj, nullptr, _SE(js_new_cc_gfx_RasterizerState)); 
    
    cls->defineProperty("isDiscard", _SE(js_cc_gfx_RasterizerState_isDiscard_get), _SE(js_cc_gfx_RasterizerState_isDiscard_set)); 
    cls->defineProperty("polygonMode", _SE(js_cc_gfx_RasterizerState_polygonMode_get), _SE(js_cc_gfx_RasterizerState_polygonMode_set)); 
    cls->defineProperty("shadeModel", _SE(js_cc_gfx_RasterizerState_shadeModel_get), _SE(js_cc_gfx_RasterizerState_shadeModel_set)); 
    cls->defineProperty("cullMode", _SE(js_cc_gfx_RasterizerState_cullMode_get), _SE(js_cc_gfx_RasterizerState_cullMode_set)); 
    cls->defineProperty("isFrontFaceCCW", _SE(js_cc_gfx_RasterizerState_isFrontFaceCCW_get), _SE(js_cc_gfx_RasterizerState_isFrontFaceCCW_set)); 
    cls->defineProperty("depthBiasEnabled", _SE(js_cc_gfx_RasterizerState_depthBiasEnabled_get), _SE(js_cc_gfx_RasterizerState_depthBiasEnabled_set)); 
    cls->defineProperty("depthBias", _SE(js_cc_gfx_RasterizerState_depthBias_get), _SE(js_cc_gfx_RasterizerState_depthBias_set)); 
    cls->defineProperty("depthBiasClamp", _SE(js_cc_gfx_RasterizerState_depthBiasClamp_get), _SE(js_cc_gfx_RasterizerState_depthBiasClamp_set)); 
    cls->defineProperty("depthBiasSlop", _SE(js_cc_gfx_RasterizerState_depthBiasSlop_get), _SE(js_cc_gfx_RasterizerState_depthBiasSlop_set)); 
    cls->defineProperty("isDepthClip", _SE(js_cc_gfx_RasterizerState_isDepthClip_get), _SE(js_cc_gfx_RasterizerState_isDepthClip_set)); 
    cls->defineProperty("isMultisample", _SE(js_cc_gfx_RasterizerState_isMultisample_get), _SE(js_cc_gfx_RasterizerState_isMultisample_set)); 
    cls->defineProperty("lineWidth", _SE(js_cc_gfx_RasterizerState_lineWidth_get), _SE(js_cc_gfx_RasterizerState_lineWidth_set)); 
    
    cls->defineFunction("reset", _SE(js_cc_gfx_RasterizerState_reset)); 
    cls->defineFunction("copy", _SE(js_cc_gfx_RasterizerState_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_RasterizerState));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::RasterizerState>(cls);
    
    __jsb_cc_gfx_RasterizerState_proto = cls->getProto();
    __jsb_cc_gfx_RasterizerState_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DepthStencilState_class = nullptr;
se::Object* __jsb_cc_gfx_DepthStencilState_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DepthStencilState) 

static bool js_cc_gfx_DepthStencilState_depthTest_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->depthTest, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilState_depthTest_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_depthTest_set) 

static bool js_cc_gfx_DepthStencilState_depthTest_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->depthTest, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilState_depthTest_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthTest, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_depthTest_get) 

static bool js_cc_gfx_DepthStencilState_depthWrite_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->depthWrite, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilState_depthWrite_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_depthWrite_set) 

static bool js_cc_gfx_DepthStencilState_depthWrite_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->depthWrite, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilState_depthWrite_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthWrite, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_depthWrite_get) 

static bool js_cc_gfx_DepthStencilState_depthFunc_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "DepthStencilState_depthFunc_set,2,SWIGTYPE_cc__gfx__ComparisonFunc");
    arg1->depthFunc = (cc::gfx::ComparisonFunc)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_depthFunc_set) 

static bool js_cc_gfx_DepthStencilState_depthFunc_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->depthFunc));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_depthFunc_get) 

static bool js_cc_gfx_DepthStencilState_stencilTestFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stencilTestFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilState_stencilTestFront_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilTestFront_set) 

static bool js_cc_gfx_DepthStencilState_stencilTestFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stencilTestFront, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilState_stencilTestFront_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilTestFront, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilTestFront_get) 

static bool js_cc_gfx_DepthStencilState_stencilFuncFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "DepthStencilState_stencilFuncFront_set,2,SWIGTYPE_cc__gfx__ComparisonFunc");
    arg1->stencilFuncFront = (cc::gfx::ComparisonFunc)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilFuncFront_set) 

static bool js_cc_gfx_DepthStencilState_stencilFuncFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->stencilFuncFront));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilFuncFront_get) 

static bool js_cc_gfx_DepthStencilState_stencilReadMaskFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stencilReadMaskFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilState_stencilReadMaskFront_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilReadMaskFront_set) 

static bool js_cc_gfx_DepthStencilState_stencilReadMaskFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stencilReadMaskFront, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilState_stencilReadMaskFront_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilReadMaskFront, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilReadMaskFront_get) 

static bool js_cc_gfx_DepthStencilState_stencilWriteMaskFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stencilWriteMaskFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilState_stencilWriteMaskFront_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilWriteMaskFront_set) 

static bool js_cc_gfx_DepthStencilState_stencilWriteMaskFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stencilWriteMaskFront, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilState_stencilWriteMaskFront_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilWriteMaskFront, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilWriteMaskFront_get) 

static bool js_cc_gfx_DepthStencilState_stencilFailOpFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "DepthStencilState_stencilFailOpFront_set,2,SWIGTYPE_cc__gfx__StencilOp");
    arg1->stencilFailOpFront = (cc::gfx::StencilOp)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilFailOpFront_set) 

static bool js_cc_gfx_DepthStencilState_stencilFailOpFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->stencilFailOpFront));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilFailOpFront_get) 

static bool js_cc_gfx_DepthStencilState_stencilZFailOpFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "DepthStencilState_stencilZFailOpFront_set,2,SWIGTYPE_cc__gfx__StencilOp");
    arg1->stencilZFailOpFront = (cc::gfx::StencilOp)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilZFailOpFront_set) 

static bool js_cc_gfx_DepthStencilState_stencilZFailOpFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->stencilZFailOpFront));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilZFailOpFront_get) 

static bool js_cc_gfx_DepthStencilState_stencilPassOpFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "DepthStencilState_stencilPassOpFront_set,2,SWIGTYPE_cc__gfx__StencilOp");
    arg1->stencilPassOpFront = (cc::gfx::StencilOp)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilPassOpFront_set) 

static bool js_cc_gfx_DepthStencilState_stencilPassOpFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->stencilPassOpFront));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilPassOpFront_get) 

static bool js_cc_gfx_DepthStencilState_stencilRefFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stencilRefFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilState_stencilRefFront_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilRefFront_set) 

static bool js_cc_gfx_DepthStencilState_stencilRefFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stencilRefFront, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilState_stencilRefFront_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilRefFront, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilRefFront_get) 

static bool js_cc_gfx_DepthStencilState_stencilTestBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stencilTestBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilState_stencilTestBack_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilTestBack_set) 

static bool js_cc_gfx_DepthStencilState_stencilTestBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stencilTestBack, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilState_stencilTestBack_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilTestBack, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilTestBack_get) 

static bool js_cc_gfx_DepthStencilState_stencilFuncBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "DepthStencilState_stencilFuncBack_set,2,SWIGTYPE_cc__gfx__ComparisonFunc");
    arg1->stencilFuncBack = (cc::gfx::ComparisonFunc)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilFuncBack_set) 

static bool js_cc_gfx_DepthStencilState_stencilFuncBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->stencilFuncBack));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilFuncBack_get) 

static bool js_cc_gfx_DepthStencilState_stencilReadMaskBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stencilReadMaskBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilState_stencilReadMaskBack_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilReadMaskBack_set) 

static bool js_cc_gfx_DepthStencilState_stencilReadMaskBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stencilReadMaskBack, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilState_stencilReadMaskBack_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilReadMaskBack, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilReadMaskBack_get) 

static bool js_cc_gfx_DepthStencilState_stencilWriteMaskBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stencilWriteMaskBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilState_stencilWriteMaskBack_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilWriteMaskBack_set) 

static bool js_cc_gfx_DepthStencilState_stencilWriteMaskBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stencilWriteMaskBack, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilState_stencilWriteMaskBack_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilWriteMaskBack, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilWriteMaskBack_get) 

static bool js_cc_gfx_DepthStencilState_stencilFailOpBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "DepthStencilState_stencilFailOpBack_set,2,SWIGTYPE_cc__gfx__StencilOp");
    arg1->stencilFailOpBack = (cc::gfx::StencilOp)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilFailOpBack_set) 

static bool js_cc_gfx_DepthStencilState_stencilFailOpBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->stencilFailOpBack));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilFailOpBack_get) 

static bool js_cc_gfx_DepthStencilState_stencilZFailOpBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "DepthStencilState_stencilZFailOpBack_set,2,SWIGTYPE_cc__gfx__StencilOp");
    arg1->stencilZFailOpBack = (cc::gfx::StencilOp)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilZFailOpBack_set) 

static bool js_cc_gfx_DepthStencilState_stencilZFailOpBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->stencilZFailOpBack));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilZFailOpBack_get) 

static bool js_cc_gfx_DepthStencilState_stencilPassOpBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "DepthStencilState_stencilPassOpBack_set,2,SWIGTYPE_cc__gfx__StencilOp");
    arg1->stencilPassOpBack = (cc::gfx::StencilOp)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilPassOpBack_set) 

static bool js_cc_gfx_DepthStencilState_stencilPassOpBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->stencilPassOpBack));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilPassOpBack_get) 

static bool js_cc_gfx_DepthStencilState_stencilRefBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stencilRefBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilState_stencilRefBack_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilRefBack_set) 

static bool js_cc_gfx_DepthStencilState_stencilRefBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stencilRefBack, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilState_stencilRefBack_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilRefBack, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilRefBack_get) 

static bool js_cc_gfx_DepthStencilState_reset(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->reset();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DepthStencilState_reset) 

static bool js_cc_gfx_DepthStencilState_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    cc::gfx::DepthStencilState *arg2 = 0 ;
    cc::gfx::DepthStencilState temp2 ;
    cc::gfx::DepthStencilState *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DepthStencilState_copy,2,SWIGTYPE_p_cc__gfx__DepthStencilState");
    arg2 = &temp2;
    
    result = (cc::gfx::DepthStencilState *) &(arg1)->copy((cc::gfx::DepthStencilState const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DepthStencilState_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DepthStencilState_copy) 

// js_ctor
static bool js_new_cc_gfx_DepthStencilState(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::DepthStencilState *result;
    result = (cc::gfx::DepthStencilState *)new cc::gfx::DepthStencilState();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_DepthStencilState, __jsb_cc_gfx_DepthStencilState_class, js_delete_cc_gfx_DepthStencilState)

static bool js_delete_cc_gfx_DepthStencilState(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DepthStencilState) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::DepthStencilState * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::DepthStencilState*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("depthTest", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthTest), ctx);
    }
    
    
    json->getProperty("depthWrite", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthWrite), ctx);
    }
    
    
    json->getProperty("depthFunc", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthFunc), ctx);
    }
    
    
    json->getProperty("stencilTestFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilTestFront), ctx);
    }
    
    
    json->getProperty("stencilFuncFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilFuncFront), ctx);
    }
    
    
    json->getProperty("stencilReadMaskFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilReadMaskFront), ctx);
    }
    
    
    json->getProperty("stencilWriteMaskFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilWriteMaskFront), ctx);
    }
    
    
    json->getProperty("stencilFailOpFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilFailOpFront), ctx);
    }
    
    
    json->getProperty("stencilZFailOpFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilZFailOpFront), ctx);
    }
    
    
    json->getProperty("stencilPassOpFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilPassOpFront), ctx);
    }
    
    
    json->getProperty("stencilRefFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilRefFront), ctx);
    }
    
    
    json->getProperty("stencilTestBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilTestBack), ctx);
    }
    
    
    json->getProperty("stencilFuncBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilFuncBack), ctx);
    }
    
    
    json->getProperty("stencilReadMaskBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilReadMaskBack), ctx);
    }
    
    
    json->getProperty("stencilWriteMaskBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilWriteMaskBack), ctx);
    }
    
    
    json->getProperty("stencilFailOpBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilFailOpBack), ctx);
    }
    
    
    json->getProperty("stencilZFailOpBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilZFailOpBack), ctx);
    }
    
    
    json->getProperty("stencilPassOpBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilPassOpBack), ctx);
    }
    
    
    json->getProperty("stencilRefBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilRefBack), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_DepthStencilState(se::Object* obj) {
    auto* cls = se::Class::create("DepthStencilState", obj, nullptr, _SE(js_new_cc_gfx_DepthStencilState)); 
    
    cls->defineProperty("depthTest", _SE(js_cc_gfx_DepthStencilState_depthTest_get), _SE(js_cc_gfx_DepthStencilState_depthTest_set)); 
    cls->defineProperty("depthWrite", _SE(js_cc_gfx_DepthStencilState_depthWrite_get), _SE(js_cc_gfx_DepthStencilState_depthWrite_set)); 
    cls->defineProperty("depthFunc", _SE(js_cc_gfx_DepthStencilState_depthFunc_get), _SE(js_cc_gfx_DepthStencilState_depthFunc_set)); 
    cls->defineProperty("stencilTestFront", _SE(js_cc_gfx_DepthStencilState_stencilTestFront_get), _SE(js_cc_gfx_DepthStencilState_stencilTestFront_set)); 
    cls->defineProperty("stencilFuncFront", _SE(js_cc_gfx_DepthStencilState_stencilFuncFront_get), _SE(js_cc_gfx_DepthStencilState_stencilFuncFront_set)); 
    cls->defineProperty("stencilReadMaskFront", _SE(js_cc_gfx_DepthStencilState_stencilReadMaskFront_get), _SE(js_cc_gfx_DepthStencilState_stencilReadMaskFront_set)); 
    cls->defineProperty("stencilWriteMaskFront", _SE(js_cc_gfx_DepthStencilState_stencilWriteMaskFront_get), _SE(js_cc_gfx_DepthStencilState_stencilWriteMaskFront_set)); 
    cls->defineProperty("stencilFailOpFront", _SE(js_cc_gfx_DepthStencilState_stencilFailOpFront_get), _SE(js_cc_gfx_DepthStencilState_stencilFailOpFront_set)); 
    cls->defineProperty("stencilZFailOpFront", _SE(js_cc_gfx_DepthStencilState_stencilZFailOpFront_get), _SE(js_cc_gfx_DepthStencilState_stencilZFailOpFront_set)); 
    cls->defineProperty("stencilPassOpFront", _SE(js_cc_gfx_DepthStencilState_stencilPassOpFront_get), _SE(js_cc_gfx_DepthStencilState_stencilPassOpFront_set)); 
    cls->defineProperty("stencilRefFront", _SE(js_cc_gfx_DepthStencilState_stencilRefFront_get), _SE(js_cc_gfx_DepthStencilState_stencilRefFront_set)); 
    cls->defineProperty("stencilTestBack", _SE(js_cc_gfx_DepthStencilState_stencilTestBack_get), _SE(js_cc_gfx_DepthStencilState_stencilTestBack_set)); 
    cls->defineProperty("stencilFuncBack", _SE(js_cc_gfx_DepthStencilState_stencilFuncBack_get), _SE(js_cc_gfx_DepthStencilState_stencilFuncBack_set)); 
    cls->defineProperty("stencilReadMaskBack", _SE(js_cc_gfx_DepthStencilState_stencilReadMaskBack_get), _SE(js_cc_gfx_DepthStencilState_stencilReadMaskBack_set)); 
    cls->defineProperty("stencilWriteMaskBack", _SE(js_cc_gfx_DepthStencilState_stencilWriteMaskBack_get), _SE(js_cc_gfx_DepthStencilState_stencilWriteMaskBack_set)); 
    cls->defineProperty("stencilFailOpBack", _SE(js_cc_gfx_DepthStencilState_stencilFailOpBack_get), _SE(js_cc_gfx_DepthStencilState_stencilFailOpBack_set)); 
    cls->defineProperty("stencilZFailOpBack", _SE(js_cc_gfx_DepthStencilState_stencilZFailOpBack_get), _SE(js_cc_gfx_DepthStencilState_stencilZFailOpBack_set)); 
    cls->defineProperty("stencilPassOpBack", _SE(js_cc_gfx_DepthStencilState_stencilPassOpBack_get), _SE(js_cc_gfx_DepthStencilState_stencilPassOpBack_set)); 
    cls->defineProperty("stencilRefBack", _SE(js_cc_gfx_DepthStencilState_stencilRefBack_get), _SE(js_cc_gfx_DepthStencilState_stencilRefBack_set)); 
    
    cls->defineFunction("reset", _SE(js_cc_gfx_DepthStencilState_reset)); 
    cls->defineFunction("copy", _SE(js_cc_gfx_DepthStencilState_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DepthStencilState));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DepthStencilState>(cls);
    
    __jsb_cc_gfx_DepthStencilState_proto = cls->getProto();
    __jsb_cc_gfx_DepthStencilState_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_BlendTarget_class = nullptr;
se::Object* __jsb_cc_gfx_BlendTarget_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_BlendTarget) 

static bool js_cc_gfx_BlendTarget_blend_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->blend, s.thisObject());
    SE_PRECONDITION2(ok, false, "BlendTarget_blend_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BlendTarget_blend_set) 

static bool js_cc_gfx_BlendTarget_blend_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->blend, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BlendTarget_blend_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blend, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BlendTarget_blend_get) 

static bool js_cc_gfx_BlendTarget_blendSrc_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "BlendTarget_blendSrc_set,2,SWIGTYPE_cc__gfx__BlendFactor");
    arg1->blendSrc = (cc::gfx::BlendFactor)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BlendTarget_blendSrc_set) 

static bool js_cc_gfx_BlendTarget_blendSrc_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->blendSrc));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BlendTarget_blendSrc_get) 

static bool js_cc_gfx_BlendTarget_blendDst_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "BlendTarget_blendDst_set,2,SWIGTYPE_cc__gfx__BlendFactor");
    arg1->blendDst = (cc::gfx::BlendFactor)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BlendTarget_blendDst_set) 

static bool js_cc_gfx_BlendTarget_blendDst_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->blendDst));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BlendTarget_blendDst_get) 

static bool js_cc_gfx_BlendTarget_blendEq_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "BlendTarget_blendEq_set,2,SWIGTYPE_cc__gfx__BlendOp");
    arg1->blendEq = (cc::gfx::BlendOp)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BlendTarget_blendEq_set) 

static bool js_cc_gfx_BlendTarget_blendEq_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->blendEq));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BlendTarget_blendEq_get) 

static bool js_cc_gfx_BlendTarget_blendSrcAlpha_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "BlendTarget_blendSrcAlpha_set,2,SWIGTYPE_cc__gfx__BlendFactor");
    arg1->blendSrcAlpha = (cc::gfx::BlendFactor)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BlendTarget_blendSrcAlpha_set) 

static bool js_cc_gfx_BlendTarget_blendSrcAlpha_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->blendSrcAlpha));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BlendTarget_blendSrcAlpha_get) 

static bool js_cc_gfx_BlendTarget_blendDstAlpha_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "BlendTarget_blendDstAlpha_set,2,SWIGTYPE_cc__gfx__BlendFactor");
    arg1->blendDstAlpha = (cc::gfx::BlendFactor)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BlendTarget_blendDstAlpha_set) 

static bool js_cc_gfx_BlendTarget_blendDstAlpha_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->blendDstAlpha));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BlendTarget_blendDstAlpha_get) 

static bool js_cc_gfx_BlendTarget_blendAlphaEq_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "BlendTarget_blendAlphaEq_set,2,SWIGTYPE_cc__gfx__BlendOp");
    arg1->blendAlphaEq = (cc::gfx::BlendOp)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BlendTarget_blendAlphaEq_set) 

static bool js_cc_gfx_BlendTarget_blendAlphaEq_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->blendAlphaEq));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BlendTarget_blendAlphaEq_get) 

static bool js_cc_gfx_BlendTarget_blendColorMask_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "BlendTarget_blendColorMask_set,2,SWIGTYPE_cc__gfx__ColorMask");
    arg1->blendColorMask = (cc::gfx::ColorMask)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BlendTarget_blendColorMask_set) 

static bool js_cc_gfx_BlendTarget_blendColorMask_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->blendColorMask));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BlendTarget_blendColorMask_get) 

static bool js_cc_gfx_BlendTarget_reset(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->reset();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BlendTarget_reset) 

static bool js_cc_gfx_BlendTarget_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    cc::gfx::BlendTarget *arg2 = 0 ;
    cc::gfx::BlendTarget temp2 ;
    cc::gfx::BlendTarget *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BlendTarget_copy,2,SWIGTYPE_p_cc__gfx__BlendTarget");
    arg2 = &temp2;
    
    result = (cc::gfx::BlendTarget *) &(arg1)->copy((cc::gfx::BlendTarget const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BlendTarget_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BlendTarget_copy) 

// js_ctor
static bool js_new_cc_gfx_BlendTarget(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::BlendTarget *result;
    result = (cc::gfx::BlendTarget *)new cc::gfx::BlendTarget();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_BlendTarget, __jsb_cc_gfx_BlendTarget_class, js_delete_cc_gfx_BlendTarget)

static bool js_delete_cc_gfx_BlendTarget(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_BlendTarget) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::BlendTarget * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::BlendTarget*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("blend", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blend), ctx);
    }
    
    
    json->getProperty("blendSrc", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendSrc), ctx);
    }
    
    
    json->getProperty("blendDst", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendDst), ctx);
    }
    
    
    json->getProperty("blendEq", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendEq), ctx);
    }
    
    
    json->getProperty("blendSrcAlpha", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendSrcAlpha), ctx);
    }
    
    
    json->getProperty("blendDstAlpha", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendDstAlpha), ctx);
    }
    
    
    json->getProperty("blendAlphaEq", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendAlphaEq), ctx);
    }
    
    
    json->getProperty("blendColorMask", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendColorMask), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_BlendTarget(se::Object* obj) {
    auto* cls = se::Class::create("BlendTarget", obj, nullptr, _SE(js_new_cc_gfx_BlendTarget)); 
    
    cls->defineProperty("blend", _SE(js_cc_gfx_BlendTarget_blend_get), _SE(js_cc_gfx_BlendTarget_blend_set)); 
    cls->defineProperty("blendSrc", _SE(js_cc_gfx_BlendTarget_blendSrc_get), _SE(js_cc_gfx_BlendTarget_blendSrc_set)); 
    cls->defineProperty("blendDst", _SE(js_cc_gfx_BlendTarget_blendDst_get), _SE(js_cc_gfx_BlendTarget_blendDst_set)); 
    cls->defineProperty("blendEq", _SE(js_cc_gfx_BlendTarget_blendEq_get), _SE(js_cc_gfx_BlendTarget_blendEq_set)); 
    cls->defineProperty("blendSrcAlpha", _SE(js_cc_gfx_BlendTarget_blendSrcAlpha_get), _SE(js_cc_gfx_BlendTarget_blendSrcAlpha_set)); 
    cls->defineProperty("blendDstAlpha", _SE(js_cc_gfx_BlendTarget_blendDstAlpha_get), _SE(js_cc_gfx_BlendTarget_blendDstAlpha_set)); 
    cls->defineProperty("blendAlphaEq", _SE(js_cc_gfx_BlendTarget_blendAlphaEq_get), _SE(js_cc_gfx_BlendTarget_blendAlphaEq_set)); 
    cls->defineProperty("blendColorMask", _SE(js_cc_gfx_BlendTarget_blendColorMask_get), _SE(js_cc_gfx_BlendTarget_blendColorMask_set)); 
    
    cls->defineFunction("reset", _SE(js_cc_gfx_BlendTarget_reset)); 
    cls->defineFunction("copy", _SE(js_cc_gfx_BlendTarget_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_BlendTarget));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::BlendTarget>(cls);
    
    __jsb_cc_gfx_BlendTarget_proto = cls->getProto();
    __jsb_cc_gfx_BlendTarget_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_BlendState_class = nullptr;
se::Object* __jsb_cc_gfx_BlendState_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_BlendState) 

static bool js_cc_gfx_BlendState_isA2C_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendState *arg1 = (cc::gfx::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->isA2C, s.thisObject());
    SE_PRECONDITION2(ok, false, "BlendState_isA2C_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BlendState_isA2C_set) 

static bool js_cc_gfx_BlendState_isA2C_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BlendState *arg1 = (cc::gfx::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->isA2C, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BlendState_isA2C_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->isA2C, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BlendState_isA2C_get) 

static bool js_cc_gfx_BlendState_isIndepend_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendState *arg1 = (cc::gfx::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->isIndepend, s.thisObject());
    SE_PRECONDITION2(ok, false, "BlendState_isIndepend_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BlendState_isIndepend_set) 

static bool js_cc_gfx_BlendState_isIndepend_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BlendState *arg1 = (cc::gfx::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->isIndepend, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BlendState_isIndepend_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->isIndepend, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BlendState_isIndepend_get) 

static bool js_cc_gfx_BlendState_blendColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendState *arg1 = (cc::gfx::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->blendColor, s.thisObject());
    SE_PRECONDITION2(ok, false, "BlendState_blendColor_set,2,SWIGTYPE_cc__gfx__Color"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BlendState_blendColor_set) 

static bool js_cc_gfx_BlendState_blendColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BlendState *arg1 = (cc::gfx::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->blendColor, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BlendState_blendColor_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendColor, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BlendState_blendColor_get) 

static bool js_cc_gfx_BlendState_targets_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendState *arg1 = (cc::gfx::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->targets, s.thisObject());
    SE_PRECONDITION2(ok, false, "BlendState_targets_set,2,SWIGTYPE_ccstd__vectorT_cc__gfx__BlendTarget_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BlendState_targets_set) 

static bool js_cc_gfx_BlendState_targets_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BlendState *arg1 = (cc::gfx::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->targets, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BlendState_targets_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->targets, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BlendState_targets_get) 

static bool js_cc_gfx_BlendState_setTarget(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendState *arg1 = (cc::gfx::BlendState *) NULL ;
    index_t arg2 ;
    cc::gfx::BlendTarget *arg3 = 0 ;
    cc::gfx::BlendTarget temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BlendState_setTarget,2,SWIGTYPE_index_t"); 
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "BlendState_setTarget,3,SWIGTYPE_p_cc__gfx__BlendTarget");
    arg3 = &temp3;
    
    (arg1)->setTarget(arg2,(cc::gfx::BlendTarget const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BlendState_setTarget) 

static bool js_cc_gfx_BlendState_reset(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendState *arg1 = (cc::gfx::BlendState *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->reset();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BlendState_reset) 

static bool js_cc_gfx_BlendState_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendState *arg1 = (cc::gfx::BlendState *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BlendState_destroy) 

static bool js_cc_gfx_BlendState_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendState *arg1 = (cc::gfx::BlendState *) NULL ;
    cc::gfx::BlendState *arg2 = 0 ;
    cc::gfx::BlendState temp2 ;
    cc::gfx::BlendState *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BlendState_copy,2,SWIGTYPE_p_cc__gfx__BlendState");
    arg2 = &temp2;
    
    result = (cc::gfx::BlendState *) &(arg1)->copy((cc::gfx::BlendState const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BlendState_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BlendState_copy) 

// js_ctor
static bool js_new_cc_gfx_BlendState(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::BlendState *result;
    result = (cc::gfx::BlendState *)new cc::gfx::BlendState();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_BlendState, __jsb_cc_gfx_BlendState_class, js_delete_cc_gfx_BlendState)

static bool js_delete_cc_gfx_BlendState(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_BlendState) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::BlendState * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::BlendState*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("isA2C", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isA2C), ctx);
    }
    
    
    json->getProperty("isIndepend", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isIndepend), ctx);
    }
    
    
    json->getProperty("blendColor", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendColor), ctx);
    }
    
    
    json->getProperty("targets", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->targets), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_BlendState(se::Object* obj) {
    auto* cls = se::Class::create("BlendState", obj, nullptr, _SE(js_new_cc_gfx_BlendState)); 
    
    cls->defineProperty("isA2C", _SE(js_cc_gfx_BlendState_isA2C_get), _SE(js_cc_gfx_BlendState_isA2C_set)); 
    cls->defineProperty("isIndepend", _SE(js_cc_gfx_BlendState_isIndepend_get), _SE(js_cc_gfx_BlendState_isIndepend_set)); 
    cls->defineProperty("blendColor", _SE(js_cc_gfx_BlendState_blendColor_get), _SE(js_cc_gfx_BlendState_blendColor_set)); 
    cls->defineProperty("targets", _SE(js_cc_gfx_BlendState_targets_get), _SE(js_cc_gfx_BlendState_targets_set)); 
    
    cls->defineFunction("setTarget", _SE(js_cc_gfx_BlendState_setTarget)); 
    cls->defineFunction("reset", _SE(js_cc_gfx_BlendState_reset)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_BlendState_destroy)); 
    cls->defineFunction("copy", _SE(js_cc_gfx_BlendState_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_BlendState));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::BlendState>(cls);
    
    __jsb_cc_gfx_BlendState_proto = cls->getProto();
    __jsb_cc_gfx_BlendState_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_PipelineStateInfo_class = nullptr;
se::Object* __jsb_cc_gfx_PipelineStateInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_PipelineStateInfo) 

static bool js_cc_gfx_PipelineStateInfo_shader_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->shader, s.thisObject());
    SE_PRECONDITION2(ok, false, "PipelineStateInfo_shader_set,2,SWIGTYPE_p_cc__gfx__Shader"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_PipelineStateInfo_shader_set) 

static bool js_cc_gfx_PipelineStateInfo_shader_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->shader, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineStateInfo_shader_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->shader, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineStateInfo_shader_get) 

static bool js_cc_gfx_PipelineStateInfo_pipelineLayout_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->pipelineLayout, s.thisObject());
    SE_PRECONDITION2(ok, false, "PipelineStateInfo_pipelineLayout_set,2,SWIGTYPE_p_cc__gfx__PipelineLayout"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_PipelineStateInfo_pipelineLayout_set) 

static bool js_cc_gfx_PipelineStateInfo_pipelineLayout_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->pipelineLayout, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineStateInfo_pipelineLayout_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->pipelineLayout, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineStateInfo_pipelineLayout_get) 

static bool js_cc_gfx_PipelineStateInfo_renderPass_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->renderPass, s.thisObject());
    SE_PRECONDITION2(ok, false, "PipelineStateInfo_renderPass_set,2,SWIGTYPE_p_cc__gfx__RenderPass"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_PipelineStateInfo_renderPass_set) 

static bool js_cc_gfx_PipelineStateInfo_renderPass_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->renderPass, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineStateInfo_renderPass_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->renderPass, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineStateInfo_renderPass_get) 

static bool js_cc_gfx_PipelineStateInfo_inputState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->inputState, s.thisObject());
    SE_PRECONDITION2(ok, false, "PipelineStateInfo_inputState_set,2,SWIGTYPE_cc__gfx__InputState"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_PipelineStateInfo_inputState_set) 

static bool js_cc_gfx_PipelineStateInfo_inputState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->inputState, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineStateInfo_inputState_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->inputState, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineStateInfo_inputState_get) 

static bool js_cc_gfx_PipelineStateInfo_rasterizerState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->rasterizerState, s.thisObject());
    SE_PRECONDITION2(ok, false, "PipelineStateInfo_rasterizerState_set,2,SWIGTYPE_cc__gfx__RasterizerState"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_PipelineStateInfo_rasterizerState_set) 

static bool js_cc_gfx_PipelineStateInfo_rasterizerState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->rasterizerState, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineStateInfo_rasterizerState_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->rasterizerState, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineStateInfo_rasterizerState_get) 

static bool js_cc_gfx_PipelineStateInfo_depthStencilState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->depthStencilState, s.thisObject());
    SE_PRECONDITION2(ok, false, "PipelineStateInfo_depthStencilState_set,2,SWIGTYPE_cc__gfx__DepthStencilState"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_PipelineStateInfo_depthStencilState_set) 

static bool js_cc_gfx_PipelineStateInfo_depthStencilState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->depthStencilState, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineStateInfo_depthStencilState_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthStencilState, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineStateInfo_depthStencilState_get) 

static bool js_cc_gfx_PipelineStateInfo_blendState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->blendState, s.thisObject());
    SE_PRECONDITION2(ok, false, "PipelineStateInfo_blendState_set,2,SWIGTYPE_cc__gfx__BlendState"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_PipelineStateInfo_blendState_set) 

static bool js_cc_gfx_PipelineStateInfo_blendState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->blendState, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineStateInfo_blendState_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendState, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineStateInfo_blendState_get) 

static bool js_cc_gfx_PipelineStateInfo_primitive_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "PipelineStateInfo_primitive_set,2,SWIGTYPE_cc__gfx__PrimitiveMode");
    arg1->primitive = (cc::gfx::PrimitiveMode)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_PipelineStateInfo_primitive_set) 

static bool js_cc_gfx_PipelineStateInfo_primitive_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->primitive));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineStateInfo_primitive_get) 

static bool js_cc_gfx_PipelineStateInfo_dynamicStates_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "PipelineStateInfo_dynamicStates_set,2,SWIGTYPE_cc__gfx__DynamicStateFlagBit");
    arg1->dynamicStates = (cc::gfx::DynamicStateFlags)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_PipelineStateInfo_dynamicStates_set) 

static bool js_cc_gfx_PipelineStateInfo_dynamicStates_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->dynamicStates));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineStateInfo_dynamicStates_get) 

static bool js_cc_gfx_PipelineStateInfo_bindPoint_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "PipelineStateInfo_bindPoint_set,2,SWIGTYPE_cc__gfx__PipelineBindPoint");
    arg1->bindPoint = (cc::gfx::PipelineBindPoint)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_PipelineStateInfo_bindPoint_set) 

static bool js_cc_gfx_PipelineStateInfo_bindPoint_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->bindPoint));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineStateInfo_bindPoint_get) 

static bool js_cc_gfx_PipelineStateInfo_subpass_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->subpass, s.thisObject());
    SE_PRECONDITION2(ok, false, "PipelineStateInfo_subpass_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_PipelineStateInfo_subpass_set) 

static bool js_cc_gfx_PipelineStateInfo_subpass_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->subpass, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineStateInfo_subpass_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->subpass, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineStateInfo_subpass_get) 

static bool js_cc_gfx_PipelineStateInfo_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    cc::gfx::PipelineStateInfo *arg2 = 0 ;
    cc::gfx::PipelineStateInfo temp2 ;
    cc::gfx::PipelineStateInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "PipelineStateInfo_copy,2,SWIGTYPE_p_cc__gfx__PipelineStateInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::PipelineStateInfo *) &(arg1)->copy((cc::gfx::PipelineStateInfo const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineStateInfo_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_PipelineStateInfo_copy) 

// js_ctor
static bool js_new_cc_gfx_PipelineStateInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::PipelineStateInfo *result;
    result = (cc::gfx::PipelineStateInfo *)new cc::gfx::PipelineStateInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_PipelineStateInfo, __jsb_cc_gfx_PipelineStateInfo_class, js_delete_cc_gfx_PipelineStateInfo)

static bool js_delete_cc_gfx_PipelineStateInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_PipelineStateInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::PipelineStateInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::PipelineStateInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("shader", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->shader), ctx);
    }
    
    
    json->getProperty("pipelineLayout", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->pipelineLayout), ctx);
    }
    
    
    json->getProperty("renderPass", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->renderPass), ctx);
    }
    
    
    json->getProperty("inputState", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->inputState), ctx);
    }
    
    
    json->getProperty("rasterizerState", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->rasterizerState), ctx);
    }
    
    
    json->getProperty("depthStencilState", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthStencilState), ctx);
    }
    
    
    json->getProperty("blendState", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendState), ctx);
    }
    
    
    json->getProperty("primitive", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->primitive), ctx);
    }
    
    
    json->getProperty("dynamicStates", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dynamicStates), ctx);
    }
    
    
    json->getProperty("bindPoint", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->bindPoint), ctx);
    }
    
    
    json->getProperty("subpass", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->subpass), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_PipelineStateInfo(se::Object* obj) {
    auto* cls = se::Class::create("PipelineStateInfo", obj, nullptr, _SE(js_new_cc_gfx_PipelineStateInfo)); 
    
    cls->defineProperty("shader", _SE(js_cc_gfx_PipelineStateInfo_shader_get), _SE(js_cc_gfx_PipelineStateInfo_shader_set)); 
    cls->defineProperty("pipelineLayout", _SE(js_cc_gfx_PipelineStateInfo_pipelineLayout_get), _SE(js_cc_gfx_PipelineStateInfo_pipelineLayout_set)); 
    cls->defineProperty("renderPass", _SE(js_cc_gfx_PipelineStateInfo_renderPass_get), _SE(js_cc_gfx_PipelineStateInfo_renderPass_set)); 
    cls->defineProperty("inputState", _SE(js_cc_gfx_PipelineStateInfo_inputState_get), _SE(js_cc_gfx_PipelineStateInfo_inputState_set)); 
    cls->defineProperty("rasterizerState", _SE(js_cc_gfx_PipelineStateInfo_rasterizerState_get), _SE(js_cc_gfx_PipelineStateInfo_rasterizerState_set)); 
    cls->defineProperty("depthStencilState", _SE(js_cc_gfx_PipelineStateInfo_depthStencilState_get), _SE(js_cc_gfx_PipelineStateInfo_depthStencilState_set)); 
    cls->defineProperty("blendState", _SE(js_cc_gfx_PipelineStateInfo_blendState_get), _SE(js_cc_gfx_PipelineStateInfo_blendState_set)); 
    cls->defineProperty("primitive", _SE(js_cc_gfx_PipelineStateInfo_primitive_get), _SE(js_cc_gfx_PipelineStateInfo_primitive_set)); 
    cls->defineProperty("dynamicStates", _SE(js_cc_gfx_PipelineStateInfo_dynamicStates_get), _SE(js_cc_gfx_PipelineStateInfo_dynamicStates_set)); 
    cls->defineProperty("bindPoint", _SE(js_cc_gfx_PipelineStateInfo_bindPoint_get), _SE(js_cc_gfx_PipelineStateInfo_bindPoint_set)); 
    cls->defineProperty("subpass", _SE(js_cc_gfx_PipelineStateInfo_subpass_get), _SE(js_cc_gfx_PipelineStateInfo_subpass_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_PipelineStateInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_PipelineStateInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::PipelineStateInfo>(cls);
    
    __jsb_cc_gfx_PipelineStateInfo_proto = cls->getProto();
    __jsb_cc_gfx_PipelineStateInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_CommandBufferInfo_class = nullptr;
se::Object* __jsb_cc_gfx_CommandBufferInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_CommandBufferInfo) 

static bool js_cc_gfx_CommandBufferInfo_queue_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBufferInfo *arg1 = (cc::gfx::CommandBufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->queue, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBufferInfo_queue_set,2,SWIGTYPE_p_cc__gfx__Queue"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_CommandBufferInfo_queue_set) 

static bool js_cc_gfx_CommandBufferInfo_queue_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::CommandBufferInfo *arg1 = (cc::gfx::CommandBufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->queue, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CommandBufferInfo_queue_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->queue, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_CommandBufferInfo_queue_get) 

static bool js_cc_gfx_CommandBufferInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBufferInfo *arg1 = (cc::gfx::CommandBufferInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "CommandBufferInfo_type_set,2,SWIGTYPE_cc__gfx__CommandBufferType");
    arg1->type = (cc::gfx::CommandBufferType)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_CommandBufferInfo_type_set) 

static bool js_cc_gfx_CommandBufferInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::CommandBufferInfo *arg1 = (cc::gfx::CommandBufferInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->type));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_CommandBufferInfo_type_get) 

static bool js_cc_gfx_CommandBufferInfo_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBufferInfo *arg1 = (cc::gfx::CommandBufferInfo *) NULL ;
    cc::gfx::CommandBufferInfo *arg2 = 0 ;
    cc::gfx::CommandBufferInfo temp2 ;
    cc::gfx::CommandBufferInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBufferInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBufferInfo_copy,2,SWIGTYPE_p_cc__gfx__CommandBufferInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::CommandBufferInfo *) &(arg1)->copy((cc::gfx::CommandBufferInfo const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CommandBufferInfo_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBufferInfo_copy) 

// js_ctor
static bool js_new_cc_gfx_CommandBufferInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::CommandBufferInfo *result;
    result = (cc::gfx::CommandBufferInfo *)new cc::gfx::CommandBufferInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_CommandBufferInfo, __jsb_cc_gfx_CommandBufferInfo_class, js_delete_cc_gfx_CommandBufferInfo)

static bool js_delete_cc_gfx_CommandBufferInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_CommandBufferInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::CommandBufferInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::CommandBufferInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("queue", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->queue), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_CommandBufferInfo(se::Object* obj) {
    auto* cls = se::Class::create("CommandBufferInfo", obj, nullptr, _SE(js_new_cc_gfx_CommandBufferInfo)); 
    
    cls->defineProperty("queue", _SE(js_cc_gfx_CommandBufferInfo_queue_get), _SE(js_cc_gfx_CommandBufferInfo_queue_set)); 
    cls->defineProperty("type", _SE(js_cc_gfx_CommandBufferInfo_type_get), _SE(js_cc_gfx_CommandBufferInfo_type_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_CommandBufferInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_CommandBufferInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::CommandBufferInfo>(cls);
    
    __jsb_cc_gfx_CommandBufferInfo_proto = cls->getProto();
    __jsb_cc_gfx_CommandBufferInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_QueueInfo_class = nullptr;
se::Object* __jsb_cc_gfx_QueueInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_QueueInfo) 

static bool js_cc_gfx_QueueInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::QueueInfo *arg1 = (cc::gfx::QueueInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::QueueInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "QueueInfo_type_set,2,SWIGTYPE_cc__gfx__QueueType");
    arg1->type = (cc::gfx::QueueType)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_QueueInfo_type_set) 

static bool js_cc_gfx_QueueInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::QueueInfo *arg1 = (cc::gfx::QueueInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::QueueInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->type));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_QueueInfo_type_get) 

static bool js_cc_gfx_QueueInfo_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::QueueInfo *arg1 = (cc::gfx::QueueInfo *) NULL ;
    cc::gfx::QueueInfo *arg2 = 0 ;
    cc::gfx::QueueInfo temp2 ;
    cc::gfx::QueueInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::QueueInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "QueueInfo_copy,2,SWIGTYPE_p_cc__gfx__QueueInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::QueueInfo *) &(arg1)->copy((cc::gfx::QueueInfo const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "QueueInfo_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_QueueInfo_copy) 

// js_ctor
static bool js_new_cc_gfx_QueueInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::QueueInfo *result;
    result = (cc::gfx::QueueInfo *)new cc::gfx::QueueInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_QueueInfo, __jsb_cc_gfx_QueueInfo_class, js_delete_cc_gfx_QueueInfo)

static bool js_delete_cc_gfx_QueueInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_QueueInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::QueueInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::QueueInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_QueueInfo(se::Object* obj) {
    auto* cls = se::Class::create("QueueInfo", obj, nullptr, _SE(js_new_cc_gfx_QueueInfo)); 
    
    cls->defineProperty("type", _SE(js_cc_gfx_QueueInfo_type_get), _SE(js_cc_gfx_QueueInfo_type_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_QueueInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_QueueInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::QueueInfo>(cls);
    
    __jsb_cc_gfx_QueueInfo_proto = cls->getProto();
    __jsb_cc_gfx_QueueInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_QueryPoolInfo_class = nullptr;
se::Object* __jsb_cc_gfx_QueryPoolInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_QueryPoolInfo) 

static bool js_cc_gfx_QueryPoolInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::QueryPoolInfo *arg1 = (cc::gfx::QueryPoolInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPoolInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "QueryPoolInfo_type_set,2,SWIGTYPE_cc__gfx__QueryType");
    arg1->type = (cc::gfx::QueryType)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_QueryPoolInfo_type_set) 

static bool js_cc_gfx_QueryPoolInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::QueryPoolInfo *arg1 = (cc::gfx::QueryPoolInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPoolInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->type));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_QueryPoolInfo_type_get) 

static bool js_cc_gfx_QueryPoolInfo_maxQueryObjects_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::QueryPoolInfo *arg1 = (cc::gfx::QueryPoolInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPoolInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->maxQueryObjects, s.thisObject());
    SE_PRECONDITION2(ok, false, "QueryPoolInfo_maxQueryObjects_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_QueryPoolInfo_maxQueryObjects_set) 

static bool js_cc_gfx_QueryPoolInfo_maxQueryObjects_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::QueryPoolInfo *arg1 = (cc::gfx::QueryPoolInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPoolInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->maxQueryObjects, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "QueryPoolInfo_maxQueryObjects_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxQueryObjects, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_QueryPoolInfo_maxQueryObjects_get) 

static bool js_cc_gfx_QueryPoolInfo_forceWait_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::QueryPoolInfo *arg1 = (cc::gfx::QueryPoolInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPoolInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->forceWait);
    SE_PRECONDITION2(ok, false, "QueryPoolInfo_forceWait_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_QueryPoolInfo_forceWait_set) 

static bool js_cc_gfx_QueryPoolInfo_forceWait_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::QueryPoolInfo *arg1 = (cc::gfx::QueryPoolInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPoolInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->forceWait, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_QueryPoolInfo_forceWait_get) 

static bool js_cc_gfx_QueryPoolInfo_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::QueryPoolInfo *arg1 = (cc::gfx::QueryPoolInfo *) NULL ;
    cc::gfx::QueryPoolInfo *arg2 = 0 ;
    cc::gfx::QueryPoolInfo temp2 ;
    cc::gfx::QueryPoolInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPoolInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "QueryPoolInfo_copy,2,SWIGTYPE_p_cc__gfx__QueryPoolInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::QueryPoolInfo *) &(arg1)->copy((cc::gfx::QueryPoolInfo const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "QueryPoolInfo_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_QueryPoolInfo_copy) 

// js_ctor
static bool js_new_cc_gfx_QueryPoolInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::QueryPoolInfo *result;
    result = (cc::gfx::QueryPoolInfo *)new cc::gfx::QueryPoolInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_QueryPoolInfo, __jsb_cc_gfx_QueryPoolInfo_class, js_delete_cc_gfx_QueryPoolInfo)

static bool js_delete_cc_gfx_QueryPoolInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_QueryPoolInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::QueryPoolInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::QueryPoolInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("maxQueryObjects", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxQueryObjects), ctx);
    }
    
    
    json->getProperty("forceWait", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->forceWait), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_QueryPoolInfo(se::Object* obj) {
    auto* cls = se::Class::create("QueryPoolInfo", obj, nullptr, _SE(js_new_cc_gfx_QueryPoolInfo)); 
    
    cls->defineProperty("type", _SE(js_cc_gfx_QueryPoolInfo_type_get), _SE(js_cc_gfx_QueryPoolInfo_type_set)); 
    cls->defineProperty("maxQueryObjects", _SE(js_cc_gfx_QueryPoolInfo_maxQueryObjects_get), _SE(js_cc_gfx_QueryPoolInfo_maxQueryObjects_set)); 
    cls->defineProperty("forceWait", _SE(js_cc_gfx_QueryPoolInfo_forceWait_get), _SE(js_cc_gfx_QueryPoolInfo_forceWait_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_QueryPoolInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_QueryPoolInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::QueryPoolInfo>(cls);
    
    __jsb_cc_gfx_QueryPoolInfo_proto = cls->getProto();
    __jsb_cc_gfx_QueryPoolInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_MemoryStatus_class = nullptr;
se::Object* __jsb_cc_gfx_MemoryStatus_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_MemoryStatus) 

static bool js_cc_gfx_MemoryStatus_bufferSize_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::MemoryStatus *arg1 = (cc::gfx::MemoryStatus *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::MemoryStatus>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->bufferSize, s.thisObject());
    SE_PRECONDITION2(ok, false, "MemoryStatus_bufferSize_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_MemoryStatus_bufferSize_set) 

static bool js_cc_gfx_MemoryStatus_bufferSize_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::MemoryStatus *arg1 = (cc::gfx::MemoryStatus *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::MemoryStatus>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->bufferSize, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MemoryStatus_bufferSize_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->bufferSize, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_MemoryStatus_bufferSize_get) 

static bool js_cc_gfx_MemoryStatus_textureSize_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::MemoryStatus *arg1 = (cc::gfx::MemoryStatus *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::MemoryStatus>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->textureSize, s.thisObject());
    SE_PRECONDITION2(ok, false, "MemoryStatus_textureSize_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_MemoryStatus_textureSize_set) 

static bool js_cc_gfx_MemoryStatus_textureSize_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::MemoryStatus *arg1 = (cc::gfx::MemoryStatus *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::MemoryStatus>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->textureSize, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MemoryStatus_textureSize_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->textureSize, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_MemoryStatus_textureSize_get) 

static bool js_cc_gfx_MemoryStatus_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::MemoryStatus *arg1 = (cc::gfx::MemoryStatus *) NULL ;
    cc::gfx::MemoryStatus *arg2 = 0 ;
    cc::gfx::MemoryStatus temp2 ;
    cc::gfx::MemoryStatus *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::MemoryStatus>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "MemoryStatus_copy,2,SWIGTYPE_p_cc__gfx__MemoryStatus");
    arg2 = &temp2;
    
    result = (cc::gfx::MemoryStatus *) &(arg1)->copy((cc::gfx::MemoryStatus const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MemoryStatus_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_MemoryStatus_copy) 

// js_ctor
static bool js_new_cc_gfx_MemoryStatus(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::MemoryStatus *result;
    result = (cc::gfx::MemoryStatus *)new cc::gfx::MemoryStatus();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_MemoryStatus, __jsb_cc_gfx_MemoryStatus_class, js_delete_cc_gfx_MemoryStatus)

static bool js_delete_cc_gfx_MemoryStatus(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_MemoryStatus) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::MemoryStatus * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::MemoryStatus*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("bufferSize", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->bufferSize), ctx);
    }
    
    
    json->getProperty("textureSize", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->textureSize), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_MemoryStatus(se::Object* obj) {
    auto* cls = se::Class::create("MemoryStatus", obj, nullptr, _SE(js_new_cc_gfx_MemoryStatus)); 
    
    cls->defineProperty("bufferSize", _SE(js_cc_gfx_MemoryStatus_bufferSize_get), _SE(js_cc_gfx_MemoryStatus_bufferSize_set)); 
    cls->defineProperty("textureSize", _SE(js_cc_gfx_MemoryStatus_textureSize_get), _SE(js_cc_gfx_MemoryStatus_textureSize_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_MemoryStatus_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_MemoryStatus));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::MemoryStatus>(cls);
    
    __jsb_cc_gfx_MemoryStatus_proto = cls->getProto();
    __jsb_cc_gfx_MemoryStatus_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DynamicStencilStates_class = nullptr;
se::Object* __jsb_cc_gfx_DynamicStencilStates_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DynamicStencilStates) 

static bool js_cc_gfx_DynamicStencilStates_writeMask_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStencilStates *arg1 = (cc::gfx::DynamicStencilStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStencilStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->writeMask, s.thisObject());
    SE_PRECONDITION2(ok, false, "DynamicStencilStates_writeMask_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStencilStates_writeMask_set) 

static bool js_cc_gfx_DynamicStencilStates_writeMask_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStencilStates *arg1 = (cc::gfx::DynamicStencilStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStencilStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->writeMask, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DynamicStencilStates_writeMask_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->writeMask, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStencilStates_writeMask_get) 

static bool js_cc_gfx_DynamicStencilStates_compareMask_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStencilStates *arg1 = (cc::gfx::DynamicStencilStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStencilStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->compareMask, s.thisObject());
    SE_PRECONDITION2(ok, false, "DynamicStencilStates_compareMask_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStencilStates_compareMask_set) 

static bool js_cc_gfx_DynamicStencilStates_compareMask_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStencilStates *arg1 = (cc::gfx::DynamicStencilStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStencilStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->compareMask, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DynamicStencilStates_compareMask_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->compareMask, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStencilStates_compareMask_get) 

static bool js_cc_gfx_DynamicStencilStates_reference_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStencilStates *arg1 = (cc::gfx::DynamicStencilStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStencilStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->reference, s.thisObject());
    SE_PRECONDITION2(ok, false, "DynamicStencilStates_reference_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStencilStates_reference_set) 

static bool js_cc_gfx_DynamicStencilStates_reference_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStencilStates *arg1 = (cc::gfx::DynamicStencilStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStencilStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->reference, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DynamicStencilStates_reference_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->reference, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStencilStates_reference_get) 

static bool js_cc_gfx_DynamicStencilStates_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStencilStates *arg1 = (cc::gfx::DynamicStencilStates *) NULL ;
    cc::gfx::DynamicStencilStates *arg2 = 0 ;
    cc::gfx::DynamicStencilStates temp2 ;
    cc::gfx::DynamicStencilStates *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStencilStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DynamicStencilStates_copy,2,SWIGTYPE_p_cc__gfx__DynamicStencilStates");
    arg2 = &temp2;
    
    result = (cc::gfx::DynamicStencilStates *) &(arg1)->copy((cc::gfx::DynamicStencilStates const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DynamicStencilStates_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DynamicStencilStates_copy) 

// js_ctor
static bool js_new_cc_gfx_DynamicStencilStates(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::DynamicStencilStates *result;
    result = (cc::gfx::DynamicStencilStates *)new cc::gfx::DynamicStencilStates();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_DynamicStencilStates, __jsb_cc_gfx_DynamicStencilStates_class, js_delete_cc_gfx_DynamicStencilStates)

static bool js_delete_cc_gfx_DynamicStencilStates(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DynamicStencilStates) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::DynamicStencilStates * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::DynamicStencilStates*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("writeMask", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->writeMask), ctx);
    }
    
    
    json->getProperty("compareMask", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->compareMask), ctx);
    }
    
    
    json->getProperty("reference", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->reference), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_DynamicStencilStates(se::Object* obj) {
    auto* cls = se::Class::create("DynamicStencilStates", obj, nullptr, _SE(js_new_cc_gfx_DynamicStencilStates)); 
    
    cls->defineProperty("writeMask", _SE(js_cc_gfx_DynamicStencilStates_writeMask_get), _SE(js_cc_gfx_DynamicStencilStates_writeMask_set)); 
    cls->defineProperty("compareMask", _SE(js_cc_gfx_DynamicStencilStates_compareMask_get), _SE(js_cc_gfx_DynamicStencilStates_compareMask_set)); 
    cls->defineProperty("reference", _SE(js_cc_gfx_DynamicStencilStates_reference_get), _SE(js_cc_gfx_DynamicStencilStates_reference_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_DynamicStencilStates_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DynamicStencilStates));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DynamicStencilStates>(cls);
    
    __jsb_cc_gfx_DynamicStencilStates_proto = cls->getProto();
    __jsb_cc_gfx_DynamicStencilStates_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DynamicStates_class = nullptr;
se::Object* __jsb_cc_gfx_DynamicStates_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DynamicStates) 

static bool js_cc_gfx_DynamicStates_viewport_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->viewport, s.thisObject());
    SE_PRECONDITION2(ok, false, "DynamicStates_viewport_set,2,SWIGTYPE_cc__gfx__Viewport"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStates_viewport_set) 

static bool js_cc_gfx_DynamicStates_viewport_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->viewport, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DynamicStates_viewport_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->viewport, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStates_viewport_get) 

static bool js_cc_gfx_DynamicStates_scissor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->scissor, s.thisObject());
    SE_PRECONDITION2(ok, false, "DynamicStates_scissor_set,2,SWIGTYPE_cc__gfx__Rect"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStates_scissor_set) 

static bool js_cc_gfx_DynamicStates_scissor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->scissor, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DynamicStates_scissor_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->scissor, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStates_scissor_get) 

static bool js_cc_gfx_DynamicStates_blendConstant_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->blendConstant, s.thisObject());
    SE_PRECONDITION2(ok, false, "DynamicStates_blendConstant_set,2,SWIGTYPE_cc__gfx__Color"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStates_blendConstant_set) 

static bool js_cc_gfx_DynamicStates_blendConstant_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->blendConstant, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DynamicStates_blendConstant_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendConstant, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStates_blendConstant_get) 

static bool js_cc_gfx_DynamicStates_lineWidth_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->lineWidth, nullptr);
    SE_PRECONDITION2(ok, false, "DynamicStates_lineWidth_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStates_lineWidth_set) 

static bool js_cc_gfx_DynamicStates_lineWidth_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->lineWidth, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStates_lineWidth_get) 

static bool js_cc_gfx_DynamicStates_depthBiasConstant_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->depthBiasConstant, nullptr);
    SE_PRECONDITION2(ok, false, "DynamicStates_depthBiasConstant_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStates_depthBiasConstant_set) 

static bool js_cc_gfx_DynamicStates_depthBiasConstant_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->depthBiasConstant, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStates_depthBiasConstant_get) 

static bool js_cc_gfx_DynamicStates_depthBiasClamp_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->depthBiasClamp, nullptr);
    SE_PRECONDITION2(ok, false, "DynamicStates_depthBiasClamp_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStates_depthBiasClamp_set) 

static bool js_cc_gfx_DynamicStates_depthBiasClamp_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->depthBiasClamp, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStates_depthBiasClamp_get) 

static bool js_cc_gfx_DynamicStates_depthBiasSlope_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->depthBiasSlope, nullptr);
    SE_PRECONDITION2(ok, false, "DynamicStates_depthBiasSlope_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStates_depthBiasSlope_set) 

static bool js_cc_gfx_DynamicStates_depthBiasSlope_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->depthBiasSlope, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStates_depthBiasSlope_get) 

static bool js_cc_gfx_DynamicStates_depthMinBounds_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->depthMinBounds, nullptr);
    SE_PRECONDITION2(ok, false, "DynamicStates_depthMinBounds_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStates_depthMinBounds_set) 

static bool js_cc_gfx_DynamicStates_depthMinBounds_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->depthMinBounds, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStates_depthMinBounds_get) 

static bool js_cc_gfx_DynamicStates_depthMaxBounds_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->depthMaxBounds, nullptr);
    SE_PRECONDITION2(ok, false, "DynamicStates_depthMaxBounds_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStates_depthMaxBounds_set) 

static bool js_cc_gfx_DynamicStates_depthMaxBounds_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->depthMaxBounds, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStates_depthMaxBounds_get) 

static bool js_cc_gfx_DynamicStates_stencilStatesFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stencilStatesFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "DynamicStates_stencilStatesFront_set,2,SWIGTYPE_cc__gfx__DynamicStencilStates"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStates_stencilStatesFront_set) 

static bool js_cc_gfx_DynamicStates_stencilStatesFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stencilStatesFront, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DynamicStates_stencilStatesFront_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilStatesFront, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStates_stencilStatesFront_get) 

static bool js_cc_gfx_DynamicStates_stencilStatesBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stencilStatesBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "DynamicStates_stencilStatesBack_set,2,SWIGTYPE_cc__gfx__DynamicStencilStates"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStates_stencilStatesBack_set) 

static bool js_cc_gfx_DynamicStates_stencilStatesBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stencilStatesBack, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DynamicStates_stencilStatesBack_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilStatesBack, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStates_stencilStatesBack_get) 

static bool js_cc_gfx_DynamicStates_copy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    cc::gfx::DynamicStates *arg2 = 0 ;
    cc::gfx::DynamicStates temp2 ;
    cc::gfx::DynamicStates *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DynamicStates_copy,2,SWIGTYPE_p_cc__gfx__DynamicStates");
    arg2 = &temp2;
    
    result = (cc::gfx::DynamicStates *) &(arg1)->copy((cc::gfx::DynamicStates const &)*arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DynamicStates_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DynamicStates_copy) 

// js_ctor
static bool js_new_cc_gfx_DynamicStates(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::DynamicStates *result;
    result = (cc::gfx::DynamicStates *)new cc::gfx::DynamicStates();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_DynamicStates, __jsb_cc_gfx_DynamicStates_class, js_delete_cc_gfx_DynamicStates)

static bool js_delete_cc_gfx_DynamicStates(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DynamicStates) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::DynamicStates * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::DynamicStates*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("viewport", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->viewport), ctx);
    }
    
    
    json->getProperty("scissor", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->scissor), ctx);
    }
    
    
    json->getProperty("blendConstant", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendConstant), ctx);
    }
    
    
    json->getProperty("lineWidth", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->lineWidth), ctx);
    }
    
    
    json->getProperty("depthBiasConstant", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthBiasConstant), ctx);
    }
    
    
    json->getProperty("depthBiasClamp", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthBiasClamp), ctx);
    }
    
    
    json->getProperty("depthBiasSlope", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthBiasSlope), ctx);
    }
    
    
    json->getProperty("depthMinBounds", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthMinBounds), ctx);
    }
    
    
    json->getProperty("depthMaxBounds", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthMaxBounds), ctx);
    }
    
    
    json->getProperty("stencilStatesFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilStatesFront), ctx);
    }
    
    
    json->getProperty("stencilStatesBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilStatesBack), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_DynamicStates(se::Object* obj) {
    auto* cls = se::Class::create("DynamicStates", obj, nullptr, _SE(js_new_cc_gfx_DynamicStates)); 
    
    cls->defineProperty("viewport", _SE(js_cc_gfx_DynamicStates_viewport_get), _SE(js_cc_gfx_DynamicStates_viewport_set)); 
    cls->defineProperty("scissor", _SE(js_cc_gfx_DynamicStates_scissor_get), _SE(js_cc_gfx_DynamicStates_scissor_set)); 
    cls->defineProperty("blendConstant", _SE(js_cc_gfx_DynamicStates_blendConstant_get), _SE(js_cc_gfx_DynamicStates_blendConstant_set)); 
    cls->defineProperty("lineWidth", _SE(js_cc_gfx_DynamicStates_lineWidth_get), _SE(js_cc_gfx_DynamicStates_lineWidth_set)); 
    cls->defineProperty("depthBiasConstant", _SE(js_cc_gfx_DynamicStates_depthBiasConstant_get), _SE(js_cc_gfx_DynamicStates_depthBiasConstant_set)); 
    cls->defineProperty("depthBiasClamp", _SE(js_cc_gfx_DynamicStates_depthBiasClamp_get), _SE(js_cc_gfx_DynamicStates_depthBiasClamp_set)); 
    cls->defineProperty("depthBiasSlope", _SE(js_cc_gfx_DynamicStates_depthBiasSlope_get), _SE(js_cc_gfx_DynamicStates_depthBiasSlope_set)); 
    cls->defineProperty("depthMinBounds", _SE(js_cc_gfx_DynamicStates_depthMinBounds_get), _SE(js_cc_gfx_DynamicStates_depthMinBounds_set)); 
    cls->defineProperty("depthMaxBounds", _SE(js_cc_gfx_DynamicStates_depthMaxBounds_get), _SE(js_cc_gfx_DynamicStates_depthMaxBounds_set)); 
    cls->defineProperty("stencilStatesFront", _SE(js_cc_gfx_DynamicStates_stencilStatesFront_get), _SE(js_cc_gfx_DynamicStates_stencilStatesFront_set)); 
    cls->defineProperty("stencilStatesBack", _SE(js_cc_gfx_DynamicStates_stencilStatesBack_get), _SE(js_cc_gfx_DynamicStates_stencilStatesBack_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_DynamicStates_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DynamicStates));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DynamicStates>(cls);
    
    __jsb_cc_gfx_DynamicStates_proto = cls->getProto();
    __jsb_cc_gfx_DynamicStates_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_GFXObject_class = nullptr;
se::Object* __jsb_cc_gfx_GFXObject_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_GFXObject) 

// js_ctor
static bool js_new_cc_gfx_GFXObject(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 1) {
        SE_REPORT_ERROR("js_new_cc_gfx_GFXObject: wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    cc::gfx::ObjectType arg1 ;
    int32_t temp1 ;
    cc::gfx::GFXObject *result;
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "new_GFXObject,1,SWIGTYPE_cc__gfx__ObjectType");
    arg1 = (cc::gfx::ObjectType)temp1;
    result = (cc::gfx::GFXObject *)new cc::gfx::GFXObject(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_GFXObject, __jsb_cc_gfx_GFXObject_class, js_delete_cc_gfx_GFXObject)

static bool js_delete_cc_gfx_GFXObject(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_GFXObject) 

static bool js_cc_gfx_GFXObject_objectType_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::GFXObject *arg1 = (cc::gfx::GFXObject *) NULL ;
    cc::gfx::ObjectType result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::GFXObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::ObjectType)cc_gfx_GFXObject_objectType_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_GFXObject_objectType_get) 

static bool js_cc_gfx_GFXObject_objectID_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::GFXObject *arg1 = (cc::gfx::GFXObject *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::GFXObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_gfx_GFXObject_objectID_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "GFXObject_objectID_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_GFXObject_objectID_get) 

static bool js_cc_gfx_GFXObject_typedID_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::GFXObject *arg1 = (cc::gfx::GFXObject *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::GFXObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_gfx_GFXObject_typedID_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "GFXObject_typedID_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_GFXObject_typedID_get) 

bool js_register_cc_gfx_GFXObject(se::Object* obj) {
    auto* cls = se::Class::create("GFXObject", obj, nullptr, _SE(js_new_cc_gfx_GFXObject)); 
    
    cls->defineProperty("objectType", _SE(js_cc_gfx_GFXObject_objectType_get), nullptr); 
    cls->defineProperty("objectID", _SE(js_cc_gfx_GFXObject_objectID_get), nullptr); 
    cls->defineProperty("typedID", _SE(js_cc_gfx_GFXObject_typedID_get), nullptr); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_GFXObject));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::GFXObject>(cls);
    
    __jsb_cc_gfx_GFXObject_proto = cls->getProto();
    __jsb_cc_gfx_GFXObject_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Buffer_class = nullptr;
se::Object* __jsb_cc_gfx_Buffer_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Buffer) 

static bool js_delete_cc_gfx_Buffer(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Buffer) 

static bool js_cc_gfx_Buffer_computeHash_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferInfo *arg1 = 0 ;
    cc::gfx::BufferInfo temp1 ;
    ccstd::hash_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Buffer_computeHash,1,SWIGTYPE_p_cc__gfx__BufferInfo");
    arg1 = &temp1;
    
    result = cc::gfx::Buffer::computeHash((cc::gfx::BufferInfo const &)*arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Buffer_computeHash, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Buffer_computeHash_static) 

static bool js_cc_gfx_Buffer_resize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Buffer *arg1 = (cc::gfx::Buffer *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Buffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Buffer_resize,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->resize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Buffer_resize) 

static bool js_cc_gfx_Buffer_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Buffer *arg1 = (cc::gfx::Buffer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Buffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Buffer_destroy) 

static bool js_cc_gfx_Buffer_isBufferView(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Buffer *arg1 = (cc::gfx::Buffer *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Buffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((cc::gfx::Buffer const *)arg1)->isBufferView();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Buffer_isBufferView) 

static bool js_cc_gfx_Buffer_usage_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Buffer *arg1 = (cc::gfx::Buffer *) NULL ;
    cc::gfx::BufferUsage result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Buffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::BufferUsage)cc_gfx_Buffer_usage_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Buffer_usage_get) 

static bool js_cc_gfx_Buffer_memUsage_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Buffer *arg1 = (cc::gfx::Buffer *) NULL ;
    cc::gfx::MemoryUsage result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Buffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::MemoryUsage)cc_gfx_Buffer_memUsage_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Buffer_memUsage_get) 

static bool js_cc_gfx_Buffer_stride_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Buffer *arg1 = (cc::gfx::Buffer *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Buffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_gfx_Buffer_stride_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Buffer_stride_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Buffer_stride_get) 

static bool js_cc_gfx_Buffer_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Buffer *arg1 = (cc::gfx::Buffer *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Buffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_gfx_Buffer_count_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Buffer_count_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Buffer_count_get) 

static bool js_cc_gfx_Buffer_size_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Buffer *arg1 = (cc::gfx::Buffer *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Buffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_gfx_Buffer_size_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Buffer_size_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Buffer_size_get) 

static bool js_cc_gfx_Buffer_flags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Buffer *arg1 = (cc::gfx::Buffer *) NULL ;
    cc::gfx::BufferFlags result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Buffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::BufferFlags)cc_gfx_Buffer_flags_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Buffer_flags_get) 

bool js_register_cc_gfx_Buffer(se::Object* obj) {
    auto* cls = se::Class::create("Buffer", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    cls->defineProperty("usage", _SE(js_cc_gfx_Buffer_usage_get), nullptr); 
    cls->defineProperty("memUsage", _SE(js_cc_gfx_Buffer_memUsage_get), nullptr); 
    cls->defineProperty("stride", _SE(js_cc_gfx_Buffer_stride_get), nullptr); 
    cls->defineProperty("count", _SE(js_cc_gfx_Buffer_count_get), nullptr); 
    cls->defineProperty("size", _SE(js_cc_gfx_Buffer_size_get), nullptr); 
    cls->defineProperty("flags", _SE(js_cc_gfx_Buffer_flags_get), nullptr); 
    
    cls->defineFunction("resize", _SE(js_cc_gfx_Buffer_resize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_Buffer_destroy)); 
    cls->defineFunction("isBufferView", _SE(js_cc_gfx_Buffer_isBufferView)); 
    
    
    cls->defineStaticFunction("computeHash", _SE(js_cc_gfx_Buffer_computeHash_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Buffer));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Buffer>(cls);
    
    __jsb_cc_gfx_Buffer_proto = cls->getProto();
    __jsb_cc_gfx_Buffer_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_CommandBuffer_class = nullptr;
se::Object* __jsb_cc_gfx_CommandBuffer_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_CommandBuffer) 

static bool js_delete_cc_gfx_CommandBuffer(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_CommandBuffer) 

static bool js_cc_gfx_CommandBuffer_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::CommandBufferInfo *arg2 = 0 ;
    cc::gfx::CommandBufferInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_initialize,2,SWIGTYPE_p_cc__gfx__CommandBufferInfo");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::CommandBufferInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_initialize) 

static bool js_cc_gfx_CommandBuffer_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_destroy) 

static bool js_cc_gfx_CommandBuffer_begin__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::RenderPass *arg2 = (cc::gfx::RenderPass *) NULL ;
    uint32_t arg3 ;
    cc::gfx::Framebuffer *arg4 = (cc::gfx::Framebuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_begin,2,SWIGTYPE_p_cc__gfx__RenderPass"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_begin,3,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_begin,4,SWIGTYPE_p_cc__gfx__Framebuffer"); 
    (arg1)->begin(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_end(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->end();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_end) 

static bool js_cc_gfx_CommandBuffer_beginRenderPass__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::RenderPass *arg2 = (cc::gfx::RenderPass *) NULL ;
    cc::gfx::Framebuffer *arg3 = (cc::gfx::Framebuffer *) NULL ;
    cc::gfx::Rect *arg4 = 0 ;
    cc::gfx::Color *arg5 = (cc::gfx::Color *) NULL ;
    float arg6 ;
    uint32_t arg7 ;
    cc::gfx::CommandBuffer **arg8 = (cc::gfx::CommandBuffer **) NULL ;
    uint32_t arg9 ;
    cc::gfx::Rect temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginRenderPass,2,SWIGTYPE_p_cc__gfx__RenderPass"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginRenderPass,3,SWIGTYPE_p_cc__gfx__Framebuffer"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginRenderPass,4,SWIGTYPE_p_cc__gfx__Rect");
    arg4 = &temp4;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginRenderPass,5,SWIGTYPE_p_cc__gfx__Color"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginRenderPass,6,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginRenderPass,7,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[6], &arg8, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginRenderPass,8,SWIGTYPE_p_p_cc__gfx__CommandBuffer"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[7], &arg9, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginRenderPass,9,SWIGTYPE_uint32_t"); 
    
    (arg1)->beginRenderPass(arg2,arg3,(cc::gfx::Rect const &)*arg4,(cc::gfx::Color const *)arg5,arg6,arg7,(cc::gfx::CommandBuffer *const *)arg8,arg9);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_endRenderPass(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->endRenderPass();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_endRenderPass) 

static bool js_cc_gfx_CommandBuffer_bindPipelineState(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::PipelineState *arg2 = (cc::gfx::PipelineState *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_bindPipelineState,2,SWIGTYPE_p_cc__gfx__PipelineState"); 
    (arg1)->bindPipelineState(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_bindPipelineState) 

static bool js_cc_gfx_CommandBuffer_bindDescriptorSet__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    uint32_t arg2 ;
    cc::gfx::DescriptorSet *arg3 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg4 ;
    uint32_t *arg5 = (uint32_t *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_bindDescriptorSet,2,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_bindDescriptorSet,3,SWIGTYPE_p_cc__gfx__DescriptorSet"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_bindDescriptorSet,4,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_bindDescriptorSet,5,SWIGTYPE_p_uint32_t"); 
    (arg1)->bindDescriptorSet(arg2,arg3,arg4,(uint32_t const *)arg5);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_bindInputAssembler(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::InputAssembler *arg2 = (cc::gfx::InputAssembler *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_bindInputAssembler,2,SWIGTYPE_p_cc__gfx__InputAssembler"); 
    (arg1)->bindInputAssembler(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_bindInputAssembler) 

static bool js_cc_gfx_CommandBuffer_setViewport(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::Viewport *arg2 = 0 ;
    cc::gfx::Viewport temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_setViewport,2,SWIGTYPE_p_cc__gfx__Viewport");
    arg2 = &temp2;
    
    (arg1)->setViewport((cc::gfx::Viewport const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_setViewport) 

static bool js_cc_gfx_CommandBuffer_setScissor(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::Rect *arg2 = 0 ;
    cc::gfx::Rect temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_setScissor,2,SWIGTYPE_p_cc__gfx__Rect");
    arg2 = &temp2;
    
    (arg1)->setScissor((cc::gfx::Rect const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_setScissor) 

static bool js_cc_gfx_CommandBuffer_setLineWidth(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "CommandBuffer_setLineWidth,2,SWIGTYPE_float"); 
    (arg1)->setLineWidth(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_setLineWidth) 

static bool js_cc_gfx_CommandBuffer_setDepthBias(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "CommandBuffer_setDepthBias,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "CommandBuffer_setDepthBias,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "CommandBuffer_setDepthBias,4,SWIGTYPE_float"); 
    (arg1)->setDepthBias(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_setDepthBias) 

static bool js_cc_gfx_CommandBuffer_setBlendConstants(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::Color *arg2 = 0 ;
    cc::gfx::Color temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_setBlendConstants,2,SWIGTYPE_p_cc__gfx__Color");
    arg2 = &temp2;
    
    (arg1)->setBlendConstants((cc::gfx::Color const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_setBlendConstants) 

static bool js_cc_gfx_CommandBuffer_setDepthBound(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    float arg2 ;
    float arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "CommandBuffer_setDepthBound,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "CommandBuffer_setDepthBound,3,SWIGTYPE_float"); 
    (arg1)->setDepthBound(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_setDepthBound) 

static bool js_cc_gfx_CommandBuffer_setStencilWriteMask(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::StencilFace arg2 ;
    uint32_t arg3 ;
    int32_t temp2 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "CommandBuffer_setStencilWriteMask,2,SWIGTYPE_cc__gfx__StencilFace");
    arg2 = (cc::gfx::StencilFace)temp2;
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_setStencilWriteMask,3,SWIGTYPE_uint32_t"); 
    
    (arg1)->setStencilWriteMask(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_setStencilWriteMask) 

static bool js_cc_gfx_CommandBuffer_setStencilCompareMask(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::StencilFace arg2 ;
    uint32_t arg3 ;
    uint32_t arg4 ;
    int32_t temp2 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "CommandBuffer_setStencilCompareMask,2,SWIGTYPE_cc__gfx__StencilFace");
    arg2 = (cc::gfx::StencilFace)temp2;
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_setStencilCompareMask,3,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_setStencilCompareMask,4,SWIGTYPE_uint32_t"); 
    
    (arg1)->setStencilCompareMask(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_setStencilCompareMask) 

static bool js_cc_gfx_CommandBuffer_nextSubpass(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->nextSubpass();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_nextSubpass) 

static bool js_cc_gfx_CommandBuffer_drawWithInfo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::DrawInfo *arg2 = 0 ;
    cc::gfx::DrawInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_drawWithInfo,2,SWIGTYPE_p_cc__gfx__DrawInfo");
    arg2 = &temp2;
    
    (arg1)->draw((cc::gfx::DrawInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_drawWithInfo) 

static bool js_cc_gfx_CommandBuffer_blitTexture__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::Texture *arg2 = (cc::gfx::Texture *) NULL ;
    cc::gfx::Texture *arg3 = (cc::gfx::Texture *) NULL ;
    cc::gfx::TextureBlit *arg4 = (cc::gfx::TextureBlit *) NULL ;
    uint32_t arg5 ;
    cc::gfx::Filter arg6 ;
    int32_t temp6 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_blitTexture,2,SWIGTYPE_p_cc__gfx__Texture"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_blitTexture,3,SWIGTYPE_p_cc__gfx__Texture"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_blitTexture,4,SWIGTYPE_p_cc__gfx__TextureBlit"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_blitTexture,5,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) enum SWIGTYPE (int32_t temp6)
    ok &= sevalue_to_native(args[4], &temp6);
    SE_PRECONDITION2(ok, false, "CommandBuffer_blitTexture,6,SWIGTYPE_cc__gfx__Filter");
    arg6 = (cc::gfx::Filter)temp6;
    (arg1)->blitTexture(arg2,arg3,(cc::gfx::TextureBlit const *)arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_dispatch(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::DispatchInfo *arg2 = 0 ;
    cc::gfx::DispatchInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_dispatch,2,SWIGTYPE_p_cc__gfx__DispatchInfo");
    arg2 = &temp2;
    
    (arg1)->dispatch((cc::gfx::DispatchInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_dispatch) 

static bool js_cc_gfx_CommandBuffer_beginQuery(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::QueryPool *arg2 = (cc::gfx::QueryPool *) NULL ;
    uint32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginQuery,2,SWIGTYPE_p_cc__gfx__QueryPool"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginQuery,3,SWIGTYPE_uint32_t"); 
    
    (arg1)->beginQuery(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_beginQuery) 

static bool js_cc_gfx_CommandBuffer_endQuery(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::QueryPool *arg2 = (cc::gfx::QueryPool *) NULL ;
    uint32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_endQuery,2,SWIGTYPE_p_cc__gfx__QueryPool"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_endQuery,3,SWIGTYPE_uint32_t"); 
    
    (arg1)->endQuery(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_endQuery) 

static bool js_cc_gfx_CommandBuffer_resetQueryPool(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::QueryPool *arg2 = (cc::gfx::QueryPool *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_resetQueryPool,2,SWIGTYPE_p_cc__gfx__QueryPool"); 
    (arg1)->resetQueryPool(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_resetQueryPool) 

static bool js_cc_gfx_CommandBuffer_completeQueryPool(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::QueryPool *arg2 = (cc::gfx::QueryPool *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_completeQueryPool,2,SWIGTYPE_p_cc__gfx__QueryPool"); 
    (arg1)->completeQueryPool(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_completeQueryPool) 

static bool js_cc_gfx_CommandBuffer_pipelineBarrier__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::GeneralBarrier *arg2 = (cc::gfx::GeneralBarrier *) NULL ;
    cc::gfx::BufferBarrier **arg3 = (cc::gfx::BufferBarrier **) NULL ;
    cc::gfx::Buffer **arg4 = (cc::gfx::Buffer **) NULL ;
    uint32_t arg5 ;
    cc::gfx::TextureBarrier **arg6 = (cc::gfx::TextureBarrier **) NULL ;
    cc::gfx::Texture **arg7 = (cc::gfx::Texture **) NULL ;
    uint32_t arg8 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_pipelineBarrier,2,SWIGTYPE_p_cc__gfx__GeneralBarrier"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_pipelineBarrier,3,SWIGTYPE_p_p_cc__gfx__BufferBarrier"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_pipelineBarrier,4,SWIGTYPE_p_p_cc__gfx__Buffer"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_pipelineBarrier,5,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_pipelineBarrier,6,SWIGTYPE_p_p_cc__gfx__TextureBarrier"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_pipelineBarrier,7,SWIGTYPE_p_p_cc__gfx__Texture"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[6], &arg8, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_pipelineBarrier,8,SWIGTYPE_uint32_t"); 
    
    (arg1)->pipelineBarrier((cc::gfx::GeneralBarrier const *)arg2,(cc::gfx::BufferBarrier const *const *)arg3,(cc::gfx::Buffer const *const *)arg4,arg5,(cc::gfx::TextureBarrier const *const *)arg6,(cc::gfx::Texture const *const *)arg7,arg8);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_begin__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->begin();
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_begin__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::RenderPass *arg2 = (cc::gfx::RenderPass *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_begin,2,SWIGTYPE_p_cc__gfx__RenderPass"); 
    (arg1)->begin(arg2);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_begin__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::RenderPass *arg2 = (cc::gfx::RenderPass *) NULL ;
    uint32_t arg3 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_begin,2,SWIGTYPE_p_cc__gfx__RenderPass"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_begin,3,SWIGTYPE_uint32_t"); 
    
    (arg1)->begin(arg2,arg3);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_begin(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_gfx_CommandBuffer_begin__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 0) {
        ok = js_cc_gfx_CommandBuffer_begin__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_gfx_CommandBuffer_begin__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_gfx_CommandBuffer_begin__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_begin) 

static bool js_cc_gfx_CommandBuffer_bindDescriptorSet__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    uint32_t arg2 ;
    cc::gfx::DescriptorSet *arg3 = (cc::gfx::DescriptorSet *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_bindDescriptorSet,2,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_bindDescriptorSet,3,SWIGTYPE_p_cc__gfx__DescriptorSet"); 
    (arg1)->bindDescriptorSet(arg2,arg3);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_bindDescriptorSet__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    uint32_t arg2 ;
    cc::gfx::DescriptorSet *arg3 = (cc::gfx::DescriptorSet *) NULL ;
    ccstd::vector< uint32_t > *arg4 = 0 ;
    ccstd::vector< uint32_t > temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_bindDescriptorSet,2,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_bindDescriptorSet,3,SWIGTYPE_p_cc__gfx__DescriptorSet"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_bindDescriptorSet,4,SWIGTYPE_p_ccstd__vectorT_uint32_t_t");
    arg4 = &temp4;
    
    (arg1)->bindDescriptorSet(arg2,arg3,(ccstd::vector< uint32_t > const &)*arg4);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_bindDescriptorSet(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_gfx_CommandBuffer_bindDescriptorSet__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_gfx_CommandBuffer_bindDescriptorSet__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_gfx_CommandBuffer_bindDescriptorSet__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_bindDescriptorSet) 

static bool js_cc_gfx_CommandBuffer_beginRenderPass__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::RenderPass *arg2 = (cc::gfx::RenderPass *) NULL ;
    cc::gfx::Framebuffer *arg3 = (cc::gfx::Framebuffer *) NULL ;
    cc::gfx::Rect *arg4 = 0 ;
    cc::gfx::ColorList *arg5 = 0 ;
    float arg6 ;
    uint32_t arg7 ;
    cc::gfx::CommandBufferList *arg8 = 0 ;
    cc::gfx::Rect temp4 ;
    cc::gfx::ColorList temp5 ;
    cc::gfx::CommandBufferList temp8 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginRenderPass,2,SWIGTYPE_p_cc__gfx__RenderPass"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginRenderPass,3,SWIGTYPE_p_cc__gfx__Framebuffer"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginRenderPass,4,SWIGTYPE_p_cc__gfx__Rect");
    arg4 = &temp4;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginRenderPass,5,SWIGTYPE_p_ccstd__vectorT_cc__gfx__Color_t");
    arg5 = &temp5;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginRenderPass,6,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginRenderPass,7,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[6], &temp8, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginRenderPass,8,SWIGTYPE_p_ccstd__vectorT_cc__gfx__CommandBuffer_p_t");
    arg8 = &temp8;
    
    (arg1)->beginRenderPass(arg2,arg3,(cc::gfx::Rect const &)*arg4,(cc::gfx::ColorList const &)*arg5,arg6,arg7,(cc::gfx::CommandBufferList const &)*arg8);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_beginRenderPass__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::RenderPass *arg2 = (cc::gfx::RenderPass *) NULL ;
    cc::gfx::Framebuffer *arg3 = (cc::gfx::Framebuffer *) NULL ;
    cc::gfx::Rect *arg4 = 0 ;
    cc::gfx::ColorList *arg5 = 0 ;
    float arg6 ;
    uint32_t arg7 ;
    cc::gfx::Rect temp4 ;
    cc::gfx::ColorList temp5 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginRenderPass,2,SWIGTYPE_p_cc__gfx__RenderPass"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginRenderPass,3,SWIGTYPE_p_cc__gfx__Framebuffer"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginRenderPass,4,SWIGTYPE_p_cc__gfx__Rect");
    arg4 = &temp4;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginRenderPass,5,SWIGTYPE_p_ccstd__vectorT_cc__gfx__Color_t");
    arg5 = &temp5;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginRenderPass,6,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginRenderPass,7,SWIGTYPE_uint32_t"); 
    
    (arg1)->beginRenderPass(arg2,arg3,(cc::gfx::Rect const &)*arg4,(cc::gfx::ColorList const &)*arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_beginRenderPass__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::RenderPass *arg2 = (cc::gfx::RenderPass *) NULL ;
    cc::gfx::Framebuffer *arg3 = (cc::gfx::Framebuffer *) NULL ;
    cc::gfx::Rect *arg4 = 0 ;
    cc::gfx::Color *arg5 = (cc::gfx::Color *) NULL ;
    float arg6 ;
    uint32_t arg7 ;
    cc::gfx::Rect temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginRenderPass,2,SWIGTYPE_p_cc__gfx__RenderPass"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginRenderPass,3,SWIGTYPE_p_cc__gfx__Framebuffer"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginRenderPass,4,SWIGTYPE_p_cc__gfx__Rect");
    arg4 = &temp4;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginRenderPass,5,SWIGTYPE_p_cc__gfx__Color"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginRenderPass,6,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_beginRenderPass,7,SWIGTYPE_uint32_t"); 
    
    (arg1)->beginRenderPass(arg2,arg3,(cc::gfx::Rect const &)*arg4,(cc::gfx::Color const *)arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_beginRenderPass(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 8) {
        ok = js_cc_gfx_CommandBuffer_beginRenderPass__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 7) {
        ok = js_cc_gfx_CommandBuffer_beginRenderPass__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 6) {
        ok = js_cc_gfx_CommandBuffer_beginRenderPass__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 6) {
        ok = js_cc_gfx_CommandBuffer_beginRenderPass__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_beginRenderPass) 

static bool js_cc_gfx_CommandBuffer_draw(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::InputAssembler *arg2 = (cc::gfx::InputAssembler *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_draw,2,SWIGTYPE_p_cc__gfx__InputAssembler"); 
    (arg1)->draw(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_draw) 

static bool js_cc_gfx_CommandBuffer_blitTexture__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::Texture *arg2 = (cc::gfx::Texture *) NULL ;
    cc::gfx::Texture *arg3 = (cc::gfx::Texture *) NULL ;
    cc::gfx::TextureBlitList *arg4 = 0 ;
    cc::gfx::Filter arg5 ;
    cc::gfx::TextureBlitList temp4 ;
    int32_t temp5 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_blitTexture,2,SWIGTYPE_p_cc__gfx__Texture"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_blitTexture,3,SWIGTYPE_p_cc__gfx__Texture"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_blitTexture,4,SWIGTYPE_p_ccstd__vectorT_cc__gfx__TextureBlit_t");
    arg4 = &temp4;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp5)
    ok &= sevalue_to_native(args[3], &temp5);
    SE_PRECONDITION2(ok, false, "CommandBuffer_blitTexture,5,SWIGTYPE_cc__gfx__Filter");
    arg5 = (cc::gfx::Filter)temp5;
    (arg1)->blitTexture(arg2,arg3,(cc::gfx::TextureBlitList const &)*arg4,arg5);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_blitTexture(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 5) {
        ok = js_cc_gfx_CommandBuffer_blitTexture__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_gfx_CommandBuffer_blitTexture__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_blitTexture) 

static bool js_cc_gfx_CommandBuffer_pipelineBarrier__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::GeneralBarrier *arg2 = (cc::gfx::GeneralBarrier *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_pipelineBarrier,2,SWIGTYPE_p_cc__gfx__GeneralBarrier"); 
    (arg1)->pipelineBarrier((cc::gfx::GeneralBarrier const *)arg2);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_pipelineBarrier__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::GeneralBarrier *arg2 = (cc::gfx::GeneralBarrier *) NULL ;
    cc::gfx::BufferBarrierList *arg3 = 0 ;
    cc::gfx::BufferList *arg4 = 0 ;
    cc::gfx::TextureBarrierList *arg5 = 0 ;
    cc::gfx::TextureList *arg6 = 0 ;
    cc::gfx::BufferBarrierList temp3 ;
    cc::gfx::BufferList temp4 ;
    cc::gfx::TextureBarrierList temp5 ;
    cc::gfx::TextureList temp6 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_pipelineBarrier,2,SWIGTYPE_p_cc__gfx__GeneralBarrier"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_pipelineBarrier,3,SWIGTYPE_p_ccstd__vectorT_cc__gfx__BufferBarrier_p_t");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_pipelineBarrier,4,SWIGTYPE_p_ccstd__vectorT_cc__gfx__Buffer_p_t");
    arg4 = &temp4;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_pipelineBarrier,5,SWIGTYPE_p_ccstd__vectorT_cc__gfx__TextureBarrier_p_t");
    arg5 = &temp5;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[4], &temp6, s.thisObject());
    SE_PRECONDITION2(ok, false, "CommandBuffer_pipelineBarrier,6,SWIGTYPE_p_ccstd__vectorT_cc__gfx__Texture_p_t");
    arg6 = &temp6;
    
    (arg1)->pipelineBarrier((cc::gfx::GeneralBarrier const *)arg2,(cc::gfx::BufferBarrierList const &)*arg3,(cc::gfx::BufferList const &)*arg4,(cc::gfx::TextureBarrierList const &)*arg5,(cc::gfx::TextureList const &)*arg6);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_pipelineBarrier(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 7) {
        ok = js_cc_gfx_CommandBuffer_pipelineBarrier__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_gfx_CommandBuffer_pipelineBarrier__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_cc_gfx_CommandBuffer_pipelineBarrier__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_pipelineBarrier) 

static bool js_cc_gfx_CommandBuffer_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::CommandBufferType result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::CommandBufferType)cc_gfx_CommandBuffer_type_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_CommandBuffer_type_get) 

static bool js_cc_gfx_CommandBuffer_queue_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::Queue *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Queue *)cc_gfx_CommandBuffer_queue_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CommandBuffer_queue_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_CommandBuffer_queue_get) 

static bool js_cc_gfx_CommandBuffer_numDrawCalls_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_gfx_CommandBuffer_numDrawCalls_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CommandBuffer_numDrawCalls_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_CommandBuffer_numDrawCalls_get) 

static bool js_cc_gfx_CommandBuffer_numInstances_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_gfx_CommandBuffer_numInstances_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CommandBuffer_numInstances_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_CommandBuffer_numInstances_get) 

static bool js_cc_gfx_CommandBuffer_numTris_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_gfx_CommandBuffer_numTris_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CommandBuffer_numTris_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_CommandBuffer_numTris_get) 

bool js_register_cc_gfx_CommandBuffer(se::Object* obj) {
    auto* cls = se::Class::create("CommandBuffer", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    cls->defineProperty("type", _SE(js_cc_gfx_CommandBuffer_type_get), nullptr); 
    cls->defineProperty("queue", _SE(js_cc_gfx_CommandBuffer_queue_get), nullptr); 
    cls->defineProperty("numDrawCalls", _SE(js_cc_gfx_CommandBuffer_numDrawCalls_get), nullptr); 
    cls->defineProperty("numInstances", _SE(js_cc_gfx_CommandBuffer_numInstances_get), nullptr); 
    cls->defineProperty("numTris", _SE(js_cc_gfx_CommandBuffer_numTris_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_CommandBuffer_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_CommandBuffer_destroy)); 
    cls->defineFunction("end", _SE(js_cc_gfx_CommandBuffer_end)); 
    cls->defineFunction("endRenderPass", _SE(js_cc_gfx_CommandBuffer_endRenderPass)); 
    cls->defineFunction("bindPipelineState", _SE(js_cc_gfx_CommandBuffer_bindPipelineState)); 
    cls->defineFunction("bindInputAssembler", _SE(js_cc_gfx_CommandBuffer_bindInputAssembler)); 
    cls->defineFunction("setViewport", _SE(js_cc_gfx_CommandBuffer_setViewport)); 
    cls->defineFunction("setScissor", _SE(js_cc_gfx_CommandBuffer_setScissor)); 
    cls->defineFunction("setLineWidth", _SE(js_cc_gfx_CommandBuffer_setLineWidth)); 
    cls->defineFunction("setDepthBias", _SE(js_cc_gfx_CommandBuffer_setDepthBias)); 
    cls->defineFunction("setBlendConstants", _SE(js_cc_gfx_CommandBuffer_setBlendConstants)); 
    cls->defineFunction("setDepthBound", _SE(js_cc_gfx_CommandBuffer_setDepthBound)); 
    cls->defineFunction("setStencilWriteMask", _SE(js_cc_gfx_CommandBuffer_setStencilWriteMask)); 
    cls->defineFunction("setStencilCompareMask", _SE(js_cc_gfx_CommandBuffer_setStencilCompareMask)); 
    cls->defineFunction("nextSubpass", _SE(js_cc_gfx_CommandBuffer_nextSubpass)); 
    cls->defineFunction("drawWithInfo", _SE(js_cc_gfx_CommandBuffer_drawWithInfo)); 
    cls->defineFunction("dispatch", _SE(js_cc_gfx_CommandBuffer_dispatch)); 
    cls->defineFunction("beginQuery", _SE(js_cc_gfx_CommandBuffer_beginQuery)); 
    cls->defineFunction("endQuery", _SE(js_cc_gfx_CommandBuffer_endQuery)); 
    cls->defineFunction("resetQueryPool", _SE(js_cc_gfx_CommandBuffer_resetQueryPool)); 
    cls->defineFunction("completeQueryPool", _SE(js_cc_gfx_CommandBuffer_completeQueryPool)); 
    cls->defineFunction("begin", _SE(js_cc_gfx_CommandBuffer_begin)); 
    cls->defineFunction("bindDescriptorSet", _SE(js_cc_gfx_CommandBuffer_bindDescriptorSet)); 
    cls->defineFunction("beginRenderPass", _SE(js_cc_gfx_CommandBuffer_beginRenderPass)); 
    cls->defineFunction("draw", _SE(js_cc_gfx_CommandBuffer_draw)); 
    cls->defineFunction("blitTexture", _SE(js_cc_gfx_CommandBuffer_blitTexture)); 
    cls->defineFunction("pipelineBarrier", _SE(js_cc_gfx_CommandBuffer_pipelineBarrier)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_CommandBuffer));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::CommandBuffer>(cls);
    
    __jsb_cc_gfx_CommandBuffer_proto = cls->getProto();
    __jsb_cc_gfx_CommandBuffer_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DescriptorSet_class = nullptr;
se::Object* __jsb_cc_gfx_DescriptorSet_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DescriptorSet) 

static bool js_delete_cc_gfx_DescriptorSet(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DescriptorSet) 

static bool js_cc_gfx_DescriptorSet_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    cc::gfx::DescriptorSetInfo *arg2 = 0 ;
    cc::gfx::DescriptorSetInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_initialize,2,SWIGTYPE_p_cc__gfx__DescriptorSetInfo");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::DescriptorSetInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSet_initialize) 

static bool js_cc_gfx_DescriptorSet_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSet_destroy) 

static bool js_cc_gfx_DescriptorSet_update(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->update();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSet_update) 

static bool js_cc_gfx_DescriptorSet_bindBuffer__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Buffer *arg3 = (cc::gfx::Buffer *) NULL ;
    uint32_t arg4 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_bindBuffer,2,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_bindBuffer,3,SWIGTYPE_p_cc__gfx__Buffer"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_bindBuffer,4,SWIGTYPE_uint32_t"); 
    
    (arg1)->bindBuffer(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_gfx_DescriptorSet_bindTexture__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Texture *arg3 = (cc::gfx::Texture *) NULL ;
    uint32_t arg4 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_bindTexture,2,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_bindTexture,3,SWIGTYPE_p_cc__gfx__Texture"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_bindTexture,4,SWIGTYPE_uint32_t"); 
    
    (arg1)->bindTexture(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_gfx_DescriptorSet_bindSampler__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Sampler *arg3 = (cc::gfx::Sampler *) NULL ;
    uint32_t arg4 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_bindSampler,2,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_bindSampler,3,SWIGTYPE_p_cc__gfx__Sampler"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_bindSampler,4,SWIGTYPE_uint32_t"); 
    
    (arg1)->bindSampler(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_gfx_DescriptorSet_bindBufferJSB(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Buffer *arg3 = (cc::gfx::Buffer *) NULL ;
    uint32_t arg4 ;
    bool result;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_bindBufferJSB,2,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_bindBufferJSB,3,SWIGTYPE_p_cc__gfx__Buffer"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_bindBufferJSB,4,SWIGTYPE_uint32_t"); 
    
    result = (bool)(arg1)->bindBufferJSB(arg2,arg3,arg4);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSet_bindBufferJSB) 

static bool js_cc_gfx_DescriptorSet_bindTextureJSB(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Texture *arg3 = (cc::gfx::Texture *) NULL ;
    uint32_t arg4 ;
    bool result;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_bindTextureJSB,2,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_bindTextureJSB,3,SWIGTYPE_p_cc__gfx__Texture"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_bindTextureJSB,4,SWIGTYPE_uint32_t"); 
    
    result = (bool)(arg1)->bindTextureJSB(arg2,arg3,arg4);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSet_bindTextureJSB) 

static bool js_cc_gfx_DescriptorSet_bindSamplerJSB(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Sampler *arg3 = (cc::gfx::Sampler *) NULL ;
    uint32_t arg4 ;
    bool result;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_bindSamplerJSB,2,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_bindSamplerJSB,3,SWIGTYPE_p_cc__gfx__Sampler"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_bindSamplerJSB,4,SWIGTYPE_uint32_t"); 
    
    result = (bool)(arg1)->bindSamplerJSB(arg2,arg3,arg4);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSet_bindSamplerJSB) 

static bool js_cc_gfx_DescriptorSet_getBuffer__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    cc::gfx::Buffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_getBuffer,2,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_getBuffer,3,SWIGTYPE_uint32_t"); 
    
    result = (cc::gfx::Buffer *)((cc::gfx::DescriptorSet const *)arg1)->getBuffer(arg2,arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DescriptorSet_getBuffer, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_gfx_DescriptorSet_getTexture__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    cc::gfx::Texture *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_getTexture,2,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_getTexture,3,SWIGTYPE_uint32_t"); 
    
    result = (cc::gfx::Texture *)((cc::gfx::DescriptorSet const *)arg1)->getTexture(arg2,arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DescriptorSet_getTexture, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_gfx_DescriptorSet_getSampler__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    cc::gfx::Sampler *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_getSampler,2,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_getSampler,3,SWIGTYPE_uint32_t"); 
    
    result = (cc::gfx::Sampler *)((cc::gfx::DescriptorSet const *)arg1)->getSampler(arg2,arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DescriptorSet_getSampler, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_gfx_DescriptorSet_bindBuffer__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Buffer *arg3 = (cc::gfx::Buffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_bindBuffer,2,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_bindBuffer,3,SWIGTYPE_p_cc__gfx__Buffer"); 
    (arg1)->bindBuffer(arg2,arg3);
    
    
    return true;
}

static bool js_cc_gfx_DescriptorSet_bindBuffer(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_gfx_DescriptorSet_bindBuffer__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_gfx_DescriptorSet_bindBuffer__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSet_bindBuffer) 

static bool js_cc_gfx_DescriptorSet_bindTexture__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Texture *arg3 = (cc::gfx::Texture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_bindTexture,2,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_bindTexture,3,SWIGTYPE_p_cc__gfx__Texture"); 
    (arg1)->bindTexture(arg2,arg3);
    
    
    return true;
}

static bool js_cc_gfx_DescriptorSet_bindTexture(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_gfx_DescriptorSet_bindTexture__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_gfx_DescriptorSet_bindTexture__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSet_bindTexture) 

static bool js_cc_gfx_DescriptorSet_bindSampler__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Sampler *arg3 = (cc::gfx::Sampler *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_bindSampler,2,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_bindSampler,3,SWIGTYPE_p_cc__gfx__Sampler"); 
    (arg1)->bindSampler(arg2,arg3);
    
    
    return true;
}

static bool js_cc_gfx_DescriptorSet_bindSampler(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_gfx_DescriptorSet_bindSampler__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_gfx_DescriptorSet_bindSampler__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSet_bindSampler) 

static bool js_cc_gfx_DescriptorSet_getBuffer__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Buffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_getBuffer,2,SWIGTYPE_uint32_t"); 
    
    result = (cc::gfx::Buffer *)((cc::gfx::DescriptorSet const *)arg1)->getBuffer(arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DescriptorSet_getBuffer, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_gfx_DescriptorSet_getBuffer(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_gfx_DescriptorSet_getBuffer__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_gfx_DescriptorSet_getBuffer__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSet_getBuffer) 

static bool js_cc_gfx_DescriptorSet_getTexture__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Texture *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_getTexture,2,SWIGTYPE_uint32_t"); 
    
    result = (cc::gfx::Texture *)((cc::gfx::DescriptorSet const *)arg1)->getTexture(arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DescriptorSet_getTexture, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_gfx_DescriptorSet_getTexture(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_gfx_DescriptorSet_getTexture__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_gfx_DescriptorSet_getTexture__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSet_getTexture) 

static bool js_cc_gfx_DescriptorSet_getSampler__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Sampler *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSet_getSampler,2,SWIGTYPE_uint32_t"); 
    
    result = (cc::gfx::Sampler *)((cc::gfx::DescriptorSet const *)arg1)->getSampler(arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DescriptorSet_getSampler, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_gfx_DescriptorSet_getSampler(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_gfx_DescriptorSet_getSampler__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_gfx_DescriptorSet_getSampler__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSet_getSampler) 

static bool js_cc_gfx_DescriptorSet_layout_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    cc::gfx::DescriptorSetLayout *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::DescriptorSetLayout *)cc_gfx_DescriptorSet_layout_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DescriptorSet_layout_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DescriptorSet_layout_get) 

bool js_register_cc_gfx_DescriptorSet(se::Object* obj) {
    auto* cls = se::Class::create("DescriptorSet", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    cls->defineProperty("layout", _SE(js_cc_gfx_DescriptorSet_layout_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_DescriptorSet_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_DescriptorSet_destroy)); 
    cls->defineFunction("update", _SE(js_cc_gfx_DescriptorSet_update)); 
    cls->defineFunction("bindBufferJSB", _SE(js_cc_gfx_DescriptorSet_bindBufferJSB)); 
    cls->defineFunction("bindTextureJSB", _SE(js_cc_gfx_DescriptorSet_bindTextureJSB)); 
    cls->defineFunction("bindSamplerJSB", _SE(js_cc_gfx_DescriptorSet_bindSamplerJSB)); 
    cls->defineFunction("bindBuffer", _SE(js_cc_gfx_DescriptorSet_bindBuffer)); 
    cls->defineFunction("bindTexture", _SE(js_cc_gfx_DescriptorSet_bindTexture)); 
    cls->defineFunction("bindSampler", _SE(js_cc_gfx_DescriptorSet_bindSampler)); 
    cls->defineFunction("getBuffer", _SE(js_cc_gfx_DescriptorSet_getBuffer)); 
    cls->defineFunction("getTexture", _SE(js_cc_gfx_DescriptorSet_getTexture)); 
    cls->defineFunction("getSampler", _SE(js_cc_gfx_DescriptorSet_getSampler)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DescriptorSet));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DescriptorSet>(cls);
    
    __jsb_cc_gfx_DescriptorSet_proto = cls->getProto();
    __jsb_cc_gfx_DescriptorSet_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DescriptorSetLayout_class = nullptr;
se::Object* __jsb_cc_gfx_DescriptorSetLayout_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DescriptorSetLayout) 

static bool js_delete_cc_gfx_DescriptorSetLayout(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DescriptorSetLayout) 

static bool js_cc_gfx_DescriptorSetLayout_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetLayout *arg1 = (cc::gfx::DescriptorSetLayout *) NULL ;
    cc::gfx::DescriptorSetLayoutInfo *arg2 = 0 ;
    cc::gfx::DescriptorSetLayoutInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayout>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSetLayout_initialize,2,SWIGTYPE_p_cc__gfx__DescriptorSetLayoutInfo");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::DescriptorSetLayoutInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSetLayout_initialize) 

static bool js_cc_gfx_DescriptorSetLayout_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetLayout *arg1 = (cc::gfx::DescriptorSetLayout *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayout>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSetLayout_destroy) 

static bool js_cc_gfx_DescriptorSetLayout_getBindings(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetLayout *arg1 = (cc::gfx::DescriptorSetLayout *) NULL ;
    cc::gfx::DescriptorSetLayoutBindingList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayout>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::DescriptorSetLayoutBindingList *) &((cc::gfx::DescriptorSetLayout const *)arg1)->getBindings();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DescriptorSetLayout_getBindings, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSetLayout_getBindings) 

static bool js_cc_gfx_DescriptorSetLayout_getDynamicBindings(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetLayout *arg1 = (cc::gfx::DescriptorSetLayout *) NULL ;
    ccstd::vector< uint32_t > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayout>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< uint32_t > *) &((cc::gfx::DescriptorSetLayout const *)arg1)->getDynamicBindings();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DescriptorSetLayout_getDynamicBindings, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSetLayout_getDynamicBindings) 

static bool js_cc_gfx_DescriptorSetLayout_getDescriptorCount(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetLayout *arg1 = (cc::gfx::DescriptorSetLayout *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayout>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::gfx::DescriptorSetLayout const *)arg1)->getDescriptorCount();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DescriptorSetLayout_getDescriptorCount, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSetLayout_getDescriptorCount) 

bool js_register_cc_gfx_DescriptorSetLayout(se::Object* obj) {
    auto* cls = se::Class::create("DescriptorSetLayout", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_DescriptorSetLayout_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_DescriptorSetLayout_destroy)); 
    cls->defineFunction("getBindings", _SE(js_cc_gfx_DescriptorSetLayout_getBindings)); 
    cls->defineFunction("getDynamicBindings", _SE(js_cc_gfx_DescriptorSetLayout_getDynamicBindings)); 
    cls->defineFunction("getDescriptorCount", _SE(js_cc_gfx_DescriptorSetLayout_getDescriptorCount)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DescriptorSetLayout));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DescriptorSetLayout>(cls);
    
    __jsb_cc_gfx_DescriptorSetLayout_proto = cls->getProto();
    __jsb_cc_gfx_DescriptorSetLayout_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Framebuffer_class = nullptr;
se::Object* __jsb_cc_gfx_Framebuffer_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Framebuffer) 

static bool js_delete_cc_gfx_Framebuffer(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Framebuffer) 

static bool js_cc_gfx_Framebuffer_computeHash_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::FramebufferInfo *arg1 = 0 ;
    cc::gfx::FramebufferInfo temp1 ;
    ccstd::hash_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Framebuffer_computeHash,1,SWIGTYPE_p_cc__gfx__FramebufferInfo");
    arg1 = &temp1;
    
    result = cc::gfx::Framebuffer::computeHash((cc::gfx::FramebufferInfo const &)*arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Framebuffer_computeHash, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Framebuffer_computeHash_static) 

static bool js_cc_gfx_Framebuffer_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Framebuffer *arg1 = (cc::gfx::Framebuffer *) NULL ;
    cc::gfx::FramebufferInfo *arg2 = 0 ;
    cc::gfx::FramebufferInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Framebuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Framebuffer_initialize,2,SWIGTYPE_p_cc__gfx__FramebufferInfo");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::FramebufferInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Framebuffer_initialize) 

static bool js_cc_gfx_Framebuffer_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Framebuffer *arg1 = (cc::gfx::Framebuffer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Framebuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Framebuffer_destroy) 

static bool js_cc_gfx_Framebuffer_renderPass_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Framebuffer *arg1 = (cc::gfx::Framebuffer *) NULL ;
    cc::gfx::RenderPass *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Framebuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::RenderPass *)cc_gfx_Framebuffer_renderPass_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Framebuffer_renderPass_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Framebuffer_renderPass_get) 

static bool js_cc_gfx_Framebuffer_colorTextures_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Framebuffer *arg1 = (cc::gfx::Framebuffer *) NULL ;
    cc::gfx::TextureList *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Framebuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::TextureList *) &cc_gfx_Framebuffer_colorTextures_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Framebuffer_colorTextures_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Framebuffer_colorTextures_get) 

static bool js_cc_gfx_Framebuffer_depthStencilTexture_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Framebuffer *arg1 = (cc::gfx::Framebuffer *) NULL ;
    cc::gfx::Texture *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Framebuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Texture *)cc_gfx_Framebuffer_depthStencilTexture_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Framebuffer_depthStencilTexture_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Framebuffer_depthStencilTexture_get) 

bool js_register_cc_gfx_Framebuffer(se::Object* obj) {
    auto* cls = se::Class::create("Framebuffer", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    cls->defineProperty("renderPass", _SE(js_cc_gfx_Framebuffer_renderPass_get), nullptr); 
    cls->defineProperty("colorTextures", _SE(js_cc_gfx_Framebuffer_colorTextures_get), nullptr); 
    cls->defineProperty("depthStencilTexture", _SE(js_cc_gfx_Framebuffer_depthStencilTexture_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_Framebuffer_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_Framebuffer_destroy)); 
    
    
    cls->defineStaticFunction("computeHash", _SE(js_cc_gfx_Framebuffer_computeHash_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Framebuffer));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Framebuffer>(cls);
    
    __jsb_cc_gfx_Framebuffer_proto = cls->getProto();
    __jsb_cc_gfx_Framebuffer_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_InputAssembler_class = nullptr;
se::Object* __jsb_cc_gfx_InputAssembler_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_InputAssembler) 

static bool js_delete_cc_gfx_InputAssembler(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_InputAssembler) 

static bool js_cc_gfx_InputAssembler_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    cc::gfx::InputAssemblerInfo *arg2 = 0 ;
    cc::gfx::InputAssemblerInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "InputAssembler_initialize,2,SWIGTYPE_p_cc__gfx__InputAssemblerInfo");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::InputAssemblerInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_InputAssembler_initialize) 

static bool js_cc_gfx_InputAssembler_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_InputAssembler_destroy) 

static bool js_cc_gfx_InputAssembler_setFirstInstance(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "InputAssembler_setFirstInstance,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setFirstInstance(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_InputAssembler_setFirstInstance) 

static bool js_cc_gfx_InputAssembler_getFirstInstance(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::gfx::InputAssembler const *)arg1)->getFirstInstance();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InputAssembler_getFirstInstance, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_InputAssembler_getFirstInstance) 

static bool js_cc_gfx_InputAssembler_vertexBuffers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    cc::gfx::BufferList *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::BufferList *) &cc_gfx_InputAssembler_vertexBuffers_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InputAssembler_vertexBuffers_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssembler_vertexBuffers_get) 

static bool js_cc_gfx_InputAssembler_attributes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    cc::gfx::AttributeList *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::AttributeList *) &cc_gfx_InputAssembler_attributes_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InputAssembler_attributes_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssembler_attributes_get) 

static bool js_cc_gfx_InputAssembler_indexBuffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    cc::gfx::Buffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Buffer *)cc_gfx_InputAssembler_indexBuffer_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InputAssembler_indexBuffer_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssembler_indexBuffer_get) 

static bool js_cc_gfx_InputAssembler_indirectBuffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    cc::gfx::Buffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Buffer *)cc_gfx_InputAssembler_indirectBuffer_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InputAssembler_indirectBuffer_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssembler_indirectBuffer_get) 

static bool js_cc_gfx_InputAssembler_attributesHash_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_gfx_InputAssembler_attributesHash_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InputAssembler_attributesHash_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssembler_attributesHash_get) 

static bool js_cc_gfx_InputAssembler_drawInfo_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    cc::gfx::DrawInfo *arg2 = 0 ;
    cc::gfx::DrawInfo temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "InputAssembler_drawInfo_set,2,SWIGTYPE_p_cc__gfx__DrawInfo");
    arg2 = &temp2;
    
    cc_gfx_InputAssembler_drawInfo_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_InputAssembler_drawInfo_set) 

static bool js_cc_gfx_InputAssembler_drawInfo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    cc::gfx::DrawInfo *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::DrawInfo *) &cc_gfx_InputAssembler_drawInfo_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InputAssembler_drawInfo_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssembler_drawInfo_get) 

static bool js_cc_gfx_InputAssembler_vertexCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "InputAssembler_vertexCount_set,2,SWIGTYPE_uint32_t"); 
    
    cc_gfx_InputAssembler_vertexCount_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_InputAssembler_vertexCount_set) 

static bool js_cc_gfx_InputAssembler_vertexCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_gfx_InputAssembler_vertexCount_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InputAssembler_vertexCount_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssembler_vertexCount_get) 

static bool js_cc_gfx_InputAssembler_firstVertex_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "InputAssembler_firstVertex_set,2,SWIGTYPE_uint32_t"); 
    
    cc_gfx_InputAssembler_firstVertex_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_InputAssembler_firstVertex_set) 

static bool js_cc_gfx_InputAssembler_firstVertex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_gfx_InputAssembler_firstVertex_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InputAssembler_firstVertex_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssembler_firstVertex_get) 

static bool js_cc_gfx_InputAssembler_indexCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "InputAssembler_indexCount_set,2,SWIGTYPE_uint32_t"); 
    
    cc_gfx_InputAssembler_indexCount_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_InputAssembler_indexCount_set) 

static bool js_cc_gfx_InputAssembler_indexCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_gfx_InputAssembler_indexCount_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InputAssembler_indexCount_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssembler_indexCount_get) 

static bool js_cc_gfx_InputAssembler_firstIndex_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "InputAssembler_firstIndex_set,2,SWIGTYPE_uint32_t"); 
    
    cc_gfx_InputAssembler_firstIndex_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_InputAssembler_firstIndex_set) 

static bool js_cc_gfx_InputAssembler_firstIndex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_gfx_InputAssembler_firstIndex_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InputAssembler_firstIndex_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssembler_firstIndex_get) 

static bool js_cc_gfx_InputAssembler_vertexOffset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "InputAssembler_vertexOffset_set,2,SWIGTYPE_uint32_t"); 
    
    cc_gfx_InputAssembler_vertexOffset_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_InputAssembler_vertexOffset_set) 

static bool js_cc_gfx_InputAssembler_vertexOffset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_gfx_InputAssembler_vertexOffset_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InputAssembler_vertexOffset_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssembler_vertexOffset_get) 

static bool js_cc_gfx_InputAssembler_instanceCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "InputAssembler_instanceCount_set,2,SWIGTYPE_uint32_t"); 
    
    cc_gfx_InputAssembler_instanceCount_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_InputAssembler_instanceCount_set) 

static bool js_cc_gfx_InputAssembler_instanceCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_gfx_InputAssembler_instanceCount_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InputAssembler_instanceCount_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssembler_instanceCount_get) 

bool js_register_cc_gfx_InputAssembler(se::Object* obj) {
    auto* cls = se::Class::create("InputAssembler", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    cls->defineProperty("vertexBuffers", _SE(js_cc_gfx_InputAssembler_vertexBuffers_get), nullptr); 
    cls->defineProperty("attributes", _SE(js_cc_gfx_InputAssembler_attributes_get), nullptr); 
    cls->defineProperty("indexBuffer", _SE(js_cc_gfx_InputAssembler_indexBuffer_get), nullptr); 
    cls->defineProperty("indirectBuffer", _SE(js_cc_gfx_InputAssembler_indirectBuffer_get), nullptr); 
    cls->defineProperty("attributesHash", _SE(js_cc_gfx_InputAssembler_attributesHash_get), nullptr); 
    cls->defineProperty("drawInfo", _SE(js_cc_gfx_InputAssembler_drawInfo_get), _SE(js_cc_gfx_InputAssembler_drawInfo_set)); 
    cls->defineProperty("vertexCount", _SE(js_cc_gfx_InputAssembler_vertexCount_get), _SE(js_cc_gfx_InputAssembler_vertexCount_set)); 
    cls->defineProperty("firstVertex", _SE(js_cc_gfx_InputAssembler_firstVertex_get), _SE(js_cc_gfx_InputAssembler_firstVertex_set)); 
    cls->defineProperty("indexCount", _SE(js_cc_gfx_InputAssembler_indexCount_get), _SE(js_cc_gfx_InputAssembler_indexCount_set)); 
    cls->defineProperty("firstIndex", _SE(js_cc_gfx_InputAssembler_firstIndex_get), _SE(js_cc_gfx_InputAssembler_firstIndex_set)); 
    cls->defineProperty("vertexOffset", _SE(js_cc_gfx_InputAssembler_vertexOffset_get), _SE(js_cc_gfx_InputAssembler_vertexOffset_set)); 
    cls->defineProperty("instanceCount", _SE(js_cc_gfx_InputAssembler_instanceCount_get), _SE(js_cc_gfx_InputAssembler_instanceCount_set)); 
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_InputAssembler_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_InputAssembler_destroy)); 
    cls->defineFunction("setFirstInstance", _SE(js_cc_gfx_InputAssembler_setFirstInstance)); 
    cls->defineFunction("getFirstInstance", _SE(js_cc_gfx_InputAssembler_getFirstInstance)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_InputAssembler));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::InputAssembler>(cls);
    
    __jsb_cc_gfx_InputAssembler_proto = cls->getProto();
    __jsb_cc_gfx_InputAssembler_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_PipelineLayout_class = nullptr;
se::Object* __jsb_cc_gfx_PipelineLayout_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_PipelineLayout) 

static bool js_delete_cc_gfx_PipelineLayout(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_PipelineLayout) 

static bool js_cc_gfx_PipelineLayout_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineLayout *arg1 = (cc::gfx::PipelineLayout *) NULL ;
    cc::gfx::PipelineLayoutInfo *arg2 = 0 ;
    cc::gfx::PipelineLayoutInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineLayout>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "PipelineLayout_initialize,2,SWIGTYPE_p_cc__gfx__PipelineLayoutInfo");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::PipelineLayoutInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_PipelineLayout_initialize) 

static bool js_cc_gfx_PipelineLayout_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineLayout *arg1 = (cc::gfx::PipelineLayout *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineLayout>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_PipelineLayout_destroy) 

static bool js_cc_gfx_PipelineLayout_getSetLayouts(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineLayout *arg1 = (cc::gfx::PipelineLayout *) NULL ;
    cc::gfx::DescriptorSetLayoutList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineLayout>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::DescriptorSetLayoutList *) &((cc::gfx::PipelineLayout const *)arg1)->getSetLayouts();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineLayout_getSetLayouts, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_PipelineLayout_getSetLayouts) 

bool js_register_cc_gfx_PipelineLayout(se::Object* obj) {
    auto* cls = se::Class::create("PipelineLayout", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_PipelineLayout_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_PipelineLayout_destroy)); 
    cls->defineFunction("getSetLayouts", _SE(js_cc_gfx_PipelineLayout_getSetLayouts)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_PipelineLayout));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::PipelineLayout>(cls);
    
    __jsb_cc_gfx_PipelineLayout_proto = cls->getProto();
    __jsb_cc_gfx_PipelineLayout_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_PipelineState_class = nullptr;
se::Object* __jsb_cc_gfx_PipelineState_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_PipelineState) 

static bool js_delete_cc_gfx_PipelineState(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_PipelineState) 

static bool js_cc_gfx_PipelineState_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineState *arg1 = (cc::gfx::PipelineState *) NULL ;
    cc::gfx::PipelineStateInfo *arg2 = 0 ;
    cc::gfx::PipelineStateInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "PipelineState_initialize,2,SWIGTYPE_p_cc__gfx__PipelineStateInfo");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::PipelineStateInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_PipelineState_initialize) 

static bool js_cc_gfx_PipelineState_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineState *arg1 = (cc::gfx::PipelineState *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_PipelineState_destroy) 

static bool js_cc_gfx_PipelineState_getDynamicStates(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineState *arg1 = (cc::gfx::PipelineState *) NULL ;
    cc::gfx::DynamicStateFlags result;
    int32_t temp ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::DynamicStateFlags)((cc::gfx::PipelineState const *)arg1)->getDynamicStates();
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_PipelineState_getDynamicStates) 

static bool js_cc_gfx_PipelineState_getPipelineLayout(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineState *arg1 = (cc::gfx::PipelineState *) NULL ;
    cc::gfx::PipelineLayout *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::PipelineLayout *)((cc::gfx::PipelineState const *)arg1)->getPipelineLayout();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineState_getPipelineLayout, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_PipelineState_getPipelineLayout) 

static bool js_cc_gfx_PipelineState_shader_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineState *arg1 = (cc::gfx::PipelineState *) NULL ;
    cc::gfx::Shader *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Shader *)cc_gfx_PipelineState_shader_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineState_shader_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineState_shader_get) 

static bool js_cc_gfx_PipelineState_primitive_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineState *arg1 = (cc::gfx::PipelineState *) NULL ;
    cc::gfx::PrimitiveMode result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::PrimitiveMode)cc_gfx_PipelineState_primitive_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineState_primitive_get) 

static bool js_cc_gfx_PipelineState_bindPoint_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineState *arg1 = (cc::gfx::PipelineState *) NULL ;
    cc::gfx::PipelineBindPoint result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::PipelineBindPoint)cc_gfx_PipelineState_bindPoint_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineState_bindPoint_get) 

static bool js_cc_gfx_PipelineState_inputState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineState *arg1 = (cc::gfx::PipelineState *) NULL ;
    cc::gfx::InputState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::InputState *) &cc_gfx_PipelineState_inputState_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineState_inputState_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineState_inputState_get) 

static bool js_cc_gfx_PipelineState_rasterizerState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineState *arg1 = (cc::gfx::PipelineState *) NULL ;
    cc::gfx::RasterizerState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::RasterizerState *) &cc_gfx_PipelineState_rasterizerState_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineState_rasterizerState_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineState_rasterizerState_get) 

static bool js_cc_gfx_PipelineState_depthStencilState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineState *arg1 = (cc::gfx::PipelineState *) NULL ;
    cc::gfx::DepthStencilState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::DepthStencilState *) &cc_gfx_PipelineState_depthStencilState_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineState_depthStencilState_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineState_depthStencilState_get) 

static bool js_cc_gfx_PipelineState_blendState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineState *arg1 = (cc::gfx::PipelineState *) NULL ;
    cc::gfx::BlendState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::BlendState *) &cc_gfx_PipelineState_blendState_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineState_blendState_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineState_blendState_get) 

static bool js_cc_gfx_PipelineState_renderPass_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineState *arg1 = (cc::gfx::PipelineState *) NULL ;
    cc::gfx::RenderPass *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineState>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::RenderPass *)cc_gfx_PipelineState_renderPass_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineState_renderPass_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineState_renderPass_get) 

bool js_register_cc_gfx_PipelineState(se::Object* obj) {
    auto* cls = se::Class::create("PipelineState", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    cls->defineProperty("shader", _SE(js_cc_gfx_PipelineState_shader_get), nullptr); 
    cls->defineProperty("primitive", _SE(js_cc_gfx_PipelineState_primitive_get), nullptr); 
    cls->defineProperty("bindPoint", _SE(js_cc_gfx_PipelineState_bindPoint_get), nullptr); 
    cls->defineProperty("inputState", _SE(js_cc_gfx_PipelineState_inputState_get), nullptr); 
    cls->defineProperty("rasterizerState", _SE(js_cc_gfx_PipelineState_rasterizerState_get), nullptr); 
    cls->defineProperty("depthStencilState", _SE(js_cc_gfx_PipelineState_depthStencilState_get), nullptr); 
    cls->defineProperty("blendState", _SE(js_cc_gfx_PipelineState_blendState_get), nullptr); 
    cls->defineProperty("renderPass", _SE(js_cc_gfx_PipelineState_renderPass_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_PipelineState_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_PipelineState_destroy)); 
    cls->defineFunction("getDynamicStates", _SE(js_cc_gfx_PipelineState_getDynamicStates)); 
    cls->defineFunction("getPipelineLayout", _SE(js_cc_gfx_PipelineState_getPipelineLayout)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_PipelineState));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::PipelineState>(cls);
    
    __jsb_cc_gfx_PipelineState_proto = cls->getProto();
    __jsb_cc_gfx_PipelineState_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_QueryPool_class = nullptr;
se::Object* __jsb_cc_gfx_QueryPool_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_QueryPool) 

static bool js_delete_cc_gfx_QueryPool(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_QueryPool) 

static bool js_cc_gfx_QueryPool_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::QueryPool *arg1 = (cc::gfx::QueryPool *) NULL ;
    cc::gfx::QueryPoolInfo *arg2 = 0 ;
    cc::gfx::QueryPoolInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPool>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "QueryPool_initialize,2,SWIGTYPE_p_cc__gfx__QueryPoolInfo");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::QueryPoolInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_QueryPool_initialize) 

static bool js_cc_gfx_QueryPool_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::QueryPool *arg1 = (cc::gfx::QueryPool *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPool>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_QueryPool_destroy) 

static bool js_cc_gfx_QueryPool_hasResult(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::QueryPool *arg1 = (cc::gfx::QueryPool *) NULL ;
    uint32_t arg2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPool>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "QueryPool_hasResult,2,SWIGTYPE_uint32_t"); 
    
    result = (bool)(arg1)->hasResult(arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_QueryPool_hasResult) 

static bool js_cc_gfx_QueryPool_getResult(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::QueryPool *arg1 = (cc::gfx::QueryPool *) NULL ;
    uint32_t arg2 ;
    uint64_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPool>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "QueryPool_getResult,2,SWIGTYPE_uint32_t"); 
    
    result = (arg1)->getResult(arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "QueryPool_getResult, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_QueryPool_getResult) 

static bool js_cc_gfx_QueryPool_getType(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::QueryPool *arg1 = (cc::gfx::QueryPool *) NULL ;
    cc::gfx::QueryType result;
    int32_t temp ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPool>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::QueryType)((cc::gfx::QueryPool const *)arg1)->getType();
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_QueryPool_getType) 

static bool js_cc_gfx_QueryPool_getMaxQueryObjects(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::QueryPool *arg1 = (cc::gfx::QueryPool *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPool>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::gfx::QueryPool const *)arg1)->getMaxQueryObjects();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "QueryPool_getMaxQueryObjects, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_QueryPool_getMaxQueryObjects) 

static bool js_cc_gfx_QueryPool_getForceWait(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::QueryPool *arg1 = (cc::gfx::QueryPool *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPool>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((cc::gfx::QueryPool const *)arg1)->getForceWait();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_QueryPool_getForceWait) 

bool js_register_cc_gfx_QueryPool(se::Object* obj) {
    auto* cls = se::Class::create("QueryPool", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_QueryPool_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_QueryPool_destroy)); 
    cls->defineFunction("hasResult", _SE(js_cc_gfx_QueryPool_hasResult)); 
    cls->defineFunction("getResult", _SE(js_cc_gfx_QueryPool_getResult)); 
    cls->defineFunction("getType", _SE(js_cc_gfx_QueryPool_getType)); 
    cls->defineFunction("getMaxQueryObjects", _SE(js_cc_gfx_QueryPool_getMaxQueryObjects)); 
    cls->defineFunction("getForceWait", _SE(js_cc_gfx_QueryPool_getForceWait)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_QueryPool));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::QueryPool>(cls);
    
    __jsb_cc_gfx_QueryPool_proto = cls->getProto();
    __jsb_cc_gfx_QueryPool_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Queue_class = nullptr;
se::Object* __jsb_cc_gfx_Queue_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Queue) 

static bool js_delete_cc_gfx_Queue(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Queue) 

static bool js_cc_gfx_Queue_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Queue *arg1 = (cc::gfx::Queue *) NULL ;
    cc::gfx::QueueInfo *arg2 = 0 ;
    cc::gfx::QueueInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Queue>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Queue_initialize,2,SWIGTYPE_p_cc__gfx__QueueInfo");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::QueueInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Queue_initialize) 

static bool js_cc_gfx_Queue_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Queue *arg1 = (cc::gfx::Queue *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Queue>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Queue_destroy) 

static bool js_cc_gfx_Queue_submit__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::Queue *arg1 = (cc::gfx::Queue *) NULL ;
    cc::gfx::CommandBuffer **arg2 = (cc::gfx::CommandBuffer **) NULL ;
    uint32_t arg3 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Queue>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Queue_submit,2,SWIGTYPE_p_p_cc__gfx__CommandBuffer"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Queue_submit,3,SWIGTYPE_uint32_t"); 
    
    (arg1)->submit((cc::gfx::CommandBuffer *const *)arg2,arg3);
    
    
    return true;
}

static bool js_cc_gfx_Queue_submit__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::Queue *arg1 = (cc::gfx::Queue *) NULL ;
    cc::gfx::CommandBufferList *arg2 = 0 ;
    cc::gfx::CommandBufferList temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Queue>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Queue_submit,2,SWIGTYPE_p_ccstd__vectorT_cc__gfx__CommandBuffer_p_t");
    arg2 = &temp2;
    
    (arg1)->submit((cc::gfx::CommandBufferList const &)*arg2);
    
    
    return true;
}

static bool js_cc_gfx_Queue_submit(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_gfx_Queue_submit__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_gfx_Queue_submit__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_Queue_submit) 

static bool js_cc_gfx_Queue_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Queue *arg1 = (cc::gfx::Queue *) NULL ;
    cc::gfx::QueueType result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Queue>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::QueueType)cc_gfx_Queue_type_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Queue_type_get) 

bool js_register_cc_gfx_Queue(se::Object* obj) {
    auto* cls = se::Class::create("Queue", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    cls->defineProperty("type", _SE(js_cc_gfx_Queue_type_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_Queue_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_Queue_destroy)); 
    cls->defineFunction("submit", _SE(js_cc_gfx_Queue_submit)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Queue));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Queue>(cls);
    
    __jsb_cc_gfx_Queue_proto = cls->getProto();
    __jsb_cc_gfx_Queue_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_RenderPass_class = nullptr;
se::Object* __jsb_cc_gfx_RenderPass_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_RenderPass) 

static bool js_delete_cc_gfx_RenderPass(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_RenderPass) 

static bool js_cc_gfx_RenderPass_computeHash_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RenderPassInfo *arg1 = 0 ;
    cc::gfx::RenderPassInfo temp1 ;
    ccstd::hash_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPass_computeHash,1,SWIGTYPE_p_cc__gfx__RenderPassInfo");
    arg1 = &temp1;
    
    result = cc::gfx::RenderPass::computeHash((cc::gfx::RenderPassInfo const &)*arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPass_computeHash, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_RenderPass_computeHash_static) 

static bool js_cc_gfx_RenderPass_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RenderPass *arg1 = (cc::gfx::RenderPass *) NULL ;
    cc::gfx::RenderPassInfo *arg2 = 0 ;
    cc::gfx::RenderPassInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPass_initialize,2,SWIGTYPE_p_cc__gfx__RenderPassInfo");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::RenderPassInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_RenderPass_initialize) 

static bool js_cc_gfx_RenderPass_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RenderPass *arg1 = (cc::gfx::RenderPass *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_RenderPass_destroy) 

static bool js_cc_gfx_RenderPass_getColorAttachments(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RenderPass *arg1 = (cc::gfx::RenderPass *) NULL ;
    cc::gfx::ColorAttachmentList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::ColorAttachmentList *) &((cc::gfx::RenderPass const *)arg1)->getColorAttachments();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPass_getColorAttachments, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_RenderPass_getColorAttachments) 

static bool js_cc_gfx_RenderPass_getDepthStencilAttachment(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RenderPass *arg1 = (cc::gfx::RenderPass *) NULL ;
    cc::gfx::DepthStencilAttachment *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::DepthStencilAttachment *) &((cc::gfx::RenderPass const *)arg1)->getDepthStencilAttachment();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPass_getDepthStencilAttachment, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_RenderPass_getDepthStencilAttachment) 

static bool js_cc_gfx_RenderPass_getSubpasses(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RenderPass *arg1 = (cc::gfx::RenderPass *) NULL ;
    cc::gfx::SubpassInfoList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::SubpassInfoList *) &((cc::gfx::RenderPass const *)arg1)->getSubpasses();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPass_getSubpasses, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_RenderPass_getSubpasses) 

static bool js_cc_gfx_RenderPass_getDependencies(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RenderPass *arg1 = (cc::gfx::RenderPass *) NULL ;
    cc::gfx::SubpassDependencyList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::SubpassDependencyList *) &((cc::gfx::RenderPass const *)arg1)->getDependencies();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPass_getDependencies, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_RenderPass_getDependencies) 

static bool js_cc_gfx_RenderPass_hash_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RenderPass *arg1 = (cc::gfx::RenderPass *) NULL ;
    ccstd::hash_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_gfx_RenderPass_hash_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPass_hash_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RenderPass_hash_get) 

bool js_register_cc_gfx_RenderPass(se::Object* obj) {
    auto* cls = se::Class::create("RenderPass", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    cls->defineProperty("hash", _SE(js_cc_gfx_RenderPass_hash_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_RenderPass_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_RenderPass_destroy)); 
    cls->defineFunction("getColorAttachments", _SE(js_cc_gfx_RenderPass_getColorAttachments)); 
    cls->defineFunction("getDepthStencilAttachment", _SE(js_cc_gfx_RenderPass_getDepthStencilAttachment)); 
    cls->defineFunction("getSubpasses", _SE(js_cc_gfx_RenderPass_getSubpasses)); 
    cls->defineFunction("getDependencies", _SE(js_cc_gfx_RenderPass_getDependencies)); 
    
    
    cls->defineStaticFunction("computeHash", _SE(js_cc_gfx_RenderPass_computeHash_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_RenderPass));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::RenderPass>(cls);
    
    __jsb_cc_gfx_RenderPass_proto = cls->getProto();
    __jsb_cc_gfx_RenderPass_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Shader_class = nullptr;
se::Object* __jsb_cc_gfx_Shader_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Shader) 

static bool js_delete_cc_gfx_Shader(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Shader) 

static bool js_cc_gfx_Shader_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Shader *arg1 = (cc::gfx::Shader *) NULL ;
    cc::gfx::ShaderInfo *arg2 = 0 ;
    cc::gfx::ShaderInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Shader>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Shader_initialize,2,SWIGTYPE_p_cc__gfx__ShaderInfo");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::ShaderInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Shader_initialize) 

static bool js_cc_gfx_Shader_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Shader *arg1 = (cc::gfx::Shader *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Shader>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Shader_destroy) 

static bool js_cc_gfx_Shader_getBuffers(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Shader *arg1 = (cc::gfx::Shader *) NULL ;
    cc::gfx::UniformStorageBufferList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Shader>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::UniformStorageBufferList *) &((cc::gfx::Shader const *)arg1)->getBuffers();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Shader_getBuffers, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Shader_getBuffers) 

static bool js_cc_gfx_Shader_getSamplerTextures(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Shader *arg1 = (cc::gfx::Shader *) NULL ;
    cc::gfx::UniformSamplerTextureList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Shader>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::UniformSamplerTextureList *) &((cc::gfx::Shader const *)arg1)->getSamplerTextures();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Shader_getSamplerTextures, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Shader_getSamplerTextures) 

static bool js_cc_gfx_Shader_getTextures(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Shader *arg1 = (cc::gfx::Shader *) NULL ;
    cc::gfx::UniformTextureList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Shader>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::UniformTextureList *) &((cc::gfx::Shader const *)arg1)->getTextures();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Shader_getTextures, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Shader_getTextures) 

static bool js_cc_gfx_Shader_getImages(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Shader *arg1 = (cc::gfx::Shader *) NULL ;
    cc::gfx::UniformStorageImageList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Shader>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::UniformStorageImageList *) &((cc::gfx::Shader const *)arg1)->getImages();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Shader_getImages, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Shader_getImages) 

static bool js_cc_gfx_Shader_getSubpassInputs(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Shader *arg1 = (cc::gfx::Shader *) NULL ;
    cc::gfx::UniformInputAttachmentList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Shader>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::UniformInputAttachmentList *) &((cc::gfx::Shader const *)arg1)->getSubpassInputs();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Shader_getSubpassInputs, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Shader_getSubpassInputs) 

static bool js_cc_gfx_Shader_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Shader *arg1 = (cc::gfx::Shader *) NULL ;
    ccstd::string *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Shader>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::string *) &cc_gfx_Shader_name_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Shader_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Shader_name_get) 

static bool js_cc_gfx_Shader_stages_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Shader *arg1 = (cc::gfx::Shader *) NULL ;
    cc::gfx::ShaderStageList *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Shader>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::ShaderStageList *) &cc_gfx_Shader_stages_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Shader_stages_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Shader_stages_get) 

static bool js_cc_gfx_Shader_attributes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Shader *arg1 = (cc::gfx::Shader *) NULL ;
    cc::gfx::AttributeList *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Shader>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::AttributeList *) &cc_gfx_Shader_attributes_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Shader_attributes_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Shader_attributes_get) 

static bool js_cc_gfx_Shader_blocks_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Shader *arg1 = (cc::gfx::Shader *) NULL ;
    cc::gfx::UniformBlockList *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Shader>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::UniformBlockList *) &cc_gfx_Shader_blocks_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Shader_blocks_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Shader_blocks_get) 

static bool js_cc_gfx_Shader_samplers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Shader *arg1 = (cc::gfx::Shader *) NULL ;
    cc::gfx::UniformSamplerList *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Shader>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::UniformSamplerList *) &cc_gfx_Shader_samplers_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Shader_samplers_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Shader_samplers_get) 

bool js_register_cc_gfx_Shader(se::Object* obj) {
    auto* cls = se::Class::create("Shader", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    cls->defineProperty("name", _SE(js_cc_gfx_Shader_name_get), nullptr); 
    cls->defineProperty("stages", _SE(js_cc_gfx_Shader_stages_get), nullptr); 
    cls->defineProperty("attributes", _SE(js_cc_gfx_Shader_attributes_get), nullptr); 
    cls->defineProperty("blocks", _SE(js_cc_gfx_Shader_blocks_get), nullptr); 
    cls->defineProperty("samplers", _SE(js_cc_gfx_Shader_samplers_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_Shader_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_Shader_destroy)); 
    cls->defineFunction("getBuffers", _SE(js_cc_gfx_Shader_getBuffers)); 
    cls->defineFunction("getSamplerTextures", _SE(js_cc_gfx_Shader_getSamplerTextures)); 
    cls->defineFunction("getTextures", _SE(js_cc_gfx_Shader_getTextures)); 
    cls->defineFunction("getImages", _SE(js_cc_gfx_Shader_getImages)); 
    cls->defineFunction("getSubpassInputs", _SE(js_cc_gfx_Shader_getSubpassInputs)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Shader));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Shader>(cls);
    
    __jsb_cc_gfx_Shader_proto = cls->getProto();
    __jsb_cc_gfx_Shader_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Swapchain_class = nullptr;
se::Object* __jsb_cc_gfx_Swapchain_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Swapchain) 

static bool js_delete_cc_gfx_Swapchain(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Swapchain) 

static bool js_cc_gfx_Swapchain_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Swapchain *arg1 = (cc::gfx::Swapchain *) NULL ;
    cc::gfx::SwapchainInfo *arg2 = 0 ;
    cc::gfx::SwapchainInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Swapchain>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Swapchain_initialize,2,SWIGTYPE_p_cc__gfx__SwapchainInfo");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::SwapchainInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Swapchain_initialize) 

static bool js_cc_gfx_Swapchain_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Swapchain *arg1 = (cc::gfx::Swapchain *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Swapchain>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Swapchain_destroy) 

static bool js_cc_gfx_Swapchain_resize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Swapchain *arg1 = (cc::gfx::Swapchain *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    cc::gfx::SurfaceTransform arg4 ;
    int32_t temp4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Swapchain>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Swapchain_resize,2,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Swapchain_resize,3,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) enum SWIGTYPE (int32_t temp4)
    ok &= sevalue_to_native(args[2], &temp4);
    SE_PRECONDITION2(ok, false, "Swapchain_resize,4,SWIGTYPE_cc__gfx__SurfaceTransform");
    arg4 = (cc::gfx::SurfaceTransform)temp4;
    (arg1)->resize(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Swapchain_resize) 

static bool js_cc_gfx_Swapchain_destroySurface(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Swapchain *arg1 = (cc::gfx::Swapchain *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Swapchain>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroySurface();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Swapchain_destroySurface) 

static bool js_cc_gfx_Swapchain_createSurface(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Swapchain *arg1 = (cc::gfx::Swapchain *) NULL ;
    void *arg2 = (void *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Swapchain>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Swapchain_createSurface,2,SWIGTYPE_p_void");
    (arg1)->createSurface(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Swapchain_createSurface) 

static bool js_cc_gfx_Swapchain_getWindowHandle(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Swapchain *arg1 = (cc::gfx::Swapchain *) NULL ;
    void *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Swapchain>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (void *)((cc::gfx::Swapchain const *)arg1)->getWindowHandle();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Swapchain_getWindowHandle, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Swapchain_getWindowHandle) 

static bool js_cc_gfx_Swapchain_getVSyncMode(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Swapchain *arg1 = (cc::gfx::Swapchain *) NULL ;
    cc::gfx::VsyncMode result;
    int32_t temp ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Swapchain>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::VsyncMode)((cc::gfx::Swapchain const *)arg1)->getVSyncMode();
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Swapchain_getVSyncMode) 

static bool js_cc_gfx_Swapchain_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Swapchain *arg1 = (cc::gfx::Swapchain *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Swapchain>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_gfx_Swapchain_width_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Swapchain_width_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Swapchain_width_get) 

static bool js_cc_gfx_Swapchain_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Swapchain *arg1 = (cc::gfx::Swapchain *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Swapchain>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_gfx_Swapchain_height_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Swapchain_height_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Swapchain_height_get) 

static bool js_cc_gfx_Swapchain_surfaceTransform_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Swapchain *arg1 = (cc::gfx::Swapchain *) NULL ;
    cc::gfx::SurfaceTransform result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Swapchain>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::SurfaceTransform)cc_gfx_Swapchain_surfaceTransform_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Swapchain_surfaceTransform_get) 

static bool js_cc_gfx_Swapchain_colorTexture_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Swapchain *arg1 = (cc::gfx::Swapchain *) NULL ;
    cc::gfx::Texture *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Swapchain>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Texture *)cc_gfx_Swapchain_colorTexture_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Swapchain_colorTexture_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Swapchain_colorTexture_get) 

static bool js_cc_gfx_Swapchain_depthStencilTexture_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Swapchain *arg1 = (cc::gfx::Swapchain *) NULL ;
    cc::gfx::Texture *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Swapchain>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Texture *)cc_gfx_Swapchain_depthStencilTexture_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Swapchain_depthStencilTexture_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Swapchain_depthStencilTexture_get) 

bool js_register_cc_gfx_Swapchain(se::Object* obj) {
    auto* cls = se::Class::create("Swapchain", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    cls->defineProperty("width", _SE(js_cc_gfx_Swapchain_width_get), nullptr); 
    cls->defineProperty("height", _SE(js_cc_gfx_Swapchain_height_get), nullptr); 
    cls->defineProperty("surfaceTransform", _SE(js_cc_gfx_Swapchain_surfaceTransform_get), nullptr); 
    cls->defineProperty("colorTexture", _SE(js_cc_gfx_Swapchain_colorTexture_get), nullptr); 
    cls->defineProperty("depthStencilTexture", _SE(js_cc_gfx_Swapchain_depthStencilTexture_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_Swapchain_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_Swapchain_destroy)); 
    cls->defineFunction("resize", _SE(js_cc_gfx_Swapchain_resize)); 
    cls->defineFunction("destroySurface", _SE(js_cc_gfx_Swapchain_destroySurface)); 
    cls->defineFunction("createSurface", _SE(js_cc_gfx_Swapchain_createSurface)); 
    cls->defineFunction("getWindowHandle", _SE(js_cc_gfx_Swapchain_getWindowHandle)); 
    cls->defineFunction("getVSyncMode", _SE(js_cc_gfx_Swapchain_getVSyncMode)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Swapchain));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Swapchain>(cls);
    
    __jsb_cc_gfx_Swapchain_proto = cls->getProto();
    __jsb_cc_gfx_Swapchain_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Texture_class = nullptr;
se::Object* __jsb_cc_gfx_Texture_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Texture) 

static bool js_delete_cc_gfx_Texture(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Texture) 

static bool js_cc_gfx_Texture_computeHash_static__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::TextureInfo *arg1 = 0 ;
    cc::gfx::TextureInfo temp1 ;
    ccstd::hash_t result;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture_computeHash,1,SWIGTYPE_p_cc__gfx__TextureInfo");
    arg1 = &temp1;
    
    result = cc::gfx::Texture::computeHash((cc::gfx::TextureInfo const &)*arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Texture_computeHash, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_gfx_Texture_computeHash_static__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::TextureViewInfo *arg1 = 0 ;
    cc::gfx::TextureViewInfo temp1 ;
    ccstd::hash_t result;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture_computeHash,1,SWIGTYPE_p_cc__gfx__TextureViewInfo");
    arg1 = &temp1;
    
    result = cc::gfx::Texture::computeHash((cc::gfx::TextureViewInfo const &)*arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Texture_computeHash, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_gfx_Texture_computeHash_static(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_gfx_Texture_computeHash_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_gfx_Texture_computeHash_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_Texture_computeHash_static) 

static bool js_cc_gfx_Texture_initialize__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::Texture *arg1 = (cc::gfx::Texture *) NULL ;
    cc::gfx::TextureInfo *arg2 = 0 ;
    cc::gfx::TextureInfo temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Texture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture_initialize,2,SWIGTYPE_p_cc__gfx__TextureInfo");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::TextureInfo const &)*arg2);
    
    
    return true;
}

static bool js_cc_gfx_Texture_initialize__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::Texture *arg1 = (cc::gfx::Texture *) NULL ;
    cc::gfx::TextureViewInfo *arg2 = 0 ;
    cc::gfx::TextureViewInfo temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Texture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture_initialize,2,SWIGTYPE_p_cc__gfx__TextureViewInfo");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::TextureViewInfo const &)*arg2);
    
    
    return true;
}

static bool js_cc_gfx_Texture_initialize(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_gfx_Texture_initialize__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_gfx_Texture_initialize__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_Texture_initialize) 

static bool js_cc_gfx_Texture_resize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Texture *arg1 = (cc::gfx::Texture *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Texture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture_resize,2,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Texture_resize,3,SWIGTYPE_uint32_t"); 
    
    (arg1)->resize(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Texture_resize) 

static bool js_cc_gfx_Texture_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Texture *arg1 = (cc::gfx::Texture *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Texture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Texture_destroy) 

static bool js_cc_gfx_Texture_isTextureView(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Texture *arg1 = (cc::gfx::Texture *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Texture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((cc::gfx::Texture const *)arg1)->isTextureView();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Texture_isTextureView) 

static bool js_cc_gfx_Texture_getRaw(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Texture *arg1 = (cc::gfx::Texture *) NULL ;
    cc::gfx::Texture *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Texture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Texture *)((cc::gfx::Texture const *)arg1)->getRaw();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Texture_getRaw, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Texture_getRaw) 

static bool js_cc_gfx_Texture_info_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Texture *arg1 = (cc::gfx::Texture *) NULL ;
    cc::gfx::TextureInfo *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Texture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::TextureInfo *) &cc_gfx_Texture_info_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Texture_info_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Texture_info_get) 

static bool js_cc_gfx_Texture_viewInfo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Texture *arg1 = (cc::gfx::Texture *) NULL ;
    cc::gfx::TextureViewInfo *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Texture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::TextureViewInfo *) &cc_gfx_Texture_viewInfo_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Texture_viewInfo_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Texture_viewInfo_get) 

static bool js_cc_gfx_Texture_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Texture *arg1 = (cc::gfx::Texture *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Texture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_gfx_Texture_width_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Texture_width_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Texture_width_get) 

static bool js_cc_gfx_Texture_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Texture *arg1 = (cc::gfx::Texture *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Texture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_gfx_Texture_height_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Texture_height_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Texture_height_get) 

static bool js_cc_gfx_Texture_format_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Texture *arg1 = (cc::gfx::Texture *) NULL ;
    cc::gfx::Format result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Texture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Format)cc_gfx_Texture_format_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Texture_format_get) 

static bool js_cc_gfx_Texture_size_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Texture *arg1 = (cc::gfx::Texture *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Texture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_gfx_Texture_size_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Texture_size_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Texture_size_get) 

static bool js_cc_gfx_Texture_hash_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Texture *arg1 = (cc::gfx::Texture *) NULL ;
    ccstd::hash_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Texture>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_gfx_Texture_hash_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Texture_hash_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Texture_hash_get) 

bool js_register_cc_gfx_Texture(se::Object* obj) {
    auto* cls = se::Class::create("Texture", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    cls->defineProperty("info", _SE(js_cc_gfx_Texture_info_get), nullptr); 
    cls->defineProperty("viewInfo", _SE(js_cc_gfx_Texture_viewInfo_get), nullptr); 
    cls->defineProperty("width", _SE(js_cc_gfx_Texture_width_get), nullptr); 
    cls->defineProperty("height", _SE(js_cc_gfx_Texture_height_get), nullptr); 
    cls->defineProperty("format", _SE(js_cc_gfx_Texture_format_get), nullptr); 
    cls->defineProperty("size", _SE(js_cc_gfx_Texture_size_get), nullptr); 
    cls->defineProperty("hash", _SE(js_cc_gfx_Texture_hash_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_Texture_initialize)); 
    cls->defineFunction("resize", _SE(js_cc_gfx_Texture_resize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_Texture_destroy)); 
    cls->defineFunction("isTextureView", _SE(js_cc_gfx_Texture_isTextureView)); 
    cls->defineFunction("getRaw", _SE(js_cc_gfx_Texture_getRaw)); 
    
    
    cls->defineStaticFunction("computeHash", _SE(js_cc_gfx_Texture_computeHash_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Texture));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Texture>(cls);
    
    __jsb_cc_gfx_Texture_proto = cls->getProto();
    __jsb_cc_gfx_Texture_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_GeneralBarrier_class = nullptr;
se::Object* __jsb_cc_gfx_GeneralBarrier_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_GeneralBarrier) 

// js_ctor
static bool js_new_cc_gfx_GeneralBarrier(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 1) {
        SE_REPORT_ERROR("js_new_cc_gfx_GeneralBarrier: wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    cc::gfx::GeneralBarrierInfo *arg1 = 0 ;
    cc::gfx::GeneralBarrierInfo temp1 ;
    cc::gfx::GeneralBarrier *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_GeneralBarrier,1,SWIGTYPE_p_cc__gfx__GeneralBarrierInfo");
    arg1 = &temp1;
    
    result = (cc::gfx::GeneralBarrier *)new cc::gfx::GeneralBarrier((cc::gfx::GeneralBarrierInfo const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_GeneralBarrier, __jsb_cc_gfx_GeneralBarrier_class, js_delete_cc_gfx_GeneralBarrier)

static bool js_cc_gfx_GeneralBarrier_computeHash_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::GeneralBarrierInfo *arg1 = 0 ;
    cc::gfx::GeneralBarrierInfo temp1 ;
    ccstd::hash_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeneralBarrier_computeHash,1,SWIGTYPE_p_cc__gfx__GeneralBarrierInfo");
    arg1 = &temp1;
    
    result = cc::gfx::GeneralBarrier::computeHash((cc::gfx::GeneralBarrierInfo const &)*arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "GeneralBarrier_computeHash, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_GeneralBarrier_computeHash_static) 

static bool js_cc_gfx_GeneralBarrier_getInfo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::GeneralBarrier *arg1 = (cc::gfx::GeneralBarrier *) NULL ;
    cc::gfx::GeneralBarrierInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::GeneralBarrier>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::GeneralBarrierInfo *) &((cc::gfx::GeneralBarrier const *)arg1)->getInfo();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "GeneralBarrier_getInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_GeneralBarrier_getInfo) 

static bool js_cc_gfx_GeneralBarrier_getHash(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::GeneralBarrier *arg1 = (cc::gfx::GeneralBarrier *) NULL ;
    ccstd::hash_t *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::GeneralBarrier>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::hash_t *) &((cc::gfx::GeneralBarrier const *)arg1)->getHash();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "GeneralBarrier_getHash, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_GeneralBarrier_getHash) 

static bool js_delete_cc_gfx_GeneralBarrier(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_GeneralBarrier) 

bool js_register_cc_gfx_GeneralBarrier(se::Object* obj) {
    auto* cls = se::Class::create("GeneralBarrier", obj, __jsb_cc_gfx_GFXObject_proto, _SE(js_new_cc_gfx_GeneralBarrier)); 
    
    
    cls->defineFunction("getInfo", _SE(js_cc_gfx_GeneralBarrier_getInfo)); 
    cls->defineFunction("getHash", _SE(js_cc_gfx_GeneralBarrier_getHash)); 
    
    
    cls->defineStaticFunction("computeHash", _SE(js_cc_gfx_GeneralBarrier_computeHash_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_GeneralBarrier));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::GeneralBarrier>(cls);
    
    __jsb_cc_gfx_GeneralBarrier_proto = cls->getProto();
    __jsb_cc_gfx_GeneralBarrier_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Sampler_class = nullptr;
se::Object* __jsb_cc_gfx_Sampler_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Sampler) 

// js_ctor
static bool js_new_cc_gfx_Sampler(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 1) {
        SE_REPORT_ERROR("js_new_cc_gfx_Sampler: wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    cc::gfx::SamplerInfo *arg1 = 0 ;
    cc::gfx::SamplerInfo temp1 ;
    cc::gfx::Sampler *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Sampler,1,SWIGTYPE_p_cc__gfx__SamplerInfo");
    arg1 = &temp1;
    
    result = (cc::gfx::Sampler *)new cc::gfx::Sampler((cc::gfx::SamplerInfo const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_Sampler, __jsb_cc_gfx_Sampler_class, js_delete_cc_gfx_Sampler)

static bool js_cc_gfx_Sampler_computeHash_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SamplerInfo *arg1 = 0 ;
    cc::gfx::SamplerInfo temp1 ;
    ccstd::hash_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sampler_computeHash,1,SWIGTYPE_p_cc__gfx__SamplerInfo");
    arg1 = &temp1;
    
    result = cc::gfx::Sampler::computeHash((cc::gfx::SamplerInfo const &)*arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Sampler_computeHash, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Sampler_computeHash_static) 

static bool js_cc_gfx_Sampler_unpackFromHash_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    ccstd::hash_t arg1 ;
    cc::gfx::SamplerInfo result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sampler_unpackFromHash,1,SWIGTYPE_ccstd__hash_t"); 
    
    result = cc::gfx::Sampler::unpackFromHash(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Sampler_unpackFromHash, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Sampler_unpackFromHash_static) 

static bool js_cc_gfx_Sampler_info_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Sampler *arg1 = (cc::gfx::Sampler *) NULL ;
    cc::gfx::SamplerInfo *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Sampler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::SamplerInfo *) &cc_gfx_Sampler_info_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Sampler_info_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Sampler_info_get) 

static bool js_cc_gfx_Sampler_hash_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Sampler *arg1 = (cc::gfx::Sampler *) NULL ;
    ccstd::hash_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Sampler>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_gfx_Sampler_hash_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Sampler_hash_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Sampler_hash_get) 

static bool js_delete_cc_gfx_Sampler(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Sampler) 

bool js_register_cc_gfx_Sampler(se::Object* obj) {
    auto* cls = se::Class::create("Sampler", obj, __jsb_cc_gfx_GFXObject_proto, _SE(js_new_cc_gfx_Sampler)); 
    
    cls->defineProperty("info", _SE(js_cc_gfx_Sampler_info_get), nullptr); 
    cls->defineProperty("hash", _SE(js_cc_gfx_Sampler_hash_get), nullptr); 
    
    
    
    cls->defineStaticFunction("computeHash", _SE(js_cc_gfx_Sampler_computeHash_static)); 
    cls->defineStaticFunction("unpackFromHash", _SE(js_cc_gfx_Sampler_unpackFromHash_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Sampler));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Sampler>(cls);
    
    __jsb_cc_gfx_Sampler_proto = cls->getProto();
    __jsb_cc_gfx_Sampler_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_TextureBarrier_class = nullptr;
se::Object* __jsb_cc_gfx_TextureBarrier_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_TextureBarrier) 

// js_ctor
static bool js_new_cc_gfx_TextureBarrier(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 1) {
        SE_REPORT_ERROR("js_new_cc_gfx_TextureBarrier: wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    cc::gfx::TextureBarrierInfo *arg1 = 0 ;
    cc::gfx::TextureBarrierInfo temp1 ;
    cc::gfx::TextureBarrier *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_TextureBarrier,1,SWIGTYPE_p_cc__gfx__TextureBarrierInfo");
    arg1 = &temp1;
    
    result = (cc::gfx::TextureBarrier *)new cc::gfx::TextureBarrier((cc::gfx::TextureBarrierInfo const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_TextureBarrier, __jsb_cc_gfx_TextureBarrier_class, js_delete_cc_gfx_TextureBarrier)

static bool js_cc_gfx_TextureBarrier_computeHash_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrierInfo *arg1 = 0 ;
    cc::gfx::TextureBarrierInfo temp1 ;
    ccstd::hash_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "TextureBarrier_computeHash,1,SWIGTYPE_p_cc__gfx__TextureBarrierInfo");
    arg1 = &temp1;
    
    result = cc::gfx::TextureBarrier::computeHash((cc::gfx::TextureBarrierInfo const &)*arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBarrier_computeHash, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_TextureBarrier_computeHash_static) 

static bool js_cc_gfx_TextureBarrier_getInfo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrier *arg1 = (cc::gfx::TextureBarrier *) NULL ;
    cc::gfx::TextureBarrierInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrier>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::TextureBarrierInfo *) &((cc::gfx::TextureBarrier const *)arg1)->getInfo();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBarrier_getInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_TextureBarrier_getInfo) 

static bool js_cc_gfx_TextureBarrier_getHash(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrier *arg1 = (cc::gfx::TextureBarrier *) NULL ;
    ccstd::hash_t *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrier>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::hash_t *) &((cc::gfx::TextureBarrier const *)arg1)->getHash();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TextureBarrier_getHash, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_TextureBarrier_getHash) 

static bool js_delete_cc_gfx_TextureBarrier(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_TextureBarrier) 

bool js_register_cc_gfx_TextureBarrier(se::Object* obj) {
    auto* cls = se::Class::create("TextureBarrier", obj, __jsb_cc_gfx_GFXObject_proto, _SE(js_new_cc_gfx_TextureBarrier)); 
    
    
    cls->defineFunction("getInfo", _SE(js_cc_gfx_TextureBarrier_getInfo)); 
    cls->defineFunction("getHash", _SE(js_cc_gfx_TextureBarrier_getHash)); 
    
    
    cls->defineStaticFunction("computeHash", _SE(js_cc_gfx_TextureBarrier_computeHash_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_TextureBarrier));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::TextureBarrier>(cls);
    
    __jsb_cc_gfx_TextureBarrier_proto = cls->getProto();
    __jsb_cc_gfx_TextureBarrier_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_BufferBarrier_class = nullptr;
se::Object* __jsb_cc_gfx_BufferBarrier_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_BufferBarrier) 

static bool js_cc_gfx_BufferBarrier_computeHash_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferBarrierInfo *arg1 = 0 ;
    cc::gfx::BufferBarrierInfo temp1 ;
    ccstd::hash_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "BufferBarrier_computeHash,1,SWIGTYPE_p_cc__gfx__BufferBarrierInfo");
    arg1 = &temp1;
    
    result = cc::gfx::BufferBarrier::computeHash((cc::gfx::BufferBarrierInfo const &)*arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BufferBarrier_computeHash, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BufferBarrier_computeHash_static) 

static bool js_cc_gfx_BufferBarrier_getInfo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferBarrier *arg1 = (cc::gfx::BufferBarrier *) NULL ;
    cc::gfx::BufferBarrierInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrier>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::BufferBarrierInfo *) &((cc::gfx::BufferBarrier const *)arg1)->getInfo();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BufferBarrier_getInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BufferBarrier_getInfo) 

static bool js_cc_gfx_BufferBarrier_getHash(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferBarrier *arg1 = (cc::gfx::BufferBarrier *) NULL ;
    ccstd::hash_t *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrier>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::hash_t *) &((cc::gfx::BufferBarrier const *)arg1)->getHash();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BufferBarrier_getHash, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BufferBarrier_getHash) 

static bool js_delete_cc_gfx_BufferBarrier(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_BufferBarrier) 

bool js_register_cc_gfx_BufferBarrier(se::Object* obj) {
    auto* cls = se::Class::create("BufferBarrier", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    
    cls->defineFunction("getInfo", _SE(js_cc_gfx_BufferBarrier_getInfo)); 
    cls->defineFunction("getHash", _SE(js_cc_gfx_BufferBarrier_getHash)); 
    
    
    cls->defineStaticFunction("computeHash", _SE(js_cc_gfx_BufferBarrier_computeHash_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_BufferBarrier));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::BufferBarrier>(cls);
    
    __jsb_cc_gfx_BufferBarrier_proto = cls->getProto();
    __jsb_cc_gfx_BufferBarrier_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Device_class = nullptr;
se::Object* __jsb_cc_gfx_Device_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Device) 

static bool js_cc_gfx_Device_getInstance_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::gfx::Device *)cc::gfx::Device::getInstance();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_getInstance, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_getInstance_static) 

static bool js_delete_cc_gfx_Device(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Device) 

static bool js_cc_gfx_Device_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::DeviceInfo *arg2 = 0 ;
    cc::gfx::DeviceInfo temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_initialize,2,SWIGTYPE_p_cc__gfx__DeviceInfo");
    arg2 = &temp2;
    
    result = (bool)(arg1)->initialize((cc::gfx::DeviceInfo const &)*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_initialize) 

static bool js_cc_gfx_Device_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_destroy) 

static bool js_cc_gfx_Device_acquire__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::Swapchain **arg2 = (cc::gfx::Swapchain **) NULL ;
    uint32_t arg3 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_acquire,2,SWIGTYPE_p_p_cc__gfx__Swapchain"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_acquire,3,SWIGTYPE_uint32_t"); 
    
    (arg1)->acquire((cc::gfx::Swapchain *const *)arg2,arg3);
    
    
    return true;
}

static bool js_cc_gfx_Device_present(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->present();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_present) 

static bool js_cc_gfx_Device_flushCommands__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::CommandBuffer **arg2 = (cc::gfx::CommandBuffer **) NULL ;
    uint32_t arg3 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_flushCommands,2,SWIGTYPE_p_p_cc__gfx__CommandBuffer"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_flushCommands,3,SWIGTYPE_uint32_t"); 
    
    (arg1)->flushCommands((cc::gfx::CommandBuffer *const *)arg2,arg3);
    
    
    return true;
}

static bool js_cc_gfx_Device_createCommandBuffer(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::CommandBufferInfo *arg2 = 0 ;
    cc::gfx::CommandBufferInfo temp2 ;
    cc::gfx::CommandBuffer *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_createCommandBuffer,2,SWIGTYPE_p_cc__gfx__CommandBufferInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::CommandBuffer *)(arg1)->createCommandBuffer((cc::gfx::CommandBufferInfo const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_createCommandBuffer, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_createCommandBuffer) 

static bool js_cc_gfx_Device_createQueue(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::QueueInfo *arg2 = 0 ;
    cc::gfx::QueueInfo temp2 ;
    cc::gfx::Queue *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_createQueue,2,SWIGTYPE_p_cc__gfx__QueueInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::Queue *)(arg1)->createQueue((cc::gfx::QueueInfo const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_createQueue, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_createQueue) 

static bool js_cc_gfx_Device_createQueryPool(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::QueryPoolInfo *arg2 = 0 ;
    cc::gfx::QueryPoolInfo temp2 ;
    cc::gfx::QueryPool *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_createQueryPool,2,SWIGTYPE_p_cc__gfx__QueryPoolInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::QueryPool *)(arg1)->createQueryPool((cc::gfx::QueryPoolInfo const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_createQueryPool, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_createQueryPool) 

static bool js_cc_gfx_Device_createSwapchain(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::SwapchainInfo *arg2 = 0 ;
    cc::gfx::SwapchainInfo temp2 ;
    cc::gfx::Swapchain *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_createSwapchain,2,SWIGTYPE_p_cc__gfx__SwapchainInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::Swapchain *)(arg1)->createSwapchain((cc::gfx::SwapchainInfo const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_createSwapchain, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_createSwapchain) 

static bool js_cc_gfx_Device_createBuffer__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::BufferInfo *arg2 = 0 ;
    cc::gfx::BufferInfo temp2 ;
    cc::gfx::Buffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_createBuffer,2,SWIGTYPE_p_cc__gfx__BufferInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::Buffer *)(arg1)->createBuffer((cc::gfx::BufferInfo const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_createBuffer, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}

static bool js_cc_gfx_Device_createBuffer__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::BufferViewInfo *arg2 = 0 ;
    cc::gfx::BufferViewInfo temp2 ;
    cc::gfx::Buffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_createBuffer,2,SWIGTYPE_p_cc__gfx__BufferViewInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::Buffer *)(arg1)->createBuffer((cc::gfx::BufferViewInfo const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_createBuffer, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}

static bool js_cc_gfx_Device_createBuffer(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_gfx_Device_createBuffer__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_gfx_Device_createBuffer__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_Device_createBuffer) 

static bool js_cc_gfx_Device_createTexture__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::TextureInfo *arg2 = 0 ;
    cc::gfx::TextureInfo temp2 ;
    cc::gfx::Texture *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_createTexture,2,SWIGTYPE_p_cc__gfx__TextureInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::Texture *)(arg1)->createTexture((cc::gfx::TextureInfo const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_createTexture, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}

static bool js_cc_gfx_Device_createTexture__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::TextureViewInfo *arg2 = 0 ;
    cc::gfx::TextureViewInfo temp2 ;
    cc::gfx::Texture *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_createTexture,2,SWIGTYPE_p_cc__gfx__TextureViewInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::Texture *)(arg1)->createTexture((cc::gfx::TextureViewInfo const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_createTexture, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}

static bool js_cc_gfx_Device_createTexture(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_gfx_Device_createTexture__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_gfx_Device_createTexture__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_Device_createTexture) 

static bool js_cc_gfx_Device_createShader(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::ShaderInfo *arg2 = 0 ;
    cc::gfx::ShaderInfo temp2 ;
    cc::gfx::Shader *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_createShader,2,SWIGTYPE_p_cc__gfx__ShaderInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::Shader *)(arg1)->createShader((cc::gfx::ShaderInfo const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_createShader, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_createShader) 

static bool js_cc_gfx_Device_createInputAssembler(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::InputAssemblerInfo *arg2 = 0 ;
    cc::gfx::InputAssemblerInfo temp2 ;
    cc::gfx::InputAssembler *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_createInputAssembler,2,SWIGTYPE_p_cc__gfx__InputAssemblerInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::InputAssembler *)(arg1)->createInputAssembler((cc::gfx::InputAssemblerInfo const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_createInputAssembler, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_createInputAssembler) 

static bool js_cc_gfx_Device_createRenderPass(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::RenderPassInfo *arg2 = 0 ;
    cc::gfx::RenderPassInfo temp2 ;
    cc::gfx::RenderPass *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_createRenderPass,2,SWIGTYPE_p_cc__gfx__RenderPassInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::RenderPass *)(arg1)->createRenderPass((cc::gfx::RenderPassInfo const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_createRenderPass, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_createRenderPass) 

static bool js_cc_gfx_Device_createFramebuffer(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::FramebufferInfo *arg2 = 0 ;
    cc::gfx::FramebufferInfo temp2 ;
    cc::gfx::Framebuffer *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_createFramebuffer,2,SWIGTYPE_p_cc__gfx__FramebufferInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::Framebuffer *)(arg1)->createFramebuffer((cc::gfx::FramebufferInfo const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_createFramebuffer, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_createFramebuffer) 

static bool js_cc_gfx_Device_createDescriptorSet(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::DescriptorSetInfo *arg2 = 0 ;
    cc::gfx::DescriptorSetInfo temp2 ;
    cc::gfx::DescriptorSet *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_createDescriptorSet,2,SWIGTYPE_p_cc__gfx__DescriptorSetInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::DescriptorSet *)(arg1)->createDescriptorSet((cc::gfx::DescriptorSetInfo const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_createDescriptorSet, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_createDescriptorSet) 

static bool js_cc_gfx_Device_createDescriptorSetLayout(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::DescriptorSetLayoutInfo *arg2 = 0 ;
    cc::gfx::DescriptorSetLayoutInfo temp2 ;
    cc::gfx::DescriptorSetLayout *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_createDescriptorSetLayout,2,SWIGTYPE_p_cc__gfx__DescriptorSetLayoutInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::DescriptorSetLayout *)(arg1)->createDescriptorSetLayout((cc::gfx::DescriptorSetLayoutInfo const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_createDescriptorSetLayout, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_createDescriptorSetLayout) 

static bool js_cc_gfx_Device_createPipelineLayout(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::PipelineLayoutInfo *arg2 = 0 ;
    cc::gfx::PipelineLayoutInfo temp2 ;
    cc::gfx::PipelineLayout *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_createPipelineLayout,2,SWIGTYPE_p_cc__gfx__PipelineLayoutInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::PipelineLayout *)(arg1)->createPipelineLayout((cc::gfx::PipelineLayoutInfo const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_createPipelineLayout, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_createPipelineLayout) 

static bool js_cc_gfx_Device_createPipelineState(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::PipelineStateInfo *arg2 = 0 ;
    cc::gfx::PipelineStateInfo temp2 ;
    cc::gfx::PipelineState *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_createPipelineState,2,SWIGTYPE_p_cc__gfx__PipelineStateInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::PipelineState *)(arg1)->createPipelineState((cc::gfx::PipelineStateInfo const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_createPipelineState, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_createPipelineState) 

static bool js_cc_gfx_Device_getSampler(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::SamplerInfo *arg2 = 0 ;
    cc::gfx::SamplerInfo temp2 ;
    cc::gfx::Sampler *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_getSampler,2,SWIGTYPE_p_cc__gfx__SamplerInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::Sampler *)(arg1)->getSampler((cc::gfx::SamplerInfo const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_getSampler, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_getSampler) 

static bool js_cc_gfx_Device_getGeneralBarrier(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::GeneralBarrierInfo *arg2 = 0 ;
    cc::gfx::GeneralBarrierInfo temp2 ;
    cc::gfx::GeneralBarrier *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_getGeneralBarrier,2,SWIGTYPE_p_cc__gfx__GeneralBarrierInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::GeneralBarrier *)(arg1)->getGeneralBarrier((cc::gfx::GeneralBarrierInfo const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_getGeneralBarrier, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_getGeneralBarrier) 

static bool js_cc_gfx_Device_getTextureBarrier(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::TextureBarrierInfo *arg2 = 0 ;
    cc::gfx::TextureBarrierInfo temp2 ;
    cc::gfx::TextureBarrier *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_getTextureBarrier,2,SWIGTYPE_p_cc__gfx__TextureBarrierInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::TextureBarrier *)(arg1)->getTextureBarrier((cc::gfx::TextureBarrierInfo const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_getTextureBarrier, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_getTextureBarrier) 

static bool js_cc_gfx_Device_getBufferBarrier(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::BufferBarrierInfo *arg2 = 0 ;
    cc::gfx::BufferBarrierInfo temp2 ;
    cc::gfx::BufferBarrier *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_getBufferBarrier,2,SWIGTYPE_p_cc__gfx__BufferBarrierInfo");
    arg2 = &temp2;
    
    result = (cc::gfx::BufferBarrier *)(arg1)->getBufferBarrier((cc::gfx::BufferBarrierInfo const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_getBufferBarrier, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_getBufferBarrier) 

static bool js_cc_gfx_Device_getQueryPoolResults(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::QueryPool *arg2 = (cc::gfx::QueryPool *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_getQueryPoolResults,2,SWIGTYPE_p_cc__gfx__QueryPool"); 
    (arg1)->getQueryPoolResults(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_getQueryPoolResults) 

static bool js_cc_gfx_Device_flushCommands__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    ccstd::vector< cc::gfx::CommandBuffer * > *arg2 = 0 ;
    ccstd::vector< cc::gfx::CommandBuffer * > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_flushCommands,2,SWIGTYPE_p_ccstd__vectorT_cc__gfx__CommandBuffer_p_t");
    arg2 = &temp2;
    
    (arg1)->flushCommands((ccstd::vector< cc::gfx::CommandBuffer * > const &)*arg2);
    
    
    return true;
}

static bool js_cc_gfx_Device_flushCommands(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_gfx_Device_flushCommands__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_gfx_Device_flushCommands__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_Device_flushCommands) 

static bool js_cc_gfx_Device_acquire__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    ccstd::vector< cc::gfx::Swapchain * > *arg2 = 0 ;
    ccstd::vector< cc::gfx::Swapchain * > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_acquire,2,SWIGTYPE_p_ccstd__vectorT_cc__gfx__Swapchain_p_t");
    arg2 = &temp2;
    
    (arg1)->acquire((ccstd::vector< cc::gfx::Swapchain * > const &)*arg2);
    
    
    return true;
}

static bool js_cc_gfx_Device_acquire(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_gfx_Device_acquire__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_gfx_Device_acquire__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_Device_acquire) 

static bool js_cc_gfx_Device_getQueryPool(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::QueryPool *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::QueryPool *)((cc::gfx::Device const *)arg1)->getQueryPool();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_getQueryPool, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_getQueryPool) 

static bool js_cc_gfx_Device_hasFeature(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::Feature arg2 ;
    int32_t temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "Device_hasFeature,2,SWIGTYPE_cc__gfx__Feature");
    arg2 = (cc::gfx::Feature)temp2;
    result = (bool)((cc::gfx::Device const *)arg1)->hasFeature(arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_hasFeature) 

static bool js_cc_gfx_Device_getFormatFeatures(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::Format arg2 ;
    int32_t temp2 ;
    cc::gfx::FormatFeature result;
    int32_t temp ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "Device_getFormatFeatures,2,SWIGTYPE_cc__gfx__Format");
    arg2 = (cc::gfx::Format)temp2;
    result = (cc::gfx::FormatFeature)((cc::gfx::Device const *)arg1)->getFormatFeatures(arg2);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_getFormatFeatures) 

static bool js_cc_gfx_Device_bindingMappingInfo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::BindingMappingInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::BindingMappingInfo *) &((cc::gfx::Device const *)arg1)->bindingMappingInfo();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_bindingMappingInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_bindingMappingInfo) 

static bool js_cc_gfx_Device_setOptions(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::DeviceOptions *arg2 = 0 ;
    cc::gfx::DeviceOptions temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Device_setOptions,2,SWIGTYPE_p_cc__gfx__DeviceOptions");
    arg2 = &temp2;
    
    (arg1)->setOptions((cc::gfx::DeviceOptions const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_setOptions) 

static bool js_cc_gfx_Device_getOptions(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::DeviceOptions *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::DeviceOptions *) &((cc::gfx::Device const *)arg1)->getOptions();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_getOptions, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_getOptions) 

static bool js_cc_gfx_Device_gfxAPI_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::API result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::API)cc_gfx_Device_gfxAPI_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Device_gfxAPI_get) 

static bool js_cc_gfx_Device_deviceName_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    ccstd::string *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::string *) &cc_gfx_Device_deviceName_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_deviceName_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Device_deviceName_get) 

static bool js_cc_gfx_Device_memoryStatus_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::MemoryStatus *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::MemoryStatus *) &cc_gfx_Device_memoryStatus_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_memoryStatus_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Device_memoryStatus_get) 

static bool js_cc_gfx_Device_queue_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::Queue *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Queue *)cc_gfx_Device_queue_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_queue_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Device_queue_get) 

static bool js_cc_gfx_Device_commandBuffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::CommandBuffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::CommandBuffer *)cc_gfx_Device_commandBuffer_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_commandBuffer_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Device_commandBuffer_get) 

static bool js_cc_gfx_Device_renderer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    ccstd::string *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::string *) &cc_gfx_Device_renderer_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_renderer_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Device_renderer_get) 

static bool js_cc_gfx_Device_vendor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    ccstd::string *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::string *) &cc_gfx_Device_vendor_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_vendor_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Device_vendor_get) 

static bool js_cc_gfx_Device_numDrawCalls_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_gfx_Device_numDrawCalls_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_numDrawCalls_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Device_numDrawCalls_get) 

static bool js_cc_gfx_Device_numInstances_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_gfx_Device_numInstances_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_numInstances_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Device_numInstances_get) 

static bool js_cc_gfx_Device_numTris_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_gfx_Device_numTris_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_numTris_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Device_numTris_get) 

static bool js_cc_gfx_Device_capabilities_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::DeviceCaps *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::DeviceCaps *) &cc_gfx_Device_capabilities_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_capabilities_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Device_capabilities_get) 

bool js_register_cc_gfx_Device(se::Object* obj) {
    auto* cls = se::Class::create("Device", obj, nullptr, nullptr); 
    
    cls->defineProperty("gfxAPI", _SE(js_cc_gfx_Device_gfxAPI_get), nullptr); 
    cls->defineProperty("deviceName", _SE(js_cc_gfx_Device_deviceName_get), nullptr); 
    cls->defineProperty("memoryStatus", _SE(js_cc_gfx_Device_memoryStatus_get), nullptr); 
    cls->defineProperty("queue", _SE(js_cc_gfx_Device_queue_get), nullptr); 
    cls->defineProperty("commandBuffer", _SE(js_cc_gfx_Device_commandBuffer_get), nullptr); 
    cls->defineProperty("renderer", _SE(js_cc_gfx_Device_renderer_get), nullptr); 
    cls->defineProperty("vendor", _SE(js_cc_gfx_Device_vendor_get), nullptr); 
    cls->defineProperty("numDrawCalls", _SE(js_cc_gfx_Device_numDrawCalls_get), nullptr); 
    cls->defineProperty("numInstances", _SE(js_cc_gfx_Device_numInstances_get), nullptr); 
    cls->defineProperty("numTris", _SE(js_cc_gfx_Device_numTris_get), nullptr); 
    cls->defineProperty("capabilities", _SE(js_cc_gfx_Device_capabilities_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_Device_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_Device_destroy)); 
    cls->defineFunction("present", _SE(js_cc_gfx_Device_present)); 
    cls->defineFunction("createCommandBuffer", _SE(js_cc_gfx_Device_createCommandBuffer)); 
    cls->defineFunction("createQueue", _SE(js_cc_gfx_Device_createQueue)); 
    cls->defineFunction("createQueryPool", _SE(js_cc_gfx_Device_createQueryPool)); 
    cls->defineFunction("createSwapchain", _SE(js_cc_gfx_Device_createSwapchain)); 
    cls->defineFunction("createBuffer", _SE(js_cc_gfx_Device_createBuffer)); 
    cls->defineFunction("createTexture", _SE(js_cc_gfx_Device_createTexture)); 
    cls->defineFunction("createShader", _SE(js_cc_gfx_Device_createShader)); 
    cls->defineFunction("createInputAssembler", _SE(js_cc_gfx_Device_createInputAssembler)); 
    cls->defineFunction("createRenderPass", _SE(js_cc_gfx_Device_createRenderPass)); 
    cls->defineFunction("createFramebuffer", _SE(js_cc_gfx_Device_createFramebuffer)); 
    cls->defineFunction("createDescriptorSet", _SE(js_cc_gfx_Device_createDescriptorSet)); 
    cls->defineFunction("createDescriptorSetLayout", _SE(js_cc_gfx_Device_createDescriptorSetLayout)); 
    cls->defineFunction("createPipelineLayout", _SE(js_cc_gfx_Device_createPipelineLayout)); 
    cls->defineFunction("createPipelineState", _SE(js_cc_gfx_Device_createPipelineState)); 
    cls->defineFunction("getSampler", _SE(js_cc_gfx_Device_getSampler)); 
    cls->defineFunction("getGeneralBarrier", _SE(js_cc_gfx_Device_getGeneralBarrier)); 
    cls->defineFunction("getTextureBarrier", _SE(js_cc_gfx_Device_getTextureBarrier)); 
    cls->defineFunction("getBufferBarrier", _SE(js_cc_gfx_Device_getBufferBarrier)); 
    cls->defineFunction("getQueryPoolResults", _SE(js_cc_gfx_Device_getQueryPoolResults)); 
    cls->defineFunction("flushCommands", _SE(js_cc_gfx_Device_flushCommands)); 
    cls->defineFunction("acquire", _SE(js_cc_gfx_Device_acquire)); 
    cls->defineFunction("getQueryPool", _SE(js_cc_gfx_Device_getQueryPool)); 
    cls->defineFunction("hasFeature", _SE(js_cc_gfx_Device_hasFeature)); 
    cls->defineFunction("getFormatFeatures", _SE(js_cc_gfx_Device_getFormatFeatures)); 
    cls->defineFunction("bindingMappingInfo", _SE(js_cc_gfx_Device_bindingMappingInfo)); 
    cls->defineFunction("setOptions", _SE(js_cc_gfx_Device_setOptions)); 
    cls->defineFunction("getOptions", _SE(js_cc_gfx_Device_getOptions)); 
    
    
    cls->defineStaticFunction("getInstance", _SE(js_cc_gfx_Device_getInstance_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Device));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Device>(cls);
    
    __jsb_cc_gfx_Device_proto = cls->getProto();
    __jsb_cc_gfx_Device_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DeviceManager_class = nullptr;
se::Object* __jsb_cc_gfx_DeviceManager_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DeviceManager) 

static bool js_cc_gfx_DeviceManager_create_static__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::Device *result = 0 ;
    
    result = (cc::gfx::Device *)cc::gfx::DeviceManager::create();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeviceManager_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_gfx_DeviceManager_create_static__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::DeviceInfo *arg1 = 0 ;
    cc::gfx::DeviceInfo temp1 ;
    cc::gfx::Device *result = 0 ;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "DeviceManager_create,1,SWIGTYPE_p_cc__gfx__DeviceInfo");
    arg1 = &temp1;
    
    result = (cc::gfx::Device *)cc::gfx::DeviceManager::create((cc::gfx::DeviceInfo const &)*arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeviceManager_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_gfx_DeviceManager_create_static(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 0) {
        ok = js_cc_gfx_DeviceManager_create_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_gfx_DeviceManager_create_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_DeviceManager_create_static) 

static bool js_cc_gfx_DeviceManager_isDetachDeviceThread_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (bool)cc::gfx::DeviceManager::isDetachDeviceThread();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DeviceManager_isDetachDeviceThread_static) 

static bool js_cc_gfx_DeviceManager_getGFXName_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    ccstd::string result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = cc::gfx::DeviceManager::getGFXName();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeviceManager_getGFXName, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DeviceManager_getGFXName_static) 

// js_ctor
static bool js_new_cc_gfx_DeviceManager(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::DeviceManager *result;
    result = (cc::gfx::DeviceManager *)new cc::gfx::DeviceManager();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_DeviceManager, __jsb_cc_gfx_DeviceManager_class, js_delete_cc_gfx_DeviceManager)

static bool js_delete_cc_gfx_DeviceManager(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DeviceManager) 

bool js_register_cc_gfx_DeviceManager(se::Object* obj) {
    auto* cls = se::Class::create("DeviceManager", obj, nullptr, _SE(js_new_cc_gfx_DeviceManager)); 
    
    
    
    
    cls->defineStaticFunction("create", _SE(js_cc_gfx_DeviceManager_create_static)); 
    cls->defineStaticFunction("isDetachDeviceThread", _SE(js_cc_gfx_DeviceManager_isDetachDeviceThread_static)); 
    cls->defineStaticFunction("getGFXName", _SE(js_cc_gfx_DeviceManager_getGFXName_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DeviceManager));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DeviceManager>(cls);
    
    __jsb_cc_gfx_DeviceManager_proto = cls->getProto();
    __jsb_cc_gfx_DeviceManager_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}




bool register_all_gfx(se::Object* obj) {
    // Get the ns
    se::Value nsVal;
    if (!obj->getProperty("gfx", &nsVal, true))
    {
        se::HandleObject jsobj(se::Object::createPlainObject());
        nsVal.setObject(jsobj);
        obj->setProperty("gfx", nsVal);
    }
    se::Object* ns = nsVal.toObject();
    /* Register classes */
    js_register_cc_gfx_Size(ns); 
    js_register_cc_gfx_DeviceCaps(ns); 
    js_register_cc_gfx_DeviceOptions(ns); 
    js_register_cc_gfx_Offset(ns); 
    js_register_cc_gfx_Rect(ns); 
    js_register_cc_gfx_Extent(ns); 
    js_register_cc_gfx_TextureSubresLayers(ns); 
    js_register_cc_gfx_TextureSubresRange(ns); 
    js_register_cc_gfx_TextureCopy(ns); 
    js_register_cc_gfx_TextureBlit(ns); 
    js_register_cc_gfx_BufferTextureCopy(ns); 
    js_register_cc_gfx_Viewport(ns); 
    js_register_cc_gfx_Color(ns); 
    js_register_cc_gfx_BindingMappingInfo(ns); 
    js_register_cc_gfx_SwapchainInfo(ns); 
    js_register_cc_gfx_DeviceInfo(ns); 
    js_register_cc_gfx_BufferInfo(ns); 
    js_register_cc_gfx_BufferViewInfo(ns); 
    js_register_cc_gfx_DrawInfo(ns); 
    js_register_cc_gfx_DispatchInfo(ns); 
    js_register_cc_gfx_IndirectBuffer(ns); 
    js_register_cc_gfx_TextureInfo(ns); 
    js_register_cc_gfx_TextureViewInfo(ns); 
    js_register_cc_gfx_SamplerInfo(ns); 
    js_register_cc_gfx_Uniform(ns); 
    js_register_cc_gfx_UniformBlock(ns); 
    js_register_cc_gfx_UniformSamplerTexture(ns); 
    js_register_cc_gfx_UniformSampler(ns); 
    js_register_cc_gfx_UniformTexture(ns); 
    js_register_cc_gfx_UniformStorageImage(ns); 
    js_register_cc_gfx_UniformStorageBuffer(ns); 
    js_register_cc_gfx_UniformInputAttachment(ns); 
    js_register_cc_gfx_ShaderStage(ns); 
    js_register_cc_gfx_Attribute(ns); 
    js_register_cc_gfx_ShaderInfo(ns); 
    js_register_cc_gfx_InputAssemblerInfo(ns); 
    js_register_cc_gfx_ColorAttachment(ns); 
    js_register_cc_gfx_DepthStencilAttachment(ns); 
    js_register_cc_gfx_SubpassInfo(ns); 
    js_register_cc_gfx_SubpassDependency(ns); 
    js_register_cc_gfx_RenderPassInfo(ns); 
    js_register_cc_gfx_GeneralBarrierInfo(ns); 
    js_register_cc_gfx_TextureBarrierInfo(ns); 
    js_register_cc_gfx_BufferBarrierInfo(ns); 
    js_register_cc_gfx_FramebufferInfo(ns); 
    js_register_cc_gfx_DescriptorSetLayoutBinding(ns); 
    js_register_cc_gfx_DescriptorSetLayoutInfo(ns); 
    js_register_cc_gfx_DescriptorSetInfo(ns); 
    js_register_cc_gfx_PipelineLayoutInfo(ns); 
    js_register_cc_gfx_InputState(ns); 
    js_register_cc_gfx_RasterizerState(ns); 
    js_register_cc_gfx_DepthStencilState(ns); 
    js_register_cc_gfx_BlendTarget(ns); 
    js_register_cc_gfx_BlendState(ns); 
    js_register_cc_gfx_PipelineStateInfo(ns); 
    js_register_cc_gfx_CommandBufferInfo(ns); 
    js_register_cc_gfx_QueueInfo(ns); 
    js_register_cc_gfx_QueryPoolInfo(ns); 
    js_register_cc_gfx_MemoryStatus(ns); 
    js_register_cc_gfx_DynamicStencilStates(ns); 
    js_register_cc_gfx_DynamicStates(ns); 
    js_register_cc_gfx_GFXObject(ns); 
    js_register_cc_gfx_Buffer(ns); 
    js_register_cc_gfx_CommandBuffer(ns); 
    js_register_cc_gfx_DescriptorSet(ns); 
    js_register_cc_gfx_DescriptorSetLayout(ns); 
    js_register_cc_gfx_Framebuffer(ns); 
    js_register_cc_gfx_InputAssembler(ns); 
    js_register_cc_gfx_PipelineLayout(ns); 
    js_register_cc_gfx_PipelineState(ns); 
    js_register_cc_gfx_QueryPool(ns); 
    js_register_cc_gfx_Queue(ns); 
    js_register_cc_gfx_RenderPass(ns); 
    js_register_cc_gfx_Shader(ns); 
    js_register_cc_gfx_Swapchain(ns); 
    js_register_cc_gfx_Texture(ns); 
    js_register_cc_gfx_GeneralBarrier(ns); 
    js_register_cc_gfx_Sampler(ns); 
    js_register_cc_gfx_TextureBarrier(ns); 
    js_register_cc_gfx_BufferBarrier(ns); 
    js_register_cc_gfx_Device(ns); 
    js_register_cc_gfx_DeviceManager(ns); 
    
    /* Register global variables & global functions */
    
    
    
    return true;
}

// clang-format on
