// clang-format off

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

/****************************************************************************
 Copyright (c) 2022-2023 Xiamen Yaji Software Co., Ltd.

 http://www.cocos.com

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights to
 use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 of the Software, and to permit persons to whom the Software is furnished to do so,
 subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
****************************************************************************/

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-variable"
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-variable"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4101)
#endif


#define SWIG_STD_MOVE(OBJ) std::move(OBJ)


#include <stdio.h>


#include "bindings/jswrapper/SeApi.h"
#include "bindings/manual/jsb_conversions.h"
#include "bindings/manual/jsb_global.h"


#include "bindings/auto/jsb_gfx_auto.h"


#define cc_gfx_Device_gfxAPI_get(self_) self_->getGfxAPI()
  

#define cc_gfx_Device_deviceName_get(self_) self_->getDeviceName()
  

#define cc_gfx_Device_memoryStatus_get(self_) self_->getMemoryStatus()
  

#define cc_gfx_Device_queue_get(self_) self_->getQueue()
  

#define cc_gfx_Device_commandBuffer_get(self_) self_->getCommandBuffer()
  

#define cc_gfx_Device_renderer_get(self_) self_->getRenderer()
  

#define cc_gfx_Device_vendor_get(self_) self_->getVendor()
  

#define cc_gfx_Device_numDrawCalls_get(self_) self_->getNumDrawCalls()
  

#define cc_gfx_Device_numInstances_get(self_) self_->getNumInstances()
  

#define cc_gfx_Device_numTris_get(self_) self_->getNumTris()
  

#define cc_gfx_Device_capabilities_get(self_) self_->getCapabilities()
  

#define cc_gfx_Shader_name_get(self_) self_->getName()
  

#define cc_gfx_Shader_stages_get(self_) self_->getStages()
  

#define cc_gfx_Shader_attributes_get(self_) self_->getAttributes()
  

#define cc_gfx_Shader_blocks_get(self_) self_->getBlocks()
  

#define cc_gfx_Shader_samplers_get(self_) self_->getSamplers()
  

#define cc_gfx_Texture_info_get(self_) self_->getInfo()
  

#define cc_gfx_Texture_viewInfo_get(self_) self_->getViewInfo()
  

#define cc_gfx_Texture_width_get(self_) self_->getWidth()
  

#define cc_gfx_Texture_height_get(self_) self_->getHeight()
  

#define cc_gfx_Texture_format_get(self_) self_->getFormat()
  

#define cc_gfx_Texture_size_get(self_) self_->getSize()
  

#define cc_gfx_Texture_hash_get(self_) self_->getHash()
  

#define cc_gfx_Queue_type_get(self_) self_->getType()
  

#define cc_gfx_RenderPass_hash_get(self_) self_->getHash()
  

#define cc_gfx_DescriptorSet_layout_get(self_) self_->getLayout()
  

#define cc_gfx_DescriptorSetLayout_bindings_get(self_) self_->getBindings()
  

#define cc_gfx_PipelineState_shader_get(self_) self_->getShader()
  

#define cc_gfx_PipelineState_primitive_get(self_) self_->getPrimitive()
  

#define cc_gfx_PipelineState_bindPoint_get(self_) self_->getBindPoint()
  

#define cc_gfx_PipelineState_inputState_get(self_) self_->getInputState()
  

#define cc_gfx_PipelineState_rasterizerState_get(self_) self_->getRasterizerState()
  

#define cc_gfx_PipelineState_depthStencilState_get(self_) self_->getDepthStencilState()
  

#define cc_gfx_PipelineState_blendState_get(self_) self_->getBlendState()
  

#define cc_gfx_PipelineState_renderPass_get(self_) self_->getRenderPass()
  

#define cc_gfx_InputAssembler_vertexBuffers_get(self_) self_->getVertexBuffers()
  

#define cc_gfx_InputAssembler_attributes_get(self_) self_->getAttributes()
  

#define cc_gfx_InputAssembler_indexBuffer_get(self_) self_->getIndexBuffer()
  

#define cc_gfx_InputAssembler_indirectBuffer_get(self_) self_->getIndirectBuffer()
  

#define cc_gfx_InputAssembler_attributesHash_get(self_) self_->getAttributesHash()
  

#define cc_gfx_InputAssembler_drawInfo_get(self_) self_->getDrawInfo()
#define cc_gfx_InputAssembler_drawInfo_set(self_, val_) self_->setDrawInfo(val_)
  

#define cc_gfx_InputAssembler_vertexCount_get(self_) self_->getVertexCount()
#define cc_gfx_InputAssembler_vertexCount_set(self_, val_) self_->setVertexCount(val_)
  

#define cc_gfx_InputAssembler_firstVertex_get(self_) self_->getFirstVertex()
#define cc_gfx_InputAssembler_firstVertex_set(self_, val_) self_->setFirstVertex(val_)
  

#define cc_gfx_InputAssembler_indexCount_get(self_) self_->getIndexCount()
#define cc_gfx_InputAssembler_indexCount_set(self_, val_) self_->setIndexCount(val_)
  

#define cc_gfx_InputAssembler_firstIndex_get(self_) self_->getFirstIndex()
#define cc_gfx_InputAssembler_firstIndex_set(self_, val_) self_->setFirstIndex(val_)
  

#define cc_gfx_InputAssembler_vertexOffset_get(self_) self_->getVertexOffset()
#define cc_gfx_InputAssembler_vertexOffset_set(self_, val_) self_->setVertexOffset(val_)
  

#define cc_gfx_InputAssembler_instanceCount_get(self_) self_->getInstanceCount()
#define cc_gfx_InputAssembler_instanceCount_set(self_, val_) self_->setInstanceCount(val_)
  

#define cc_gfx_InputAssembler_firstInstance_get(self_) self_->getFirstInstance()
#define cc_gfx_InputAssembler_firstInstance_set(self_, val_) self_->setFirstInstance(val_)
  

#define cc_gfx_CommandBuffer_type_get(self_) self_->getType()
  

#define cc_gfx_CommandBuffer_queue_get(self_) self_->getQueue()
  

#define cc_gfx_CommandBuffer_numDrawCalls_get(self_) self_->getNumDrawCalls()
  

#define cc_gfx_CommandBuffer_numInstances_get(self_) self_->getNumInstances()
  

#define cc_gfx_CommandBuffer_numTris_get(self_) self_->getNumTris()
  

#define cc_gfx_Framebuffer_renderPass_get(self_) self_->getRenderPass()
  

#define cc_gfx_Framebuffer_colorTextures_get(self_) self_->getColorTextures()
  

#define cc_gfx_Framebuffer_depthStencilTexture_get(self_) self_->getDepthStencilTexture()
  

#define cc_gfx_Buffer_usage_get(self_) self_->getUsage()
  

#define cc_gfx_Buffer_memUsage_get(self_) self_->getMemUsage()
  

#define cc_gfx_Buffer_stride_get(self_) self_->getStride()
  

#define cc_gfx_Buffer_count_get(self_) self_->getCount()
  

#define cc_gfx_Buffer_size_get(self_) self_->getSize()
  

#define cc_gfx_Buffer_flags_get(self_) self_->getFlags()
  

#define cc_gfx_Sampler_info_get(self_) self_->getInfo()
  

#define cc_gfx_Sampler_hash_get(self_) self_->getHash()
  

#define cc_gfx_Swapchain_width_get(self_) self_->getWidth()
  

#define cc_gfx_Swapchain_height_get(self_) self_->getHeight()
  

#define cc_gfx_Swapchain_surfaceTransform_get(self_) self_->getSurfaceTransform()
  

#define cc_gfx_Swapchain_colorTexture_get(self_) self_->getColorTexture()
  

#define cc_gfx_Swapchain_depthStencilTexture_get(self_) self_->getDepthStencilTexture()
  

#define cc_gfx_GFXObject_objectType_get(self_) self_->getObjectType()
  

#define cc_gfx_GFXObject_objectID_get(self_) self_->getObjectID()
  

#define cc_gfx_GFXObject_typedID_get(self_) self_->getTypedID()
  


static bool js_cc_gfx_isCombinedImageSampler(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Type arg1 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = (bool)cc::gfx::isCombinedImageSampler(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_isCombinedImageSampler) 

static bool js_cc_gfx_isSampledImage(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Type arg1 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = (bool)cc::gfx::isSampledImage(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_isSampledImage) 

static bool js_cc_gfx_isStorageImage(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Type arg1 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = (bool)cc::gfx::isStorageImage(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_isStorageImage) 

se::Class* __jsb_cc_gfx_Size_class = nullptr;
se::Object* __jsb_cc_gfx_Size_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Size) 

static bool js_cc_gfx_Size_x_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Size *arg1 = (cc::gfx::Size *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Size>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->x, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Size_x_set) 

static bool js_cc_gfx_Size_x_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Size *arg1 = (cc::gfx::Size *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Size>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->x, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Size_x_get) 

static bool js_cc_gfx_Size_y_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Size *arg1 = (cc::gfx::Size *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Size>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->y, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Size_y_set) 

static bool js_cc_gfx_Size_y_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Size *arg1 = (cc::gfx::Size *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Size>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->y, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Size_y_get) 

static bool js_cc_gfx_Size_z_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Size *arg1 = (cc::gfx::Size *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Size>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->z, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Size_z_set) 

static bool js_cc_gfx_Size_z_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Size *arg1 = (cc::gfx::Size *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Size>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->z, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Size_z_get) 

static bool js_cc_gfx_Size_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Size *arg1 = (cc::gfx::Size *) NULL ;
    cc::gfx::Size *arg2 = 0 ;
    cc::gfx::Size temp2 ;
    cc::gfx::Size *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Size>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::Size *) &(arg1)->copy((cc::gfx::Size const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Size_copy) 

static bool js_new_cc_gfx_Size(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::Size *result;
    result = (cc::gfx::Size *)new cc::gfx::Size();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_Size, __jsb_cc_gfx_Size_class, js_delete_cc_gfx_Size)

static bool js_delete_cc_gfx_Size(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Size) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::Size * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::Size*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("x", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->x), ctx);
    }
    
    
    json->getProperty("y", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->y), ctx);
    }
    
    
    json->getProperty("z", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->z), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_Size(se::Object* obj) {
    auto* cls = se::Class::create("Size", obj, nullptr, _SE(js_new_cc_gfx_Size)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("x", _SE(js_cc_gfx_Size_x_get), _SE(js_cc_gfx_Size_x_set)); 
    cls->defineProperty("y", _SE(js_cc_gfx_Size_y_get), _SE(js_cc_gfx_Size_y_set)); 
    cls->defineProperty("z", _SE(js_cc_gfx_Size_z_get), _SE(js_cc_gfx_Size_z_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_Size_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Size));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Size>(cls);
    
    __jsb_cc_gfx_Size_proto = cls->getProto();
    __jsb_cc_gfx_Size_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DeviceCaps_class = nullptr;
se::Object* __jsb_cc_gfx_DeviceCaps_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DeviceCaps) 

static bool js_cc_gfx_DeviceCaps_maxVertexAttributes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxVertexAttributes, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxVertexAttributes_set) 

static bool js_cc_gfx_DeviceCaps_maxVertexAttributes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxVertexAttributes, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxVertexAttributes_get) 

static bool js_cc_gfx_DeviceCaps_maxVertexUniformVectors_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxVertexUniformVectors, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxVertexUniformVectors_set) 

static bool js_cc_gfx_DeviceCaps_maxVertexUniformVectors_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxVertexUniformVectors, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxVertexUniformVectors_get) 

static bool js_cc_gfx_DeviceCaps_maxFragmentUniformVectors_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxFragmentUniformVectors, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxFragmentUniformVectors_set) 

static bool js_cc_gfx_DeviceCaps_maxFragmentUniformVectors_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxFragmentUniformVectors, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxFragmentUniformVectors_get) 

static bool js_cc_gfx_DeviceCaps_maxTextureUnits_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxTextureUnits, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxTextureUnits_set) 

static bool js_cc_gfx_DeviceCaps_maxTextureUnits_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxTextureUnits, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxTextureUnits_get) 

static bool js_cc_gfx_DeviceCaps_maxImageUnits_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxImageUnits, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxImageUnits_set) 

static bool js_cc_gfx_DeviceCaps_maxImageUnits_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxImageUnits, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxImageUnits_get) 

static bool js_cc_gfx_DeviceCaps_maxVertexTextureUnits_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxVertexTextureUnits, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxVertexTextureUnits_set) 

static bool js_cc_gfx_DeviceCaps_maxVertexTextureUnits_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxVertexTextureUnits, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxVertexTextureUnits_get) 

static bool js_cc_gfx_DeviceCaps_maxColorRenderTargets_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxColorRenderTargets, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxColorRenderTargets_set) 

static bool js_cc_gfx_DeviceCaps_maxColorRenderTargets_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxColorRenderTargets, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxColorRenderTargets_get) 

static bool js_cc_gfx_DeviceCaps_maxShaderStorageBufferBindings_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxShaderStorageBufferBindings, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxShaderStorageBufferBindings_set) 

static bool js_cc_gfx_DeviceCaps_maxShaderStorageBufferBindings_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxShaderStorageBufferBindings, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxShaderStorageBufferBindings_get) 

static bool js_cc_gfx_DeviceCaps_maxShaderStorageBlockSize_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxShaderStorageBlockSize, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxShaderStorageBlockSize_set) 

static bool js_cc_gfx_DeviceCaps_maxShaderStorageBlockSize_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxShaderStorageBlockSize, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxShaderStorageBlockSize_get) 

static bool js_cc_gfx_DeviceCaps_maxUniformBufferBindings_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxUniformBufferBindings, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxUniformBufferBindings_set) 

static bool js_cc_gfx_DeviceCaps_maxUniformBufferBindings_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxUniformBufferBindings, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxUniformBufferBindings_get) 

static bool js_cc_gfx_DeviceCaps_maxUniformBlockSize_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxUniformBlockSize, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxUniformBlockSize_set) 

static bool js_cc_gfx_DeviceCaps_maxUniformBlockSize_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxUniformBlockSize, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxUniformBlockSize_get) 

static bool js_cc_gfx_DeviceCaps_maxTextureSize_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxTextureSize, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxTextureSize_set) 

static bool js_cc_gfx_DeviceCaps_maxTextureSize_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxTextureSize, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxTextureSize_get) 

static bool js_cc_gfx_DeviceCaps_maxCubeMapTextureSize_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxCubeMapTextureSize, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxCubeMapTextureSize_set) 

static bool js_cc_gfx_DeviceCaps_maxCubeMapTextureSize_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxCubeMapTextureSize, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxCubeMapTextureSize_get) 

static bool js_cc_gfx_DeviceCaps_maxArrayTextureLayers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxArrayTextureLayers, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxArrayTextureLayers_set) 

static bool js_cc_gfx_DeviceCaps_maxArrayTextureLayers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxArrayTextureLayers, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxArrayTextureLayers_get) 

static bool js_cc_gfx_DeviceCaps_max3DTextureSize_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->max3DTextureSize, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_max3DTextureSize_set) 

static bool js_cc_gfx_DeviceCaps_max3DTextureSize_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->max3DTextureSize, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_max3DTextureSize_get) 

static bool js_cc_gfx_DeviceCaps_uboOffsetAlignment_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->uboOffsetAlignment, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_uboOffsetAlignment_set) 

static bool js_cc_gfx_DeviceCaps_uboOffsetAlignment_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->uboOffsetAlignment, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_uboOffsetAlignment_get) 

static bool js_cc_gfx_DeviceCaps_maxComputeSharedMemorySize_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxComputeSharedMemorySize, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxComputeSharedMemorySize_set) 

static bool js_cc_gfx_DeviceCaps_maxComputeSharedMemorySize_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxComputeSharedMemorySize, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxComputeSharedMemorySize_get) 

static bool js_cc_gfx_DeviceCaps_maxComputeWorkGroupInvocations_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxComputeWorkGroupInvocations, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxComputeWorkGroupInvocations_set) 

static bool js_cc_gfx_DeviceCaps_maxComputeWorkGroupInvocations_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxComputeWorkGroupInvocations, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxComputeWorkGroupInvocations_get) 

static bool js_cc_gfx_DeviceCaps_maxComputeWorkGroupSize_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxComputeWorkGroupSize, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxComputeWorkGroupSize_set) 

static bool js_cc_gfx_DeviceCaps_maxComputeWorkGroupSize_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxComputeWorkGroupSize, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxComputeWorkGroupSize, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxComputeWorkGroupSize_get) 

static bool js_cc_gfx_DeviceCaps_maxComputeWorkGroupCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxComputeWorkGroupCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_maxComputeWorkGroupCount_set) 

static bool js_cc_gfx_DeviceCaps_maxComputeWorkGroupCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxComputeWorkGroupCount, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxComputeWorkGroupCount, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_maxComputeWorkGroupCount_get) 

static bool js_cc_gfx_DeviceCaps_supportQuery_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->supportQuery);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_supportQuery_set) 

static bool js_cc_gfx_DeviceCaps_supportQuery_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->supportQuery, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_supportQuery_get) 

static bool js_cc_gfx_DeviceCaps_clipSpaceMinZ_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->clipSpaceMinZ, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_clipSpaceMinZ_set) 

static bool js_cc_gfx_DeviceCaps_clipSpaceMinZ_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->clipSpaceMinZ, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_clipSpaceMinZ_get) 

static bool js_cc_gfx_DeviceCaps_screenSpaceSignY_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->screenSpaceSignY, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_screenSpaceSignY_set) 

static bool js_cc_gfx_DeviceCaps_screenSpaceSignY_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->screenSpaceSignY, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_screenSpaceSignY_get) 

static bool js_cc_gfx_DeviceCaps_clipSpaceSignY_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->clipSpaceSignY, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceCaps_clipSpaceSignY_set) 

static bool js_cc_gfx_DeviceCaps_clipSpaceSignY_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->clipSpaceSignY, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceCaps_clipSpaceSignY_get) 

static bool js_cc_gfx_DeviceCaps_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceCaps *arg1 = (cc::gfx::DeviceCaps *) NULL ;
    cc::gfx::DeviceCaps *arg2 = 0 ;
    cc::gfx::DeviceCaps temp2 ;
    cc::gfx::DeviceCaps *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceCaps>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::DeviceCaps *) &(arg1)->copy((cc::gfx::DeviceCaps const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DeviceCaps_copy) 

static bool js_new_cc_gfx_DeviceCaps(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::DeviceCaps *result;
    result = (cc::gfx::DeviceCaps *)new cc::gfx::DeviceCaps();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_DeviceCaps, __jsb_cc_gfx_DeviceCaps_class, js_delete_cc_gfx_DeviceCaps)

static bool js_delete_cc_gfx_DeviceCaps(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DeviceCaps) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::DeviceCaps * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::DeviceCaps*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("maxVertexAttributes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxVertexAttributes), ctx);
    }
    
    
    json->getProperty("maxVertexUniformVectors", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxVertexUniformVectors), ctx);
    }
    
    
    json->getProperty("maxFragmentUniformVectors", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxFragmentUniformVectors), ctx);
    }
    
    
    json->getProperty("maxTextureUnits", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxTextureUnits), ctx);
    }
    
    
    json->getProperty("maxImageUnits", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxImageUnits), ctx);
    }
    
    
    json->getProperty("maxVertexTextureUnits", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxVertexTextureUnits), ctx);
    }
    
    
    json->getProperty("maxColorRenderTargets", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxColorRenderTargets), ctx);
    }
    
    
    json->getProperty("maxShaderStorageBufferBindings", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxShaderStorageBufferBindings), ctx);
    }
    
    
    json->getProperty("maxShaderStorageBlockSize", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxShaderStorageBlockSize), ctx);
    }
    
    
    json->getProperty("maxUniformBufferBindings", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxUniformBufferBindings), ctx);
    }
    
    
    json->getProperty("maxUniformBlockSize", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxUniformBlockSize), ctx);
    }
    
    
    json->getProperty("maxTextureSize", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxTextureSize), ctx);
    }
    
    
    json->getProperty("maxCubeMapTextureSize", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxCubeMapTextureSize), ctx);
    }
    
    
    json->getProperty("maxArrayTextureLayers", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxArrayTextureLayers), ctx);
    }
    
    
    json->getProperty("max3DTextureSize", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->max3DTextureSize), ctx);
    }
    
    
    json->getProperty("uboOffsetAlignment", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->uboOffsetAlignment), ctx);
    }
    
    
    json->getProperty("maxComputeSharedMemorySize", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxComputeSharedMemorySize), ctx);
    }
    
    
    json->getProperty("maxComputeWorkGroupInvocations", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxComputeWorkGroupInvocations), ctx);
    }
    
    
    json->getProperty("maxComputeWorkGroupSize", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxComputeWorkGroupSize), ctx);
    }
    
    
    json->getProperty("maxComputeWorkGroupCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxComputeWorkGroupCount), ctx);
    }
    
    
    json->getProperty("supportQuery", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->supportQuery), ctx);
    }
    
    
    json->getProperty("clipSpaceMinZ", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->clipSpaceMinZ), ctx);
    }
    
    
    json->getProperty("screenSpaceSignY", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->screenSpaceSignY), ctx);
    }
    
    
    json->getProperty("clipSpaceSignY", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->clipSpaceSignY), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_DeviceCaps(se::Object* obj) {
    auto* cls = se::Class::create("DeviceCaps", obj, nullptr, _SE(js_new_cc_gfx_DeviceCaps)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("maxVertexAttributes", _SE(js_cc_gfx_DeviceCaps_maxVertexAttributes_get), _SE(js_cc_gfx_DeviceCaps_maxVertexAttributes_set)); 
    cls->defineProperty("maxVertexUniformVectors", _SE(js_cc_gfx_DeviceCaps_maxVertexUniformVectors_get), _SE(js_cc_gfx_DeviceCaps_maxVertexUniformVectors_set)); 
    cls->defineProperty("maxFragmentUniformVectors", _SE(js_cc_gfx_DeviceCaps_maxFragmentUniformVectors_get), _SE(js_cc_gfx_DeviceCaps_maxFragmentUniformVectors_set)); 
    cls->defineProperty("maxTextureUnits", _SE(js_cc_gfx_DeviceCaps_maxTextureUnits_get), _SE(js_cc_gfx_DeviceCaps_maxTextureUnits_set)); 
    cls->defineProperty("maxImageUnits", _SE(js_cc_gfx_DeviceCaps_maxImageUnits_get), _SE(js_cc_gfx_DeviceCaps_maxImageUnits_set)); 
    cls->defineProperty("maxVertexTextureUnits", _SE(js_cc_gfx_DeviceCaps_maxVertexTextureUnits_get), _SE(js_cc_gfx_DeviceCaps_maxVertexTextureUnits_set)); 
    cls->defineProperty("maxColorRenderTargets", _SE(js_cc_gfx_DeviceCaps_maxColorRenderTargets_get), _SE(js_cc_gfx_DeviceCaps_maxColorRenderTargets_set)); 
    cls->defineProperty("maxShaderStorageBufferBindings", _SE(js_cc_gfx_DeviceCaps_maxShaderStorageBufferBindings_get), _SE(js_cc_gfx_DeviceCaps_maxShaderStorageBufferBindings_set)); 
    cls->defineProperty("maxShaderStorageBlockSize", _SE(js_cc_gfx_DeviceCaps_maxShaderStorageBlockSize_get), _SE(js_cc_gfx_DeviceCaps_maxShaderStorageBlockSize_set)); 
    cls->defineProperty("maxUniformBufferBindings", _SE(js_cc_gfx_DeviceCaps_maxUniformBufferBindings_get), _SE(js_cc_gfx_DeviceCaps_maxUniformBufferBindings_set)); 
    cls->defineProperty("maxUniformBlockSize", _SE(js_cc_gfx_DeviceCaps_maxUniformBlockSize_get), _SE(js_cc_gfx_DeviceCaps_maxUniformBlockSize_set)); 
    cls->defineProperty("maxTextureSize", _SE(js_cc_gfx_DeviceCaps_maxTextureSize_get), _SE(js_cc_gfx_DeviceCaps_maxTextureSize_set)); 
    cls->defineProperty("maxCubeMapTextureSize", _SE(js_cc_gfx_DeviceCaps_maxCubeMapTextureSize_get), _SE(js_cc_gfx_DeviceCaps_maxCubeMapTextureSize_set)); 
    cls->defineProperty("maxArrayTextureLayers", _SE(js_cc_gfx_DeviceCaps_maxArrayTextureLayers_get), _SE(js_cc_gfx_DeviceCaps_maxArrayTextureLayers_set)); 
    cls->defineProperty("max3DTextureSize", _SE(js_cc_gfx_DeviceCaps_max3DTextureSize_get), _SE(js_cc_gfx_DeviceCaps_max3DTextureSize_set)); 
    cls->defineProperty("uboOffsetAlignment", _SE(js_cc_gfx_DeviceCaps_uboOffsetAlignment_get), _SE(js_cc_gfx_DeviceCaps_uboOffsetAlignment_set)); 
    cls->defineProperty("maxComputeSharedMemorySize", _SE(js_cc_gfx_DeviceCaps_maxComputeSharedMemorySize_get), _SE(js_cc_gfx_DeviceCaps_maxComputeSharedMemorySize_set)); 
    cls->defineProperty("maxComputeWorkGroupInvocations", _SE(js_cc_gfx_DeviceCaps_maxComputeWorkGroupInvocations_get), _SE(js_cc_gfx_DeviceCaps_maxComputeWorkGroupInvocations_set)); 
    cls->defineProperty("maxComputeWorkGroupSize", _SE(js_cc_gfx_DeviceCaps_maxComputeWorkGroupSize_get), _SE(js_cc_gfx_DeviceCaps_maxComputeWorkGroupSize_set)); 
    cls->defineProperty("maxComputeWorkGroupCount", _SE(js_cc_gfx_DeviceCaps_maxComputeWorkGroupCount_get), _SE(js_cc_gfx_DeviceCaps_maxComputeWorkGroupCount_set)); 
    cls->defineProperty("supportQuery", _SE(js_cc_gfx_DeviceCaps_supportQuery_get), _SE(js_cc_gfx_DeviceCaps_supportQuery_set)); 
    cls->defineProperty("clipSpaceMinZ", _SE(js_cc_gfx_DeviceCaps_clipSpaceMinZ_get), _SE(js_cc_gfx_DeviceCaps_clipSpaceMinZ_set)); 
    cls->defineProperty("screenSpaceSignY", _SE(js_cc_gfx_DeviceCaps_screenSpaceSignY_get), _SE(js_cc_gfx_DeviceCaps_screenSpaceSignY_set)); 
    cls->defineProperty("clipSpaceSignY", _SE(js_cc_gfx_DeviceCaps_clipSpaceSignY_get), _SE(js_cc_gfx_DeviceCaps_clipSpaceSignY_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_DeviceCaps_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DeviceCaps));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DeviceCaps>(cls);
    
    __jsb_cc_gfx_DeviceCaps_proto = cls->getProto();
    __jsb_cc_gfx_DeviceCaps_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DeviceOptions_class = nullptr;
se::Object* __jsb_cc_gfx_DeviceOptions_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DeviceOptions) 

static bool js_cc_gfx_DeviceOptions_enableBarrierDeduce_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceOptions *arg1 = (cc::gfx::DeviceOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceOptions>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->enableBarrierDeduce);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceOptions_enableBarrierDeduce_set) 

static bool js_cc_gfx_DeviceOptions_enableBarrierDeduce_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceOptions *arg1 = (cc::gfx::DeviceOptions *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceOptions>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->enableBarrierDeduce, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceOptions_enableBarrierDeduce_get) 

static bool js_new_cc_gfx_DeviceOptions(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::DeviceOptions *result;
    result = (cc::gfx::DeviceOptions *)new cc::gfx::DeviceOptions();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_DeviceOptions, __jsb_cc_gfx_DeviceOptions_class, js_delete_cc_gfx_DeviceOptions)

static bool js_delete_cc_gfx_DeviceOptions(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DeviceOptions) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::DeviceOptions * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::DeviceOptions*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("enableBarrierDeduce", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->enableBarrierDeduce), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_DeviceOptions(se::Object* obj) {
    auto* cls = se::Class::create("DeviceOptions", obj, nullptr, _SE(js_new_cc_gfx_DeviceOptions)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("enableBarrierDeduce", _SE(js_cc_gfx_DeviceOptions_enableBarrierDeduce_get), _SE(js_cc_gfx_DeviceOptions_enableBarrierDeduce_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DeviceOptions));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DeviceOptions>(cls);
    
    __jsb_cc_gfx_DeviceOptions_proto = cls->getProto();
    __jsb_cc_gfx_DeviceOptions_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Offset_class = nullptr;
se::Object* __jsb_cc_gfx_Offset_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Offset) 

static bool js_cc_gfx_Offset_x_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Offset *arg1 = (cc::gfx::Offset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Offset>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->x, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Offset_x_set) 

static bool js_cc_gfx_Offset_x_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Offset *arg1 = (cc::gfx::Offset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Offset>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->x, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Offset_x_get) 

static bool js_cc_gfx_Offset_y_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Offset *arg1 = (cc::gfx::Offset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Offset>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->y, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Offset_y_set) 

static bool js_cc_gfx_Offset_y_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Offset *arg1 = (cc::gfx::Offset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Offset>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->y, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Offset_y_get) 

static bool js_cc_gfx_Offset_z_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Offset *arg1 = (cc::gfx::Offset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Offset>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->z, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Offset_z_set) 

static bool js_cc_gfx_Offset_z_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Offset *arg1 = (cc::gfx::Offset *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Offset>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->z, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Offset_z_get) 

static bool js_cc_gfx_Offset_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Offset *arg1 = (cc::gfx::Offset *) NULL ;
    cc::gfx::Offset *arg2 = 0 ;
    cc::gfx::Offset temp2 ;
    cc::gfx::Offset *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Offset>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::Offset *) &(arg1)->copy((cc::gfx::Offset const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Offset_copy) 

static bool js_new_cc_gfx_Offset(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::Offset *result;
    result = (cc::gfx::Offset *)new cc::gfx::Offset();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_Offset, __jsb_cc_gfx_Offset_class, js_delete_cc_gfx_Offset)

static bool js_delete_cc_gfx_Offset(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Offset) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::Offset * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::Offset*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("x", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->x), ctx);
    }
    
    
    json->getProperty("y", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->y), ctx);
    }
    
    
    json->getProperty("z", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->z), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_Offset(se::Object* obj) {
    auto* cls = se::Class::create("Offset", obj, nullptr, _SE(js_new_cc_gfx_Offset)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("x", _SE(js_cc_gfx_Offset_x_get), _SE(js_cc_gfx_Offset_x_set)); 
    cls->defineProperty("y", _SE(js_cc_gfx_Offset_y_get), _SE(js_cc_gfx_Offset_y_set)); 
    cls->defineProperty("z", _SE(js_cc_gfx_Offset_z_get), _SE(js_cc_gfx_Offset_z_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_Offset_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Offset));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Offset>(cls);
    
    __jsb_cc_gfx_Offset_proto = cls->getProto();
    __jsb_cc_gfx_Offset_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Rect_class = nullptr;
se::Object* __jsb_cc_gfx_Rect_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Rect) 

static bool js_cc_gfx_Rect_x_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Rect *arg1 = (cc::gfx::Rect *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Rect>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->x, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Rect_x_set) 

static bool js_cc_gfx_Rect_x_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Rect *arg1 = (cc::gfx::Rect *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Rect>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->x, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Rect_x_get) 

static bool js_cc_gfx_Rect_y_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Rect *arg1 = (cc::gfx::Rect *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Rect>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->y, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Rect_y_set) 

static bool js_cc_gfx_Rect_y_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Rect *arg1 = (cc::gfx::Rect *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Rect>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->y, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Rect_y_get) 

static bool js_cc_gfx_Rect_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Rect *arg1 = (cc::gfx::Rect *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Rect>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->width, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Rect_width_set) 

static bool js_cc_gfx_Rect_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Rect *arg1 = (cc::gfx::Rect *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Rect>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->width, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Rect_width_get) 

static bool js_cc_gfx_Rect_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Rect *arg1 = (cc::gfx::Rect *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Rect>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->height, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Rect_height_set) 

static bool js_cc_gfx_Rect_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Rect *arg1 = (cc::gfx::Rect *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Rect>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->height, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Rect_height_get) 

static bool js_cc_gfx_Rect_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Rect *arg1 = (cc::gfx::Rect *) NULL ;
    cc::gfx::Rect *arg2 = 0 ;
    cc::gfx::Rect temp2 ;
    cc::gfx::Rect *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Rect>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::Rect *) &(arg1)->copy((cc::gfx::Rect const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Rect_copy) 

static bool js_new_cc_gfx_Rect(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::Rect *result;
    result = (cc::gfx::Rect *)new cc::gfx::Rect();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_Rect, __jsb_cc_gfx_Rect_class, js_delete_cc_gfx_Rect)

static bool js_delete_cc_gfx_Rect(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Rect) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::Rect * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::Rect*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("x", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->x), ctx);
    }
    
    
    json->getProperty("y", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->y), ctx);
    }
    
    
    json->getProperty("width", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->width), ctx);
    }
    
    
    json->getProperty("height", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->height), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_Rect(se::Object* obj) {
    auto* cls = se::Class::create("Rect", obj, nullptr, _SE(js_new_cc_gfx_Rect)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("x", _SE(js_cc_gfx_Rect_x_get), _SE(js_cc_gfx_Rect_x_set)); 
    cls->defineProperty("y", _SE(js_cc_gfx_Rect_y_get), _SE(js_cc_gfx_Rect_y_set)); 
    cls->defineProperty("width", _SE(js_cc_gfx_Rect_width_get), _SE(js_cc_gfx_Rect_width_set)); 
    cls->defineProperty("height", _SE(js_cc_gfx_Rect_height_get), _SE(js_cc_gfx_Rect_height_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_Rect_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Rect));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Rect>(cls);
    
    __jsb_cc_gfx_Rect_proto = cls->getProto();
    __jsb_cc_gfx_Rect_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Extent_class = nullptr;
se::Object* __jsb_cc_gfx_Extent_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Extent) 

static bool js_cc_gfx_Extent_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Extent *arg1 = (cc::gfx::Extent *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Extent>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->width, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Extent_width_set) 

static bool js_cc_gfx_Extent_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Extent *arg1 = (cc::gfx::Extent *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Extent>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->width, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Extent_width_get) 

static bool js_cc_gfx_Extent_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Extent *arg1 = (cc::gfx::Extent *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Extent>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->height, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Extent_height_set) 

static bool js_cc_gfx_Extent_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Extent *arg1 = (cc::gfx::Extent *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Extent>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->height, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Extent_height_get) 

static bool js_cc_gfx_Extent_depth_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Extent *arg1 = (cc::gfx::Extent *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Extent>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depth, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Extent_depth_set) 

static bool js_cc_gfx_Extent_depth_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Extent *arg1 = (cc::gfx::Extent *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Extent>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depth, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Extent_depth_get) 

static bool js_cc_gfx_Extent_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Extent *arg1 = (cc::gfx::Extent *) NULL ;
    cc::gfx::Extent *arg2 = 0 ;
    cc::gfx::Extent temp2 ;
    cc::gfx::Extent *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Extent>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::Extent *) &(arg1)->copy((cc::gfx::Extent const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Extent_copy) 

static bool js_new_cc_gfx_Extent(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::Extent *result;
    result = (cc::gfx::Extent *)new cc::gfx::Extent();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_Extent, __jsb_cc_gfx_Extent_class, js_delete_cc_gfx_Extent)

static bool js_delete_cc_gfx_Extent(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Extent) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::Extent * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::Extent*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("width", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->width), ctx);
    }
    
    
    json->getProperty("height", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->height), ctx);
    }
    
    
    json->getProperty("depth", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depth), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_Extent(se::Object* obj) {
    auto* cls = se::Class::create("Extent", obj, nullptr, _SE(js_new_cc_gfx_Extent)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("width", _SE(js_cc_gfx_Extent_width_get), _SE(js_cc_gfx_Extent_width_set)); 
    cls->defineProperty("height", _SE(js_cc_gfx_Extent_height_get), _SE(js_cc_gfx_Extent_height_set)); 
    cls->defineProperty("depth", _SE(js_cc_gfx_Extent_depth_get), _SE(js_cc_gfx_Extent_depth_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_Extent_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Extent));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Extent>(cls);
    
    __jsb_cc_gfx_Extent_proto = cls->getProto();
    __jsb_cc_gfx_Extent_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_TextureSubresLayers_class = nullptr;
se::Object* __jsb_cc_gfx_TextureSubresLayers_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_TextureSubresLayers) 

static bool js_cc_gfx_TextureSubresLayers_mipLevel_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureSubresLayers *arg1 = (cc::gfx::TextureSubresLayers *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresLayers>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->mipLevel, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureSubresLayers_mipLevel_set) 

static bool js_cc_gfx_TextureSubresLayers_mipLevel_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureSubresLayers *arg1 = (cc::gfx::TextureSubresLayers *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresLayers>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->mipLevel, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureSubresLayers_mipLevel_get) 

static bool js_cc_gfx_TextureSubresLayers_baseArrayLayer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureSubresLayers *arg1 = (cc::gfx::TextureSubresLayers *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresLayers>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->baseArrayLayer, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureSubresLayers_baseArrayLayer_set) 

static bool js_cc_gfx_TextureSubresLayers_baseArrayLayer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureSubresLayers *arg1 = (cc::gfx::TextureSubresLayers *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresLayers>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->baseArrayLayer, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureSubresLayers_baseArrayLayer_get) 

static bool js_cc_gfx_TextureSubresLayers_layerCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureSubresLayers *arg1 = (cc::gfx::TextureSubresLayers *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresLayers>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->layerCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureSubresLayers_layerCount_set) 

static bool js_cc_gfx_TextureSubresLayers_layerCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureSubresLayers *arg1 = (cc::gfx::TextureSubresLayers *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresLayers>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->layerCount, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureSubresLayers_layerCount_get) 

static bool js_cc_gfx_TextureSubresLayers_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureSubresLayers *arg1 = (cc::gfx::TextureSubresLayers *) NULL ;
    cc::gfx::TextureSubresLayers *arg2 = 0 ;
    cc::gfx::TextureSubresLayers temp2 ;
    cc::gfx::TextureSubresLayers *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresLayers>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::TextureSubresLayers *) &(arg1)->copy((cc::gfx::TextureSubresLayers const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_TextureSubresLayers_copy) 

static bool js_new_cc_gfx_TextureSubresLayers(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::TextureSubresLayers *result;
    result = (cc::gfx::TextureSubresLayers *)new cc::gfx::TextureSubresLayers();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_TextureSubresLayers, __jsb_cc_gfx_TextureSubresLayers_class, js_delete_cc_gfx_TextureSubresLayers)

static bool js_delete_cc_gfx_TextureSubresLayers(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_TextureSubresLayers) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::TextureSubresLayers * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::TextureSubresLayers*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("mipLevel", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->mipLevel), ctx);
    }
    
    
    json->getProperty("baseArrayLayer", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->baseArrayLayer), ctx);
    }
    
    
    json->getProperty("layerCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->layerCount), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_TextureSubresLayers(se::Object* obj) {
    auto* cls = se::Class::create("TextureSubresLayers", obj, nullptr, _SE(js_new_cc_gfx_TextureSubresLayers)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("mipLevel", _SE(js_cc_gfx_TextureSubresLayers_mipLevel_get), _SE(js_cc_gfx_TextureSubresLayers_mipLevel_set)); 
    cls->defineProperty("baseArrayLayer", _SE(js_cc_gfx_TextureSubresLayers_baseArrayLayer_get), _SE(js_cc_gfx_TextureSubresLayers_baseArrayLayer_set)); 
    cls->defineProperty("layerCount", _SE(js_cc_gfx_TextureSubresLayers_layerCount_get), _SE(js_cc_gfx_TextureSubresLayers_layerCount_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_TextureSubresLayers_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_TextureSubresLayers));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::TextureSubresLayers>(cls);
    
    __jsb_cc_gfx_TextureSubresLayers_proto = cls->getProto();
    __jsb_cc_gfx_TextureSubresLayers_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_TextureSubresRange_class = nullptr;
se::Object* __jsb_cc_gfx_TextureSubresRange_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_TextureSubresRange) 

static bool js_cc_gfx_TextureSubresRange_baseMipLevel_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureSubresRange *arg1 = (cc::gfx::TextureSubresRange *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresRange>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->baseMipLevel, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureSubresRange_baseMipLevel_set) 

static bool js_cc_gfx_TextureSubresRange_baseMipLevel_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureSubresRange *arg1 = (cc::gfx::TextureSubresRange *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresRange>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->baseMipLevel, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureSubresRange_baseMipLevel_get) 

static bool js_cc_gfx_TextureSubresRange_levelCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureSubresRange *arg1 = (cc::gfx::TextureSubresRange *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresRange>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->levelCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureSubresRange_levelCount_set) 

static bool js_cc_gfx_TextureSubresRange_levelCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureSubresRange *arg1 = (cc::gfx::TextureSubresRange *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresRange>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->levelCount, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureSubresRange_levelCount_get) 

static bool js_cc_gfx_TextureSubresRange_baseArrayLayer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureSubresRange *arg1 = (cc::gfx::TextureSubresRange *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresRange>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->baseArrayLayer, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureSubresRange_baseArrayLayer_set) 

static bool js_cc_gfx_TextureSubresRange_baseArrayLayer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureSubresRange *arg1 = (cc::gfx::TextureSubresRange *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresRange>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->baseArrayLayer, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureSubresRange_baseArrayLayer_get) 

static bool js_cc_gfx_TextureSubresRange_layerCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureSubresRange *arg1 = (cc::gfx::TextureSubresRange *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresRange>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->layerCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureSubresRange_layerCount_set) 

static bool js_cc_gfx_TextureSubresRange_layerCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureSubresRange *arg1 = (cc::gfx::TextureSubresRange *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresRange>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->layerCount, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureSubresRange_layerCount_get) 

static bool js_cc_gfx_TextureSubresRange_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureSubresRange *arg1 = (cc::gfx::TextureSubresRange *) NULL ;
    cc::gfx::TextureSubresRange *arg2 = 0 ;
    cc::gfx::TextureSubresRange temp2 ;
    cc::gfx::TextureSubresRange *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureSubresRange>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::TextureSubresRange *) &(arg1)->copy((cc::gfx::TextureSubresRange const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_TextureSubresRange_copy) 

static bool js_new_cc_gfx_TextureSubresRange(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::TextureSubresRange *result;
    result = (cc::gfx::TextureSubresRange *)new cc::gfx::TextureSubresRange();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_TextureSubresRange, __jsb_cc_gfx_TextureSubresRange_class, js_delete_cc_gfx_TextureSubresRange)

static bool js_delete_cc_gfx_TextureSubresRange(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_TextureSubresRange) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::TextureSubresRange * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::TextureSubresRange*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("baseMipLevel", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->baseMipLevel), ctx);
    }
    
    
    json->getProperty("levelCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->levelCount), ctx);
    }
    
    
    json->getProperty("baseArrayLayer", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->baseArrayLayer), ctx);
    }
    
    
    json->getProperty("layerCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->layerCount), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_TextureSubresRange(se::Object* obj) {
    auto* cls = se::Class::create("TextureSubresRange", obj, nullptr, _SE(js_new_cc_gfx_TextureSubresRange)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("baseMipLevel", _SE(js_cc_gfx_TextureSubresRange_baseMipLevel_get), _SE(js_cc_gfx_TextureSubresRange_baseMipLevel_set)); 
    cls->defineProperty("levelCount", _SE(js_cc_gfx_TextureSubresRange_levelCount_get), _SE(js_cc_gfx_TextureSubresRange_levelCount_set)); 
    cls->defineProperty("baseArrayLayer", _SE(js_cc_gfx_TextureSubresRange_baseArrayLayer_get), _SE(js_cc_gfx_TextureSubresRange_baseArrayLayer_set)); 
    cls->defineProperty("layerCount", _SE(js_cc_gfx_TextureSubresRange_layerCount_get), _SE(js_cc_gfx_TextureSubresRange_layerCount_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_TextureSubresRange_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_TextureSubresRange));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::TextureSubresRange>(cls);
    
    __jsb_cc_gfx_TextureSubresRange_proto = cls->getProto();
    __jsb_cc_gfx_TextureSubresRange_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_TextureCopy_class = nullptr;
se::Object* __jsb_cc_gfx_TextureCopy_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_TextureCopy) 

static bool js_cc_gfx_TextureCopy_srcSubres_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureCopy *arg1 = (cc::gfx::TextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureCopy>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->srcSubres, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureCopy_srcSubres_set) 

static bool js_cc_gfx_TextureCopy_srcSubres_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureCopy *arg1 = (cc::gfx::TextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureCopy>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->srcSubres, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->srcSubres, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureCopy_srcSubres_get) 

static bool js_cc_gfx_TextureCopy_srcOffset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureCopy *arg1 = (cc::gfx::TextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureCopy>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->srcOffset, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureCopy_srcOffset_set) 

static bool js_cc_gfx_TextureCopy_srcOffset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureCopy *arg1 = (cc::gfx::TextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureCopy>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->srcOffset, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->srcOffset, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureCopy_srcOffset_get) 

static bool js_cc_gfx_TextureCopy_dstSubres_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureCopy *arg1 = (cc::gfx::TextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureCopy>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->dstSubres, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureCopy_dstSubres_set) 

static bool js_cc_gfx_TextureCopy_dstSubres_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureCopy *arg1 = (cc::gfx::TextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureCopy>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->dstSubres, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->dstSubres, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureCopy_dstSubres_get) 

static bool js_cc_gfx_TextureCopy_dstOffset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureCopy *arg1 = (cc::gfx::TextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureCopy>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->dstOffset, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureCopy_dstOffset_set) 

static bool js_cc_gfx_TextureCopy_dstOffset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureCopy *arg1 = (cc::gfx::TextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureCopy>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->dstOffset, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->dstOffset, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureCopy_dstOffset_get) 

static bool js_cc_gfx_TextureCopy_extent_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureCopy *arg1 = (cc::gfx::TextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureCopy>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->extent, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureCopy_extent_set) 

static bool js_cc_gfx_TextureCopy_extent_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureCopy *arg1 = (cc::gfx::TextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureCopy>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->extent, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->extent, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureCopy_extent_get) 

static bool js_cc_gfx_TextureCopy_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureCopy *arg1 = (cc::gfx::TextureCopy *) NULL ;
    cc::gfx::TextureCopy *arg2 = 0 ;
    cc::gfx::TextureCopy temp2 ;
    cc::gfx::TextureCopy *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureCopy>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::TextureCopy *) &(arg1)->copy((cc::gfx::TextureCopy const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_TextureCopy_copy) 

static bool js_new_cc_gfx_TextureCopy(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::TextureCopy *result;
    result = (cc::gfx::TextureCopy *)new cc::gfx::TextureCopy();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_TextureCopy, __jsb_cc_gfx_TextureCopy_class, js_delete_cc_gfx_TextureCopy)

static bool js_delete_cc_gfx_TextureCopy(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_TextureCopy) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::TextureCopy * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::TextureCopy*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("srcSubres", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->srcSubres), ctx);
    }
    
    
    json->getProperty("srcOffset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->srcOffset), ctx);
    }
    
    
    json->getProperty("dstSubres", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dstSubres), ctx);
    }
    
    
    json->getProperty("dstOffset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dstOffset), ctx);
    }
    
    
    json->getProperty("extent", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->extent), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_TextureCopy(se::Object* obj) {
    auto* cls = se::Class::create("TextureCopy", obj, nullptr, _SE(js_new_cc_gfx_TextureCopy)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("srcSubres", _SE(js_cc_gfx_TextureCopy_srcSubres_get), _SE(js_cc_gfx_TextureCopy_srcSubres_set)); 
    cls->defineProperty("srcOffset", _SE(js_cc_gfx_TextureCopy_srcOffset_get), _SE(js_cc_gfx_TextureCopy_srcOffset_set)); 
    cls->defineProperty("dstSubres", _SE(js_cc_gfx_TextureCopy_dstSubres_get), _SE(js_cc_gfx_TextureCopy_dstSubres_set)); 
    cls->defineProperty("dstOffset", _SE(js_cc_gfx_TextureCopy_dstOffset_get), _SE(js_cc_gfx_TextureCopy_dstOffset_set)); 
    cls->defineProperty("extent", _SE(js_cc_gfx_TextureCopy_extent_get), _SE(js_cc_gfx_TextureCopy_extent_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_TextureCopy_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_TextureCopy));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::TextureCopy>(cls);
    
    __jsb_cc_gfx_TextureCopy_proto = cls->getProto();
    __jsb_cc_gfx_TextureCopy_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_TextureBlit_class = nullptr;
se::Object* __jsb_cc_gfx_TextureBlit_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_TextureBlit) 

static bool js_cc_gfx_TextureBlit_srcSubres_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBlit *arg1 = (cc::gfx::TextureBlit *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBlit>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->srcSubres, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBlit_srcSubres_set) 

static bool js_cc_gfx_TextureBlit_srcSubres_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBlit *arg1 = (cc::gfx::TextureBlit *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBlit>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->srcSubres, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->srcSubres, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBlit_srcSubres_get) 

static bool js_cc_gfx_TextureBlit_srcOffset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBlit *arg1 = (cc::gfx::TextureBlit *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBlit>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->srcOffset, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBlit_srcOffset_set) 

static bool js_cc_gfx_TextureBlit_srcOffset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBlit *arg1 = (cc::gfx::TextureBlit *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBlit>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->srcOffset, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->srcOffset, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBlit_srcOffset_get) 

static bool js_cc_gfx_TextureBlit_srcExtent_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBlit *arg1 = (cc::gfx::TextureBlit *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBlit>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->srcExtent, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBlit_srcExtent_set) 

static bool js_cc_gfx_TextureBlit_srcExtent_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBlit *arg1 = (cc::gfx::TextureBlit *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBlit>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->srcExtent, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->srcExtent, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBlit_srcExtent_get) 

static bool js_cc_gfx_TextureBlit_dstSubres_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBlit *arg1 = (cc::gfx::TextureBlit *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBlit>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->dstSubres, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBlit_dstSubres_set) 

static bool js_cc_gfx_TextureBlit_dstSubres_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBlit *arg1 = (cc::gfx::TextureBlit *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBlit>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->dstSubres, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->dstSubres, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBlit_dstSubres_get) 

static bool js_cc_gfx_TextureBlit_dstOffset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBlit *arg1 = (cc::gfx::TextureBlit *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBlit>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->dstOffset, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBlit_dstOffset_set) 

static bool js_cc_gfx_TextureBlit_dstOffset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBlit *arg1 = (cc::gfx::TextureBlit *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBlit>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->dstOffset, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->dstOffset, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBlit_dstOffset_get) 

static bool js_cc_gfx_TextureBlit_dstExtent_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBlit *arg1 = (cc::gfx::TextureBlit *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBlit>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->dstExtent, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBlit_dstExtent_set) 

static bool js_cc_gfx_TextureBlit_dstExtent_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBlit *arg1 = (cc::gfx::TextureBlit *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBlit>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->dstExtent, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->dstExtent, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBlit_dstExtent_get) 

static bool js_cc_gfx_TextureBlit_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBlit *arg1 = (cc::gfx::TextureBlit *) NULL ;
    cc::gfx::TextureBlit *arg2 = 0 ;
    cc::gfx::TextureBlit temp2 ;
    cc::gfx::TextureBlit *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBlit>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::TextureBlit *) &(arg1)->copy((cc::gfx::TextureBlit const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_TextureBlit_copy) 

static bool js_new_cc_gfx_TextureBlit(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::TextureBlit *result;
    result = (cc::gfx::TextureBlit *)new cc::gfx::TextureBlit();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_TextureBlit, __jsb_cc_gfx_TextureBlit_class, js_delete_cc_gfx_TextureBlit)

static bool js_delete_cc_gfx_TextureBlit(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_TextureBlit) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::TextureBlit * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::TextureBlit*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("srcSubres", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->srcSubres), ctx);
    }
    
    
    json->getProperty("srcOffset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->srcOffset), ctx);
    }
    
    
    json->getProperty("srcExtent", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->srcExtent), ctx);
    }
    
    
    json->getProperty("dstSubres", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dstSubres), ctx);
    }
    
    
    json->getProperty("dstOffset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dstOffset), ctx);
    }
    
    
    json->getProperty("dstExtent", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dstExtent), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_TextureBlit(se::Object* obj) {
    auto* cls = se::Class::create("TextureBlit", obj, nullptr, _SE(js_new_cc_gfx_TextureBlit)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("srcSubres", _SE(js_cc_gfx_TextureBlit_srcSubres_get), _SE(js_cc_gfx_TextureBlit_srcSubres_set)); 
    cls->defineProperty("srcOffset", _SE(js_cc_gfx_TextureBlit_srcOffset_get), _SE(js_cc_gfx_TextureBlit_srcOffset_set)); 
    cls->defineProperty("srcExtent", _SE(js_cc_gfx_TextureBlit_srcExtent_get), _SE(js_cc_gfx_TextureBlit_srcExtent_set)); 
    cls->defineProperty("dstSubres", _SE(js_cc_gfx_TextureBlit_dstSubres_get), _SE(js_cc_gfx_TextureBlit_dstSubres_set)); 
    cls->defineProperty("dstOffset", _SE(js_cc_gfx_TextureBlit_dstOffset_get), _SE(js_cc_gfx_TextureBlit_dstOffset_set)); 
    cls->defineProperty("dstExtent", _SE(js_cc_gfx_TextureBlit_dstExtent_get), _SE(js_cc_gfx_TextureBlit_dstExtent_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_TextureBlit_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_TextureBlit));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::TextureBlit>(cls);
    
    __jsb_cc_gfx_TextureBlit_proto = cls->getProto();
    __jsb_cc_gfx_TextureBlit_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_BufferTextureCopy_class = nullptr;
se::Object* __jsb_cc_gfx_BufferTextureCopy_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_BufferTextureCopy) 

static bool js_cc_gfx_BufferTextureCopy_buffOffset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferTextureCopy *arg1 = (cc::gfx::BufferTextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferTextureCopy>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->buffOffset, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferTextureCopy_buffOffset_set) 

static bool js_cc_gfx_BufferTextureCopy_buffOffset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferTextureCopy *arg1 = (cc::gfx::BufferTextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferTextureCopy>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->buffOffset, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferTextureCopy_buffOffset_get) 

static bool js_cc_gfx_BufferTextureCopy_buffStride_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferTextureCopy *arg1 = (cc::gfx::BufferTextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferTextureCopy>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->buffStride, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferTextureCopy_buffStride_set) 

static bool js_cc_gfx_BufferTextureCopy_buffStride_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferTextureCopy *arg1 = (cc::gfx::BufferTextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferTextureCopy>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->buffStride, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferTextureCopy_buffStride_get) 

static bool js_cc_gfx_BufferTextureCopy_buffTexHeight_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferTextureCopy *arg1 = (cc::gfx::BufferTextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferTextureCopy>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->buffTexHeight, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferTextureCopy_buffTexHeight_set) 

static bool js_cc_gfx_BufferTextureCopy_buffTexHeight_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferTextureCopy *arg1 = (cc::gfx::BufferTextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferTextureCopy>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->buffTexHeight, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferTextureCopy_buffTexHeight_get) 

static bool js_cc_gfx_BufferTextureCopy_texOffset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferTextureCopy *arg1 = (cc::gfx::BufferTextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferTextureCopy>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->texOffset, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferTextureCopy_texOffset_set) 

static bool js_cc_gfx_BufferTextureCopy_texOffset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferTextureCopy *arg1 = (cc::gfx::BufferTextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferTextureCopy>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->texOffset, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->texOffset, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferTextureCopy_texOffset_get) 

static bool js_cc_gfx_BufferTextureCopy_texExtent_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferTextureCopy *arg1 = (cc::gfx::BufferTextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferTextureCopy>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->texExtent, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferTextureCopy_texExtent_set) 

static bool js_cc_gfx_BufferTextureCopy_texExtent_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferTextureCopy *arg1 = (cc::gfx::BufferTextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferTextureCopy>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->texExtent, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->texExtent, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferTextureCopy_texExtent_get) 

static bool js_cc_gfx_BufferTextureCopy_texSubres_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferTextureCopy *arg1 = (cc::gfx::BufferTextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferTextureCopy>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->texSubres, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferTextureCopy_texSubres_set) 

static bool js_cc_gfx_BufferTextureCopy_texSubres_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferTextureCopy *arg1 = (cc::gfx::BufferTextureCopy *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferTextureCopy>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->texSubres, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->texSubres, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferTextureCopy_texSubres_get) 

static bool js_cc_gfx_BufferTextureCopy_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferTextureCopy *arg1 = (cc::gfx::BufferTextureCopy *) NULL ;
    cc::gfx::BufferTextureCopy *arg2 = 0 ;
    cc::gfx::BufferTextureCopy temp2 ;
    cc::gfx::BufferTextureCopy *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferTextureCopy>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::BufferTextureCopy *) &(arg1)->copy((cc::gfx::BufferTextureCopy const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BufferTextureCopy_copy) 

static bool js_new_cc_gfx_BufferTextureCopy(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::BufferTextureCopy *result;
    result = (cc::gfx::BufferTextureCopy *)new cc::gfx::BufferTextureCopy();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_BufferTextureCopy, __jsb_cc_gfx_BufferTextureCopy_class, js_delete_cc_gfx_BufferTextureCopy)

static bool js_delete_cc_gfx_BufferTextureCopy(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_BufferTextureCopy) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::BufferTextureCopy * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::BufferTextureCopy*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("buffOffset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->buffOffset), ctx);
    }
    
    
    json->getProperty("buffStride", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->buffStride), ctx);
    }
    
    
    json->getProperty("buffTexHeight", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->buffTexHeight), ctx);
    }
    
    
    json->getProperty("texOffset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->texOffset), ctx);
    }
    
    
    json->getProperty("texExtent", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->texExtent), ctx);
    }
    
    
    json->getProperty("texSubres", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->texSubres), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_BufferTextureCopy(se::Object* obj) {
    auto* cls = se::Class::create("BufferTextureCopy", obj, nullptr, _SE(js_new_cc_gfx_BufferTextureCopy)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("buffOffset", _SE(js_cc_gfx_BufferTextureCopy_buffOffset_get), _SE(js_cc_gfx_BufferTextureCopy_buffOffset_set)); 
    cls->defineProperty("buffStride", _SE(js_cc_gfx_BufferTextureCopy_buffStride_get), _SE(js_cc_gfx_BufferTextureCopy_buffStride_set)); 
    cls->defineProperty("buffTexHeight", _SE(js_cc_gfx_BufferTextureCopy_buffTexHeight_get), _SE(js_cc_gfx_BufferTextureCopy_buffTexHeight_set)); 
    cls->defineProperty("texOffset", _SE(js_cc_gfx_BufferTextureCopy_texOffset_get), _SE(js_cc_gfx_BufferTextureCopy_texOffset_set)); 
    cls->defineProperty("texExtent", _SE(js_cc_gfx_BufferTextureCopy_texExtent_get), _SE(js_cc_gfx_BufferTextureCopy_texExtent_set)); 
    cls->defineProperty("texSubres", _SE(js_cc_gfx_BufferTextureCopy_texSubres_get), _SE(js_cc_gfx_BufferTextureCopy_texSubres_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_BufferTextureCopy_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_BufferTextureCopy));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::BufferTextureCopy>(cls);
    
    __jsb_cc_gfx_BufferTextureCopy_proto = cls->getProto();
    __jsb_cc_gfx_BufferTextureCopy_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Viewport_class = nullptr;
se::Object* __jsb_cc_gfx_Viewport_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Viewport) 

static bool js_cc_gfx_Viewport_left_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Viewport *arg1 = (cc::gfx::Viewport *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Viewport>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->left, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Viewport_left_set) 

static bool js_cc_gfx_Viewport_left_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Viewport *arg1 = (cc::gfx::Viewport *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Viewport>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->left, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Viewport_left_get) 

static bool js_cc_gfx_Viewport_top_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Viewport *arg1 = (cc::gfx::Viewport *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Viewport>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->top, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Viewport_top_set) 

static bool js_cc_gfx_Viewport_top_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Viewport *arg1 = (cc::gfx::Viewport *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Viewport>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->top, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Viewport_top_get) 

static bool js_cc_gfx_Viewport_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Viewport *arg1 = (cc::gfx::Viewport *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Viewport>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->width, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Viewport_width_set) 

static bool js_cc_gfx_Viewport_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Viewport *arg1 = (cc::gfx::Viewport *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Viewport>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->width, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Viewport_width_get) 

static bool js_cc_gfx_Viewport_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Viewport *arg1 = (cc::gfx::Viewport *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Viewport>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->height, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Viewport_height_set) 

static bool js_cc_gfx_Viewport_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Viewport *arg1 = (cc::gfx::Viewport *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Viewport>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->height, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Viewport_height_get) 

static bool js_cc_gfx_Viewport_minDepth_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Viewport *arg1 = (cc::gfx::Viewport *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Viewport>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->minDepth, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Viewport_minDepth_set) 

static bool js_cc_gfx_Viewport_minDepth_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Viewport *arg1 = (cc::gfx::Viewport *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Viewport>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->minDepth, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Viewport_minDepth_get) 

static bool js_cc_gfx_Viewport_maxDepth_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Viewport *arg1 = (cc::gfx::Viewport *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Viewport>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxDepth, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Viewport_maxDepth_set) 

static bool js_cc_gfx_Viewport_maxDepth_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Viewport *arg1 = (cc::gfx::Viewport *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Viewport>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxDepth, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Viewport_maxDepth_get) 

static bool js_cc_gfx_Viewport_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Viewport *arg1 = (cc::gfx::Viewport *) NULL ;
    cc::gfx::Viewport *arg2 = 0 ;
    cc::gfx::Viewport temp2 ;
    cc::gfx::Viewport *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Viewport>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::Viewport *) &(arg1)->copy((cc::gfx::Viewport const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Viewport_copy) 

static bool js_new_cc_gfx_Viewport(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::Viewport *result;
    result = (cc::gfx::Viewport *)new cc::gfx::Viewport();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_Viewport, __jsb_cc_gfx_Viewport_class, js_delete_cc_gfx_Viewport)

static bool js_delete_cc_gfx_Viewport(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Viewport) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::Viewport * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::Viewport*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("left", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->left), ctx);
    }
    
    
    json->getProperty("top", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->top), ctx);
    }
    
    
    json->getProperty("width", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->width), ctx);
    }
    
    
    json->getProperty("height", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->height), ctx);
    }
    
    
    json->getProperty("minDepth", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->minDepth), ctx);
    }
    
    
    json->getProperty("maxDepth", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxDepth), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_Viewport(se::Object* obj) {
    auto* cls = se::Class::create("Viewport", obj, nullptr, _SE(js_new_cc_gfx_Viewport)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("left", _SE(js_cc_gfx_Viewport_left_get), _SE(js_cc_gfx_Viewport_left_set)); 
    cls->defineProperty("top", _SE(js_cc_gfx_Viewport_top_get), _SE(js_cc_gfx_Viewport_top_set)); 
    cls->defineProperty("width", _SE(js_cc_gfx_Viewport_width_get), _SE(js_cc_gfx_Viewport_width_set)); 
    cls->defineProperty("height", _SE(js_cc_gfx_Viewport_height_get), _SE(js_cc_gfx_Viewport_height_set)); 
    cls->defineProperty("minDepth", _SE(js_cc_gfx_Viewport_minDepth_get), _SE(js_cc_gfx_Viewport_minDepth_set)); 
    cls->defineProperty("maxDepth", _SE(js_cc_gfx_Viewport_maxDepth_get), _SE(js_cc_gfx_Viewport_maxDepth_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_Viewport_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Viewport));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Viewport>(cls);
    
    __jsb_cc_gfx_Viewport_proto = cls->getProto();
    __jsb_cc_gfx_Viewport_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Color_class = nullptr;
se::Object* __jsb_cc_gfx_Color_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Color) 

static bool js_cc_gfx_Color_x_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Color *arg1 = (cc::gfx::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Color>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->x, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Color_x_set) 

static bool js_cc_gfx_Color_x_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Color *arg1 = (cc::gfx::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Color>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->x, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Color_x_get) 

static bool js_cc_gfx_Color_y_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Color *arg1 = (cc::gfx::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Color>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->y, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Color_y_set) 

static bool js_cc_gfx_Color_y_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Color *arg1 = (cc::gfx::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Color>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->y, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Color_y_get) 

static bool js_cc_gfx_Color_z_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Color *arg1 = (cc::gfx::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Color>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->z, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Color_z_set) 

static bool js_cc_gfx_Color_z_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Color *arg1 = (cc::gfx::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Color>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->z, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Color_z_get) 

static bool js_cc_gfx_Color_w_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Color *arg1 = (cc::gfx::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Color>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->w, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Color_w_set) 

static bool js_cc_gfx_Color_w_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Color *arg1 = (cc::gfx::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Color>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->w, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Color_w_get) 

static bool js_cc_gfx_Color_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Color *arg1 = (cc::gfx::Color *) NULL ;
    cc::gfx::Color *arg2 = 0 ;
    cc::gfx::Color temp2 ;
    cc::gfx::Color *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Color>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::Color *) &(arg1)->copy((cc::gfx::Color const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Color_copy) 

static bool js_new_cc_gfx_Color(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::Color *result;
    result = (cc::gfx::Color *)new cc::gfx::Color();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_Color, __jsb_cc_gfx_Color_class, js_delete_cc_gfx_Color)

static bool js_delete_cc_gfx_Color(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Color) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::Color * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::Color*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("x", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->x), ctx);
    }
    
    
    json->getProperty("y", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->y), ctx);
    }
    
    
    json->getProperty("z", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->z), ctx);
    }
    
    
    json->getProperty("w", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->w), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_Color(se::Object* obj) {
    auto* cls = se::Class::create("Color", obj, nullptr, _SE(js_new_cc_gfx_Color)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("x", _SE(js_cc_gfx_Color_x_get), _SE(js_cc_gfx_Color_x_set)); 
    cls->defineProperty("y", _SE(js_cc_gfx_Color_y_get), _SE(js_cc_gfx_Color_y_set)); 
    cls->defineProperty("z", _SE(js_cc_gfx_Color_z_get), _SE(js_cc_gfx_Color_z_set)); 
    cls->defineProperty("w", _SE(js_cc_gfx_Color_w_get), _SE(js_cc_gfx_Color_w_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_Color_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Color));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Color>(cls);
    
    __jsb_cc_gfx_Color_proto = cls->getProto();
    __jsb_cc_gfx_Color_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_BindingMappingInfo_class = nullptr;
se::Object* __jsb_cc_gfx_BindingMappingInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_BindingMappingInfo) 

static bool js_cc_gfx_BindingMappingInfo_maxBlockCounts_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxBlockCounts, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BindingMappingInfo_maxBlockCounts_set) 

static bool js_cc_gfx_BindingMappingInfo_maxBlockCounts_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxBlockCounts, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxBlockCounts, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BindingMappingInfo_maxBlockCounts_get) 

static bool js_cc_gfx_BindingMappingInfo_maxSamplerTextureCounts_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxSamplerTextureCounts, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BindingMappingInfo_maxSamplerTextureCounts_set) 

static bool js_cc_gfx_BindingMappingInfo_maxSamplerTextureCounts_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxSamplerTextureCounts, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxSamplerTextureCounts, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BindingMappingInfo_maxSamplerTextureCounts_get) 

static bool js_cc_gfx_BindingMappingInfo_maxSamplerCounts_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxSamplerCounts, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BindingMappingInfo_maxSamplerCounts_set) 

static bool js_cc_gfx_BindingMappingInfo_maxSamplerCounts_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxSamplerCounts, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxSamplerCounts, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BindingMappingInfo_maxSamplerCounts_get) 

static bool js_cc_gfx_BindingMappingInfo_maxTextureCounts_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxTextureCounts, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BindingMappingInfo_maxTextureCounts_set) 

static bool js_cc_gfx_BindingMappingInfo_maxTextureCounts_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxTextureCounts, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxTextureCounts, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BindingMappingInfo_maxTextureCounts_get) 

static bool js_cc_gfx_BindingMappingInfo_maxBufferCounts_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxBufferCounts, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BindingMappingInfo_maxBufferCounts_set) 

static bool js_cc_gfx_BindingMappingInfo_maxBufferCounts_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxBufferCounts, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxBufferCounts, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BindingMappingInfo_maxBufferCounts_get) 

static bool js_cc_gfx_BindingMappingInfo_maxImageCounts_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxImageCounts, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BindingMappingInfo_maxImageCounts_set) 

static bool js_cc_gfx_BindingMappingInfo_maxImageCounts_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxImageCounts, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxImageCounts, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BindingMappingInfo_maxImageCounts_get) 

static bool js_cc_gfx_BindingMappingInfo_maxSubpassInputCounts_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxSubpassInputCounts, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BindingMappingInfo_maxSubpassInputCounts_set) 

static bool js_cc_gfx_BindingMappingInfo_maxSubpassInputCounts_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxSubpassInputCounts, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->maxSubpassInputCounts, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BindingMappingInfo_maxSubpassInputCounts_get) 

static bool js_cc_gfx_BindingMappingInfo_setIndices_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->setIndices, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BindingMappingInfo_setIndices_set) 

static bool js_cc_gfx_BindingMappingInfo_setIndices_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->setIndices, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->setIndices, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BindingMappingInfo_setIndices_get) 

static bool js_cc_gfx_BindingMappingInfo_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BindingMappingInfo *arg1 = (cc::gfx::BindingMappingInfo *) NULL ;
    cc::gfx::BindingMappingInfo *arg2 = 0 ;
    cc::gfx::BindingMappingInfo temp2 ;
    cc::gfx::BindingMappingInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::BindingMappingInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::BindingMappingInfo *) &(arg1)->copy((cc::gfx::BindingMappingInfo const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BindingMappingInfo_copy) 

static bool js_new_cc_gfx_BindingMappingInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::BindingMappingInfo *result;
    result = (cc::gfx::BindingMappingInfo *)new cc::gfx::BindingMappingInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_BindingMappingInfo, __jsb_cc_gfx_BindingMappingInfo_class, js_delete_cc_gfx_BindingMappingInfo)

static bool js_delete_cc_gfx_BindingMappingInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_BindingMappingInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::BindingMappingInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::BindingMappingInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("maxBlockCounts", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxBlockCounts), ctx);
    }
    
    
    json->getProperty("maxSamplerTextureCounts", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxSamplerTextureCounts), ctx);
    }
    
    
    json->getProperty("maxSamplerCounts", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxSamplerCounts), ctx);
    }
    
    
    json->getProperty("maxTextureCounts", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxTextureCounts), ctx);
    }
    
    
    json->getProperty("maxBufferCounts", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxBufferCounts), ctx);
    }
    
    
    json->getProperty("maxImageCounts", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxImageCounts), ctx);
    }
    
    
    json->getProperty("maxSubpassInputCounts", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxSubpassInputCounts), ctx);
    }
    
    
    json->getProperty("setIndices", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->setIndices), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_BindingMappingInfo(se::Object* obj) {
    auto* cls = se::Class::create("BindingMappingInfo", obj, nullptr, _SE(js_new_cc_gfx_BindingMappingInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("maxBlockCounts", _SE(js_cc_gfx_BindingMappingInfo_maxBlockCounts_get), _SE(js_cc_gfx_BindingMappingInfo_maxBlockCounts_set)); 
    cls->defineProperty("maxSamplerTextureCounts", _SE(js_cc_gfx_BindingMappingInfo_maxSamplerTextureCounts_get), _SE(js_cc_gfx_BindingMappingInfo_maxSamplerTextureCounts_set)); 
    cls->defineProperty("maxSamplerCounts", _SE(js_cc_gfx_BindingMappingInfo_maxSamplerCounts_get), _SE(js_cc_gfx_BindingMappingInfo_maxSamplerCounts_set)); 
    cls->defineProperty("maxTextureCounts", _SE(js_cc_gfx_BindingMappingInfo_maxTextureCounts_get), _SE(js_cc_gfx_BindingMappingInfo_maxTextureCounts_set)); 
    cls->defineProperty("maxBufferCounts", _SE(js_cc_gfx_BindingMappingInfo_maxBufferCounts_get), _SE(js_cc_gfx_BindingMappingInfo_maxBufferCounts_set)); 
    cls->defineProperty("maxImageCounts", _SE(js_cc_gfx_BindingMappingInfo_maxImageCounts_get), _SE(js_cc_gfx_BindingMappingInfo_maxImageCounts_set)); 
    cls->defineProperty("maxSubpassInputCounts", _SE(js_cc_gfx_BindingMappingInfo_maxSubpassInputCounts_get), _SE(js_cc_gfx_BindingMappingInfo_maxSubpassInputCounts_set)); 
    cls->defineProperty("setIndices", _SE(js_cc_gfx_BindingMappingInfo_setIndices_get), _SE(js_cc_gfx_BindingMappingInfo_setIndices_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_BindingMappingInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_BindingMappingInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::BindingMappingInfo>(cls);
    
    __jsb_cc_gfx_BindingMappingInfo_proto = cls->getProto();
    __jsb_cc_gfx_BindingMappingInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_SwapchainInfo_class = nullptr;
se::Object* __jsb_cc_gfx_SwapchainInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_SwapchainInfo) 

static bool js_cc_gfx_SwapchainInfo_windowId_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SwapchainInfo *arg1 = (cc::gfx::SwapchainInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SwapchainInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->windowId, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SwapchainInfo_windowId_set) 

static bool js_cc_gfx_SwapchainInfo_windowId_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SwapchainInfo *arg1 = (cc::gfx::SwapchainInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SwapchainInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->windowId, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SwapchainInfo_windowId_get) 

static bool js_cc_gfx_SwapchainInfo_windowHandle_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SwapchainInfo *arg1 = (cc::gfx::SwapchainInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SwapchainInfo>(s);
    if (nullptr == arg1) return true;
    ok &= sevalue_to_native(args[0], &arg1->windowHandle);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SwapchainInfo_windowHandle_set) 

static bool js_cc_gfx_SwapchainInfo_windowHandle_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SwapchainInfo *arg1 = (cc::gfx::SwapchainInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SwapchainInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->windowHandle, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->windowHandle, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SwapchainInfo_windowHandle_get) 

static bool js_cc_gfx_SwapchainInfo_vsyncMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SwapchainInfo *arg1 = (cc::gfx::SwapchainInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SwapchainInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->vsyncMode, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SwapchainInfo_vsyncMode_set) 

static bool js_cc_gfx_SwapchainInfo_vsyncMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SwapchainInfo *arg1 = (cc::gfx::SwapchainInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SwapchainInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->vsyncMode, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->vsyncMode, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SwapchainInfo_vsyncMode_get) 

static bool js_cc_gfx_SwapchainInfo_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SwapchainInfo *arg1 = (cc::gfx::SwapchainInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SwapchainInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->width, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SwapchainInfo_width_set) 

static bool js_cc_gfx_SwapchainInfo_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SwapchainInfo *arg1 = (cc::gfx::SwapchainInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SwapchainInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->width, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SwapchainInfo_width_get) 

static bool js_cc_gfx_SwapchainInfo_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SwapchainInfo *arg1 = (cc::gfx::SwapchainInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SwapchainInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->height, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SwapchainInfo_height_set) 

static bool js_cc_gfx_SwapchainInfo_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SwapchainInfo *arg1 = (cc::gfx::SwapchainInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SwapchainInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->height, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SwapchainInfo_height_get) 

static bool js_cc_gfx_SwapchainInfo_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SwapchainInfo *arg1 = (cc::gfx::SwapchainInfo *) NULL ;
    cc::gfx::SwapchainInfo *arg2 = 0 ;
    cc::gfx::SwapchainInfo temp2 ;
    cc::gfx::SwapchainInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::SwapchainInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::SwapchainInfo *) &(arg1)->copy((cc::gfx::SwapchainInfo const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_SwapchainInfo_copy) 

static bool js_new_cc_gfx_SwapchainInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::SwapchainInfo *result;
    result = (cc::gfx::SwapchainInfo *)new cc::gfx::SwapchainInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_SwapchainInfo, __jsb_cc_gfx_SwapchainInfo_class, js_delete_cc_gfx_SwapchainInfo)

static bool js_delete_cc_gfx_SwapchainInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_SwapchainInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::SwapchainInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::SwapchainInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("windowId", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->windowId), ctx);
    }
    
    
    json->getProperty("windowHandle", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->windowHandle), ctx);
    }
    
    
    json->getProperty("vsyncMode", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->vsyncMode), ctx);
    }
    
    
    json->getProperty("width", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->width), ctx);
    }
    
    
    json->getProperty("height", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->height), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_SwapchainInfo(se::Object* obj) {
    auto* cls = se::Class::create("SwapchainInfo", obj, nullptr, _SE(js_new_cc_gfx_SwapchainInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("windowId", _SE(js_cc_gfx_SwapchainInfo_windowId_get), _SE(js_cc_gfx_SwapchainInfo_windowId_set)); 
    cls->defineProperty("windowHandle", _SE(js_cc_gfx_SwapchainInfo_windowHandle_get), _SE(js_cc_gfx_SwapchainInfo_windowHandle_set)); 
    cls->defineProperty("vsyncMode", _SE(js_cc_gfx_SwapchainInfo_vsyncMode_get), _SE(js_cc_gfx_SwapchainInfo_vsyncMode_set)); 
    cls->defineProperty("width", _SE(js_cc_gfx_SwapchainInfo_width_get), _SE(js_cc_gfx_SwapchainInfo_width_set)); 
    cls->defineProperty("height", _SE(js_cc_gfx_SwapchainInfo_height_get), _SE(js_cc_gfx_SwapchainInfo_height_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_SwapchainInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_SwapchainInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::SwapchainInfo>(cls);
    
    __jsb_cc_gfx_SwapchainInfo_proto = cls->getProto();
    __jsb_cc_gfx_SwapchainInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DeviceInfo_class = nullptr;
se::Object* __jsb_cc_gfx_DeviceInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DeviceInfo) 

static bool js_cc_gfx_DeviceInfo_bindingMappingInfo_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceInfo *arg1 = (cc::gfx::DeviceInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->bindingMappingInfo, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DeviceInfo_bindingMappingInfo_set) 

static bool js_cc_gfx_DeviceInfo_bindingMappingInfo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DeviceInfo *arg1 = (cc::gfx::DeviceInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->bindingMappingInfo, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->bindingMappingInfo, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DeviceInfo_bindingMappingInfo_get) 

static bool js_cc_gfx_DeviceInfo_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DeviceInfo *arg1 = (cc::gfx::DeviceInfo *) NULL ;
    cc::gfx::DeviceInfo *arg2 = 0 ;
    cc::gfx::DeviceInfo temp2 ;
    cc::gfx::DeviceInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DeviceInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::DeviceInfo *) &(arg1)->copy((cc::gfx::DeviceInfo const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DeviceInfo_copy) 

static bool js_new_cc_gfx_DeviceInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::DeviceInfo *result;
    result = (cc::gfx::DeviceInfo *)new cc::gfx::DeviceInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_DeviceInfo, __jsb_cc_gfx_DeviceInfo_class, js_delete_cc_gfx_DeviceInfo)

static bool js_delete_cc_gfx_DeviceInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DeviceInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::DeviceInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::DeviceInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("bindingMappingInfo", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->bindingMappingInfo), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_DeviceInfo(se::Object* obj) {
    auto* cls = se::Class::create("DeviceInfo", obj, nullptr, _SE(js_new_cc_gfx_DeviceInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("bindingMappingInfo", _SE(js_cc_gfx_DeviceInfo_bindingMappingInfo_get), _SE(js_cc_gfx_DeviceInfo_bindingMappingInfo_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_DeviceInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DeviceInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DeviceInfo>(cls);
    
    __jsb_cc_gfx_DeviceInfo_proto = cls->getProto();
    __jsb_cc_gfx_DeviceInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_BufferInfo_class = nullptr;
se::Object* __jsb_cc_gfx_BufferInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_BufferInfo) 

static bool js_cc_gfx_BufferInfo_usage_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferInfo *arg1 = (cc::gfx::BufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->usage, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferInfo_usage_set) 

static bool js_cc_gfx_BufferInfo_usage_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferInfo *arg1 = (cc::gfx::BufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->usage, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->usage, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferInfo_usage_get) 

static bool js_cc_gfx_BufferInfo_memUsage_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferInfo *arg1 = (cc::gfx::BufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->memUsage, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferInfo_memUsage_set) 

static bool js_cc_gfx_BufferInfo_memUsage_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferInfo *arg1 = (cc::gfx::BufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->memUsage, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->memUsage, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferInfo_memUsage_get) 

static bool js_cc_gfx_BufferInfo_size_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferInfo *arg1 = (cc::gfx::BufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->size, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferInfo_size_set) 

static bool js_cc_gfx_BufferInfo_size_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferInfo *arg1 = (cc::gfx::BufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->size, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferInfo_size_get) 

static bool js_cc_gfx_BufferInfo_stride_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferInfo *arg1 = (cc::gfx::BufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stride, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferInfo_stride_set) 

static bool js_cc_gfx_BufferInfo_stride_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferInfo *arg1 = (cc::gfx::BufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stride, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferInfo_stride_get) 

static bool js_cc_gfx_BufferInfo_flags_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferInfo *arg1 = (cc::gfx::BufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->flags, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferInfo_flags_set) 

static bool js_cc_gfx_BufferInfo_flags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferInfo *arg1 = (cc::gfx::BufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->flags, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->flags, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferInfo_flags_get) 

static bool js_cc_gfx_BufferInfo_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferInfo *arg1 = (cc::gfx::BufferInfo *) NULL ;
    cc::gfx::BufferInfo *arg2 = 0 ;
    cc::gfx::BufferInfo temp2 ;
    cc::gfx::BufferInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::BufferInfo *) &(arg1)->copy((cc::gfx::BufferInfo const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BufferInfo_copy) 

static bool js_new_cc_gfx_BufferInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::BufferInfo *result;
    result = (cc::gfx::BufferInfo *)new cc::gfx::BufferInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_BufferInfo, __jsb_cc_gfx_BufferInfo_class, js_delete_cc_gfx_BufferInfo)

static bool js_delete_cc_gfx_BufferInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_BufferInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::BufferInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::BufferInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("usage", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->usage), ctx);
    }
    
    
    json->getProperty("memUsage", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->memUsage), ctx);
    }
    
    
    json->getProperty("size", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->size), ctx);
    }
    
    
    json->getProperty("stride", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stride), ctx);
    }
    
    
    json->getProperty("flags", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->flags), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_BufferInfo(se::Object* obj) {
    auto* cls = se::Class::create("BufferInfo", obj, nullptr, _SE(js_new_cc_gfx_BufferInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("usage", _SE(js_cc_gfx_BufferInfo_usage_get), _SE(js_cc_gfx_BufferInfo_usage_set)); 
    cls->defineProperty("memUsage", _SE(js_cc_gfx_BufferInfo_memUsage_get), _SE(js_cc_gfx_BufferInfo_memUsage_set)); 
    cls->defineProperty("size", _SE(js_cc_gfx_BufferInfo_size_get), _SE(js_cc_gfx_BufferInfo_size_set)); 
    cls->defineProperty("stride", _SE(js_cc_gfx_BufferInfo_stride_get), _SE(js_cc_gfx_BufferInfo_stride_set)); 
    cls->defineProperty("flags", _SE(js_cc_gfx_BufferInfo_flags_get), _SE(js_cc_gfx_BufferInfo_flags_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_BufferInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_BufferInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::BufferInfo>(cls);
    
    __jsb_cc_gfx_BufferInfo_proto = cls->getProto();
    __jsb_cc_gfx_BufferInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_BufferViewInfo_class = nullptr;
se::Object* __jsb_cc_gfx_BufferViewInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_BufferViewInfo) 

static bool js_cc_gfx_BufferViewInfo_buffer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferViewInfo *arg1 = (cc::gfx::BufferViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferViewInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->buffer, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferViewInfo_buffer_set) 

static bool js_cc_gfx_BufferViewInfo_buffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferViewInfo *arg1 = (cc::gfx::BufferViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferViewInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->buffer, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->buffer, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferViewInfo_buffer_get) 

static bool js_cc_gfx_BufferViewInfo_offset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferViewInfo *arg1 = (cc::gfx::BufferViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferViewInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->offset, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferViewInfo_offset_set) 

static bool js_cc_gfx_BufferViewInfo_offset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferViewInfo *arg1 = (cc::gfx::BufferViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferViewInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->offset, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferViewInfo_offset_get) 

static bool js_cc_gfx_BufferViewInfo_range_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferViewInfo *arg1 = (cc::gfx::BufferViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferViewInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->range, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferViewInfo_range_set) 

static bool js_cc_gfx_BufferViewInfo_range_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferViewInfo *arg1 = (cc::gfx::BufferViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferViewInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->range, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferViewInfo_range_get) 

static bool js_cc_gfx_BufferViewInfo_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferViewInfo *arg1 = (cc::gfx::BufferViewInfo *) NULL ;
    cc::gfx::BufferViewInfo *arg2 = 0 ;
    cc::gfx::BufferViewInfo temp2 ;
    cc::gfx::BufferViewInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferViewInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::BufferViewInfo *) &(arg1)->copy((cc::gfx::BufferViewInfo const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BufferViewInfo_copy) 

static bool js_new_cc_gfx_BufferViewInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::BufferViewInfo *result;
    result = (cc::gfx::BufferViewInfo *)new cc::gfx::BufferViewInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_BufferViewInfo, __jsb_cc_gfx_BufferViewInfo_class, js_delete_cc_gfx_BufferViewInfo)

static bool js_delete_cc_gfx_BufferViewInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_BufferViewInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::BufferViewInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::BufferViewInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("buffer", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->buffer), ctx);
    }
    
    
    json->getProperty("offset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->offset), ctx);
    }
    
    
    json->getProperty("range", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->range), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_BufferViewInfo(se::Object* obj) {
    auto* cls = se::Class::create("BufferViewInfo", obj, nullptr, _SE(js_new_cc_gfx_BufferViewInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("buffer", _SE(js_cc_gfx_BufferViewInfo_buffer_get), _SE(js_cc_gfx_BufferViewInfo_buffer_set)); 
    cls->defineProperty("offset", _SE(js_cc_gfx_BufferViewInfo_offset_get), _SE(js_cc_gfx_BufferViewInfo_offset_set)); 
    cls->defineProperty("range", _SE(js_cc_gfx_BufferViewInfo_range_get), _SE(js_cc_gfx_BufferViewInfo_range_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_BufferViewInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_BufferViewInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::BufferViewInfo>(cls);
    
    __jsb_cc_gfx_BufferViewInfo_proto = cls->getProto();
    __jsb_cc_gfx_BufferViewInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DrawInfo_class = nullptr;
se::Object* __jsb_cc_gfx_DrawInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DrawInfo) 

static bool js_cc_gfx_DrawInfo_vertexCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->vertexCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DrawInfo_vertexCount_set) 

static bool js_cc_gfx_DrawInfo_vertexCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->vertexCount, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DrawInfo_vertexCount_get) 

static bool js_cc_gfx_DrawInfo_firstVertex_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->firstVertex, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DrawInfo_firstVertex_set) 

static bool js_cc_gfx_DrawInfo_firstVertex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->firstVertex, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DrawInfo_firstVertex_get) 

static bool js_cc_gfx_DrawInfo_indexCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->indexCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DrawInfo_indexCount_set) 

static bool js_cc_gfx_DrawInfo_indexCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->indexCount, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DrawInfo_indexCount_get) 

static bool js_cc_gfx_DrawInfo_firstIndex_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->firstIndex, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DrawInfo_firstIndex_set) 

static bool js_cc_gfx_DrawInfo_firstIndex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->firstIndex, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DrawInfo_firstIndex_get) 

static bool js_cc_gfx_DrawInfo_vertexOffset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->vertexOffset, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DrawInfo_vertexOffset_set) 

static bool js_cc_gfx_DrawInfo_vertexOffset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->vertexOffset, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DrawInfo_vertexOffset_get) 

static bool js_cc_gfx_DrawInfo_instanceCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->instanceCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DrawInfo_instanceCount_set) 

static bool js_cc_gfx_DrawInfo_instanceCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->instanceCount, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DrawInfo_instanceCount_get) 

static bool js_cc_gfx_DrawInfo_firstInstance_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->firstInstance, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DrawInfo_firstInstance_set) 

static bool js_cc_gfx_DrawInfo_firstInstance_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->firstInstance, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DrawInfo_firstInstance_get) 

static bool js_cc_gfx_DrawInfo_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DrawInfo *arg1 = (cc::gfx::DrawInfo *) NULL ;
    cc::gfx::DrawInfo *arg2 = 0 ;
    cc::gfx::DrawInfo temp2 ;
    cc::gfx::DrawInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::DrawInfo *) &(arg1)->copy((cc::gfx::DrawInfo const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DrawInfo_copy) 

static bool js_new_cc_gfx_DrawInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::DrawInfo *result;
    result = (cc::gfx::DrawInfo *)new cc::gfx::DrawInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_DrawInfo, __jsb_cc_gfx_DrawInfo_class, js_delete_cc_gfx_DrawInfo)

static bool js_delete_cc_gfx_DrawInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DrawInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::DrawInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::DrawInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("vertexCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->vertexCount), ctx);
    }
    
    
    json->getProperty("firstVertex", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->firstVertex), ctx);
    }
    
    
    json->getProperty("indexCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->indexCount), ctx);
    }
    
    
    json->getProperty("firstIndex", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->firstIndex), ctx);
    }
    
    
    json->getProperty("vertexOffset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->vertexOffset), ctx);
    }
    
    
    json->getProperty("instanceCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->instanceCount), ctx);
    }
    
    
    json->getProperty("firstInstance", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->firstInstance), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_DrawInfo(se::Object* obj) {
    auto* cls = se::Class::create("DrawInfo", obj, nullptr, _SE(js_new_cc_gfx_DrawInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("vertexCount", _SE(js_cc_gfx_DrawInfo_vertexCount_get), _SE(js_cc_gfx_DrawInfo_vertexCount_set)); 
    cls->defineProperty("firstVertex", _SE(js_cc_gfx_DrawInfo_firstVertex_get), _SE(js_cc_gfx_DrawInfo_firstVertex_set)); 
    cls->defineProperty("indexCount", _SE(js_cc_gfx_DrawInfo_indexCount_get), _SE(js_cc_gfx_DrawInfo_indexCount_set)); 
    cls->defineProperty("firstIndex", _SE(js_cc_gfx_DrawInfo_firstIndex_get), _SE(js_cc_gfx_DrawInfo_firstIndex_set)); 
    cls->defineProperty("vertexOffset", _SE(js_cc_gfx_DrawInfo_vertexOffset_get), _SE(js_cc_gfx_DrawInfo_vertexOffset_set)); 
    cls->defineProperty("instanceCount", _SE(js_cc_gfx_DrawInfo_instanceCount_get), _SE(js_cc_gfx_DrawInfo_instanceCount_set)); 
    cls->defineProperty("firstInstance", _SE(js_cc_gfx_DrawInfo_firstInstance_get), _SE(js_cc_gfx_DrawInfo_firstInstance_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_DrawInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DrawInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DrawInfo>(cls);
    
    __jsb_cc_gfx_DrawInfo_proto = cls->getProto();
    __jsb_cc_gfx_DrawInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DispatchInfo_class = nullptr;
se::Object* __jsb_cc_gfx_DispatchInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DispatchInfo) 

static bool js_cc_gfx_DispatchInfo_groupCountX_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DispatchInfo *arg1 = (cc::gfx::DispatchInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DispatchInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->groupCountX, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DispatchInfo_groupCountX_set) 

static bool js_cc_gfx_DispatchInfo_groupCountX_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DispatchInfo *arg1 = (cc::gfx::DispatchInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DispatchInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->groupCountX, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DispatchInfo_groupCountX_get) 

static bool js_cc_gfx_DispatchInfo_groupCountY_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DispatchInfo *arg1 = (cc::gfx::DispatchInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DispatchInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->groupCountY, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DispatchInfo_groupCountY_set) 

static bool js_cc_gfx_DispatchInfo_groupCountY_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DispatchInfo *arg1 = (cc::gfx::DispatchInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DispatchInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->groupCountY, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DispatchInfo_groupCountY_get) 

static bool js_cc_gfx_DispatchInfo_groupCountZ_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DispatchInfo *arg1 = (cc::gfx::DispatchInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DispatchInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->groupCountZ, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DispatchInfo_groupCountZ_set) 

static bool js_cc_gfx_DispatchInfo_groupCountZ_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DispatchInfo *arg1 = (cc::gfx::DispatchInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DispatchInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->groupCountZ, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DispatchInfo_groupCountZ_get) 

static bool js_cc_gfx_DispatchInfo_indirectBuffer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DispatchInfo *arg1 = (cc::gfx::DispatchInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DispatchInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->indirectBuffer, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DispatchInfo_indirectBuffer_set) 

static bool js_cc_gfx_DispatchInfo_indirectBuffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DispatchInfo *arg1 = (cc::gfx::DispatchInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DispatchInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->indirectBuffer, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->indirectBuffer, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DispatchInfo_indirectBuffer_get) 

static bool js_cc_gfx_DispatchInfo_indirectOffset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DispatchInfo *arg1 = (cc::gfx::DispatchInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DispatchInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->indirectOffset, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DispatchInfo_indirectOffset_set) 

static bool js_cc_gfx_DispatchInfo_indirectOffset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DispatchInfo *arg1 = (cc::gfx::DispatchInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DispatchInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->indirectOffset, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DispatchInfo_indirectOffset_get) 

static bool js_cc_gfx_DispatchInfo_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DispatchInfo *arg1 = (cc::gfx::DispatchInfo *) NULL ;
    cc::gfx::DispatchInfo *arg2 = 0 ;
    cc::gfx::DispatchInfo temp2 ;
    cc::gfx::DispatchInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DispatchInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::DispatchInfo *) &(arg1)->copy((cc::gfx::DispatchInfo const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DispatchInfo_copy) 

static bool js_new_cc_gfx_DispatchInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::DispatchInfo *result;
    result = (cc::gfx::DispatchInfo *)new cc::gfx::DispatchInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_DispatchInfo, __jsb_cc_gfx_DispatchInfo_class, js_delete_cc_gfx_DispatchInfo)

static bool js_delete_cc_gfx_DispatchInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DispatchInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::DispatchInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::DispatchInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("groupCountX", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->groupCountX), ctx);
    }
    
    
    json->getProperty("groupCountY", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->groupCountY), ctx);
    }
    
    
    json->getProperty("groupCountZ", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->groupCountZ), ctx);
    }
    
    
    json->getProperty("indirectBuffer", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->indirectBuffer), ctx);
    }
    
    
    json->getProperty("indirectOffset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->indirectOffset), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_DispatchInfo(se::Object* obj) {
    auto* cls = se::Class::create("DispatchInfo", obj, nullptr, _SE(js_new_cc_gfx_DispatchInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("groupCountX", _SE(js_cc_gfx_DispatchInfo_groupCountX_get), _SE(js_cc_gfx_DispatchInfo_groupCountX_set)); 
    cls->defineProperty("groupCountY", _SE(js_cc_gfx_DispatchInfo_groupCountY_get), _SE(js_cc_gfx_DispatchInfo_groupCountY_set)); 
    cls->defineProperty("groupCountZ", _SE(js_cc_gfx_DispatchInfo_groupCountZ_get), _SE(js_cc_gfx_DispatchInfo_groupCountZ_set)); 
    cls->defineProperty("indirectBuffer", _SE(js_cc_gfx_DispatchInfo_indirectBuffer_get), _SE(js_cc_gfx_DispatchInfo_indirectBuffer_set)); 
    cls->defineProperty("indirectOffset", _SE(js_cc_gfx_DispatchInfo_indirectOffset_get), _SE(js_cc_gfx_DispatchInfo_indirectOffset_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_DispatchInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DispatchInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DispatchInfo>(cls);
    
    __jsb_cc_gfx_DispatchInfo_proto = cls->getProto();
    __jsb_cc_gfx_DispatchInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_IndirectBuffer_class = nullptr;
se::Object* __jsb_cc_gfx_IndirectBuffer_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_IndirectBuffer) 

static bool js_cc_gfx_IndirectBuffer_drawInfos_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::IndirectBuffer *arg1 = (cc::gfx::IndirectBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::IndirectBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->drawInfos, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_IndirectBuffer_drawInfos_set) 

static bool js_cc_gfx_IndirectBuffer_drawInfos_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::IndirectBuffer *arg1 = (cc::gfx::IndirectBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::IndirectBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->drawInfos, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->drawInfos, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_IndirectBuffer_drawInfos_get) 

static bool js_cc_gfx_IndirectBuffer_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::IndirectBuffer *arg1 = (cc::gfx::IndirectBuffer *) NULL ;
    cc::gfx::IndirectBuffer *arg2 = 0 ;
    cc::gfx::IndirectBuffer temp2 ;
    cc::gfx::IndirectBuffer *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::IndirectBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::IndirectBuffer *) &(arg1)->copy((cc::gfx::IndirectBuffer const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_IndirectBuffer_copy) 

static bool js_new_cc_gfx_IndirectBuffer(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::IndirectBuffer *result;
    result = (cc::gfx::IndirectBuffer *)new cc::gfx::IndirectBuffer();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_IndirectBuffer, __jsb_cc_gfx_IndirectBuffer_class, js_delete_cc_gfx_IndirectBuffer)

static bool js_delete_cc_gfx_IndirectBuffer(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_IndirectBuffer) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::IndirectBuffer * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::IndirectBuffer*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("drawInfos", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->drawInfos), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_IndirectBuffer(se::Object* obj) {
    auto* cls = se::Class::create("IndirectBuffer", obj, nullptr, _SE(js_new_cc_gfx_IndirectBuffer)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("drawInfos", _SE(js_cc_gfx_IndirectBuffer_drawInfos_get), _SE(js_cc_gfx_IndirectBuffer_drawInfos_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_IndirectBuffer_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_IndirectBuffer));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::IndirectBuffer>(cls);
    
    __jsb_cc_gfx_IndirectBuffer_proto = cls->getProto();
    __jsb_cc_gfx_IndirectBuffer_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_TextureInfo_class = nullptr;
se::Object* __jsb_cc_gfx_TextureInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_TextureInfo) 

static bool js_cc_gfx_TextureInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->type, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureInfo_type_set) 

static bool js_cc_gfx_TextureInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->type, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->type, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureInfo_type_get) 

static bool js_cc_gfx_TextureInfo_usage_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->usage, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureInfo_usage_set) 

static bool js_cc_gfx_TextureInfo_usage_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->usage, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->usage, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureInfo_usage_get) 

static bool js_cc_gfx_TextureInfo_format_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->format, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureInfo_format_set) 

static bool js_cc_gfx_TextureInfo_format_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->format, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->format, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureInfo_format_get) 

static bool js_cc_gfx_TextureInfo_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->width, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureInfo_width_set) 

static bool js_cc_gfx_TextureInfo_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->width, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureInfo_width_get) 

static bool js_cc_gfx_TextureInfo_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->height, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureInfo_height_set) 

static bool js_cc_gfx_TextureInfo_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->height, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureInfo_height_get) 

static bool js_cc_gfx_TextureInfo_flags_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->flags, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureInfo_flags_set) 

static bool js_cc_gfx_TextureInfo_flags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->flags, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->flags, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureInfo_flags_get) 

static bool js_cc_gfx_TextureInfo_layerCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->layerCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureInfo_layerCount_set) 

static bool js_cc_gfx_TextureInfo_layerCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->layerCount, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureInfo_layerCount_get) 

static bool js_cc_gfx_TextureInfo_levelCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->levelCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureInfo_levelCount_set) 

static bool js_cc_gfx_TextureInfo_levelCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->levelCount, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureInfo_levelCount_get) 

static bool js_cc_gfx_TextureInfo_samples_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->samples, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureInfo_samples_set) 

static bool js_cc_gfx_TextureInfo_samples_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->samples, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->samples, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureInfo_samples_get) 

static bool js_cc_gfx_TextureInfo_depth_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depth, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureInfo_depth_set) 

static bool js_cc_gfx_TextureInfo_depth_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depth, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureInfo_depth_get) 

static bool js_cc_gfx_TextureInfo_externalRes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    if (nullptr == arg1) return true;
    ok &= sevalue_to_native(args[0], &arg1->externalRes);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureInfo_externalRes_set) 

static bool js_cc_gfx_TextureInfo_externalRes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->externalRes, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->externalRes, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureInfo_externalRes_get) 

static bool js_cc_gfx_TextureInfo_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureInfo *arg1 = (cc::gfx::TextureInfo *) NULL ;
    cc::gfx::TextureInfo *arg2 = 0 ;
    cc::gfx::TextureInfo temp2 ;
    cc::gfx::TextureInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::TextureInfo *) &(arg1)->copy((cc::gfx::TextureInfo const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_TextureInfo_copy) 

static bool js_new_cc_gfx_TextureInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::TextureInfo *result;
    result = (cc::gfx::TextureInfo *)new cc::gfx::TextureInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_TextureInfo, __jsb_cc_gfx_TextureInfo_class, js_delete_cc_gfx_TextureInfo)

static bool js_delete_cc_gfx_TextureInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_TextureInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::TextureInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::TextureInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("usage", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->usage), ctx);
    }
    
    
    json->getProperty("format", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->format), ctx);
    }
    
    
    json->getProperty("width", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->width), ctx);
    }
    
    
    json->getProperty("height", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->height), ctx);
    }
    
    
    json->getProperty("flags", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->flags), ctx);
    }
    
    
    json->getProperty("layerCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->layerCount), ctx);
    }
    
    
    json->getProperty("levelCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->levelCount), ctx);
    }
    
    
    json->getProperty("samples", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->samples), ctx);
    }
    
    
    json->getProperty("depth", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depth), ctx);
    }
    
    
    json->getProperty("externalRes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->externalRes), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_TextureInfo(se::Object* obj) {
    auto* cls = se::Class::create("TextureInfo", obj, nullptr, _SE(js_new_cc_gfx_TextureInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("type", _SE(js_cc_gfx_TextureInfo_type_get), _SE(js_cc_gfx_TextureInfo_type_set)); 
    cls->defineProperty("usage", _SE(js_cc_gfx_TextureInfo_usage_get), _SE(js_cc_gfx_TextureInfo_usage_set)); 
    cls->defineProperty("format", _SE(js_cc_gfx_TextureInfo_format_get), _SE(js_cc_gfx_TextureInfo_format_set)); 
    cls->defineProperty("width", _SE(js_cc_gfx_TextureInfo_width_get), _SE(js_cc_gfx_TextureInfo_width_set)); 
    cls->defineProperty("height", _SE(js_cc_gfx_TextureInfo_height_get), _SE(js_cc_gfx_TextureInfo_height_set)); 
    cls->defineProperty("flags", _SE(js_cc_gfx_TextureInfo_flags_get), _SE(js_cc_gfx_TextureInfo_flags_set)); 
    cls->defineProperty("layerCount", _SE(js_cc_gfx_TextureInfo_layerCount_get), _SE(js_cc_gfx_TextureInfo_layerCount_set)); 
    cls->defineProperty("levelCount", _SE(js_cc_gfx_TextureInfo_levelCount_get), _SE(js_cc_gfx_TextureInfo_levelCount_set)); 
    cls->defineProperty("samples", _SE(js_cc_gfx_TextureInfo_samples_get), _SE(js_cc_gfx_TextureInfo_samples_set)); 
    cls->defineProperty("depth", _SE(js_cc_gfx_TextureInfo_depth_get), _SE(js_cc_gfx_TextureInfo_depth_set)); 
    cls->defineProperty("externalRes", _SE(js_cc_gfx_TextureInfo_externalRes_get), _SE(js_cc_gfx_TextureInfo_externalRes_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_TextureInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_TextureInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::TextureInfo>(cls);
    
    __jsb_cc_gfx_TextureInfo_proto = cls->getProto();
    __jsb_cc_gfx_TextureInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_TextureViewInfo_class = nullptr;
se::Object* __jsb_cc_gfx_TextureViewInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_TextureViewInfo) 

static bool js_cc_gfx_TextureViewInfo_texture_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->texture, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureViewInfo_texture_set) 

static bool js_cc_gfx_TextureViewInfo_texture_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->texture, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->texture, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureViewInfo_texture_get) 

static bool js_cc_gfx_TextureViewInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->type, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureViewInfo_type_set) 

static bool js_cc_gfx_TextureViewInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->type, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->type, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureViewInfo_type_get) 

static bool js_cc_gfx_TextureViewInfo_format_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->format, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureViewInfo_format_set) 

static bool js_cc_gfx_TextureViewInfo_format_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->format, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->format, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureViewInfo_format_get) 

static bool js_cc_gfx_TextureViewInfo_baseLevel_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->baseLevel, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureViewInfo_baseLevel_set) 

static bool js_cc_gfx_TextureViewInfo_baseLevel_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->baseLevel, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureViewInfo_baseLevel_get) 

static bool js_cc_gfx_TextureViewInfo_levelCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->levelCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureViewInfo_levelCount_set) 

static bool js_cc_gfx_TextureViewInfo_levelCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->levelCount, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureViewInfo_levelCount_get) 

static bool js_cc_gfx_TextureViewInfo_baseLayer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->baseLayer, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureViewInfo_baseLayer_set) 

static bool js_cc_gfx_TextureViewInfo_baseLayer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->baseLayer, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureViewInfo_baseLayer_get) 

static bool js_cc_gfx_TextureViewInfo_layerCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->layerCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureViewInfo_layerCount_set) 

static bool js_cc_gfx_TextureViewInfo_layerCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->layerCount, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureViewInfo_layerCount_get) 

static bool js_cc_gfx_TextureViewInfo_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureViewInfo *arg1 = (cc::gfx::TextureViewInfo *) NULL ;
    cc::gfx::TextureViewInfo *arg2 = 0 ;
    cc::gfx::TextureViewInfo temp2 ;
    cc::gfx::TextureViewInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureViewInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::TextureViewInfo *) &(arg1)->copy((cc::gfx::TextureViewInfo const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_TextureViewInfo_copy) 

static bool js_new_cc_gfx_TextureViewInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::TextureViewInfo *result;
    result = (cc::gfx::TextureViewInfo *)new cc::gfx::TextureViewInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_TextureViewInfo, __jsb_cc_gfx_TextureViewInfo_class, js_delete_cc_gfx_TextureViewInfo)

static bool js_delete_cc_gfx_TextureViewInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_TextureViewInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::TextureViewInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::TextureViewInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("texture", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->texture), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("format", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->format), ctx);
    }
    
    
    json->getProperty("baseLevel", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->baseLevel), ctx);
    }
    
    
    json->getProperty("levelCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->levelCount), ctx);
    }
    
    
    json->getProperty("baseLayer", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->baseLayer), ctx);
    }
    
    
    json->getProperty("layerCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->layerCount), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_TextureViewInfo(se::Object* obj) {
    auto* cls = se::Class::create("TextureViewInfo", obj, nullptr, _SE(js_new_cc_gfx_TextureViewInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("texture", _SE(js_cc_gfx_TextureViewInfo_texture_get), _SE(js_cc_gfx_TextureViewInfo_texture_set)); 
    cls->defineProperty("type", _SE(js_cc_gfx_TextureViewInfo_type_get), _SE(js_cc_gfx_TextureViewInfo_type_set)); 
    cls->defineProperty("format", _SE(js_cc_gfx_TextureViewInfo_format_get), _SE(js_cc_gfx_TextureViewInfo_format_set)); 
    cls->defineProperty("baseLevel", _SE(js_cc_gfx_TextureViewInfo_baseLevel_get), _SE(js_cc_gfx_TextureViewInfo_baseLevel_set)); 
    cls->defineProperty("levelCount", _SE(js_cc_gfx_TextureViewInfo_levelCount_get), _SE(js_cc_gfx_TextureViewInfo_levelCount_set)); 
    cls->defineProperty("baseLayer", _SE(js_cc_gfx_TextureViewInfo_baseLayer_get), _SE(js_cc_gfx_TextureViewInfo_baseLayer_set)); 
    cls->defineProperty("layerCount", _SE(js_cc_gfx_TextureViewInfo_layerCount_get), _SE(js_cc_gfx_TextureViewInfo_layerCount_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_TextureViewInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_TextureViewInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::TextureViewInfo>(cls);
    
    __jsb_cc_gfx_TextureViewInfo_proto = cls->getProto();
    __jsb_cc_gfx_TextureViewInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_SamplerInfo_class = nullptr;
se::Object* __jsb_cc_gfx_SamplerInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_SamplerInfo) 

static bool js_cc_gfx_SamplerInfo_minFilter_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->minFilter, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SamplerInfo_minFilter_set) 

static bool js_cc_gfx_SamplerInfo_minFilter_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->minFilter, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->minFilter, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SamplerInfo_minFilter_get) 

static bool js_cc_gfx_SamplerInfo_magFilter_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->magFilter, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SamplerInfo_magFilter_set) 

static bool js_cc_gfx_SamplerInfo_magFilter_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->magFilter, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->magFilter, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SamplerInfo_magFilter_get) 

static bool js_cc_gfx_SamplerInfo_mipFilter_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->mipFilter, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SamplerInfo_mipFilter_set) 

static bool js_cc_gfx_SamplerInfo_mipFilter_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->mipFilter, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->mipFilter, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SamplerInfo_mipFilter_get) 

static bool js_cc_gfx_SamplerInfo_addressU_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->addressU, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SamplerInfo_addressU_set) 

static bool js_cc_gfx_SamplerInfo_addressU_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->addressU, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->addressU, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SamplerInfo_addressU_get) 

static bool js_cc_gfx_SamplerInfo_addressV_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->addressV, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SamplerInfo_addressV_set) 

static bool js_cc_gfx_SamplerInfo_addressV_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->addressV, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->addressV, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SamplerInfo_addressV_get) 

static bool js_cc_gfx_SamplerInfo_addressW_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->addressW, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SamplerInfo_addressW_set) 

static bool js_cc_gfx_SamplerInfo_addressW_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->addressW, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->addressW, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SamplerInfo_addressW_get) 

static bool js_cc_gfx_SamplerInfo_maxAnisotropy_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxAnisotropy, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SamplerInfo_maxAnisotropy_set) 

static bool js_cc_gfx_SamplerInfo_maxAnisotropy_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxAnisotropy, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SamplerInfo_maxAnisotropy_get) 

static bool js_cc_gfx_SamplerInfo_cmpFunc_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->cmpFunc, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SamplerInfo_cmpFunc_set) 

static bool js_cc_gfx_SamplerInfo_cmpFunc_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->cmpFunc, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->cmpFunc, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SamplerInfo_cmpFunc_get) 

static bool js_cc_gfx_SamplerInfo_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SamplerInfo *arg1 = (cc::gfx::SamplerInfo *) NULL ;
    cc::gfx::SamplerInfo *arg2 = 0 ;
    cc::gfx::SamplerInfo temp2 ;
    cc::gfx::SamplerInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::SamplerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::SamplerInfo *) &(arg1)->copy((cc::gfx::SamplerInfo const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_SamplerInfo_copy) 

static bool js_new_cc_gfx_SamplerInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::SamplerInfo *result;
    result = (cc::gfx::SamplerInfo *)new cc::gfx::SamplerInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_SamplerInfo, __jsb_cc_gfx_SamplerInfo_class, js_delete_cc_gfx_SamplerInfo)

static bool js_delete_cc_gfx_SamplerInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_SamplerInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::SamplerInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::SamplerInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("minFilter", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->minFilter), ctx);
    }
    
    
    json->getProperty("magFilter", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->magFilter), ctx);
    }
    
    
    json->getProperty("mipFilter", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->mipFilter), ctx);
    }
    
    
    json->getProperty("addressU", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->addressU), ctx);
    }
    
    
    json->getProperty("addressV", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->addressV), ctx);
    }
    
    
    json->getProperty("addressW", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->addressW), ctx);
    }
    
    
    json->getProperty("maxAnisotropy", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxAnisotropy), ctx);
    }
    
    
    json->getProperty("cmpFunc", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->cmpFunc), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_SamplerInfo(se::Object* obj) {
    auto* cls = se::Class::create("SamplerInfo", obj, nullptr, _SE(js_new_cc_gfx_SamplerInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("minFilter", _SE(js_cc_gfx_SamplerInfo_minFilter_get), _SE(js_cc_gfx_SamplerInfo_minFilter_set)); 
    cls->defineProperty("magFilter", _SE(js_cc_gfx_SamplerInfo_magFilter_get), _SE(js_cc_gfx_SamplerInfo_magFilter_set)); 
    cls->defineProperty("mipFilter", _SE(js_cc_gfx_SamplerInfo_mipFilter_get), _SE(js_cc_gfx_SamplerInfo_mipFilter_set)); 
    cls->defineProperty("addressU", _SE(js_cc_gfx_SamplerInfo_addressU_get), _SE(js_cc_gfx_SamplerInfo_addressU_set)); 
    cls->defineProperty("addressV", _SE(js_cc_gfx_SamplerInfo_addressV_get), _SE(js_cc_gfx_SamplerInfo_addressV_set)); 
    cls->defineProperty("addressW", _SE(js_cc_gfx_SamplerInfo_addressW_get), _SE(js_cc_gfx_SamplerInfo_addressW_set)); 
    cls->defineProperty("maxAnisotropy", _SE(js_cc_gfx_SamplerInfo_maxAnisotropy_get), _SE(js_cc_gfx_SamplerInfo_maxAnisotropy_set)); 
    cls->defineProperty("cmpFunc", _SE(js_cc_gfx_SamplerInfo_cmpFunc_get), _SE(js_cc_gfx_SamplerInfo_cmpFunc_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_SamplerInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_SamplerInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::SamplerInfo>(cls);
    
    __jsb_cc_gfx_SamplerInfo_proto = cls->getProto();
    __jsb_cc_gfx_SamplerInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Uniform_class = nullptr;
se::Object* __jsb_cc_gfx_Uniform_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Uniform) 

static bool js_cc_gfx_Uniform_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Uniform *arg1 = (cc::gfx::Uniform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Uniform>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Uniform_name_set) 

static bool js_cc_gfx_Uniform_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Uniform *arg1 = (cc::gfx::Uniform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Uniform>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Uniform_name_get) 

static bool js_cc_gfx_Uniform_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Uniform *arg1 = (cc::gfx::Uniform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Uniform>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->type, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Uniform_type_set) 

static bool js_cc_gfx_Uniform_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Uniform *arg1 = (cc::gfx::Uniform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Uniform>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->type, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->type, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Uniform_type_get) 

static bool js_cc_gfx_Uniform_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Uniform *arg1 = (cc::gfx::Uniform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Uniform>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Uniform_count_set) 

static bool js_cc_gfx_Uniform_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Uniform *arg1 = (cc::gfx::Uniform *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Uniform>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Uniform_count_get) 

static bool js_cc_gfx_Uniform_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Uniform *arg1 = (cc::gfx::Uniform *) NULL ;
    cc::gfx::Uniform *arg2 = 0 ;
    cc::gfx::Uniform temp2 ;
    cc::gfx::Uniform *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Uniform>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::Uniform *) &(arg1)->copy((cc::gfx::Uniform const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Uniform_copy) 

static bool js_new_cc_gfx_Uniform(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::Uniform *result;
    result = (cc::gfx::Uniform *)new cc::gfx::Uniform();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_Uniform, __jsb_cc_gfx_Uniform_class, js_delete_cc_gfx_Uniform)

static bool js_delete_cc_gfx_Uniform(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Uniform) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::Uniform * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::Uniform*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_Uniform(se::Object* obj) {
    auto* cls = se::Class::create("Uniform", obj, nullptr, _SE(js_new_cc_gfx_Uniform)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("name", _SE(js_cc_gfx_Uniform_name_get), _SE(js_cc_gfx_Uniform_name_set)); 
    cls->defineProperty("type", _SE(js_cc_gfx_Uniform_type_get), _SE(js_cc_gfx_Uniform_type_set)); 
    cls->defineProperty("count", _SE(js_cc_gfx_Uniform_count_get), _SE(js_cc_gfx_Uniform_count_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_Uniform_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Uniform));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Uniform>(cls);
    
    __jsb_cc_gfx_Uniform_proto = cls->getProto();
    __jsb_cc_gfx_Uniform_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_UniformBlock_class = nullptr;
se::Object* __jsb_cc_gfx_UniformBlock_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_UniformBlock) 

static bool js_cc_gfx_UniformBlock_set_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformBlock *arg1 = (cc::gfx::UniformBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformBlock>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->set, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformBlock_set_set) 

static bool js_cc_gfx_UniformBlock_set_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock *arg1 = (cc::gfx::UniformBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformBlock>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->set, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformBlock_set_get) 

static bool js_cc_gfx_UniformBlock_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformBlock *arg1 = (cc::gfx::UniformBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformBlock>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformBlock_binding_set) 

static bool js_cc_gfx_UniformBlock_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock *arg1 = (cc::gfx::UniformBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformBlock>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformBlock_binding_get) 

static bool js_cc_gfx_UniformBlock_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformBlock *arg1 = (cc::gfx::UniformBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformBlock>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformBlock_name_set) 

static bool js_cc_gfx_UniformBlock_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock *arg1 = (cc::gfx::UniformBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformBlock>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformBlock_name_get) 

static bool js_cc_gfx_UniformBlock_members_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformBlock *arg1 = (cc::gfx::UniformBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformBlock>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->members, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformBlock_members_set) 

static bool js_cc_gfx_UniformBlock_members_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock *arg1 = (cc::gfx::UniformBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformBlock>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->members, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->members, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformBlock_members_get) 

static bool js_cc_gfx_UniformBlock_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformBlock *arg1 = (cc::gfx::UniformBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformBlock>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformBlock_count_set) 

static bool js_cc_gfx_UniformBlock_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock *arg1 = (cc::gfx::UniformBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformBlock>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformBlock_count_get) 

static bool js_cc_gfx_UniformBlock_flattened_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformBlock *arg1 = (cc::gfx::UniformBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformBlock>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->flattened, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformBlock_flattened_set) 

static bool js_cc_gfx_UniformBlock_flattened_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock *arg1 = (cc::gfx::UniformBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformBlock>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->flattened, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformBlock_flattened_get) 

static bool js_cc_gfx_UniformBlock_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformBlock *arg1 = (cc::gfx::UniformBlock *) NULL ;
    cc::gfx::UniformBlock *arg2 = 0 ;
    cc::gfx::UniformBlock temp2 ;
    cc::gfx::UniformBlock *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformBlock>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::UniformBlock *) &(arg1)->copy((cc::gfx::UniformBlock const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_UniformBlock_copy) 

static bool js_new_cc_gfx_UniformBlock(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::UniformBlock *result;
    result = (cc::gfx::UniformBlock *)new cc::gfx::UniformBlock();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_UniformBlock, __jsb_cc_gfx_UniformBlock_class, js_delete_cc_gfx_UniformBlock)

static bool js_delete_cc_gfx_UniformBlock(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_UniformBlock) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::UniformBlock * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::UniformBlock*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("set", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->set), ctx);
    }
    
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("members", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->members), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("flattened", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->flattened), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_UniformBlock(se::Object* obj) {
    auto* cls = se::Class::create("UniformBlock", obj, nullptr, _SE(js_new_cc_gfx_UniformBlock)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("set", _SE(js_cc_gfx_UniformBlock_set_get), _SE(js_cc_gfx_UniformBlock_set_set)); 
    cls->defineProperty("binding", _SE(js_cc_gfx_UniformBlock_binding_get), _SE(js_cc_gfx_UniformBlock_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_gfx_UniformBlock_name_get), _SE(js_cc_gfx_UniformBlock_name_set)); 
    cls->defineProperty("members", _SE(js_cc_gfx_UniformBlock_members_get), _SE(js_cc_gfx_UniformBlock_members_set)); 
    cls->defineProperty("count", _SE(js_cc_gfx_UniformBlock_count_get), _SE(js_cc_gfx_UniformBlock_count_set)); 
    cls->defineProperty("flattened", _SE(js_cc_gfx_UniformBlock_flattened_get), _SE(js_cc_gfx_UniformBlock_flattened_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_UniformBlock_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_UniformBlock));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::UniformBlock>(cls);
    
    __jsb_cc_gfx_UniformBlock_proto = cls->getProto();
    __jsb_cc_gfx_UniformBlock_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_UniformSamplerTexture_class = nullptr;
se::Object* __jsb_cc_gfx_UniformSamplerTexture_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_UniformSamplerTexture) 

static bool js_cc_gfx_UniformSamplerTexture_set_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformSamplerTexture *arg1 = (cc::gfx::UniformSamplerTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSamplerTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->set, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformSamplerTexture_set_set) 

static bool js_cc_gfx_UniformSamplerTexture_set_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture *arg1 = (cc::gfx::UniformSamplerTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSamplerTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->set, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformSamplerTexture_set_get) 

static bool js_cc_gfx_UniformSamplerTexture_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformSamplerTexture *arg1 = (cc::gfx::UniformSamplerTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSamplerTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformSamplerTexture_binding_set) 

static bool js_cc_gfx_UniformSamplerTexture_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture *arg1 = (cc::gfx::UniformSamplerTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSamplerTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformSamplerTexture_binding_get) 

static bool js_cc_gfx_UniformSamplerTexture_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformSamplerTexture *arg1 = (cc::gfx::UniformSamplerTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSamplerTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformSamplerTexture_name_set) 

static bool js_cc_gfx_UniformSamplerTexture_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture *arg1 = (cc::gfx::UniformSamplerTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSamplerTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformSamplerTexture_name_get) 

static bool js_cc_gfx_UniformSamplerTexture_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformSamplerTexture *arg1 = (cc::gfx::UniformSamplerTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSamplerTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->type, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformSamplerTexture_type_set) 

static bool js_cc_gfx_UniformSamplerTexture_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture *arg1 = (cc::gfx::UniformSamplerTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSamplerTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->type, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->type, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformSamplerTexture_type_get) 

static bool js_cc_gfx_UniformSamplerTexture_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformSamplerTexture *arg1 = (cc::gfx::UniformSamplerTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSamplerTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformSamplerTexture_count_set) 

static bool js_cc_gfx_UniformSamplerTexture_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture *arg1 = (cc::gfx::UniformSamplerTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSamplerTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformSamplerTexture_count_get) 

static bool js_cc_gfx_UniformSamplerTexture_flattened_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformSamplerTexture *arg1 = (cc::gfx::UniformSamplerTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSamplerTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->flattened, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformSamplerTexture_flattened_set) 

static bool js_cc_gfx_UniformSamplerTexture_flattened_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture *arg1 = (cc::gfx::UniformSamplerTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSamplerTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->flattened, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformSamplerTexture_flattened_get) 

static bool js_cc_gfx_UniformSamplerTexture_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformSamplerTexture *arg1 = (cc::gfx::UniformSamplerTexture *) NULL ;
    cc::gfx::UniformSamplerTexture *arg2 = 0 ;
    cc::gfx::UniformSamplerTexture temp2 ;
    cc::gfx::UniformSamplerTexture *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSamplerTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::UniformSamplerTexture *) &(arg1)->copy((cc::gfx::UniformSamplerTexture const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_UniformSamplerTexture_copy) 

static bool js_new_cc_gfx_UniformSamplerTexture(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::UniformSamplerTexture *result;
    result = (cc::gfx::UniformSamplerTexture *)new cc::gfx::UniformSamplerTexture();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_UniformSamplerTexture, __jsb_cc_gfx_UniformSamplerTexture_class, js_delete_cc_gfx_UniformSamplerTexture)

static bool js_delete_cc_gfx_UniformSamplerTexture(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_UniformSamplerTexture) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::UniformSamplerTexture * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::UniformSamplerTexture*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("set", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->set), ctx);
    }
    
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("flattened", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->flattened), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_UniformSamplerTexture(se::Object* obj) {
    auto* cls = se::Class::create("UniformSamplerTexture", obj, nullptr, _SE(js_new_cc_gfx_UniformSamplerTexture)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("set", _SE(js_cc_gfx_UniformSamplerTexture_set_get), _SE(js_cc_gfx_UniformSamplerTexture_set_set)); 
    cls->defineProperty("binding", _SE(js_cc_gfx_UniformSamplerTexture_binding_get), _SE(js_cc_gfx_UniformSamplerTexture_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_gfx_UniformSamplerTexture_name_get), _SE(js_cc_gfx_UniformSamplerTexture_name_set)); 
    cls->defineProperty("type", _SE(js_cc_gfx_UniformSamplerTexture_type_get), _SE(js_cc_gfx_UniformSamplerTexture_type_set)); 
    cls->defineProperty("count", _SE(js_cc_gfx_UniformSamplerTexture_count_get), _SE(js_cc_gfx_UniformSamplerTexture_count_set)); 
    cls->defineProperty("flattened", _SE(js_cc_gfx_UniformSamplerTexture_flattened_get), _SE(js_cc_gfx_UniformSamplerTexture_flattened_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_UniformSamplerTexture_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_UniformSamplerTexture));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::UniformSamplerTexture>(cls);
    
    __jsb_cc_gfx_UniformSamplerTexture_proto = cls->getProto();
    __jsb_cc_gfx_UniformSamplerTexture_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_UniformSampler_class = nullptr;
se::Object* __jsb_cc_gfx_UniformSampler_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_UniformSampler) 

static bool js_cc_gfx_UniformSampler_set_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformSampler *arg1 = (cc::gfx::UniformSampler *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSampler>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->set, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformSampler_set_set) 

static bool js_cc_gfx_UniformSampler_set_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSampler *arg1 = (cc::gfx::UniformSampler *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSampler>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->set, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformSampler_set_get) 

static bool js_cc_gfx_UniformSampler_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformSampler *arg1 = (cc::gfx::UniformSampler *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSampler>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformSampler_binding_set) 

static bool js_cc_gfx_UniformSampler_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSampler *arg1 = (cc::gfx::UniformSampler *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSampler>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformSampler_binding_get) 

static bool js_cc_gfx_UniformSampler_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformSampler *arg1 = (cc::gfx::UniformSampler *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSampler>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformSampler_name_set) 

static bool js_cc_gfx_UniformSampler_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSampler *arg1 = (cc::gfx::UniformSampler *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSampler>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformSampler_name_get) 

static bool js_cc_gfx_UniformSampler_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformSampler *arg1 = (cc::gfx::UniformSampler *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSampler>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformSampler_count_set) 

static bool js_cc_gfx_UniformSampler_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSampler *arg1 = (cc::gfx::UniformSampler *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSampler>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformSampler_count_get) 

static bool js_cc_gfx_UniformSampler_flattened_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformSampler *arg1 = (cc::gfx::UniformSampler *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSampler>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->flattened, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformSampler_flattened_set) 

static bool js_cc_gfx_UniformSampler_flattened_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSampler *arg1 = (cc::gfx::UniformSampler *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSampler>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->flattened, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformSampler_flattened_get) 

static bool js_cc_gfx_UniformSampler_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformSampler *arg1 = (cc::gfx::UniformSampler *) NULL ;
    cc::gfx::UniformSampler *arg2 = 0 ;
    cc::gfx::UniformSampler temp2 ;
    cc::gfx::UniformSampler *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformSampler>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::UniformSampler *) &(arg1)->copy((cc::gfx::UniformSampler const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_UniformSampler_copy) 

static bool js_new_cc_gfx_UniformSampler(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::UniformSampler *result;
    result = (cc::gfx::UniformSampler *)new cc::gfx::UniformSampler();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_UniformSampler, __jsb_cc_gfx_UniformSampler_class, js_delete_cc_gfx_UniformSampler)

static bool js_delete_cc_gfx_UniformSampler(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_UniformSampler) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::UniformSampler * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::UniformSampler*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("set", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->set), ctx);
    }
    
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("flattened", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->flattened), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_UniformSampler(se::Object* obj) {
    auto* cls = se::Class::create("UniformSampler", obj, nullptr, _SE(js_new_cc_gfx_UniformSampler)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("set", _SE(js_cc_gfx_UniformSampler_set_get), _SE(js_cc_gfx_UniformSampler_set_set)); 
    cls->defineProperty("binding", _SE(js_cc_gfx_UniformSampler_binding_get), _SE(js_cc_gfx_UniformSampler_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_gfx_UniformSampler_name_get), _SE(js_cc_gfx_UniformSampler_name_set)); 
    cls->defineProperty("count", _SE(js_cc_gfx_UniformSampler_count_get), _SE(js_cc_gfx_UniformSampler_count_set)); 
    cls->defineProperty("flattened", _SE(js_cc_gfx_UniformSampler_flattened_get), _SE(js_cc_gfx_UniformSampler_flattened_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_UniformSampler_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_UniformSampler));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::UniformSampler>(cls);
    
    __jsb_cc_gfx_UniformSampler_proto = cls->getProto();
    __jsb_cc_gfx_UniformSampler_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_UniformTexture_class = nullptr;
se::Object* __jsb_cc_gfx_UniformTexture_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_UniformTexture) 

static bool js_cc_gfx_UniformTexture_set_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformTexture *arg1 = (cc::gfx::UniformTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->set, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformTexture_set_set) 

static bool js_cc_gfx_UniformTexture_set_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformTexture *arg1 = (cc::gfx::UniformTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->set, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformTexture_set_get) 

static bool js_cc_gfx_UniformTexture_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformTexture *arg1 = (cc::gfx::UniformTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformTexture_binding_set) 

static bool js_cc_gfx_UniformTexture_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformTexture *arg1 = (cc::gfx::UniformTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformTexture_binding_get) 

static bool js_cc_gfx_UniformTexture_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformTexture *arg1 = (cc::gfx::UniformTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformTexture_name_set) 

static bool js_cc_gfx_UniformTexture_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformTexture *arg1 = (cc::gfx::UniformTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformTexture_name_get) 

static bool js_cc_gfx_UniformTexture_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformTexture *arg1 = (cc::gfx::UniformTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->type, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformTexture_type_set) 

static bool js_cc_gfx_UniformTexture_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformTexture *arg1 = (cc::gfx::UniformTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->type, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->type, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformTexture_type_get) 

static bool js_cc_gfx_UniformTexture_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformTexture *arg1 = (cc::gfx::UniformTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformTexture_count_set) 

static bool js_cc_gfx_UniformTexture_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformTexture *arg1 = (cc::gfx::UniformTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformTexture_count_get) 

static bool js_cc_gfx_UniformTexture_flattened_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformTexture *arg1 = (cc::gfx::UniformTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->flattened, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformTexture_flattened_set) 

static bool js_cc_gfx_UniformTexture_flattened_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformTexture *arg1 = (cc::gfx::UniformTexture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->flattened, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformTexture_flattened_get) 

static bool js_cc_gfx_UniformTexture_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformTexture *arg1 = (cc::gfx::UniformTexture *) NULL ;
    cc::gfx::UniformTexture *arg2 = 0 ;
    cc::gfx::UniformTexture temp2 ;
    cc::gfx::UniformTexture *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformTexture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::UniformTexture *) &(arg1)->copy((cc::gfx::UniformTexture const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_UniformTexture_copy) 

static bool js_new_cc_gfx_UniformTexture(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::UniformTexture *result;
    result = (cc::gfx::UniformTexture *)new cc::gfx::UniformTexture();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_UniformTexture, __jsb_cc_gfx_UniformTexture_class, js_delete_cc_gfx_UniformTexture)

static bool js_delete_cc_gfx_UniformTexture(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_UniformTexture) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::UniformTexture * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::UniformTexture*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("set", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->set), ctx);
    }
    
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("flattened", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->flattened), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_UniformTexture(se::Object* obj) {
    auto* cls = se::Class::create("UniformTexture", obj, nullptr, _SE(js_new_cc_gfx_UniformTexture)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("set", _SE(js_cc_gfx_UniformTexture_set_get), _SE(js_cc_gfx_UniformTexture_set_set)); 
    cls->defineProperty("binding", _SE(js_cc_gfx_UniformTexture_binding_get), _SE(js_cc_gfx_UniformTexture_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_gfx_UniformTexture_name_get), _SE(js_cc_gfx_UniformTexture_name_set)); 
    cls->defineProperty("type", _SE(js_cc_gfx_UniformTexture_type_get), _SE(js_cc_gfx_UniformTexture_type_set)); 
    cls->defineProperty("count", _SE(js_cc_gfx_UniformTexture_count_get), _SE(js_cc_gfx_UniformTexture_count_set)); 
    cls->defineProperty("flattened", _SE(js_cc_gfx_UniformTexture_flattened_get), _SE(js_cc_gfx_UniformTexture_flattened_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_UniformTexture_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_UniformTexture));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::UniformTexture>(cls);
    
    __jsb_cc_gfx_UniformTexture_proto = cls->getProto();
    __jsb_cc_gfx_UniformTexture_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_UniformStorageImage_class = nullptr;
se::Object* __jsb_cc_gfx_UniformStorageImage_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_UniformStorageImage) 

static bool js_cc_gfx_UniformStorageImage_set_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->set, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformStorageImage_set_set) 

static bool js_cc_gfx_UniformStorageImage_set_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->set, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformStorageImage_set_get) 

static bool js_cc_gfx_UniformStorageImage_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformStorageImage_binding_set) 

static bool js_cc_gfx_UniformStorageImage_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformStorageImage_binding_get) 

static bool js_cc_gfx_UniformStorageImage_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformStorageImage_name_set) 

static bool js_cc_gfx_UniformStorageImage_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformStorageImage_name_get) 

static bool js_cc_gfx_UniformStorageImage_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->type, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformStorageImage_type_set) 

static bool js_cc_gfx_UniformStorageImage_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->type, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->type, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformStorageImage_type_get) 

static bool js_cc_gfx_UniformStorageImage_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformStorageImage_count_set) 

static bool js_cc_gfx_UniformStorageImage_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformStorageImage_count_get) 

static bool js_cc_gfx_UniformStorageImage_memoryAccess_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->memoryAccess, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformStorageImage_memoryAccess_set) 

static bool js_cc_gfx_UniformStorageImage_memoryAccess_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->memoryAccess, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->memoryAccess, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformStorageImage_memoryAccess_get) 

static bool js_cc_gfx_UniformStorageImage_flattened_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->flattened, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformStorageImage_flattened_set) 

static bool js_cc_gfx_UniformStorageImage_flattened_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->flattened, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformStorageImage_flattened_get) 

static bool js_cc_gfx_UniformStorageImage_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageImage *arg1 = (cc::gfx::UniformStorageImage *) NULL ;
    cc::gfx::UniformStorageImage *arg2 = 0 ;
    cc::gfx::UniformStorageImage temp2 ;
    cc::gfx::UniformStorageImage *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageImage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::UniformStorageImage *) &(arg1)->copy((cc::gfx::UniformStorageImage const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_UniformStorageImage_copy) 

static bool js_new_cc_gfx_UniformStorageImage(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::UniformStorageImage *result;
    result = (cc::gfx::UniformStorageImage *)new cc::gfx::UniformStorageImage();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_UniformStorageImage, __jsb_cc_gfx_UniformStorageImage_class, js_delete_cc_gfx_UniformStorageImage)

static bool js_delete_cc_gfx_UniformStorageImage(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_UniformStorageImage) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::UniformStorageImage * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::UniformStorageImage*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("set", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->set), ctx);
    }
    
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("memoryAccess", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->memoryAccess), ctx);
    }
    
    
    json->getProperty("flattened", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->flattened), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_UniformStorageImage(se::Object* obj) {
    auto* cls = se::Class::create("UniformStorageImage", obj, nullptr, _SE(js_new_cc_gfx_UniformStorageImage)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("set", _SE(js_cc_gfx_UniformStorageImage_set_get), _SE(js_cc_gfx_UniformStorageImage_set_set)); 
    cls->defineProperty("binding", _SE(js_cc_gfx_UniformStorageImage_binding_get), _SE(js_cc_gfx_UniformStorageImage_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_gfx_UniformStorageImage_name_get), _SE(js_cc_gfx_UniformStorageImage_name_set)); 
    cls->defineProperty("type", _SE(js_cc_gfx_UniformStorageImage_type_get), _SE(js_cc_gfx_UniformStorageImage_type_set)); 
    cls->defineProperty("count", _SE(js_cc_gfx_UniformStorageImage_count_get), _SE(js_cc_gfx_UniformStorageImage_count_set)); 
    cls->defineProperty("memoryAccess", _SE(js_cc_gfx_UniformStorageImage_memoryAccess_get), _SE(js_cc_gfx_UniformStorageImage_memoryAccess_set)); 
    cls->defineProperty("flattened", _SE(js_cc_gfx_UniformStorageImage_flattened_get), _SE(js_cc_gfx_UniformStorageImage_flattened_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_UniformStorageImage_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_UniformStorageImage));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::UniformStorageImage>(cls);
    
    __jsb_cc_gfx_UniformStorageImage_proto = cls->getProto();
    __jsb_cc_gfx_UniformStorageImage_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_UniformStorageBuffer_class = nullptr;
se::Object* __jsb_cc_gfx_UniformStorageBuffer_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_UniformStorageBuffer) 

static bool js_cc_gfx_UniformStorageBuffer_set_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageBuffer *arg1 = (cc::gfx::UniformStorageBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->set, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformStorageBuffer_set_set) 

static bool js_cc_gfx_UniformStorageBuffer_set_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformStorageBuffer *arg1 = (cc::gfx::UniformStorageBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->set, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformStorageBuffer_set_get) 

static bool js_cc_gfx_UniformStorageBuffer_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageBuffer *arg1 = (cc::gfx::UniformStorageBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformStorageBuffer_binding_set) 

static bool js_cc_gfx_UniformStorageBuffer_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformStorageBuffer *arg1 = (cc::gfx::UniformStorageBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformStorageBuffer_binding_get) 

static bool js_cc_gfx_UniformStorageBuffer_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageBuffer *arg1 = (cc::gfx::UniformStorageBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformStorageBuffer_name_set) 

static bool js_cc_gfx_UniformStorageBuffer_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformStorageBuffer *arg1 = (cc::gfx::UniformStorageBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformStorageBuffer_name_get) 

static bool js_cc_gfx_UniformStorageBuffer_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageBuffer *arg1 = (cc::gfx::UniformStorageBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformStorageBuffer_count_set) 

static bool js_cc_gfx_UniformStorageBuffer_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformStorageBuffer *arg1 = (cc::gfx::UniformStorageBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformStorageBuffer_count_get) 

static bool js_cc_gfx_UniformStorageBuffer_memoryAccess_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageBuffer *arg1 = (cc::gfx::UniformStorageBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->memoryAccess, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformStorageBuffer_memoryAccess_set) 

static bool js_cc_gfx_UniformStorageBuffer_memoryAccess_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformStorageBuffer *arg1 = (cc::gfx::UniformStorageBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->memoryAccess, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->memoryAccess, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformStorageBuffer_memoryAccess_get) 

static bool js_cc_gfx_UniformStorageBuffer_flattened_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageBuffer *arg1 = (cc::gfx::UniformStorageBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->flattened, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformStorageBuffer_flattened_set) 

static bool js_cc_gfx_UniformStorageBuffer_flattened_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformStorageBuffer *arg1 = (cc::gfx::UniformStorageBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->flattened, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformStorageBuffer_flattened_get) 

static bool js_cc_gfx_UniformStorageBuffer_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformStorageBuffer *arg1 = (cc::gfx::UniformStorageBuffer *) NULL ;
    cc::gfx::UniformStorageBuffer *arg2 = 0 ;
    cc::gfx::UniformStorageBuffer temp2 ;
    cc::gfx::UniformStorageBuffer *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformStorageBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::UniformStorageBuffer *) &(arg1)->copy((cc::gfx::UniformStorageBuffer const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_UniformStorageBuffer_copy) 

static bool js_new_cc_gfx_UniformStorageBuffer(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::UniformStorageBuffer *result;
    result = (cc::gfx::UniformStorageBuffer *)new cc::gfx::UniformStorageBuffer();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_UniformStorageBuffer, __jsb_cc_gfx_UniformStorageBuffer_class, js_delete_cc_gfx_UniformStorageBuffer)

static bool js_delete_cc_gfx_UniformStorageBuffer(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_UniformStorageBuffer) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::UniformStorageBuffer * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::UniformStorageBuffer*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("set", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->set), ctx);
    }
    
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("memoryAccess", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->memoryAccess), ctx);
    }
    
    
    json->getProperty("flattened", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->flattened), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_UniformStorageBuffer(se::Object* obj) {
    auto* cls = se::Class::create("UniformStorageBuffer", obj, nullptr, _SE(js_new_cc_gfx_UniformStorageBuffer)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("set", _SE(js_cc_gfx_UniformStorageBuffer_set_get), _SE(js_cc_gfx_UniformStorageBuffer_set_set)); 
    cls->defineProperty("binding", _SE(js_cc_gfx_UniformStorageBuffer_binding_get), _SE(js_cc_gfx_UniformStorageBuffer_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_gfx_UniformStorageBuffer_name_get), _SE(js_cc_gfx_UniformStorageBuffer_name_set)); 
    cls->defineProperty("count", _SE(js_cc_gfx_UniformStorageBuffer_count_get), _SE(js_cc_gfx_UniformStorageBuffer_count_set)); 
    cls->defineProperty("memoryAccess", _SE(js_cc_gfx_UniformStorageBuffer_memoryAccess_get), _SE(js_cc_gfx_UniformStorageBuffer_memoryAccess_set)); 
    cls->defineProperty("flattened", _SE(js_cc_gfx_UniformStorageBuffer_flattened_get), _SE(js_cc_gfx_UniformStorageBuffer_flattened_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_UniformStorageBuffer_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_UniformStorageBuffer));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::UniformStorageBuffer>(cls);
    
    __jsb_cc_gfx_UniformStorageBuffer_proto = cls->getProto();
    __jsb_cc_gfx_UniformStorageBuffer_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_UniformInputAttachment_class = nullptr;
se::Object* __jsb_cc_gfx_UniformInputAttachment_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_UniformInputAttachment) 

static bool js_cc_gfx_UniformInputAttachment_set_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformInputAttachment *arg1 = (cc::gfx::UniformInputAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformInputAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->set, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformInputAttachment_set_set) 

static bool js_cc_gfx_UniformInputAttachment_set_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformInputAttachment *arg1 = (cc::gfx::UniformInputAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformInputAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->set, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformInputAttachment_set_get) 

static bool js_cc_gfx_UniformInputAttachment_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformInputAttachment *arg1 = (cc::gfx::UniformInputAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformInputAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformInputAttachment_binding_set) 

static bool js_cc_gfx_UniformInputAttachment_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformInputAttachment *arg1 = (cc::gfx::UniformInputAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformInputAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformInputAttachment_binding_get) 

static bool js_cc_gfx_UniformInputAttachment_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformInputAttachment *arg1 = (cc::gfx::UniformInputAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformInputAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformInputAttachment_name_set) 

static bool js_cc_gfx_UniformInputAttachment_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformInputAttachment *arg1 = (cc::gfx::UniformInputAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformInputAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformInputAttachment_name_get) 

static bool js_cc_gfx_UniformInputAttachment_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformInputAttachment *arg1 = (cc::gfx::UniformInputAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformInputAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformInputAttachment_count_set) 

static bool js_cc_gfx_UniformInputAttachment_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformInputAttachment *arg1 = (cc::gfx::UniformInputAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformInputAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformInputAttachment_count_get) 

static bool js_cc_gfx_UniformInputAttachment_flattened_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformInputAttachment *arg1 = (cc::gfx::UniformInputAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformInputAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->flattened, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_UniformInputAttachment_flattened_set) 

static bool js_cc_gfx_UniformInputAttachment_flattened_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformInputAttachment *arg1 = (cc::gfx::UniformInputAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformInputAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->flattened, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_UniformInputAttachment_flattened_get) 

static bool js_cc_gfx_UniformInputAttachment_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformInputAttachment *arg1 = (cc::gfx::UniformInputAttachment *) NULL ;
    cc::gfx::UniformInputAttachment *arg2 = 0 ;
    cc::gfx::UniformInputAttachment temp2 ;
    cc::gfx::UniformInputAttachment *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::UniformInputAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::UniformInputAttachment *) &(arg1)->copy((cc::gfx::UniformInputAttachment const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_UniformInputAttachment_copy) 

static bool js_new_cc_gfx_UniformInputAttachment(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::UniformInputAttachment *result;
    result = (cc::gfx::UniformInputAttachment *)new cc::gfx::UniformInputAttachment();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_UniformInputAttachment, __jsb_cc_gfx_UniformInputAttachment_class, js_delete_cc_gfx_UniformInputAttachment)

static bool js_delete_cc_gfx_UniformInputAttachment(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_UniformInputAttachment) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::UniformInputAttachment * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::UniformInputAttachment*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("set", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->set), ctx);
    }
    
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("flattened", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->flattened), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_UniformInputAttachment(se::Object* obj) {
    auto* cls = se::Class::create("UniformInputAttachment", obj, nullptr, _SE(js_new_cc_gfx_UniformInputAttachment)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("set", _SE(js_cc_gfx_UniformInputAttachment_set_get), _SE(js_cc_gfx_UniformInputAttachment_set_set)); 
    cls->defineProperty("binding", _SE(js_cc_gfx_UniformInputAttachment_binding_get), _SE(js_cc_gfx_UniformInputAttachment_binding_set)); 
    cls->defineProperty("name", _SE(js_cc_gfx_UniformInputAttachment_name_get), _SE(js_cc_gfx_UniformInputAttachment_name_set)); 
    cls->defineProperty("count", _SE(js_cc_gfx_UniformInputAttachment_count_get), _SE(js_cc_gfx_UniformInputAttachment_count_set)); 
    cls->defineProperty("flattened", _SE(js_cc_gfx_UniformInputAttachment_flattened_get), _SE(js_cc_gfx_UniformInputAttachment_flattened_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_UniformInputAttachment_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_UniformInputAttachment));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::UniformInputAttachment>(cls);
    
    __jsb_cc_gfx_UniformInputAttachment_proto = cls->getProto();
    __jsb_cc_gfx_UniformInputAttachment_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_ShaderStage_class = nullptr;
se::Object* __jsb_cc_gfx_ShaderStage_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_ShaderStage) 

static bool js_cc_gfx_ShaderStage_stage_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderStage *arg1 = (cc::gfx::ShaderStage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderStage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stage, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ShaderStage_stage_set) 

static bool js_cc_gfx_ShaderStage_stage_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ShaderStage *arg1 = (cc::gfx::ShaderStage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderStage>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stage, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stage, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ShaderStage_stage_get) 

static bool js_cc_gfx_ShaderStage_source_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderStage *arg1 = (cc::gfx::ShaderStage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderStage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->source, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ShaderStage_source_set) 

static bool js_cc_gfx_ShaderStage_source_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ShaderStage *arg1 = (cc::gfx::ShaderStage *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderStage>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->source, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->source, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ShaderStage_source_get) 

static bool js_cc_gfx_ShaderStage_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderStage *arg1 = (cc::gfx::ShaderStage *) NULL ;
    cc::gfx::ShaderStage *arg2 = 0 ;
    cc::gfx::ShaderStage temp2 ;
    cc::gfx::ShaderStage *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderStage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::ShaderStage *) &(arg1)->copy((cc::gfx::ShaderStage const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_ShaderStage_copy) 

static bool js_new_cc_gfx_ShaderStage(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::ShaderStage *result;
    result = (cc::gfx::ShaderStage *)new cc::gfx::ShaderStage();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_ShaderStage, __jsb_cc_gfx_ShaderStage_class, js_delete_cc_gfx_ShaderStage)

static bool js_delete_cc_gfx_ShaderStage(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_ShaderStage) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::ShaderStage * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::ShaderStage*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("stage", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stage), ctx);
    }
    
    
    json->getProperty("source", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->source), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_ShaderStage(se::Object* obj) {
    auto* cls = se::Class::create("ShaderStage", obj, nullptr, _SE(js_new_cc_gfx_ShaderStage)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("stage", _SE(js_cc_gfx_ShaderStage_stage_get), _SE(js_cc_gfx_ShaderStage_stage_set)); 
    cls->defineProperty("source", _SE(js_cc_gfx_ShaderStage_source_get), _SE(js_cc_gfx_ShaderStage_source_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_ShaderStage_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_ShaderStage));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::ShaderStage>(cls);
    
    __jsb_cc_gfx_ShaderStage_proto = cls->getProto();
    __jsb_cc_gfx_ShaderStage_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Attribute_class = nullptr;
se::Object* __jsb_cc_gfx_Attribute_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Attribute) 

static bool js_cc_gfx_Attribute_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Attribute *arg1 = (cc::gfx::Attribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Attribute>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Attribute_name_set) 

static bool js_cc_gfx_Attribute_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Attribute *arg1 = (cc::gfx::Attribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Attribute>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Attribute_name_get) 

static bool js_cc_gfx_Attribute_format_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Attribute *arg1 = (cc::gfx::Attribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Attribute>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->format, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Attribute_format_set) 

static bool js_cc_gfx_Attribute_format_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Attribute *arg1 = (cc::gfx::Attribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Attribute>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->format, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->format, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Attribute_format_get) 

static bool js_cc_gfx_Attribute_isNormalized_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Attribute *arg1 = (cc::gfx::Attribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Attribute>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->isNormalized);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Attribute_isNormalized_set) 

static bool js_cc_gfx_Attribute_isNormalized_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Attribute *arg1 = (cc::gfx::Attribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Attribute>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->isNormalized, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Attribute_isNormalized_get) 

static bool js_cc_gfx_Attribute_stream_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Attribute *arg1 = (cc::gfx::Attribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Attribute>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stream, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Attribute_stream_set) 

static bool js_cc_gfx_Attribute_stream_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Attribute *arg1 = (cc::gfx::Attribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Attribute>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stream, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Attribute_stream_get) 

static bool js_cc_gfx_Attribute_isInstanced_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Attribute *arg1 = (cc::gfx::Attribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Attribute>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->isInstanced);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Attribute_isInstanced_set) 

static bool js_cc_gfx_Attribute_isInstanced_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Attribute *arg1 = (cc::gfx::Attribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Attribute>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->isInstanced, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Attribute_isInstanced_get) 

static bool js_cc_gfx_Attribute_location_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Attribute *arg1 = (cc::gfx::Attribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Attribute>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->location, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_Attribute_location_set) 

static bool js_cc_gfx_Attribute_location_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Attribute *arg1 = (cc::gfx::Attribute *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Attribute>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->location, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Attribute_location_get) 

static bool js_cc_gfx_Attribute_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Attribute *arg1 = (cc::gfx::Attribute *) NULL ;
    cc::gfx::Attribute *arg2 = 0 ;
    cc::gfx::Attribute temp2 ;
    cc::gfx::Attribute *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Attribute>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::Attribute *) &(arg1)->copy((cc::gfx::Attribute const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Attribute_copy) 

static bool js_new_cc_gfx_Attribute(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::Attribute *result;
    result = (cc::gfx::Attribute *)new cc::gfx::Attribute();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_Attribute, __jsb_cc_gfx_Attribute_class, js_delete_cc_gfx_Attribute)

static bool js_delete_cc_gfx_Attribute(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Attribute) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::Attribute * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::Attribute*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("format", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->format), ctx);
    }
    
    
    json->getProperty("isNormalized", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isNormalized), ctx);
    }
    
    
    json->getProperty("stream", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stream), ctx);
    }
    
    
    json->getProperty("isInstanced", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isInstanced), ctx);
    }
    
    
    json->getProperty("location", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->location), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_Attribute(se::Object* obj) {
    auto* cls = se::Class::create("Attribute", obj, nullptr, _SE(js_new_cc_gfx_Attribute)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("name", _SE(js_cc_gfx_Attribute_name_get), _SE(js_cc_gfx_Attribute_name_set)); 
    cls->defineProperty("format", _SE(js_cc_gfx_Attribute_format_get), _SE(js_cc_gfx_Attribute_format_set)); 
    cls->defineProperty("isNormalized", _SE(js_cc_gfx_Attribute_isNormalized_get), _SE(js_cc_gfx_Attribute_isNormalized_set)); 
    cls->defineProperty("stream", _SE(js_cc_gfx_Attribute_stream_get), _SE(js_cc_gfx_Attribute_stream_set)); 
    cls->defineProperty("isInstanced", _SE(js_cc_gfx_Attribute_isInstanced_get), _SE(js_cc_gfx_Attribute_isInstanced_set)); 
    cls->defineProperty("location", _SE(js_cc_gfx_Attribute_location_get), _SE(js_cc_gfx_Attribute_location_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_Attribute_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Attribute));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Attribute>(cls);
    
    __jsb_cc_gfx_Attribute_proto = cls->getProto();
    __jsb_cc_gfx_Attribute_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_ShaderInfo_class = nullptr;
se::Object* __jsb_cc_gfx_ShaderInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_ShaderInfo) 

static bool js_cc_gfx_ShaderInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ShaderInfo_name_set) 

static bool js_cc_gfx_ShaderInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ShaderInfo_name_get) 

static bool js_cc_gfx_ShaderInfo_stages_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stages, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ShaderInfo_stages_set) 

static bool js_cc_gfx_ShaderInfo_stages_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stages, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stages, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ShaderInfo_stages_get) 

static bool js_cc_gfx_ShaderInfo_attributes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->attributes, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ShaderInfo_attributes_set) 

static bool js_cc_gfx_ShaderInfo_attributes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->attributes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->attributes, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ShaderInfo_attributes_get) 

static bool js_cc_gfx_ShaderInfo_blocks_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blocks, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ShaderInfo_blocks_set) 

static bool js_cc_gfx_ShaderInfo_blocks_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blocks, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blocks, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ShaderInfo_blocks_get) 

static bool js_cc_gfx_ShaderInfo_buffers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->buffers, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ShaderInfo_buffers_set) 

static bool js_cc_gfx_ShaderInfo_buffers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->buffers, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->buffers, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ShaderInfo_buffers_get) 

static bool js_cc_gfx_ShaderInfo_samplerTextures_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->samplerTextures, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ShaderInfo_samplerTextures_set) 

static bool js_cc_gfx_ShaderInfo_samplerTextures_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->samplerTextures, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->samplerTextures, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ShaderInfo_samplerTextures_get) 

static bool js_cc_gfx_ShaderInfo_samplers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->samplers, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ShaderInfo_samplers_set) 

static bool js_cc_gfx_ShaderInfo_samplers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->samplers, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->samplers, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ShaderInfo_samplers_get) 

static bool js_cc_gfx_ShaderInfo_textures_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->textures, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ShaderInfo_textures_set) 

static bool js_cc_gfx_ShaderInfo_textures_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->textures, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->textures, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ShaderInfo_textures_get) 

static bool js_cc_gfx_ShaderInfo_images_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->images, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ShaderInfo_images_set) 

static bool js_cc_gfx_ShaderInfo_images_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->images, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->images, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ShaderInfo_images_get) 

static bool js_cc_gfx_ShaderInfo_subpassInputs_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->subpassInputs, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ShaderInfo_subpassInputs_set) 

static bool js_cc_gfx_ShaderInfo_subpassInputs_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->subpassInputs, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->subpassInputs, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ShaderInfo_subpassInputs_get) 

static bool js_cc_gfx_ShaderInfo_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ShaderInfo *arg1 = (cc::gfx::ShaderInfo *) NULL ;
    cc::gfx::ShaderInfo *arg2 = 0 ;
    cc::gfx::ShaderInfo temp2 ;
    cc::gfx::ShaderInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::ShaderInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::ShaderInfo *) &(arg1)->copy((cc::gfx::ShaderInfo const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_ShaderInfo_copy) 

static bool js_new_cc_gfx_ShaderInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::ShaderInfo *result;
    result = (cc::gfx::ShaderInfo *)new cc::gfx::ShaderInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_ShaderInfo, __jsb_cc_gfx_ShaderInfo_class, js_delete_cc_gfx_ShaderInfo)

static bool js_delete_cc_gfx_ShaderInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_ShaderInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::ShaderInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::ShaderInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("stages", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stages), ctx);
    }
    
    
    json->getProperty("attributes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->attributes), ctx);
    }
    
    
    json->getProperty("blocks", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blocks), ctx);
    }
    
    
    json->getProperty("buffers", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->buffers), ctx);
    }
    
    
    json->getProperty("samplerTextures", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->samplerTextures), ctx);
    }
    
    
    json->getProperty("samplers", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->samplers), ctx);
    }
    
    
    json->getProperty("textures", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->textures), ctx);
    }
    
    
    json->getProperty("images", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->images), ctx);
    }
    
    
    json->getProperty("subpassInputs", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->subpassInputs), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_ShaderInfo(se::Object* obj) {
    auto* cls = se::Class::create("ShaderInfo", obj, nullptr, _SE(js_new_cc_gfx_ShaderInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("name", _SE(js_cc_gfx_ShaderInfo_name_get), _SE(js_cc_gfx_ShaderInfo_name_set)); 
    cls->defineProperty("stages", _SE(js_cc_gfx_ShaderInfo_stages_get), _SE(js_cc_gfx_ShaderInfo_stages_set)); 
    cls->defineProperty("attributes", _SE(js_cc_gfx_ShaderInfo_attributes_get), _SE(js_cc_gfx_ShaderInfo_attributes_set)); 
    cls->defineProperty("blocks", _SE(js_cc_gfx_ShaderInfo_blocks_get), _SE(js_cc_gfx_ShaderInfo_blocks_set)); 
    cls->defineProperty("buffers", _SE(js_cc_gfx_ShaderInfo_buffers_get), _SE(js_cc_gfx_ShaderInfo_buffers_set)); 
    cls->defineProperty("samplerTextures", _SE(js_cc_gfx_ShaderInfo_samplerTextures_get), _SE(js_cc_gfx_ShaderInfo_samplerTextures_set)); 
    cls->defineProperty("samplers", _SE(js_cc_gfx_ShaderInfo_samplers_get), _SE(js_cc_gfx_ShaderInfo_samplers_set)); 
    cls->defineProperty("textures", _SE(js_cc_gfx_ShaderInfo_textures_get), _SE(js_cc_gfx_ShaderInfo_textures_set)); 
    cls->defineProperty("images", _SE(js_cc_gfx_ShaderInfo_images_get), _SE(js_cc_gfx_ShaderInfo_images_set)); 
    cls->defineProperty("subpassInputs", _SE(js_cc_gfx_ShaderInfo_subpassInputs_get), _SE(js_cc_gfx_ShaderInfo_subpassInputs_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_ShaderInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_ShaderInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::ShaderInfo>(cls);
    
    __jsb_cc_gfx_ShaderInfo_proto = cls->getProto();
    __jsb_cc_gfx_ShaderInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_InputAssemblerInfo_class = nullptr;
se::Object* __jsb_cc_gfx_InputAssemblerInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_InputAssemblerInfo) 

static bool js_cc_gfx_InputAssemblerInfo_attributes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssemblerInfo *arg1 = (cc::gfx::InputAssemblerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssemblerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->attributes, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_InputAssemblerInfo_attributes_set) 

static bool js_cc_gfx_InputAssemblerInfo_attributes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssemblerInfo *arg1 = (cc::gfx::InputAssemblerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssemblerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->attributes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->attributes, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssemblerInfo_attributes_get) 

static bool js_cc_gfx_InputAssemblerInfo_vertexBuffers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssemblerInfo *arg1 = (cc::gfx::InputAssemblerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssemblerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->vertexBuffers, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_InputAssemblerInfo_vertexBuffers_set) 

static bool js_cc_gfx_InputAssemblerInfo_vertexBuffers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssemblerInfo *arg1 = (cc::gfx::InputAssemblerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssemblerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->vertexBuffers, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->vertexBuffers, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssemblerInfo_vertexBuffers_get) 

static bool js_cc_gfx_InputAssemblerInfo_indexBuffer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssemblerInfo *arg1 = (cc::gfx::InputAssemblerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssemblerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->indexBuffer, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_InputAssemblerInfo_indexBuffer_set) 

static bool js_cc_gfx_InputAssemblerInfo_indexBuffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssemblerInfo *arg1 = (cc::gfx::InputAssemblerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssemblerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->indexBuffer, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->indexBuffer, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssemblerInfo_indexBuffer_get) 

static bool js_cc_gfx_InputAssemblerInfo_indirectBuffer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssemblerInfo *arg1 = (cc::gfx::InputAssemblerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssemblerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->indirectBuffer, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_InputAssemblerInfo_indirectBuffer_set) 

static bool js_cc_gfx_InputAssemblerInfo_indirectBuffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssemblerInfo *arg1 = (cc::gfx::InputAssemblerInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssemblerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->indirectBuffer, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->indirectBuffer, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssemblerInfo_indirectBuffer_get) 

static bool js_cc_gfx_InputAssemblerInfo_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssemblerInfo *arg1 = (cc::gfx::InputAssemblerInfo *) NULL ;
    cc::gfx::InputAssemblerInfo *arg2 = 0 ;
    cc::gfx::InputAssemblerInfo temp2 ;
    cc::gfx::InputAssemblerInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssemblerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::InputAssemblerInfo *) &(arg1)->copy((cc::gfx::InputAssemblerInfo const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_InputAssemblerInfo_copy) 

static bool js_new_cc_gfx_InputAssemblerInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::InputAssemblerInfo *result;
    result = (cc::gfx::InputAssemblerInfo *)new cc::gfx::InputAssemblerInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_InputAssemblerInfo, __jsb_cc_gfx_InputAssemblerInfo_class, js_delete_cc_gfx_InputAssemblerInfo)

static bool js_delete_cc_gfx_InputAssemblerInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_InputAssemblerInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::InputAssemblerInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::InputAssemblerInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("attributes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->attributes), ctx);
    }
    
    
    json->getProperty("vertexBuffers", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->vertexBuffers), ctx);
    }
    
    
    json->getProperty("indexBuffer", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->indexBuffer), ctx);
    }
    
    
    json->getProperty("indirectBuffer", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->indirectBuffer), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_InputAssemblerInfo(se::Object* obj) {
    auto* cls = se::Class::create("InputAssemblerInfo", obj, nullptr, _SE(js_new_cc_gfx_InputAssemblerInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("attributes", _SE(js_cc_gfx_InputAssemblerInfo_attributes_get), _SE(js_cc_gfx_InputAssemblerInfo_attributes_set)); 
    cls->defineProperty("vertexBuffers", _SE(js_cc_gfx_InputAssemblerInfo_vertexBuffers_get), _SE(js_cc_gfx_InputAssemblerInfo_vertexBuffers_set)); 
    cls->defineProperty("indexBuffer", _SE(js_cc_gfx_InputAssemblerInfo_indexBuffer_get), _SE(js_cc_gfx_InputAssemblerInfo_indexBuffer_set)); 
    cls->defineProperty("indirectBuffer", _SE(js_cc_gfx_InputAssemblerInfo_indirectBuffer_get), _SE(js_cc_gfx_InputAssemblerInfo_indirectBuffer_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_InputAssemblerInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_InputAssemblerInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::InputAssemblerInfo>(cls);
    
    __jsb_cc_gfx_InputAssemblerInfo_proto = cls->getProto();
    __jsb_cc_gfx_InputAssemblerInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_ColorAttachment_class = nullptr;
se::Object* __jsb_cc_gfx_ColorAttachment_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_ColorAttachment) 

static bool js_cc_gfx_ColorAttachment_format_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ColorAttachment *arg1 = (cc::gfx::ColorAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ColorAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->format, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ColorAttachment_format_set) 

static bool js_cc_gfx_ColorAttachment_format_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ColorAttachment *arg1 = (cc::gfx::ColorAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ColorAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->format, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->format, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ColorAttachment_format_get) 

static bool js_cc_gfx_ColorAttachment_sampleCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ColorAttachment *arg1 = (cc::gfx::ColorAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ColorAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->sampleCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ColorAttachment_sampleCount_set) 

static bool js_cc_gfx_ColorAttachment_sampleCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ColorAttachment *arg1 = (cc::gfx::ColorAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ColorAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->sampleCount, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->sampleCount, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ColorAttachment_sampleCount_get) 

static bool js_cc_gfx_ColorAttachment_loadOp_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ColorAttachment *arg1 = (cc::gfx::ColorAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ColorAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->loadOp, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ColorAttachment_loadOp_set) 

static bool js_cc_gfx_ColorAttachment_loadOp_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ColorAttachment *arg1 = (cc::gfx::ColorAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ColorAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->loadOp, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->loadOp, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ColorAttachment_loadOp_get) 

static bool js_cc_gfx_ColorAttachment_storeOp_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ColorAttachment *arg1 = (cc::gfx::ColorAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ColorAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->storeOp, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ColorAttachment_storeOp_set) 

static bool js_cc_gfx_ColorAttachment_storeOp_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ColorAttachment *arg1 = (cc::gfx::ColorAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ColorAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->storeOp, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->storeOp, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ColorAttachment_storeOp_get) 

static bool js_cc_gfx_ColorAttachment_barrier_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ColorAttachment *arg1 = (cc::gfx::ColorAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ColorAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->barrier, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ColorAttachment_barrier_set) 

static bool js_cc_gfx_ColorAttachment_barrier_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ColorAttachment *arg1 = (cc::gfx::ColorAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ColorAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->barrier, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->barrier, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ColorAttachment_barrier_get) 

static bool js_cc_gfx_ColorAttachment_isGeneralLayout_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ColorAttachment *arg1 = (cc::gfx::ColorAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ColorAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->isGeneralLayout, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_ColorAttachment_isGeneralLayout_set) 

static bool js_cc_gfx_ColorAttachment_isGeneralLayout_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::ColorAttachment *arg1 = (cc::gfx::ColorAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::ColorAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->isGeneralLayout, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_ColorAttachment_isGeneralLayout_get) 

static bool js_cc_gfx_ColorAttachment_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::ColorAttachment *arg1 = (cc::gfx::ColorAttachment *) NULL ;
    cc::gfx::ColorAttachment *arg2 = 0 ;
    cc::gfx::ColorAttachment temp2 ;
    cc::gfx::ColorAttachment *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::ColorAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::ColorAttachment *) &(arg1)->copy((cc::gfx::ColorAttachment const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_ColorAttachment_copy) 

static bool js_new_cc_gfx_ColorAttachment(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::ColorAttachment *result;
    result = (cc::gfx::ColorAttachment *)new cc::gfx::ColorAttachment();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_ColorAttachment, __jsb_cc_gfx_ColorAttachment_class, js_delete_cc_gfx_ColorAttachment)

static bool js_delete_cc_gfx_ColorAttachment(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_ColorAttachment) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::ColorAttachment * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::ColorAttachment*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("format", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->format), ctx);
    }
    
    
    json->getProperty("sampleCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->sampleCount), ctx);
    }
    
    
    json->getProperty("loadOp", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->loadOp), ctx);
    }
    
    
    json->getProperty("storeOp", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->storeOp), ctx);
    }
    
    
    json->getProperty("barrier", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->barrier), ctx);
    }
    
    
    json->getProperty("isGeneralLayout", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isGeneralLayout), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_ColorAttachment(se::Object* obj) {
    auto* cls = se::Class::create("ColorAttachment", obj, nullptr, _SE(js_new_cc_gfx_ColorAttachment)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("format", _SE(js_cc_gfx_ColorAttachment_format_get), _SE(js_cc_gfx_ColorAttachment_format_set)); 
    cls->defineProperty("sampleCount", _SE(js_cc_gfx_ColorAttachment_sampleCount_get), _SE(js_cc_gfx_ColorAttachment_sampleCount_set)); 
    cls->defineProperty("loadOp", _SE(js_cc_gfx_ColorAttachment_loadOp_get), _SE(js_cc_gfx_ColorAttachment_loadOp_set)); 
    cls->defineProperty("storeOp", _SE(js_cc_gfx_ColorAttachment_storeOp_get), _SE(js_cc_gfx_ColorAttachment_storeOp_set)); 
    cls->defineProperty("barrier", _SE(js_cc_gfx_ColorAttachment_barrier_get), _SE(js_cc_gfx_ColorAttachment_barrier_set)); 
    cls->defineProperty("isGeneralLayout", _SE(js_cc_gfx_ColorAttachment_isGeneralLayout_get), _SE(js_cc_gfx_ColorAttachment_isGeneralLayout_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_ColorAttachment_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_ColorAttachment));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::ColorAttachment>(cls);
    
    __jsb_cc_gfx_ColorAttachment_proto = cls->getProto();
    __jsb_cc_gfx_ColorAttachment_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DepthStencilAttachment_class = nullptr;
se::Object* __jsb_cc_gfx_DepthStencilAttachment_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DepthStencilAttachment) 

static bool js_cc_gfx_DepthStencilAttachment_format_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->format, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilAttachment_format_set) 

static bool js_cc_gfx_DepthStencilAttachment_format_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->format, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->format, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilAttachment_format_get) 

static bool js_cc_gfx_DepthStencilAttachment_sampleCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->sampleCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilAttachment_sampleCount_set) 

static bool js_cc_gfx_DepthStencilAttachment_sampleCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->sampleCount, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->sampleCount, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilAttachment_sampleCount_get) 

static bool js_cc_gfx_DepthStencilAttachment_depthLoadOp_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthLoadOp, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilAttachment_depthLoadOp_set) 

static bool js_cc_gfx_DepthStencilAttachment_depthLoadOp_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthLoadOp, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthLoadOp, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilAttachment_depthLoadOp_get) 

static bool js_cc_gfx_DepthStencilAttachment_depthStoreOp_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthStoreOp, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilAttachment_depthStoreOp_set) 

static bool js_cc_gfx_DepthStencilAttachment_depthStoreOp_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthStoreOp, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthStoreOp, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilAttachment_depthStoreOp_get) 

static bool js_cc_gfx_DepthStencilAttachment_stencilLoadOp_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilLoadOp, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilAttachment_stencilLoadOp_set) 

static bool js_cc_gfx_DepthStencilAttachment_stencilLoadOp_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilLoadOp, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilLoadOp, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilAttachment_stencilLoadOp_get) 

static bool js_cc_gfx_DepthStencilAttachment_stencilStoreOp_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilStoreOp, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilAttachment_stencilStoreOp_set) 

static bool js_cc_gfx_DepthStencilAttachment_stencilStoreOp_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilStoreOp, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilStoreOp, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilAttachment_stencilStoreOp_get) 

static bool js_cc_gfx_DepthStencilAttachment_barrier_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->barrier, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilAttachment_barrier_set) 

static bool js_cc_gfx_DepthStencilAttachment_barrier_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->barrier, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->barrier, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilAttachment_barrier_get) 

static bool js_cc_gfx_DepthStencilAttachment_isGeneralLayout_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->isGeneralLayout, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilAttachment_isGeneralLayout_set) 

static bool js_cc_gfx_DepthStencilAttachment_isGeneralLayout_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->isGeneralLayout, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilAttachment_isGeneralLayout_get) 

static bool js_cc_gfx_DepthStencilAttachment_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilAttachment *arg1 = (cc::gfx::DepthStencilAttachment *) NULL ;
    cc::gfx::DepthStencilAttachment *arg2 = 0 ;
    cc::gfx::DepthStencilAttachment temp2 ;
    cc::gfx::DepthStencilAttachment *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilAttachment>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::DepthStencilAttachment *) &(arg1)->copy((cc::gfx::DepthStencilAttachment const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DepthStencilAttachment_copy) 

static bool js_new_cc_gfx_DepthStencilAttachment(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::DepthStencilAttachment *result;
    result = (cc::gfx::DepthStencilAttachment *)new cc::gfx::DepthStencilAttachment();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_DepthStencilAttachment, __jsb_cc_gfx_DepthStencilAttachment_class, js_delete_cc_gfx_DepthStencilAttachment)

static bool js_delete_cc_gfx_DepthStencilAttachment(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DepthStencilAttachment) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::DepthStencilAttachment * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::DepthStencilAttachment*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("format", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->format), ctx);
    }
    
    
    json->getProperty("sampleCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->sampleCount), ctx);
    }
    
    
    json->getProperty("depthLoadOp", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthLoadOp), ctx);
    }
    
    
    json->getProperty("depthStoreOp", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthStoreOp), ctx);
    }
    
    
    json->getProperty("stencilLoadOp", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilLoadOp), ctx);
    }
    
    
    json->getProperty("stencilStoreOp", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilStoreOp), ctx);
    }
    
    
    json->getProperty("barrier", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->barrier), ctx);
    }
    
    
    json->getProperty("isGeneralLayout", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isGeneralLayout), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_DepthStencilAttachment(se::Object* obj) {
    auto* cls = se::Class::create("DepthStencilAttachment", obj, nullptr, _SE(js_new_cc_gfx_DepthStencilAttachment)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("format", _SE(js_cc_gfx_DepthStencilAttachment_format_get), _SE(js_cc_gfx_DepthStencilAttachment_format_set)); 
    cls->defineProperty("sampleCount", _SE(js_cc_gfx_DepthStencilAttachment_sampleCount_get), _SE(js_cc_gfx_DepthStencilAttachment_sampleCount_set)); 
    cls->defineProperty("depthLoadOp", _SE(js_cc_gfx_DepthStencilAttachment_depthLoadOp_get), _SE(js_cc_gfx_DepthStencilAttachment_depthLoadOp_set)); 
    cls->defineProperty("depthStoreOp", _SE(js_cc_gfx_DepthStencilAttachment_depthStoreOp_get), _SE(js_cc_gfx_DepthStencilAttachment_depthStoreOp_set)); 
    cls->defineProperty("stencilLoadOp", _SE(js_cc_gfx_DepthStencilAttachment_stencilLoadOp_get), _SE(js_cc_gfx_DepthStencilAttachment_stencilLoadOp_set)); 
    cls->defineProperty("stencilStoreOp", _SE(js_cc_gfx_DepthStencilAttachment_stencilStoreOp_get), _SE(js_cc_gfx_DepthStencilAttachment_stencilStoreOp_set)); 
    cls->defineProperty("barrier", _SE(js_cc_gfx_DepthStencilAttachment_barrier_get), _SE(js_cc_gfx_DepthStencilAttachment_barrier_set)); 
    cls->defineProperty("isGeneralLayout", _SE(js_cc_gfx_DepthStencilAttachment_isGeneralLayout_get), _SE(js_cc_gfx_DepthStencilAttachment_isGeneralLayout_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_DepthStencilAttachment_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DepthStencilAttachment));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DepthStencilAttachment>(cls);
    
    __jsb_cc_gfx_DepthStencilAttachment_proto = cls->getProto();
    __jsb_cc_gfx_DepthStencilAttachment_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_SubpassInfo_class = nullptr;
se::Object* __jsb_cc_gfx_SubpassInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_SubpassInfo) 

static bool js_cc_gfx_SubpassInfo_inputs_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->inputs, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassInfo_inputs_set) 

static bool js_cc_gfx_SubpassInfo_inputs_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->inputs, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->inputs, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassInfo_inputs_get) 

static bool js_cc_gfx_SubpassInfo_colors_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->colors, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassInfo_colors_set) 

static bool js_cc_gfx_SubpassInfo_colors_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->colors, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->colors, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassInfo_colors_get) 

static bool js_cc_gfx_SubpassInfo_resolves_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->resolves, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassInfo_resolves_set) 

static bool js_cc_gfx_SubpassInfo_resolves_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->resolves, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->resolves, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassInfo_resolves_get) 

static bool js_cc_gfx_SubpassInfo_preserves_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->preserves, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassInfo_preserves_set) 

static bool js_cc_gfx_SubpassInfo_preserves_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->preserves, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->preserves, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassInfo_preserves_get) 

static bool js_cc_gfx_SubpassInfo_depthStencil_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthStencil, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassInfo_depthStencil_set) 

static bool js_cc_gfx_SubpassInfo_depthStencil_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthStencil, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassInfo_depthStencil_get) 

static bool js_cc_gfx_SubpassInfo_depthStencilResolve_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthStencilResolve, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassInfo_depthStencilResolve_set) 

static bool js_cc_gfx_SubpassInfo_depthStencilResolve_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthStencilResolve, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassInfo_depthStencilResolve_get) 

static bool js_cc_gfx_SubpassInfo_depthResolveMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthResolveMode, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassInfo_depthResolveMode_set) 

static bool js_cc_gfx_SubpassInfo_depthResolveMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthResolveMode, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthResolveMode, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassInfo_depthResolveMode_get) 

static bool js_cc_gfx_SubpassInfo_stencilResolveMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilResolveMode, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassInfo_stencilResolveMode_set) 

static bool js_cc_gfx_SubpassInfo_stencilResolveMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilResolveMode, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilResolveMode, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassInfo_stencilResolveMode_get) 

static bool js_cc_gfx_SubpassInfo_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassInfo *arg1 = (cc::gfx::SubpassInfo *) NULL ;
    cc::gfx::SubpassInfo *arg2 = 0 ;
    cc::gfx::SubpassInfo temp2 ;
    cc::gfx::SubpassInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::SubpassInfo *) &(arg1)->copy((cc::gfx::SubpassInfo const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_SubpassInfo_copy) 

static bool js_new_cc_gfx_SubpassInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::SubpassInfo *result;
    result = (cc::gfx::SubpassInfo *)new cc::gfx::SubpassInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_SubpassInfo, __jsb_cc_gfx_SubpassInfo_class, js_delete_cc_gfx_SubpassInfo)

static bool js_delete_cc_gfx_SubpassInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_SubpassInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::SubpassInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::SubpassInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("inputs", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->inputs), ctx);
    }
    
    
    json->getProperty("colors", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->colors), ctx);
    }
    
    
    json->getProperty("resolves", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->resolves), ctx);
    }
    
    
    json->getProperty("preserves", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->preserves), ctx);
    }
    
    
    json->getProperty("depthStencil", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthStencil), ctx);
    }
    
    
    json->getProperty("depthStencilResolve", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthStencilResolve), ctx);
    }
    
    
    json->getProperty("depthResolveMode", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthResolveMode), ctx);
    }
    
    
    json->getProperty("stencilResolveMode", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilResolveMode), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_SubpassInfo(se::Object* obj) {
    auto* cls = se::Class::create("SubpassInfo", obj, nullptr, _SE(js_new_cc_gfx_SubpassInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("inputs", _SE(js_cc_gfx_SubpassInfo_inputs_get), _SE(js_cc_gfx_SubpassInfo_inputs_set)); 
    cls->defineProperty("colors", _SE(js_cc_gfx_SubpassInfo_colors_get), _SE(js_cc_gfx_SubpassInfo_colors_set)); 
    cls->defineProperty("resolves", _SE(js_cc_gfx_SubpassInfo_resolves_get), _SE(js_cc_gfx_SubpassInfo_resolves_set)); 
    cls->defineProperty("preserves", _SE(js_cc_gfx_SubpassInfo_preserves_get), _SE(js_cc_gfx_SubpassInfo_preserves_set)); 
    cls->defineProperty("depthStencil", _SE(js_cc_gfx_SubpassInfo_depthStencil_get), _SE(js_cc_gfx_SubpassInfo_depthStencil_set)); 
    cls->defineProperty("depthStencilResolve", _SE(js_cc_gfx_SubpassInfo_depthStencilResolve_get), _SE(js_cc_gfx_SubpassInfo_depthStencilResolve_set)); 
    cls->defineProperty("depthResolveMode", _SE(js_cc_gfx_SubpassInfo_depthResolveMode_get), _SE(js_cc_gfx_SubpassInfo_depthResolveMode_set)); 
    cls->defineProperty("stencilResolveMode", _SE(js_cc_gfx_SubpassInfo_stencilResolveMode_get), _SE(js_cc_gfx_SubpassInfo_stencilResolveMode_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_SubpassInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_SubpassInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::SubpassInfo>(cls);
    
    __jsb_cc_gfx_SubpassInfo_proto = cls->getProto();
    __jsb_cc_gfx_SubpassInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_SubpassDependency_class = nullptr;
se::Object* __jsb_cc_gfx_SubpassDependency_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_SubpassDependency) 

static bool js_cc_gfx_SubpassDependency_srcSubpass_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->srcSubpass, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassDependency_srcSubpass_set) 

static bool js_cc_gfx_SubpassDependency_srcSubpass_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->srcSubpass, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassDependency_srcSubpass_get) 

static bool js_cc_gfx_SubpassDependency_dstSubpass_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->dstSubpass, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassDependency_dstSubpass_set) 

static bool js_cc_gfx_SubpassDependency_dstSubpass_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->dstSubpass, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassDependency_dstSubpass_get) 

static bool js_cc_gfx_SubpassDependency_generalBarrier_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->generalBarrier, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassDependency_generalBarrier_set) 

static bool js_cc_gfx_SubpassDependency_generalBarrier_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->generalBarrier, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->generalBarrier, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassDependency_generalBarrier_get) 

static bool js_cc_gfx_SubpassDependency_bufferBarriers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->bufferBarriers, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassDependency_bufferBarriers_set) 

static bool js_cc_gfx_SubpassDependency_bufferBarriers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->bufferBarriers, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->bufferBarriers, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassDependency_bufferBarriers_get) 

static bool js_cc_gfx_SubpassDependency_buffers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->buffers, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassDependency_buffers_set) 

static bool js_cc_gfx_SubpassDependency_buffers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->buffers, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->buffers, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassDependency_buffers_get) 

static bool js_cc_gfx_SubpassDependency_bufferBarrierCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->bufferBarrierCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassDependency_bufferBarrierCount_set) 

static bool js_cc_gfx_SubpassDependency_bufferBarrierCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->bufferBarrierCount, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassDependency_bufferBarrierCount_get) 

static bool js_cc_gfx_SubpassDependency_textureBarriers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->textureBarriers, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassDependency_textureBarriers_set) 

static bool js_cc_gfx_SubpassDependency_textureBarriers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->textureBarriers, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->textureBarriers, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassDependency_textureBarriers_get) 

static bool js_cc_gfx_SubpassDependency_textures_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->textures, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassDependency_textures_set) 

static bool js_cc_gfx_SubpassDependency_textures_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->textures, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->textures, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassDependency_textures_get) 

static bool js_cc_gfx_SubpassDependency_textureBarrierCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->textureBarrierCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_SubpassDependency_textureBarrierCount_set) 

static bool js_cc_gfx_SubpassDependency_textureBarrierCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->textureBarrierCount, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_SubpassDependency_textureBarrierCount_get) 

static bool js_cc_gfx_SubpassDependency_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SubpassDependency *arg1 = (cc::gfx::SubpassDependency *) NULL ;
    cc::gfx::SubpassDependency *arg2 = 0 ;
    cc::gfx::SubpassDependency temp2 ;
    cc::gfx::SubpassDependency *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::SubpassDependency>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::SubpassDependency *) &(arg1)->copy((cc::gfx::SubpassDependency const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_SubpassDependency_copy) 

static bool js_new_cc_gfx_SubpassDependency(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::SubpassDependency *result;
    result = (cc::gfx::SubpassDependency *)new cc::gfx::SubpassDependency();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_SubpassDependency, __jsb_cc_gfx_SubpassDependency_class, js_delete_cc_gfx_SubpassDependency)

static bool js_delete_cc_gfx_SubpassDependency(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_SubpassDependency) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::SubpassDependency * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::SubpassDependency*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("srcSubpass", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->srcSubpass), ctx);
    }
    
    
    json->getProperty("dstSubpass", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dstSubpass), ctx);
    }
    
    
    json->getProperty("generalBarrier", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->generalBarrier), ctx);
    }
    
    
    json->getProperty("bufferBarriers", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->bufferBarriers), ctx);
    }
    
    
    json->getProperty("buffers", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->buffers), ctx);
    }
    
    
    json->getProperty("bufferBarrierCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->bufferBarrierCount), ctx);
    }
    
    
    json->getProperty("textureBarriers", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->textureBarriers), ctx);
    }
    
    
    json->getProperty("textures", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->textures), ctx);
    }
    
    
    json->getProperty("textureBarrierCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->textureBarrierCount), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_SubpassDependency(se::Object* obj) {
    auto* cls = se::Class::create("SubpassDependency", obj, nullptr, _SE(js_new_cc_gfx_SubpassDependency)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("srcSubpass", _SE(js_cc_gfx_SubpassDependency_srcSubpass_get), _SE(js_cc_gfx_SubpassDependency_srcSubpass_set)); 
    cls->defineProperty("dstSubpass", _SE(js_cc_gfx_SubpassDependency_dstSubpass_get), _SE(js_cc_gfx_SubpassDependency_dstSubpass_set)); 
    cls->defineProperty("generalBarrier", _SE(js_cc_gfx_SubpassDependency_generalBarrier_get), _SE(js_cc_gfx_SubpassDependency_generalBarrier_set)); 
    cls->defineProperty("bufferBarriers", _SE(js_cc_gfx_SubpassDependency_bufferBarriers_get), _SE(js_cc_gfx_SubpassDependency_bufferBarriers_set)); 
    cls->defineProperty("buffers", _SE(js_cc_gfx_SubpassDependency_buffers_get), _SE(js_cc_gfx_SubpassDependency_buffers_set)); 
    cls->defineProperty("bufferBarrierCount", _SE(js_cc_gfx_SubpassDependency_bufferBarrierCount_get), _SE(js_cc_gfx_SubpassDependency_bufferBarrierCount_set)); 
    cls->defineProperty("textureBarriers", _SE(js_cc_gfx_SubpassDependency_textureBarriers_get), _SE(js_cc_gfx_SubpassDependency_textureBarriers_set)); 
    cls->defineProperty("textures", _SE(js_cc_gfx_SubpassDependency_textures_get), _SE(js_cc_gfx_SubpassDependency_textures_set)); 
    cls->defineProperty("textureBarrierCount", _SE(js_cc_gfx_SubpassDependency_textureBarrierCount_get), _SE(js_cc_gfx_SubpassDependency_textureBarrierCount_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_SubpassDependency_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_SubpassDependency));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::SubpassDependency>(cls);
    
    __jsb_cc_gfx_SubpassDependency_proto = cls->getProto();
    __jsb_cc_gfx_SubpassDependency_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_RenderPassInfo_class = nullptr;
se::Object* __jsb_cc_gfx_RenderPassInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_RenderPassInfo) 

static bool js_cc_gfx_RenderPassInfo_colorAttachments_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RenderPassInfo *arg1 = (cc::gfx::RenderPassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPassInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->colorAttachments, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RenderPassInfo_colorAttachments_set) 

static bool js_cc_gfx_RenderPassInfo_colorAttachments_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RenderPassInfo *arg1 = (cc::gfx::RenderPassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPassInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->colorAttachments, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->colorAttachments, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RenderPassInfo_colorAttachments_get) 

static bool js_cc_gfx_RenderPassInfo_depthStencilAttachment_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RenderPassInfo *arg1 = (cc::gfx::RenderPassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPassInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthStencilAttachment, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RenderPassInfo_depthStencilAttachment_set) 

static bool js_cc_gfx_RenderPassInfo_depthStencilAttachment_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RenderPassInfo *arg1 = (cc::gfx::RenderPassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPassInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthStencilAttachment, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthStencilAttachment, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RenderPassInfo_depthStencilAttachment_get) 

static bool js_cc_gfx_RenderPassInfo_subpasses_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RenderPassInfo *arg1 = (cc::gfx::RenderPassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPassInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->subpasses, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RenderPassInfo_subpasses_set) 

static bool js_cc_gfx_RenderPassInfo_subpasses_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RenderPassInfo *arg1 = (cc::gfx::RenderPassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPassInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->subpasses, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->subpasses, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RenderPassInfo_subpasses_get) 

static bool js_cc_gfx_RenderPassInfo_dependencies_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RenderPassInfo *arg1 = (cc::gfx::RenderPassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPassInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->dependencies, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RenderPassInfo_dependencies_set) 

static bool js_cc_gfx_RenderPassInfo_dependencies_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RenderPassInfo *arg1 = (cc::gfx::RenderPassInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPassInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->dependencies, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->dependencies, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RenderPassInfo_dependencies_get) 

static bool js_cc_gfx_RenderPassInfo_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RenderPassInfo *arg1 = (cc::gfx::RenderPassInfo *) NULL ;
    cc::gfx::RenderPassInfo *arg2 = 0 ;
    cc::gfx::RenderPassInfo temp2 ;
    cc::gfx::RenderPassInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPassInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::RenderPassInfo *) &(arg1)->copy((cc::gfx::RenderPassInfo const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_RenderPassInfo_copy) 

static bool js_new_cc_gfx_RenderPassInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::RenderPassInfo *result;
    result = (cc::gfx::RenderPassInfo *)new cc::gfx::RenderPassInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_RenderPassInfo, __jsb_cc_gfx_RenderPassInfo_class, js_delete_cc_gfx_RenderPassInfo)

static bool js_delete_cc_gfx_RenderPassInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_RenderPassInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::RenderPassInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::RenderPassInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("colorAttachments", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->colorAttachments), ctx);
    }
    
    
    json->getProperty("depthStencilAttachment", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthStencilAttachment), ctx);
    }
    
    
    json->getProperty("subpasses", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->subpasses), ctx);
    }
    
    
    json->getProperty("dependencies", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dependencies), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_RenderPassInfo(se::Object* obj) {
    auto* cls = se::Class::create("RenderPassInfo", obj, nullptr, _SE(js_new_cc_gfx_RenderPassInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("colorAttachments", _SE(js_cc_gfx_RenderPassInfo_colorAttachments_get), _SE(js_cc_gfx_RenderPassInfo_colorAttachments_set)); 
    cls->defineProperty("depthStencilAttachment", _SE(js_cc_gfx_RenderPassInfo_depthStencilAttachment_get), _SE(js_cc_gfx_RenderPassInfo_depthStencilAttachment_set)); 
    cls->defineProperty("subpasses", _SE(js_cc_gfx_RenderPassInfo_subpasses_get), _SE(js_cc_gfx_RenderPassInfo_subpasses_set)); 
    cls->defineProperty("dependencies", _SE(js_cc_gfx_RenderPassInfo_dependencies_get), _SE(js_cc_gfx_RenderPassInfo_dependencies_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_RenderPassInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_RenderPassInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::RenderPassInfo>(cls);
    
    __jsb_cc_gfx_RenderPassInfo_proto = cls->getProto();
    __jsb_cc_gfx_RenderPassInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_GeneralBarrierInfo_class = nullptr;
se::Object* __jsb_cc_gfx_GeneralBarrierInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_GeneralBarrierInfo) 

static bool js_cc_gfx_GeneralBarrierInfo_prevAccesses_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::GeneralBarrierInfo *arg1 = (cc::gfx::GeneralBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::GeneralBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->prevAccesses, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_GeneralBarrierInfo_prevAccesses_set) 

static bool js_cc_gfx_GeneralBarrierInfo_prevAccesses_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::GeneralBarrierInfo *arg1 = (cc::gfx::GeneralBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::GeneralBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->prevAccesses, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->prevAccesses, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_GeneralBarrierInfo_prevAccesses_get) 

static bool js_cc_gfx_GeneralBarrierInfo_nextAccesses_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::GeneralBarrierInfo *arg1 = (cc::gfx::GeneralBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::GeneralBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->nextAccesses, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_GeneralBarrierInfo_nextAccesses_set) 

static bool js_cc_gfx_GeneralBarrierInfo_nextAccesses_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::GeneralBarrierInfo *arg1 = (cc::gfx::GeneralBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::GeneralBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->nextAccesses, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->nextAccesses, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_GeneralBarrierInfo_nextAccesses_get) 

static bool js_cc_gfx_GeneralBarrierInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::GeneralBarrierInfo *arg1 = (cc::gfx::GeneralBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::GeneralBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->type, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_GeneralBarrierInfo_type_set) 

static bool js_cc_gfx_GeneralBarrierInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::GeneralBarrierInfo *arg1 = (cc::gfx::GeneralBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::GeneralBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->type, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->type, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_GeneralBarrierInfo_type_get) 

static bool js_cc_gfx_GeneralBarrierInfo__padding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::GeneralBarrierInfo *arg1 = (cc::gfx::GeneralBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::GeneralBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_padding, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_GeneralBarrierInfo__padding_set) 

static bool js_cc_gfx_GeneralBarrierInfo__padding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::GeneralBarrierInfo *arg1 = (cc::gfx::GeneralBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::GeneralBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_padding, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_GeneralBarrierInfo__padding_get) 

static bool js_cc_gfx_GeneralBarrierInfo_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::GeneralBarrierInfo *arg1 = (cc::gfx::GeneralBarrierInfo *) NULL ;
    cc::gfx::GeneralBarrierInfo *arg2 = 0 ;
    cc::gfx::GeneralBarrierInfo temp2 ;
    cc::gfx::GeneralBarrierInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::GeneralBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::GeneralBarrierInfo *) &(arg1)->copy((cc::gfx::GeneralBarrierInfo const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_GeneralBarrierInfo_copy) 

static bool js_new_cc_gfx_GeneralBarrierInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::GeneralBarrierInfo *result;
    result = (cc::gfx::GeneralBarrierInfo *)new cc::gfx::GeneralBarrierInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_GeneralBarrierInfo, __jsb_cc_gfx_GeneralBarrierInfo_class, js_delete_cc_gfx_GeneralBarrierInfo)

static bool js_delete_cc_gfx_GeneralBarrierInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_GeneralBarrierInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::GeneralBarrierInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::GeneralBarrierInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("prevAccesses", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->prevAccesses), ctx);
    }
    
    
    json->getProperty("nextAccesses", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->nextAccesses), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("_padding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->_padding), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_GeneralBarrierInfo(se::Object* obj) {
    auto* cls = se::Class::create("GeneralBarrierInfo", obj, nullptr, _SE(js_new_cc_gfx_GeneralBarrierInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("prevAccesses", _SE(js_cc_gfx_GeneralBarrierInfo_prevAccesses_get), _SE(js_cc_gfx_GeneralBarrierInfo_prevAccesses_set)); 
    cls->defineProperty("nextAccesses", _SE(js_cc_gfx_GeneralBarrierInfo_nextAccesses_get), _SE(js_cc_gfx_GeneralBarrierInfo_nextAccesses_set)); 
    cls->defineProperty("type", _SE(js_cc_gfx_GeneralBarrierInfo_type_get), _SE(js_cc_gfx_GeneralBarrierInfo_type_set)); 
    cls->defineProperty("_padding", _SE(js_cc_gfx_GeneralBarrierInfo__padding_get), _SE(js_cc_gfx_GeneralBarrierInfo__padding_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_GeneralBarrierInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_GeneralBarrierInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::GeneralBarrierInfo>(cls);
    
    __jsb_cc_gfx_GeneralBarrierInfo_proto = cls->getProto();
    __jsb_cc_gfx_GeneralBarrierInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_TextureBarrierInfo_class = nullptr;
se::Object* __jsb_cc_gfx_TextureBarrierInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_TextureBarrierInfo) 

static bool js_cc_gfx_TextureBarrierInfo_prevAccesses_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->prevAccesses, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBarrierInfo_prevAccesses_set) 

static bool js_cc_gfx_TextureBarrierInfo_prevAccesses_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->prevAccesses, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->prevAccesses, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBarrierInfo_prevAccesses_get) 

static bool js_cc_gfx_TextureBarrierInfo_nextAccesses_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->nextAccesses, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBarrierInfo_nextAccesses_set) 

static bool js_cc_gfx_TextureBarrierInfo_nextAccesses_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->nextAccesses, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->nextAccesses, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBarrierInfo_nextAccesses_get) 

static bool js_cc_gfx_TextureBarrierInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->type, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBarrierInfo_type_set) 

static bool js_cc_gfx_TextureBarrierInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->type, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->type, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBarrierInfo_type_get) 

static bool js_cc_gfx_TextureBarrierInfo_baseMipLevel_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->baseMipLevel, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBarrierInfo_baseMipLevel_set) 

static bool js_cc_gfx_TextureBarrierInfo_baseMipLevel_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->baseMipLevel, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBarrierInfo_baseMipLevel_get) 

static bool js_cc_gfx_TextureBarrierInfo_levelCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->levelCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBarrierInfo_levelCount_set) 

static bool js_cc_gfx_TextureBarrierInfo_levelCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->levelCount, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBarrierInfo_levelCount_get) 

static bool js_cc_gfx_TextureBarrierInfo_baseSlice_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->baseSlice, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBarrierInfo_baseSlice_set) 

static bool js_cc_gfx_TextureBarrierInfo_baseSlice_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->baseSlice, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBarrierInfo_baseSlice_get) 

static bool js_cc_gfx_TextureBarrierInfo_sliceCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->sliceCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBarrierInfo_sliceCount_set) 

static bool js_cc_gfx_TextureBarrierInfo_sliceCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->sliceCount, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBarrierInfo_sliceCount_get) 

static bool js_cc_gfx_TextureBarrierInfo_discardContents_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->discardContents, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBarrierInfo_discardContents_set) 

static bool js_cc_gfx_TextureBarrierInfo_discardContents_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->discardContents, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBarrierInfo_discardContents_get) 

static bool js_cc_gfx_TextureBarrierInfo_srcQueue_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->srcQueue, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBarrierInfo_srcQueue_set) 

static bool js_cc_gfx_TextureBarrierInfo_srcQueue_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->srcQueue, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->srcQueue, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBarrierInfo_srcQueue_get) 

static bool js_cc_gfx_TextureBarrierInfo_dstQueue_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->dstQueue, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_TextureBarrierInfo_dstQueue_set) 

static bool js_cc_gfx_TextureBarrierInfo_dstQueue_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->dstQueue, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->dstQueue, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_TextureBarrierInfo_dstQueue_get) 

static bool js_cc_gfx_TextureBarrierInfo_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrierInfo *arg1 = (cc::gfx::TextureBarrierInfo *) NULL ;
    cc::gfx::TextureBarrierInfo *arg2 = 0 ;
    cc::gfx::TextureBarrierInfo temp2 ;
    cc::gfx::TextureBarrierInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::TextureBarrierInfo *) &(arg1)->copy((cc::gfx::TextureBarrierInfo const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_TextureBarrierInfo_copy) 

static bool js_new_cc_gfx_TextureBarrierInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::TextureBarrierInfo *result;
    result = (cc::gfx::TextureBarrierInfo *)new cc::gfx::TextureBarrierInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_TextureBarrierInfo, __jsb_cc_gfx_TextureBarrierInfo_class, js_delete_cc_gfx_TextureBarrierInfo)

static bool js_delete_cc_gfx_TextureBarrierInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_TextureBarrierInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::TextureBarrierInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::TextureBarrierInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("prevAccesses", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->prevAccesses), ctx);
    }
    
    
    json->getProperty("nextAccesses", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->nextAccesses), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("baseMipLevel", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->baseMipLevel), ctx);
    }
    
    
    json->getProperty("levelCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->levelCount), ctx);
    }
    
    
    json->getProperty("baseSlice", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->baseSlice), ctx);
    }
    
    
    json->getProperty("sliceCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->sliceCount), ctx);
    }
    
    
    json->getProperty("discardContents", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->discardContents), ctx);
    }
    
    
    json->getProperty("srcQueue", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->srcQueue), ctx);
    }
    
    
    json->getProperty("dstQueue", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dstQueue), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_TextureBarrierInfo(se::Object* obj) {
    auto* cls = se::Class::create("TextureBarrierInfo", obj, nullptr, _SE(js_new_cc_gfx_TextureBarrierInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("prevAccesses", _SE(js_cc_gfx_TextureBarrierInfo_prevAccesses_get), _SE(js_cc_gfx_TextureBarrierInfo_prevAccesses_set)); 
    cls->defineProperty("nextAccesses", _SE(js_cc_gfx_TextureBarrierInfo_nextAccesses_get), _SE(js_cc_gfx_TextureBarrierInfo_nextAccesses_set)); 
    cls->defineProperty("type", _SE(js_cc_gfx_TextureBarrierInfo_type_get), _SE(js_cc_gfx_TextureBarrierInfo_type_set)); 
    cls->defineProperty("baseMipLevel", _SE(js_cc_gfx_TextureBarrierInfo_baseMipLevel_get), _SE(js_cc_gfx_TextureBarrierInfo_baseMipLevel_set)); 
    cls->defineProperty("levelCount", _SE(js_cc_gfx_TextureBarrierInfo_levelCount_get), _SE(js_cc_gfx_TextureBarrierInfo_levelCount_set)); 
    cls->defineProperty("baseSlice", _SE(js_cc_gfx_TextureBarrierInfo_baseSlice_get), _SE(js_cc_gfx_TextureBarrierInfo_baseSlice_set)); 
    cls->defineProperty("sliceCount", _SE(js_cc_gfx_TextureBarrierInfo_sliceCount_get), _SE(js_cc_gfx_TextureBarrierInfo_sliceCount_set)); 
    cls->defineProperty("discardContents", _SE(js_cc_gfx_TextureBarrierInfo_discardContents_get), _SE(js_cc_gfx_TextureBarrierInfo_discardContents_set)); 
    cls->defineProperty("srcQueue", _SE(js_cc_gfx_TextureBarrierInfo_srcQueue_get), _SE(js_cc_gfx_TextureBarrierInfo_srcQueue_set)); 
    cls->defineProperty("dstQueue", _SE(js_cc_gfx_TextureBarrierInfo_dstQueue_get), _SE(js_cc_gfx_TextureBarrierInfo_dstQueue_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_TextureBarrierInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_TextureBarrierInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::TextureBarrierInfo>(cls);
    
    __jsb_cc_gfx_TextureBarrierInfo_proto = cls->getProto();
    __jsb_cc_gfx_TextureBarrierInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_BufferBarrierInfo_class = nullptr;
se::Object* __jsb_cc_gfx_BufferBarrierInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_BufferBarrierInfo) 

static bool js_cc_gfx_BufferBarrierInfo_prevAccesses_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->prevAccesses, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferBarrierInfo_prevAccesses_set) 

static bool js_cc_gfx_BufferBarrierInfo_prevAccesses_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->prevAccesses, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->prevAccesses, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferBarrierInfo_prevAccesses_get) 

static bool js_cc_gfx_BufferBarrierInfo_nextAccesses_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->nextAccesses, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferBarrierInfo_nextAccesses_set) 

static bool js_cc_gfx_BufferBarrierInfo_nextAccesses_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->nextAccesses, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->nextAccesses, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferBarrierInfo_nextAccesses_get) 

static bool js_cc_gfx_BufferBarrierInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->type, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferBarrierInfo_type_set) 

static bool js_cc_gfx_BufferBarrierInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->type, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->type, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferBarrierInfo_type_get) 

static bool js_cc_gfx_BufferBarrierInfo_offset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->offset, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferBarrierInfo_offset_set) 

static bool js_cc_gfx_BufferBarrierInfo_offset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->offset, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferBarrierInfo_offset_get) 

static bool js_cc_gfx_BufferBarrierInfo_size_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->size, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferBarrierInfo_size_set) 

static bool js_cc_gfx_BufferBarrierInfo_size_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->size, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferBarrierInfo_size_get) 

static bool js_cc_gfx_BufferBarrierInfo_discardContents_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->discardContents, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferBarrierInfo_discardContents_set) 

static bool js_cc_gfx_BufferBarrierInfo_discardContents_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->discardContents, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferBarrierInfo_discardContents_get) 

static bool js_cc_gfx_BufferBarrierInfo_srcQueue_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->srcQueue, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferBarrierInfo_srcQueue_set) 

static bool js_cc_gfx_BufferBarrierInfo_srcQueue_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->srcQueue, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->srcQueue, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferBarrierInfo_srcQueue_get) 

static bool js_cc_gfx_BufferBarrierInfo_dstQueue_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->dstQueue, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BufferBarrierInfo_dstQueue_set) 

static bool js_cc_gfx_BufferBarrierInfo_dstQueue_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->dstQueue, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->dstQueue, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BufferBarrierInfo_dstQueue_get) 

static bool js_cc_gfx_BufferBarrierInfo_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferBarrierInfo *arg1 = (cc::gfx::BufferBarrierInfo *) NULL ;
    cc::gfx::BufferBarrierInfo *arg2 = 0 ;
    cc::gfx::BufferBarrierInfo temp2 ;
    cc::gfx::BufferBarrierInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrierInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::BufferBarrierInfo *) &(arg1)->copy((cc::gfx::BufferBarrierInfo const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BufferBarrierInfo_copy) 

static bool js_new_cc_gfx_BufferBarrierInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::BufferBarrierInfo *result;
    result = (cc::gfx::BufferBarrierInfo *)new cc::gfx::BufferBarrierInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_BufferBarrierInfo, __jsb_cc_gfx_BufferBarrierInfo_class, js_delete_cc_gfx_BufferBarrierInfo)

static bool js_delete_cc_gfx_BufferBarrierInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_BufferBarrierInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::BufferBarrierInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::BufferBarrierInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("prevAccesses", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->prevAccesses), ctx);
    }
    
    
    json->getProperty("nextAccesses", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->nextAccesses), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("offset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->offset), ctx);
    }
    
    
    json->getProperty("size", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->size), ctx);
    }
    
    
    json->getProperty("discardContents", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->discardContents), ctx);
    }
    
    
    json->getProperty("srcQueue", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->srcQueue), ctx);
    }
    
    
    json->getProperty("dstQueue", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dstQueue), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_BufferBarrierInfo(se::Object* obj) {
    auto* cls = se::Class::create("BufferBarrierInfo", obj, nullptr, _SE(js_new_cc_gfx_BufferBarrierInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("prevAccesses", _SE(js_cc_gfx_BufferBarrierInfo_prevAccesses_get), _SE(js_cc_gfx_BufferBarrierInfo_prevAccesses_set)); 
    cls->defineProperty("nextAccesses", _SE(js_cc_gfx_BufferBarrierInfo_nextAccesses_get), _SE(js_cc_gfx_BufferBarrierInfo_nextAccesses_set)); 
    cls->defineProperty("type", _SE(js_cc_gfx_BufferBarrierInfo_type_get), _SE(js_cc_gfx_BufferBarrierInfo_type_set)); 
    cls->defineProperty("offset", _SE(js_cc_gfx_BufferBarrierInfo_offset_get), _SE(js_cc_gfx_BufferBarrierInfo_offset_set)); 
    cls->defineProperty("size", _SE(js_cc_gfx_BufferBarrierInfo_size_get), _SE(js_cc_gfx_BufferBarrierInfo_size_set)); 
    cls->defineProperty("discardContents", _SE(js_cc_gfx_BufferBarrierInfo_discardContents_get), _SE(js_cc_gfx_BufferBarrierInfo_discardContents_set)); 
    cls->defineProperty("srcQueue", _SE(js_cc_gfx_BufferBarrierInfo_srcQueue_get), _SE(js_cc_gfx_BufferBarrierInfo_srcQueue_set)); 
    cls->defineProperty("dstQueue", _SE(js_cc_gfx_BufferBarrierInfo_dstQueue_get), _SE(js_cc_gfx_BufferBarrierInfo_dstQueue_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_BufferBarrierInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_BufferBarrierInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::BufferBarrierInfo>(cls);
    
    __jsb_cc_gfx_BufferBarrierInfo_proto = cls->getProto();
    __jsb_cc_gfx_BufferBarrierInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_FramebufferInfo_class = nullptr;
se::Object* __jsb_cc_gfx_FramebufferInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_FramebufferInfo) 

static bool js_cc_gfx_FramebufferInfo_renderPass_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::FramebufferInfo *arg1 = (cc::gfx::FramebufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FramebufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->renderPass, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_FramebufferInfo_renderPass_set) 

static bool js_cc_gfx_FramebufferInfo_renderPass_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::FramebufferInfo *arg1 = (cc::gfx::FramebufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FramebufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->renderPass, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->renderPass, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_FramebufferInfo_renderPass_get) 

static bool js_cc_gfx_FramebufferInfo_colorTextures_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::FramebufferInfo *arg1 = (cc::gfx::FramebufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FramebufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->colorTextures, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_FramebufferInfo_colorTextures_set) 

static bool js_cc_gfx_FramebufferInfo_colorTextures_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::FramebufferInfo *arg1 = (cc::gfx::FramebufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FramebufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->colorTextures, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->colorTextures, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_FramebufferInfo_colorTextures_get) 

static bool js_cc_gfx_FramebufferInfo_depthStencilTexture_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::FramebufferInfo *arg1 = (cc::gfx::FramebufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FramebufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthStencilTexture, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_FramebufferInfo_depthStencilTexture_set) 

static bool js_cc_gfx_FramebufferInfo_depthStencilTexture_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::FramebufferInfo *arg1 = (cc::gfx::FramebufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FramebufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthStencilTexture, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthStencilTexture, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_FramebufferInfo_depthStencilTexture_get) 

static bool js_cc_gfx_FramebufferInfo_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::FramebufferInfo *arg1 = (cc::gfx::FramebufferInfo *) NULL ;
    cc::gfx::FramebufferInfo *arg2 = 0 ;
    cc::gfx::FramebufferInfo temp2 ;
    cc::gfx::FramebufferInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::FramebufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::FramebufferInfo *) &(arg1)->copy((cc::gfx::FramebufferInfo const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_FramebufferInfo_copy) 

static bool js_new_cc_gfx_FramebufferInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::FramebufferInfo *result;
    result = (cc::gfx::FramebufferInfo *)new cc::gfx::FramebufferInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_FramebufferInfo, __jsb_cc_gfx_FramebufferInfo_class, js_delete_cc_gfx_FramebufferInfo)

static bool js_delete_cc_gfx_FramebufferInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_FramebufferInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::FramebufferInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::FramebufferInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("renderPass", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->renderPass), ctx);
    }
    
    
    json->getProperty("colorTextures", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->colorTextures), ctx);
    }
    
    
    json->getProperty("depthStencilTexture", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthStencilTexture), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_FramebufferInfo(se::Object* obj) {
    auto* cls = se::Class::create("FramebufferInfo", obj, nullptr, _SE(js_new_cc_gfx_FramebufferInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("renderPass", _SE(js_cc_gfx_FramebufferInfo_renderPass_get), _SE(js_cc_gfx_FramebufferInfo_renderPass_set)); 
    cls->defineProperty("colorTextures", _SE(js_cc_gfx_FramebufferInfo_colorTextures_get), _SE(js_cc_gfx_FramebufferInfo_colorTextures_set)); 
    cls->defineProperty("depthStencilTexture", _SE(js_cc_gfx_FramebufferInfo_depthStencilTexture_get), _SE(js_cc_gfx_FramebufferInfo_depthStencilTexture_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_FramebufferInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_FramebufferInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::FramebufferInfo>(cls);
    
    __jsb_cc_gfx_FramebufferInfo_proto = cls->getProto();
    __jsb_cc_gfx_FramebufferInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DescriptorSetLayoutBinding_class = nullptr;
se::Object* __jsb_cc_gfx_DescriptorSetLayoutBinding_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DescriptorSetLayoutBinding) 

static bool js_cc_gfx_DescriptorSetLayoutBinding_binding_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetLayoutBinding *arg1 = (cc::gfx::DescriptorSetLayoutBinding *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutBinding>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->binding, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DescriptorSetLayoutBinding_binding_set) 

static bool js_cc_gfx_DescriptorSetLayoutBinding_binding_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding *arg1 = (cc::gfx::DescriptorSetLayoutBinding *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutBinding>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->binding, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DescriptorSetLayoutBinding_binding_get) 

static bool js_cc_gfx_DescriptorSetLayoutBinding_descriptorType_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetLayoutBinding *arg1 = (cc::gfx::DescriptorSetLayoutBinding *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutBinding>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->descriptorType, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DescriptorSetLayoutBinding_descriptorType_set) 

static bool js_cc_gfx_DescriptorSetLayoutBinding_descriptorType_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding *arg1 = (cc::gfx::DescriptorSetLayoutBinding *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutBinding>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->descriptorType, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->descriptorType, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DescriptorSetLayoutBinding_descriptorType_get) 

static bool js_cc_gfx_DescriptorSetLayoutBinding_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetLayoutBinding *arg1 = (cc::gfx::DescriptorSetLayoutBinding *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutBinding>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DescriptorSetLayoutBinding_count_set) 

static bool js_cc_gfx_DescriptorSetLayoutBinding_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding *arg1 = (cc::gfx::DescriptorSetLayoutBinding *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutBinding>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DescriptorSetLayoutBinding_count_get) 

static bool js_cc_gfx_DescriptorSetLayoutBinding_stageFlags_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetLayoutBinding *arg1 = (cc::gfx::DescriptorSetLayoutBinding *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutBinding>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stageFlags, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DescriptorSetLayoutBinding_stageFlags_set) 

static bool js_cc_gfx_DescriptorSetLayoutBinding_stageFlags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding *arg1 = (cc::gfx::DescriptorSetLayoutBinding *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutBinding>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stageFlags, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stageFlags, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DescriptorSetLayoutBinding_stageFlags_get) 

static bool js_cc_gfx_DescriptorSetLayoutBinding_immutableSamplers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetLayoutBinding *arg1 = (cc::gfx::DescriptorSetLayoutBinding *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutBinding>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->immutableSamplers, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DescriptorSetLayoutBinding_immutableSamplers_set) 

static bool js_cc_gfx_DescriptorSetLayoutBinding_immutableSamplers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding *arg1 = (cc::gfx::DescriptorSetLayoutBinding *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutBinding>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->immutableSamplers, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->immutableSamplers, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DescriptorSetLayoutBinding_immutableSamplers_get) 

static bool js_cc_gfx_DescriptorSetLayoutBinding_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetLayoutBinding *arg1 = (cc::gfx::DescriptorSetLayoutBinding *) NULL ;
    cc::gfx::DescriptorSetLayoutBinding *arg2 = 0 ;
    cc::gfx::DescriptorSetLayoutBinding temp2 ;
    cc::gfx::DescriptorSetLayoutBinding *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutBinding>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::DescriptorSetLayoutBinding *) &(arg1)->copy((cc::gfx::DescriptorSetLayoutBinding const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSetLayoutBinding_copy) 

static bool js_new_cc_gfx_DescriptorSetLayoutBinding(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::DescriptorSetLayoutBinding *result;
    result = (cc::gfx::DescriptorSetLayoutBinding *)new cc::gfx::DescriptorSetLayoutBinding();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_DescriptorSetLayoutBinding, __jsb_cc_gfx_DescriptorSetLayoutBinding_class, js_delete_cc_gfx_DescriptorSetLayoutBinding)

static bool js_delete_cc_gfx_DescriptorSetLayoutBinding(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DescriptorSetLayoutBinding) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::DescriptorSetLayoutBinding * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::DescriptorSetLayoutBinding*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("binding", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->binding), ctx);
    }
    
    
    json->getProperty("descriptorType", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->descriptorType), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("stageFlags", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stageFlags), ctx);
    }
    
    
    json->getProperty("immutableSamplers", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->immutableSamplers), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_DescriptorSetLayoutBinding(se::Object* obj) {
    auto* cls = se::Class::create("DescriptorSetLayoutBinding", obj, nullptr, _SE(js_new_cc_gfx_DescriptorSetLayoutBinding)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("binding", _SE(js_cc_gfx_DescriptorSetLayoutBinding_binding_get), _SE(js_cc_gfx_DescriptorSetLayoutBinding_binding_set)); 
    cls->defineProperty("descriptorType", _SE(js_cc_gfx_DescriptorSetLayoutBinding_descriptorType_get), _SE(js_cc_gfx_DescriptorSetLayoutBinding_descriptorType_set)); 
    cls->defineProperty("count", _SE(js_cc_gfx_DescriptorSetLayoutBinding_count_get), _SE(js_cc_gfx_DescriptorSetLayoutBinding_count_set)); 
    cls->defineProperty("stageFlags", _SE(js_cc_gfx_DescriptorSetLayoutBinding_stageFlags_get), _SE(js_cc_gfx_DescriptorSetLayoutBinding_stageFlags_set)); 
    cls->defineProperty("immutableSamplers", _SE(js_cc_gfx_DescriptorSetLayoutBinding_immutableSamplers_get), _SE(js_cc_gfx_DescriptorSetLayoutBinding_immutableSamplers_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_DescriptorSetLayoutBinding_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DescriptorSetLayoutBinding));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DescriptorSetLayoutBinding>(cls);
    
    __jsb_cc_gfx_DescriptorSetLayoutBinding_proto = cls->getProto();
    __jsb_cc_gfx_DescriptorSetLayoutBinding_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DescriptorSetLayoutInfo_class = nullptr;
se::Object* __jsb_cc_gfx_DescriptorSetLayoutInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DescriptorSetLayoutInfo) 

static bool js_cc_gfx_DescriptorSetLayoutInfo_bindings_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetLayoutInfo *arg1 = (cc::gfx::DescriptorSetLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->bindings, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DescriptorSetLayoutInfo_bindings_set) 

static bool js_cc_gfx_DescriptorSetLayoutInfo_bindings_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutInfo *arg1 = (cc::gfx::DescriptorSetLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->bindings, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->bindings, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DescriptorSetLayoutInfo_bindings_get) 

static bool js_cc_gfx_DescriptorSetLayoutInfo_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetLayoutInfo *arg1 = (cc::gfx::DescriptorSetLayoutInfo *) NULL ;
    cc::gfx::DescriptorSetLayoutInfo *arg2 = 0 ;
    cc::gfx::DescriptorSetLayoutInfo temp2 ;
    cc::gfx::DescriptorSetLayoutInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayoutInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::DescriptorSetLayoutInfo *) &(arg1)->copy((cc::gfx::DescriptorSetLayoutInfo const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSetLayoutInfo_copy) 

static bool js_new_cc_gfx_DescriptorSetLayoutInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::DescriptorSetLayoutInfo *result;
    result = (cc::gfx::DescriptorSetLayoutInfo *)new cc::gfx::DescriptorSetLayoutInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_DescriptorSetLayoutInfo, __jsb_cc_gfx_DescriptorSetLayoutInfo_class, js_delete_cc_gfx_DescriptorSetLayoutInfo)

static bool js_delete_cc_gfx_DescriptorSetLayoutInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DescriptorSetLayoutInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::DescriptorSetLayoutInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::DescriptorSetLayoutInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("bindings", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->bindings), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_DescriptorSetLayoutInfo(se::Object* obj) {
    auto* cls = se::Class::create("DescriptorSetLayoutInfo", obj, nullptr, _SE(js_new_cc_gfx_DescriptorSetLayoutInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("bindings", _SE(js_cc_gfx_DescriptorSetLayoutInfo_bindings_get), _SE(js_cc_gfx_DescriptorSetLayoutInfo_bindings_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_DescriptorSetLayoutInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DescriptorSetLayoutInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DescriptorSetLayoutInfo>(cls);
    
    __jsb_cc_gfx_DescriptorSetLayoutInfo_proto = cls->getProto();
    __jsb_cc_gfx_DescriptorSetLayoutInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DescriptorSetInfo_class = nullptr;
se::Object* __jsb_cc_gfx_DescriptorSetInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DescriptorSetInfo) 

static bool js_cc_gfx_DescriptorSetInfo_layout_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetInfo *arg1 = (cc::gfx::DescriptorSetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->layout, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DescriptorSetInfo_layout_set) 

static bool js_cc_gfx_DescriptorSetInfo_layout_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetInfo *arg1 = (cc::gfx::DescriptorSetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->layout, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->layout, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DescriptorSetInfo_layout_get) 

static bool js_cc_gfx_DescriptorSetInfo_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetInfo *arg1 = (cc::gfx::DescriptorSetInfo *) NULL ;
    cc::gfx::DescriptorSetInfo *arg2 = 0 ;
    cc::gfx::DescriptorSetInfo temp2 ;
    cc::gfx::DescriptorSetInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::DescriptorSetInfo *) &(arg1)->copy((cc::gfx::DescriptorSetInfo const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSetInfo_copy) 

static bool js_new_cc_gfx_DescriptorSetInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::DescriptorSetInfo *result;
    result = (cc::gfx::DescriptorSetInfo *)new cc::gfx::DescriptorSetInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_DescriptorSetInfo, __jsb_cc_gfx_DescriptorSetInfo_class, js_delete_cc_gfx_DescriptorSetInfo)

static bool js_delete_cc_gfx_DescriptorSetInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DescriptorSetInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::DescriptorSetInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::DescriptorSetInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("layout", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->layout), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_DescriptorSetInfo(se::Object* obj) {
    auto* cls = se::Class::create("DescriptorSetInfo", obj, nullptr, _SE(js_new_cc_gfx_DescriptorSetInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("layout", _SE(js_cc_gfx_DescriptorSetInfo_layout_get), _SE(js_cc_gfx_DescriptorSetInfo_layout_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_DescriptorSetInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DescriptorSetInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DescriptorSetInfo>(cls);
    
    __jsb_cc_gfx_DescriptorSetInfo_proto = cls->getProto();
    __jsb_cc_gfx_DescriptorSetInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_PipelineLayoutInfo_class = nullptr;
se::Object* __jsb_cc_gfx_PipelineLayoutInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_PipelineLayoutInfo) 

static bool js_cc_gfx_PipelineLayoutInfo_setLayouts_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineLayoutInfo *arg1 = (cc::gfx::PipelineLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineLayoutInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->setLayouts, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_PipelineLayoutInfo_setLayouts_set) 

static bool js_cc_gfx_PipelineLayoutInfo_setLayouts_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineLayoutInfo *arg1 = (cc::gfx::PipelineLayoutInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineLayoutInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->setLayouts, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->setLayouts, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineLayoutInfo_setLayouts_get) 

static bool js_cc_gfx_PipelineLayoutInfo_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineLayoutInfo *arg1 = (cc::gfx::PipelineLayoutInfo *) NULL ;
    cc::gfx::PipelineLayoutInfo *arg2 = 0 ;
    cc::gfx::PipelineLayoutInfo temp2 ;
    cc::gfx::PipelineLayoutInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineLayoutInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::PipelineLayoutInfo *) &(arg1)->copy((cc::gfx::PipelineLayoutInfo const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_PipelineLayoutInfo_copy) 

static bool js_new_cc_gfx_PipelineLayoutInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::PipelineLayoutInfo *result;
    result = (cc::gfx::PipelineLayoutInfo *)new cc::gfx::PipelineLayoutInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_PipelineLayoutInfo, __jsb_cc_gfx_PipelineLayoutInfo_class, js_delete_cc_gfx_PipelineLayoutInfo)

static bool js_delete_cc_gfx_PipelineLayoutInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_PipelineLayoutInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::PipelineLayoutInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::PipelineLayoutInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("setLayouts", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->setLayouts), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_PipelineLayoutInfo(se::Object* obj) {
    auto* cls = se::Class::create("PipelineLayoutInfo", obj, nullptr, _SE(js_new_cc_gfx_PipelineLayoutInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("setLayouts", _SE(js_cc_gfx_PipelineLayoutInfo_setLayouts_get), _SE(js_cc_gfx_PipelineLayoutInfo_setLayouts_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_PipelineLayoutInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_PipelineLayoutInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::PipelineLayoutInfo>(cls);
    
    __jsb_cc_gfx_PipelineLayoutInfo_proto = cls->getProto();
    __jsb_cc_gfx_PipelineLayoutInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_InputState_class = nullptr;
se::Object* __jsb_cc_gfx_InputState_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_InputState) 

static bool js_cc_gfx_InputState_attributes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputState *arg1 = (cc::gfx::InputState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->attributes, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_InputState_attributes_set) 

static bool js_cc_gfx_InputState_attributes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputState *arg1 = (cc::gfx::InputState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->attributes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->attributes, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputState_attributes_get) 

static bool js_cc_gfx_InputState_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputState *arg1 = (cc::gfx::InputState *) NULL ;
    cc::gfx::InputState *arg2 = 0 ;
    cc::gfx::InputState temp2 ;
    cc::gfx::InputState *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::InputState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::InputState *) &(arg1)->copy((cc::gfx::InputState const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_InputState_copy) 

static bool js_new_cc_gfx_InputState(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::InputState *result;
    result = (cc::gfx::InputState *)new cc::gfx::InputState();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_InputState, __jsb_cc_gfx_InputState_class, js_delete_cc_gfx_InputState)

static bool js_delete_cc_gfx_InputState(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_InputState) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::InputState * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::InputState*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("attributes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->attributes), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_InputState(se::Object* obj) {
    auto* cls = se::Class::create("InputState", obj, nullptr, _SE(js_new_cc_gfx_InputState)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("attributes", _SE(js_cc_gfx_InputState_attributes_get), _SE(js_cc_gfx_InputState_attributes_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_InputState_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_InputState));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::InputState>(cls);
    
    __jsb_cc_gfx_InputState_proto = cls->getProto();
    __jsb_cc_gfx_InputState_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_RasterizerState_class = nullptr;
se::Object* __jsb_cc_gfx_RasterizerState_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_RasterizerState) 

static bool js_cc_gfx_RasterizerState_isDiscard_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->isDiscard, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RasterizerState_isDiscard_set) 

static bool js_cc_gfx_RasterizerState_isDiscard_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->isDiscard, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RasterizerState_isDiscard_get) 

static bool js_cc_gfx_RasterizerState_polygonMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->polygonMode, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RasterizerState_polygonMode_set) 

static bool js_cc_gfx_RasterizerState_polygonMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->polygonMode, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->polygonMode, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RasterizerState_polygonMode_get) 

static bool js_cc_gfx_RasterizerState_shadeModel_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->shadeModel, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RasterizerState_shadeModel_set) 

static bool js_cc_gfx_RasterizerState_shadeModel_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->shadeModel, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->shadeModel, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RasterizerState_shadeModel_get) 

static bool js_cc_gfx_RasterizerState_cullMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->cullMode, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RasterizerState_cullMode_set) 

static bool js_cc_gfx_RasterizerState_cullMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->cullMode, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->cullMode, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RasterizerState_cullMode_get) 

static bool js_cc_gfx_RasterizerState_isFrontFaceCCW_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->isFrontFaceCCW, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RasterizerState_isFrontFaceCCW_set) 

static bool js_cc_gfx_RasterizerState_isFrontFaceCCW_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->isFrontFaceCCW, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RasterizerState_isFrontFaceCCW_get) 

static bool js_cc_gfx_RasterizerState_depthBiasEnabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthBiasEnabled, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RasterizerState_depthBiasEnabled_set) 

static bool js_cc_gfx_RasterizerState_depthBiasEnabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthBiasEnabled, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RasterizerState_depthBiasEnabled_get) 

static bool js_cc_gfx_RasterizerState_depthBias_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthBias, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RasterizerState_depthBias_set) 

static bool js_cc_gfx_RasterizerState_depthBias_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthBias, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RasterizerState_depthBias_get) 

static bool js_cc_gfx_RasterizerState_depthBiasClamp_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthBiasClamp, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RasterizerState_depthBiasClamp_set) 

static bool js_cc_gfx_RasterizerState_depthBiasClamp_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthBiasClamp, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RasterizerState_depthBiasClamp_get) 

static bool js_cc_gfx_RasterizerState_depthBiasSlop_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthBiasSlop, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RasterizerState_depthBiasSlop_set) 

static bool js_cc_gfx_RasterizerState_depthBiasSlop_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthBiasSlop, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RasterizerState_depthBiasSlop_get) 

static bool js_cc_gfx_RasterizerState_isDepthClip_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->isDepthClip, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RasterizerState_isDepthClip_set) 

static bool js_cc_gfx_RasterizerState_isDepthClip_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->isDepthClip, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RasterizerState_isDepthClip_get) 

static bool js_cc_gfx_RasterizerState_isMultisample_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->isMultisample, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RasterizerState_isMultisample_set) 

static bool js_cc_gfx_RasterizerState_isMultisample_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->isMultisample, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RasterizerState_isMultisample_get) 

static bool js_cc_gfx_RasterizerState_lineWidth_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->lineWidth, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_RasterizerState_lineWidth_set) 

static bool js_cc_gfx_RasterizerState_lineWidth_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->lineWidth, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RasterizerState_lineWidth_get) 

static bool js_cc_gfx_RasterizerState_reset(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    if (nullptr == arg1) return true;
    (arg1)->reset();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_RasterizerState_reset) 

static bool js_cc_gfx_RasterizerState_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RasterizerState *arg1 = (cc::gfx::RasterizerState *) NULL ;
    cc::gfx::RasterizerState *arg2 = 0 ;
    cc::gfx::RasterizerState temp2 ;
    cc::gfx::RasterizerState *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::RasterizerState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::RasterizerState *) &(arg1)->copy((cc::gfx::RasterizerState const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_RasterizerState_copy) 

static bool js_new_cc_gfx_RasterizerState(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::RasterizerState *result;
    result = (cc::gfx::RasterizerState *)new cc::gfx::RasterizerState();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_RasterizerState, __jsb_cc_gfx_RasterizerState_class, js_delete_cc_gfx_RasterizerState)

static bool js_delete_cc_gfx_RasterizerState(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_RasterizerState) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::RasterizerState * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::RasterizerState*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("isDiscard", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isDiscard), ctx);
    }
    
    
    json->getProperty("polygonMode", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->polygonMode), ctx);
    }
    
    
    json->getProperty("shadeModel", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->shadeModel), ctx);
    }
    
    
    json->getProperty("cullMode", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->cullMode), ctx);
    }
    
    
    json->getProperty("isFrontFaceCCW", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isFrontFaceCCW), ctx);
    }
    
    
    json->getProperty("depthBiasEnabled", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthBiasEnabled), ctx);
    }
    
    
    json->getProperty("depthBias", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthBias), ctx);
    }
    
    
    json->getProperty("depthBiasClamp", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthBiasClamp), ctx);
    }
    
    
    json->getProperty("depthBiasSlop", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthBiasSlop), ctx);
    }
    
    
    json->getProperty("isDepthClip", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isDepthClip), ctx);
    }
    
    
    json->getProperty("isMultisample", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isMultisample), ctx);
    }
    
    
    json->getProperty("lineWidth", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->lineWidth), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_RasterizerState(se::Object* obj) {
    auto* cls = se::Class::create("RasterizerState", obj, nullptr, _SE(js_new_cc_gfx_RasterizerState)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("isDiscard", _SE(js_cc_gfx_RasterizerState_isDiscard_get), _SE(js_cc_gfx_RasterizerState_isDiscard_set)); 
    cls->defineProperty("polygonMode", _SE(js_cc_gfx_RasterizerState_polygonMode_get), _SE(js_cc_gfx_RasterizerState_polygonMode_set)); 
    cls->defineProperty("shadeModel", _SE(js_cc_gfx_RasterizerState_shadeModel_get), _SE(js_cc_gfx_RasterizerState_shadeModel_set)); 
    cls->defineProperty("cullMode", _SE(js_cc_gfx_RasterizerState_cullMode_get), _SE(js_cc_gfx_RasterizerState_cullMode_set)); 
    cls->defineProperty("isFrontFaceCCW", _SE(js_cc_gfx_RasterizerState_isFrontFaceCCW_get), _SE(js_cc_gfx_RasterizerState_isFrontFaceCCW_set)); 
    cls->defineProperty("depthBiasEnabled", _SE(js_cc_gfx_RasterizerState_depthBiasEnabled_get), _SE(js_cc_gfx_RasterizerState_depthBiasEnabled_set)); 
    cls->defineProperty("depthBias", _SE(js_cc_gfx_RasterizerState_depthBias_get), _SE(js_cc_gfx_RasterizerState_depthBias_set)); 
    cls->defineProperty("depthBiasClamp", _SE(js_cc_gfx_RasterizerState_depthBiasClamp_get), _SE(js_cc_gfx_RasterizerState_depthBiasClamp_set)); 
    cls->defineProperty("depthBiasSlop", _SE(js_cc_gfx_RasterizerState_depthBiasSlop_get), _SE(js_cc_gfx_RasterizerState_depthBiasSlop_set)); 
    cls->defineProperty("isDepthClip", _SE(js_cc_gfx_RasterizerState_isDepthClip_get), _SE(js_cc_gfx_RasterizerState_isDepthClip_set)); 
    cls->defineProperty("isMultisample", _SE(js_cc_gfx_RasterizerState_isMultisample_get), _SE(js_cc_gfx_RasterizerState_isMultisample_set)); 
    cls->defineProperty("lineWidth", _SE(js_cc_gfx_RasterizerState_lineWidth_get), _SE(js_cc_gfx_RasterizerState_lineWidth_set)); 
    
    cls->defineFunction("reset", _SE(js_cc_gfx_RasterizerState_reset)); 
    cls->defineFunction("copy", _SE(js_cc_gfx_RasterizerState_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_RasterizerState));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::RasterizerState>(cls);
    
    __jsb_cc_gfx_RasterizerState_proto = cls->getProto();
    __jsb_cc_gfx_RasterizerState_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DepthStencilState_class = nullptr;
se::Object* __jsb_cc_gfx_DepthStencilState_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DepthStencilState) 

static bool js_cc_gfx_DepthStencilState_depthTest_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthTest, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_depthTest_set) 

static bool js_cc_gfx_DepthStencilState_depthTest_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthTest, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_depthTest_get) 

static bool js_cc_gfx_DepthStencilState_depthWrite_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthWrite, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_depthWrite_set) 

static bool js_cc_gfx_DepthStencilState_depthWrite_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthWrite, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_depthWrite_get) 

static bool js_cc_gfx_DepthStencilState_depthFunc_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthFunc, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_depthFunc_set) 

static bool js_cc_gfx_DepthStencilState_depthFunc_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthFunc, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthFunc, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_depthFunc_get) 

static bool js_cc_gfx_DepthStencilState_stencilTestFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilTestFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilTestFront_set) 

static bool js_cc_gfx_DepthStencilState_stencilTestFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilTestFront, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilTestFront_get) 

static bool js_cc_gfx_DepthStencilState_stencilFuncFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilFuncFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilFuncFront_set) 

static bool js_cc_gfx_DepthStencilState_stencilFuncFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilFuncFront, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilFuncFront, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilFuncFront_get) 

static bool js_cc_gfx_DepthStencilState_stencilReadMaskFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilReadMaskFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilReadMaskFront_set) 

static bool js_cc_gfx_DepthStencilState_stencilReadMaskFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilReadMaskFront, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilReadMaskFront_get) 

static bool js_cc_gfx_DepthStencilState_stencilWriteMaskFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilWriteMaskFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilWriteMaskFront_set) 

static bool js_cc_gfx_DepthStencilState_stencilWriteMaskFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilWriteMaskFront, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilWriteMaskFront_get) 

static bool js_cc_gfx_DepthStencilState_stencilFailOpFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilFailOpFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilFailOpFront_set) 

static bool js_cc_gfx_DepthStencilState_stencilFailOpFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilFailOpFront, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilFailOpFront, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilFailOpFront_get) 

static bool js_cc_gfx_DepthStencilState_stencilZFailOpFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilZFailOpFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilZFailOpFront_set) 

static bool js_cc_gfx_DepthStencilState_stencilZFailOpFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilZFailOpFront, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilZFailOpFront, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilZFailOpFront_get) 

static bool js_cc_gfx_DepthStencilState_stencilPassOpFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilPassOpFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilPassOpFront_set) 

static bool js_cc_gfx_DepthStencilState_stencilPassOpFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilPassOpFront, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilPassOpFront, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilPassOpFront_get) 

static bool js_cc_gfx_DepthStencilState_stencilRefFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilRefFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilRefFront_set) 

static bool js_cc_gfx_DepthStencilState_stencilRefFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilRefFront, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilRefFront_get) 

static bool js_cc_gfx_DepthStencilState_stencilTestBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilTestBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilTestBack_set) 

static bool js_cc_gfx_DepthStencilState_stencilTestBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilTestBack, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilTestBack_get) 

static bool js_cc_gfx_DepthStencilState_stencilFuncBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilFuncBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilFuncBack_set) 

static bool js_cc_gfx_DepthStencilState_stencilFuncBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilFuncBack, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilFuncBack, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilFuncBack_get) 

static bool js_cc_gfx_DepthStencilState_stencilReadMaskBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilReadMaskBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilReadMaskBack_set) 

static bool js_cc_gfx_DepthStencilState_stencilReadMaskBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilReadMaskBack, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilReadMaskBack_get) 

static bool js_cc_gfx_DepthStencilState_stencilWriteMaskBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilWriteMaskBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilWriteMaskBack_set) 

static bool js_cc_gfx_DepthStencilState_stencilWriteMaskBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilWriteMaskBack, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilWriteMaskBack_get) 

static bool js_cc_gfx_DepthStencilState_stencilFailOpBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilFailOpBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilFailOpBack_set) 

static bool js_cc_gfx_DepthStencilState_stencilFailOpBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilFailOpBack, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilFailOpBack, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilFailOpBack_get) 

static bool js_cc_gfx_DepthStencilState_stencilZFailOpBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilZFailOpBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilZFailOpBack_set) 

static bool js_cc_gfx_DepthStencilState_stencilZFailOpBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilZFailOpBack, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilZFailOpBack, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilZFailOpBack_get) 

static bool js_cc_gfx_DepthStencilState_stencilPassOpBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilPassOpBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilPassOpBack_set) 

static bool js_cc_gfx_DepthStencilState_stencilPassOpBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilPassOpBack, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilPassOpBack, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilPassOpBack_get) 

static bool js_cc_gfx_DepthStencilState_stencilRefBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilRefBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DepthStencilState_stencilRefBack_set) 

static bool js_cc_gfx_DepthStencilState_stencilRefBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilRefBack, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DepthStencilState_stencilRefBack_get) 

static bool js_cc_gfx_DepthStencilState_reset(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    (arg1)->reset();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DepthStencilState_reset) 

static bool js_cc_gfx_DepthStencilState_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DepthStencilState *arg1 = (cc::gfx::DepthStencilState *) NULL ;
    cc::gfx::DepthStencilState *arg2 = 0 ;
    cc::gfx::DepthStencilState temp2 ;
    cc::gfx::DepthStencilState *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DepthStencilState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::DepthStencilState *) &(arg1)->copy((cc::gfx::DepthStencilState const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DepthStencilState_copy) 

static bool js_new_cc_gfx_DepthStencilState(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::DepthStencilState *result;
    result = (cc::gfx::DepthStencilState *)new cc::gfx::DepthStencilState();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_DepthStencilState, __jsb_cc_gfx_DepthStencilState_class, js_delete_cc_gfx_DepthStencilState)

static bool js_delete_cc_gfx_DepthStencilState(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DepthStencilState) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::DepthStencilState * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::DepthStencilState*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("depthTest", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthTest), ctx);
    }
    
    
    json->getProperty("depthWrite", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthWrite), ctx);
    }
    
    
    json->getProperty("depthFunc", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthFunc), ctx);
    }
    
    
    json->getProperty("stencilTestFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilTestFront), ctx);
    }
    
    
    json->getProperty("stencilFuncFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilFuncFront), ctx);
    }
    
    
    json->getProperty("stencilReadMaskFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilReadMaskFront), ctx);
    }
    
    
    json->getProperty("stencilWriteMaskFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilWriteMaskFront), ctx);
    }
    
    
    json->getProperty("stencilFailOpFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilFailOpFront), ctx);
    }
    
    
    json->getProperty("stencilZFailOpFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilZFailOpFront), ctx);
    }
    
    
    json->getProperty("stencilPassOpFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilPassOpFront), ctx);
    }
    
    
    json->getProperty("stencilRefFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilRefFront), ctx);
    }
    
    
    json->getProperty("stencilTestBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilTestBack), ctx);
    }
    
    
    json->getProperty("stencilFuncBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilFuncBack), ctx);
    }
    
    
    json->getProperty("stencilReadMaskBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilReadMaskBack), ctx);
    }
    
    
    json->getProperty("stencilWriteMaskBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilWriteMaskBack), ctx);
    }
    
    
    json->getProperty("stencilFailOpBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilFailOpBack), ctx);
    }
    
    
    json->getProperty("stencilZFailOpBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilZFailOpBack), ctx);
    }
    
    
    json->getProperty("stencilPassOpBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilPassOpBack), ctx);
    }
    
    
    json->getProperty("stencilRefBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilRefBack), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_DepthStencilState(se::Object* obj) {
    auto* cls = se::Class::create("DepthStencilState", obj, nullptr, _SE(js_new_cc_gfx_DepthStencilState)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("depthTest", _SE(js_cc_gfx_DepthStencilState_depthTest_get), _SE(js_cc_gfx_DepthStencilState_depthTest_set)); 
    cls->defineProperty("depthWrite", _SE(js_cc_gfx_DepthStencilState_depthWrite_get), _SE(js_cc_gfx_DepthStencilState_depthWrite_set)); 
    cls->defineProperty("depthFunc", _SE(js_cc_gfx_DepthStencilState_depthFunc_get), _SE(js_cc_gfx_DepthStencilState_depthFunc_set)); 
    cls->defineProperty("stencilTestFront", _SE(js_cc_gfx_DepthStencilState_stencilTestFront_get), _SE(js_cc_gfx_DepthStencilState_stencilTestFront_set)); 
    cls->defineProperty("stencilFuncFront", _SE(js_cc_gfx_DepthStencilState_stencilFuncFront_get), _SE(js_cc_gfx_DepthStencilState_stencilFuncFront_set)); 
    cls->defineProperty("stencilReadMaskFront", _SE(js_cc_gfx_DepthStencilState_stencilReadMaskFront_get), _SE(js_cc_gfx_DepthStencilState_stencilReadMaskFront_set)); 
    cls->defineProperty("stencilWriteMaskFront", _SE(js_cc_gfx_DepthStencilState_stencilWriteMaskFront_get), _SE(js_cc_gfx_DepthStencilState_stencilWriteMaskFront_set)); 
    cls->defineProperty("stencilFailOpFront", _SE(js_cc_gfx_DepthStencilState_stencilFailOpFront_get), _SE(js_cc_gfx_DepthStencilState_stencilFailOpFront_set)); 
    cls->defineProperty("stencilZFailOpFront", _SE(js_cc_gfx_DepthStencilState_stencilZFailOpFront_get), _SE(js_cc_gfx_DepthStencilState_stencilZFailOpFront_set)); 
    cls->defineProperty("stencilPassOpFront", _SE(js_cc_gfx_DepthStencilState_stencilPassOpFront_get), _SE(js_cc_gfx_DepthStencilState_stencilPassOpFront_set)); 
    cls->defineProperty("stencilRefFront", _SE(js_cc_gfx_DepthStencilState_stencilRefFront_get), _SE(js_cc_gfx_DepthStencilState_stencilRefFront_set)); 
    cls->defineProperty("stencilTestBack", _SE(js_cc_gfx_DepthStencilState_stencilTestBack_get), _SE(js_cc_gfx_DepthStencilState_stencilTestBack_set)); 
    cls->defineProperty("stencilFuncBack", _SE(js_cc_gfx_DepthStencilState_stencilFuncBack_get), _SE(js_cc_gfx_DepthStencilState_stencilFuncBack_set)); 
    cls->defineProperty("stencilReadMaskBack", _SE(js_cc_gfx_DepthStencilState_stencilReadMaskBack_get), _SE(js_cc_gfx_DepthStencilState_stencilReadMaskBack_set)); 
    cls->defineProperty("stencilWriteMaskBack", _SE(js_cc_gfx_DepthStencilState_stencilWriteMaskBack_get), _SE(js_cc_gfx_DepthStencilState_stencilWriteMaskBack_set)); 
    cls->defineProperty("stencilFailOpBack", _SE(js_cc_gfx_DepthStencilState_stencilFailOpBack_get), _SE(js_cc_gfx_DepthStencilState_stencilFailOpBack_set)); 
    cls->defineProperty("stencilZFailOpBack", _SE(js_cc_gfx_DepthStencilState_stencilZFailOpBack_get), _SE(js_cc_gfx_DepthStencilState_stencilZFailOpBack_set)); 
    cls->defineProperty("stencilPassOpBack", _SE(js_cc_gfx_DepthStencilState_stencilPassOpBack_get), _SE(js_cc_gfx_DepthStencilState_stencilPassOpBack_set)); 
    cls->defineProperty("stencilRefBack", _SE(js_cc_gfx_DepthStencilState_stencilRefBack_get), _SE(js_cc_gfx_DepthStencilState_stencilRefBack_set)); 
    
    cls->defineFunction("reset", _SE(js_cc_gfx_DepthStencilState_reset)); 
    cls->defineFunction("copy", _SE(js_cc_gfx_DepthStencilState_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DepthStencilState));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DepthStencilState>(cls);
    
    __jsb_cc_gfx_DepthStencilState_proto = cls->getProto();
    __jsb_cc_gfx_DepthStencilState_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_BlendTarget_class = nullptr;
se::Object* __jsb_cc_gfx_BlendTarget_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_BlendTarget) 

static bool js_cc_gfx_BlendTarget_blend_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blend, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BlendTarget_blend_set) 

static bool js_cc_gfx_BlendTarget_blend_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blend, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BlendTarget_blend_get) 

static bool js_cc_gfx_BlendTarget_blendSrc_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blendSrc, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BlendTarget_blendSrc_set) 

static bool js_cc_gfx_BlendTarget_blendSrc_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blendSrc, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendSrc, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BlendTarget_blendSrc_get) 

static bool js_cc_gfx_BlendTarget_blendDst_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blendDst, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BlendTarget_blendDst_set) 

static bool js_cc_gfx_BlendTarget_blendDst_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blendDst, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendDst, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BlendTarget_blendDst_get) 

static bool js_cc_gfx_BlendTarget_blendEq_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blendEq, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BlendTarget_blendEq_set) 

static bool js_cc_gfx_BlendTarget_blendEq_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blendEq, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendEq, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BlendTarget_blendEq_get) 

static bool js_cc_gfx_BlendTarget_blendSrcAlpha_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blendSrcAlpha, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BlendTarget_blendSrcAlpha_set) 

static bool js_cc_gfx_BlendTarget_blendSrcAlpha_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blendSrcAlpha, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendSrcAlpha, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BlendTarget_blendSrcAlpha_get) 

static bool js_cc_gfx_BlendTarget_blendDstAlpha_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blendDstAlpha, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BlendTarget_blendDstAlpha_set) 

static bool js_cc_gfx_BlendTarget_blendDstAlpha_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blendDstAlpha, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendDstAlpha, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BlendTarget_blendDstAlpha_get) 

static bool js_cc_gfx_BlendTarget_blendAlphaEq_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blendAlphaEq, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BlendTarget_blendAlphaEq_set) 

static bool js_cc_gfx_BlendTarget_blendAlphaEq_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blendAlphaEq, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendAlphaEq, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BlendTarget_blendAlphaEq_get) 

static bool js_cc_gfx_BlendTarget_blendColorMask_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blendColorMask, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BlendTarget_blendColorMask_set) 

static bool js_cc_gfx_BlendTarget_blendColorMask_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blendColorMask, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendColorMask, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BlendTarget_blendColorMask_get) 

static bool js_cc_gfx_BlendTarget_reset(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    if (nullptr == arg1) return true;
    (arg1)->reset();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BlendTarget_reset) 

static bool js_cc_gfx_BlendTarget_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendTarget *arg1 = (cc::gfx::BlendTarget *) NULL ;
    cc::gfx::BlendTarget *arg2 = 0 ;
    cc::gfx::BlendTarget temp2 ;
    cc::gfx::BlendTarget *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendTarget>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::BlendTarget *) &(arg1)->copy((cc::gfx::BlendTarget const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BlendTarget_copy) 

static bool js_new_cc_gfx_BlendTarget(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::BlendTarget *result;
    result = (cc::gfx::BlendTarget *)new cc::gfx::BlendTarget();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_BlendTarget, __jsb_cc_gfx_BlendTarget_class, js_delete_cc_gfx_BlendTarget)

static bool js_delete_cc_gfx_BlendTarget(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_BlendTarget) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::BlendTarget * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::BlendTarget*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("blend", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blend), ctx);
    }
    
    
    json->getProperty("blendSrc", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendSrc), ctx);
    }
    
    
    json->getProperty("blendDst", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendDst), ctx);
    }
    
    
    json->getProperty("blendEq", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendEq), ctx);
    }
    
    
    json->getProperty("blendSrcAlpha", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendSrcAlpha), ctx);
    }
    
    
    json->getProperty("blendDstAlpha", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendDstAlpha), ctx);
    }
    
    
    json->getProperty("blendAlphaEq", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendAlphaEq), ctx);
    }
    
    
    json->getProperty("blendColorMask", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendColorMask), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_BlendTarget(se::Object* obj) {
    auto* cls = se::Class::create("BlendTarget", obj, nullptr, _SE(js_new_cc_gfx_BlendTarget)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("blend", _SE(js_cc_gfx_BlendTarget_blend_get), _SE(js_cc_gfx_BlendTarget_blend_set)); 
    cls->defineProperty("blendSrc", _SE(js_cc_gfx_BlendTarget_blendSrc_get), _SE(js_cc_gfx_BlendTarget_blendSrc_set)); 
    cls->defineProperty("blendDst", _SE(js_cc_gfx_BlendTarget_blendDst_get), _SE(js_cc_gfx_BlendTarget_blendDst_set)); 
    cls->defineProperty("blendEq", _SE(js_cc_gfx_BlendTarget_blendEq_get), _SE(js_cc_gfx_BlendTarget_blendEq_set)); 
    cls->defineProperty("blendSrcAlpha", _SE(js_cc_gfx_BlendTarget_blendSrcAlpha_get), _SE(js_cc_gfx_BlendTarget_blendSrcAlpha_set)); 
    cls->defineProperty("blendDstAlpha", _SE(js_cc_gfx_BlendTarget_blendDstAlpha_get), _SE(js_cc_gfx_BlendTarget_blendDstAlpha_set)); 
    cls->defineProperty("blendAlphaEq", _SE(js_cc_gfx_BlendTarget_blendAlphaEq_get), _SE(js_cc_gfx_BlendTarget_blendAlphaEq_set)); 
    cls->defineProperty("blendColorMask", _SE(js_cc_gfx_BlendTarget_blendColorMask_get), _SE(js_cc_gfx_BlendTarget_blendColorMask_set)); 
    
    cls->defineFunction("reset", _SE(js_cc_gfx_BlendTarget_reset)); 
    cls->defineFunction("copy", _SE(js_cc_gfx_BlendTarget_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_BlendTarget));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::BlendTarget>(cls);
    
    __jsb_cc_gfx_BlendTarget_proto = cls->getProto();
    __jsb_cc_gfx_BlendTarget_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_BlendState_class = nullptr;
se::Object* __jsb_cc_gfx_BlendState_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_BlendState) 

static bool js_cc_gfx_BlendState_isA2C_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendState *arg1 = (cc::gfx::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->isA2C, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BlendState_isA2C_set) 

static bool js_cc_gfx_BlendState_isA2C_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BlendState *arg1 = (cc::gfx::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->isA2C, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BlendState_isA2C_get) 

static bool js_cc_gfx_BlendState_isIndepend_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendState *arg1 = (cc::gfx::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->isIndepend, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BlendState_isIndepend_set) 

static bool js_cc_gfx_BlendState_isIndepend_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BlendState *arg1 = (cc::gfx::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->isIndepend, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BlendState_isIndepend_get) 

static bool js_cc_gfx_BlendState_blendColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendState *arg1 = (cc::gfx::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blendColor, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BlendState_blendColor_set) 

static bool js_cc_gfx_BlendState_blendColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BlendState *arg1 = (cc::gfx::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blendColor, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendColor, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BlendState_blendColor_get) 

static bool js_cc_gfx_BlendState_targets_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendState *arg1 = (cc::gfx::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->targets, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_BlendState_targets_set) 

static bool js_cc_gfx_BlendState_targets_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::BlendState *arg1 = (cc::gfx::BlendState *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendState>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->targets, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->targets, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_BlendState_targets_get) 

static bool js_cc_gfx_BlendState_setTarget(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendState *arg1 = (cc::gfx::BlendState *) NULL ;
    index_t arg2 ;
    cc::gfx::BlendTarget *arg3 = 0 ;
    cc::gfx::BlendTarget temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setTarget(arg2,(cc::gfx::BlendTarget const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BlendState_setTarget) 

static bool js_cc_gfx_BlendState_reset(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendState *arg1 = (cc::gfx::BlendState *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendState>(s);
    if (nullptr == arg1) return true;
    (arg1)->reset();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BlendState_reset) 

static bool js_cc_gfx_BlendState_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendState *arg1 = (cc::gfx::BlendState *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendState>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BlendState_destroy) 

static bool js_cc_gfx_BlendState_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BlendState *arg1 = (cc::gfx::BlendState *) NULL ;
    cc::gfx::BlendState *arg2 = 0 ;
    cc::gfx::BlendState temp2 ;
    cc::gfx::BlendState *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::BlendState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::BlendState *) &(arg1)->copy((cc::gfx::BlendState const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BlendState_copy) 

static bool js_new_cc_gfx_BlendState(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::BlendState *result;
    result = (cc::gfx::BlendState *)new cc::gfx::BlendState();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_BlendState, __jsb_cc_gfx_BlendState_class, js_delete_cc_gfx_BlendState)

static bool js_delete_cc_gfx_BlendState(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_BlendState) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::BlendState * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::BlendState*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("isA2C", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isA2C), ctx);
    }
    
    
    json->getProperty("isIndepend", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isIndepend), ctx);
    }
    
    
    json->getProperty("blendColor", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendColor), ctx);
    }
    
    
    json->getProperty("targets", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->targets), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_BlendState(se::Object* obj) {
    auto* cls = se::Class::create("BlendState", obj, nullptr, _SE(js_new_cc_gfx_BlendState)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("isA2C", _SE(js_cc_gfx_BlendState_isA2C_get), _SE(js_cc_gfx_BlendState_isA2C_set)); 
    cls->defineProperty("isIndepend", _SE(js_cc_gfx_BlendState_isIndepend_get), _SE(js_cc_gfx_BlendState_isIndepend_set)); 
    cls->defineProperty("blendColor", _SE(js_cc_gfx_BlendState_blendColor_get), _SE(js_cc_gfx_BlendState_blendColor_set)); 
    cls->defineProperty("targets", _SE(js_cc_gfx_BlendState_targets_get), _SE(js_cc_gfx_BlendState_targets_set)); 
    
    cls->defineFunction("setTarget", _SE(js_cc_gfx_BlendState_setTarget)); 
    cls->defineFunction("reset", _SE(js_cc_gfx_BlendState_reset)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_BlendState_destroy)); 
    cls->defineFunction("copy", _SE(js_cc_gfx_BlendState_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_BlendState));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::BlendState>(cls);
    
    __jsb_cc_gfx_BlendState_proto = cls->getProto();
    __jsb_cc_gfx_BlendState_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_PipelineStateInfo_class = nullptr;
se::Object* __jsb_cc_gfx_PipelineStateInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_PipelineStateInfo) 

static bool js_cc_gfx_PipelineStateInfo_shader_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->shader, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_PipelineStateInfo_shader_set) 

static bool js_cc_gfx_PipelineStateInfo_shader_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->shader, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->shader, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineStateInfo_shader_get) 

static bool js_cc_gfx_PipelineStateInfo_pipelineLayout_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->pipelineLayout, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_PipelineStateInfo_pipelineLayout_set) 

static bool js_cc_gfx_PipelineStateInfo_pipelineLayout_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->pipelineLayout, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->pipelineLayout, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineStateInfo_pipelineLayout_get) 

static bool js_cc_gfx_PipelineStateInfo_renderPass_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->renderPass, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_PipelineStateInfo_renderPass_set) 

static bool js_cc_gfx_PipelineStateInfo_renderPass_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->renderPass, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->renderPass, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineStateInfo_renderPass_get) 

static bool js_cc_gfx_PipelineStateInfo_inputState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->inputState, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_PipelineStateInfo_inputState_set) 

static bool js_cc_gfx_PipelineStateInfo_inputState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->inputState, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->inputState, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineStateInfo_inputState_get) 

static bool js_cc_gfx_PipelineStateInfo_rasterizerState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->rasterizerState, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_PipelineStateInfo_rasterizerState_set) 

static bool js_cc_gfx_PipelineStateInfo_rasterizerState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->rasterizerState, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->rasterizerState, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineStateInfo_rasterizerState_get) 

static bool js_cc_gfx_PipelineStateInfo_depthStencilState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthStencilState, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_PipelineStateInfo_depthStencilState_set) 

static bool js_cc_gfx_PipelineStateInfo_depthStencilState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthStencilState, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthStencilState, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineStateInfo_depthStencilState_get) 

static bool js_cc_gfx_PipelineStateInfo_blendState_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blendState, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_PipelineStateInfo_blendState_set) 

static bool js_cc_gfx_PipelineStateInfo_blendState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blendState, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendState, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineStateInfo_blendState_get) 

static bool js_cc_gfx_PipelineStateInfo_primitive_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->primitive, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_PipelineStateInfo_primitive_set) 

static bool js_cc_gfx_PipelineStateInfo_primitive_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->primitive, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->primitive, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineStateInfo_primitive_get) 

static bool js_cc_gfx_PipelineStateInfo_dynamicStates_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->dynamicStates, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_PipelineStateInfo_dynamicStates_set) 

static bool js_cc_gfx_PipelineStateInfo_dynamicStates_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->dynamicStates, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->dynamicStates, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineStateInfo_dynamicStates_get) 

static bool js_cc_gfx_PipelineStateInfo_bindPoint_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->bindPoint, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_PipelineStateInfo_bindPoint_set) 

static bool js_cc_gfx_PipelineStateInfo_bindPoint_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->bindPoint, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->bindPoint, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineStateInfo_bindPoint_get) 

static bool js_cc_gfx_PipelineStateInfo_subpass_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->subpass, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_PipelineStateInfo_subpass_set) 

static bool js_cc_gfx_PipelineStateInfo_subpass_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->subpass, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineStateInfo_subpass_get) 

static bool js_cc_gfx_PipelineStateInfo_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineStateInfo *arg1 = (cc::gfx::PipelineStateInfo *) NULL ;
    cc::gfx::PipelineStateInfo *arg2 = 0 ;
    cc::gfx::PipelineStateInfo temp2 ;
    cc::gfx::PipelineStateInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineStateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::PipelineStateInfo *) &(arg1)->copy((cc::gfx::PipelineStateInfo const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_PipelineStateInfo_copy) 

static bool js_new_cc_gfx_PipelineStateInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::PipelineStateInfo *result;
    result = (cc::gfx::PipelineStateInfo *)new cc::gfx::PipelineStateInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_PipelineStateInfo, __jsb_cc_gfx_PipelineStateInfo_class, js_delete_cc_gfx_PipelineStateInfo)

static bool js_delete_cc_gfx_PipelineStateInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_PipelineStateInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::PipelineStateInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::PipelineStateInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("shader", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->shader), ctx);
    }
    
    
    json->getProperty("pipelineLayout", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->pipelineLayout), ctx);
    }
    
    
    json->getProperty("renderPass", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->renderPass), ctx);
    }
    
    
    json->getProperty("inputState", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->inputState), ctx);
    }
    
    
    json->getProperty("rasterizerState", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->rasterizerState), ctx);
    }
    
    
    json->getProperty("depthStencilState", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthStencilState), ctx);
    }
    
    
    json->getProperty("blendState", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendState), ctx);
    }
    
    
    json->getProperty("primitive", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->primitive), ctx);
    }
    
    
    json->getProperty("dynamicStates", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dynamicStates), ctx);
    }
    
    
    json->getProperty("bindPoint", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->bindPoint), ctx);
    }
    
    
    json->getProperty("subpass", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->subpass), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_PipelineStateInfo(se::Object* obj) {
    auto* cls = se::Class::create("PipelineStateInfo", obj, nullptr, _SE(js_new_cc_gfx_PipelineStateInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("shader", _SE(js_cc_gfx_PipelineStateInfo_shader_get), _SE(js_cc_gfx_PipelineStateInfo_shader_set)); 
    cls->defineProperty("pipelineLayout", _SE(js_cc_gfx_PipelineStateInfo_pipelineLayout_get), _SE(js_cc_gfx_PipelineStateInfo_pipelineLayout_set)); 
    cls->defineProperty("renderPass", _SE(js_cc_gfx_PipelineStateInfo_renderPass_get), _SE(js_cc_gfx_PipelineStateInfo_renderPass_set)); 
    cls->defineProperty("inputState", _SE(js_cc_gfx_PipelineStateInfo_inputState_get), _SE(js_cc_gfx_PipelineStateInfo_inputState_set)); 
    cls->defineProperty("rasterizerState", _SE(js_cc_gfx_PipelineStateInfo_rasterizerState_get), _SE(js_cc_gfx_PipelineStateInfo_rasterizerState_set)); 
    cls->defineProperty("depthStencilState", _SE(js_cc_gfx_PipelineStateInfo_depthStencilState_get), _SE(js_cc_gfx_PipelineStateInfo_depthStencilState_set)); 
    cls->defineProperty("blendState", _SE(js_cc_gfx_PipelineStateInfo_blendState_get), _SE(js_cc_gfx_PipelineStateInfo_blendState_set)); 
    cls->defineProperty("primitive", _SE(js_cc_gfx_PipelineStateInfo_primitive_get), _SE(js_cc_gfx_PipelineStateInfo_primitive_set)); 
    cls->defineProperty("dynamicStates", _SE(js_cc_gfx_PipelineStateInfo_dynamicStates_get), _SE(js_cc_gfx_PipelineStateInfo_dynamicStates_set)); 
    cls->defineProperty("bindPoint", _SE(js_cc_gfx_PipelineStateInfo_bindPoint_get), _SE(js_cc_gfx_PipelineStateInfo_bindPoint_set)); 
    cls->defineProperty("subpass", _SE(js_cc_gfx_PipelineStateInfo_subpass_get), _SE(js_cc_gfx_PipelineStateInfo_subpass_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_PipelineStateInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_PipelineStateInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::PipelineStateInfo>(cls);
    
    __jsb_cc_gfx_PipelineStateInfo_proto = cls->getProto();
    __jsb_cc_gfx_PipelineStateInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_CommandBufferInfo_class = nullptr;
se::Object* __jsb_cc_gfx_CommandBufferInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_CommandBufferInfo) 

static bool js_cc_gfx_CommandBufferInfo_queue_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBufferInfo *arg1 = (cc::gfx::CommandBufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->queue, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_CommandBufferInfo_queue_set) 

static bool js_cc_gfx_CommandBufferInfo_queue_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::CommandBufferInfo *arg1 = (cc::gfx::CommandBufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->queue, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->queue, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_CommandBufferInfo_queue_get) 

static bool js_cc_gfx_CommandBufferInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBufferInfo *arg1 = (cc::gfx::CommandBufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->type, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_CommandBufferInfo_type_set) 

static bool js_cc_gfx_CommandBufferInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::CommandBufferInfo *arg1 = (cc::gfx::CommandBufferInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->type, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->type, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_CommandBufferInfo_type_get) 

static bool js_cc_gfx_CommandBufferInfo_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBufferInfo *arg1 = (cc::gfx::CommandBufferInfo *) NULL ;
    cc::gfx::CommandBufferInfo *arg2 = 0 ;
    cc::gfx::CommandBufferInfo temp2 ;
    cc::gfx::CommandBufferInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBufferInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::CommandBufferInfo *) &(arg1)->copy((cc::gfx::CommandBufferInfo const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBufferInfo_copy) 

static bool js_new_cc_gfx_CommandBufferInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::CommandBufferInfo *result;
    result = (cc::gfx::CommandBufferInfo *)new cc::gfx::CommandBufferInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_CommandBufferInfo, __jsb_cc_gfx_CommandBufferInfo_class, js_delete_cc_gfx_CommandBufferInfo)

static bool js_delete_cc_gfx_CommandBufferInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_CommandBufferInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::CommandBufferInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::CommandBufferInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("queue", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->queue), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_CommandBufferInfo(se::Object* obj) {
    auto* cls = se::Class::create("CommandBufferInfo", obj, nullptr, _SE(js_new_cc_gfx_CommandBufferInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("queue", _SE(js_cc_gfx_CommandBufferInfo_queue_get), _SE(js_cc_gfx_CommandBufferInfo_queue_set)); 
    cls->defineProperty("type", _SE(js_cc_gfx_CommandBufferInfo_type_get), _SE(js_cc_gfx_CommandBufferInfo_type_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_CommandBufferInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_CommandBufferInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::CommandBufferInfo>(cls);
    
    __jsb_cc_gfx_CommandBufferInfo_proto = cls->getProto();
    __jsb_cc_gfx_CommandBufferInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_QueueInfo_class = nullptr;
se::Object* __jsb_cc_gfx_QueueInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_QueueInfo) 

static bool js_cc_gfx_QueueInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::QueueInfo *arg1 = (cc::gfx::QueueInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::QueueInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->type, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_QueueInfo_type_set) 

static bool js_cc_gfx_QueueInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::QueueInfo *arg1 = (cc::gfx::QueueInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::QueueInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->type, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->type, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_QueueInfo_type_get) 

static bool js_cc_gfx_QueueInfo_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::QueueInfo *arg1 = (cc::gfx::QueueInfo *) NULL ;
    cc::gfx::QueueInfo *arg2 = 0 ;
    cc::gfx::QueueInfo temp2 ;
    cc::gfx::QueueInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::QueueInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::QueueInfo *) &(arg1)->copy((cc::gfx::QueueInfo const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_QueueInfo_copy) 

static bool js_new_cc_gfx_QueueInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::QueueInfo *result;
    result = (cc::gfx::QueueInfo *)new cc::gfx::QueueInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_QueueInfo, __jsb_cc_gfx_QueueInfo_class, js_delete_cc_gfx_QueueInfo)

static bool js_delete_cc_gfx_QueueInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_QueueInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::QueueInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::QueueInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_QueueInfo(se::Object* obj) {
    auto* cls = se::Class::create("QueueInfo", obj, nullptr, _SE(js_new_cc_gfx_QueueInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("type", _SE(js_cc_gfx_QueueInfo_type_get), _SE(js_cc_gfx_QueueInfo_type_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_QueueInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_QueueInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::QueueInfo>(cls);
    
    __jsb_cc_gfx_QueueInfo_proto = cls->getProto();
    __jsb_cc_gfx_QueueInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_QueryPoolInfo_class = nullptr;
se::Object* __jsb_cc_gfx_QueryPoolInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_QueryPoolInfo) 

static bool js_cc_gfx_QueryPoolInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::QueryPoolInfo *arg1 = (cc::gfx::QueryPoolInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPoolInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->type, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_QueryPoolInfo_type_set) 

static bool js_cc_gfx_QueryPoolInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::QueryPoolInfo *arg1 = (cc::gfx::QueryPoolInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPoolInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->type, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->type, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_QueryPoolInfo_type_get) 

static bool js_cc_gfx_QueryPoolInfo_maxQueryObjects_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::QueryPoolInfo *arg1 = (cc::gfx::QueryPoolInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPoolInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maxQueryObjects, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_QueryPoolInfo_maxQueryObjects_set) 

static bool js_cc_gfx_QueryPoolInfo_maxQueryObjects_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::QueryPoolInfo *arg1 = (cc::gfx::QueryPoolInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPoolInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maxQueryObjects, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_QueryPoolInfo_maxQueryObjects_get) 

static bool js_cc_gfx_QueryPoolInfo_forceWait_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::QueryPoolInfo *arg1 = (cc::gfx::QueryPoolInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPoolInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->forceWait);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_QueryPoolInfo_forceWait_set) 

static bool js_cc_gfx_QueryPoolInfo_forceWait_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::QueryPoolInfo *arg1 = (cc::gfx::QueryPoolInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPoolInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->forceWait, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_QueryPoolInfo_forceWait_get) 

static bool js_cc_gfx_QueryPoolInfo_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::QueryPoolInfo *arg1 = (cc::gfx::QueryPoolInfo *) NULL ;
    cc::gfx::QueryPoolInfo *arg2 = 0 ;
    cc::gfx::QueryPoolInfo temp2 ;
    cc::gfx::QueryPoolInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPoolInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::QueryPoolInfo *) &(arg1)->copy((cc::gfx::QueryPoolInfo const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_QueryPoolInfo_copy) 

static bool js_new_cc_gfx_QueryPoolInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::QueryPoolInfo *result;
    result = (cc::gfx::QueryPoolInfo *)new cc::gfx::QueryPoolInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_QueryPoolInfo, __jsb_cc_gfx_QueryPoolInfo_class, js_delete_cc_gfx_QueryPoolInfo)

static bool js_delete_cc_gfx_QueryPoolInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_QueryPoolInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::QueryPoolInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::QueryPoolInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("maxQueryObjects", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maxQueryObjects), ctx);
    }
    
    
    json->getProperty("forceWait", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->forceWait), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_QueryPoolInfo(se::Object* obj) {
    auto* cls = se::Class::create("QueryPoolInfo", obj, nullptr, _SE(js_new_cc_gfx_QueryPoolInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("type", _SE(js_cc_gfx_QueryPoolInfo_type_get), _SE(js_cc_gfx_QueryPoolInfo_type_set)); 
    cls->defineProperty("maxQueryObjects", _SE(js_cc_gfx_QueryPoolInfo_maxQueryObjects_get), _SE(js_cc_gfx_QueryPoolInfo_maxQueryObjects_set)); 
    cls->defineProperty("forceWait", _SE(js_cc_gfx_QueryPoolInfo_forceWait_get), _SE(js_cc_gfx_QueryPoolInfo_forceWait_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_QueryPoolInfo_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_QueryPoolInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::QueryPoolInfo>(cls);
    
    __jsb_cc_gfx_QueryPoolInfo_proto = cls->getProto();
    __jsb_cc_gfx_QueryPoolInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_FormatInfo_class = nullptr;
se::Object* __jsb_cc_gfx_FormatInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_FormatInfo) 

static bool js_cc_gfx_FormatInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::FormatInfo *arg1 = (cc::gfx::FormatInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FormatInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_FormatInfo_name_set) 

static bool js_cc_gfx_FormatInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::FormatInfo *arg1 = (cc::gfx::FormatInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FormatInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_FormatInfo_name_get) 

static bool js_cc_gfx_FormatInfo_size_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::FormatInfo *arg1 = (cc::gfx::FormatInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FormatInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->size, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_FormatInfo_size_set) 

static bool js_cc_gfx_FormatInfo_size_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::FormatInfo *arg1 = (cc::gfx::FormatInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FormatInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->size, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_FormatInfo_size_get) 

static bool js_cc_gfx_FormatInfo_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::FormatInfo *arg1 = (cc::gfx::FormatInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FormatInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_FormatInfo_count_set) 

static bool js_cc_gfx_FormatInfo_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::FormatInfo *arg1 = (cc::gfx::FormatInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FormatInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_FormatInfo_count_get) 

static bool js_cc_gfx_FormatInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::FormatInfo *arg1 = (cc::gfx::FormatInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FormatInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->type, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_FormatInfo_type_set) 

static bool js_cc_gfx_FormatInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::FormatInfo *arg1 = (cc::gfx::FormatInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FormatInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->type, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->type, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_FormatInfo_type_get) 

static bool js_cc_gfx_FormatInfo_hasAlpha_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::FormatInfo *arg1 = (cc::gfx::FormatInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FormatInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->hasAlpha);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_FormatInfo_hasAlpha_set) 

static bool js_cc_gfx_FormatInfo_hasAlpha_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::FormatInfo *arg1 = (cc::gfx::FormatInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FormatInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->hasAlpha, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_FormatInfo_hasAlpha_get) 

static bool js_cc_gfx_FormatInfo_hasDepth_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::FormatInfo *arg1 = (cc::gfx::FormatInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FormatInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->hasDepth);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_FormatInfo_hasDepth_set) 

static bool js_cc_gfx_FormatInfo_hasDepth_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::FormatInfo *arg1 = (cc::gfx::FormatInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FormatInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->hasDepth, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_FormatInfo_hasDepth_get) 

static bool js_cc_gfx_FormatInfo_hasStencil_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::FormatInfo *arg1 = (cc::gfx::FormatInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FormatInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->hasStencil);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_FormatInfo_hasStencil_set) 

static bool js_cc_gfx_FormatInfo_hasStencil_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::FormatInfo *arg1 = (cc::gfx::FormatInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FormatInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->hasStencil, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_FormatInfo_hasStencil_get) 

static bool js_cc_gfx_FormatInfo_isCompressed_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::FormatInfo *arg1 = (cc::gfx::FormatInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FormatInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->isCompressed);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_FormatInfo_isCompressed_set) 

static bool js_cc_gfx_FormatInfo_isCompressed_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::FormatInfo *arg1 = (cc::gfx::FormatInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::FormatInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->isCompressed, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_FormatInfo_isCompressed_get) 

static bool js_new_cc_gfx_FormatInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::FormatInfo *result;
    result = (cc::gfx::FormatInfo *)new cc::gfx::FormatInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_FormatInfo, __jsb_cc_gfx_FormatInfo_class, js_delete_cc_gfx_FormatInfo)

static bool js_delete_cc_gfx_FormatInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_FormatInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::FormatInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::FormatInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("size", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->size), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("hasAlpha", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->hasAlpha), ctx);
    }
    
    
    json->getProperty("hasDepth", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->hasDepth), ctx);
    }
    
    
    json->getProperty("hasStencil", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->hasStencil), ctx);
    }
    
    
    json->getProperty("isCompressed", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isCompressed), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_FormatInfo(se::Object* obj) {
    auto* cls = se::Class::create("FormatInfo", obj, nullptr, _SE(js_new_cc_gfx_FormatInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("name", _SE(js_cc_gfx_FormatInfo_name_get), _SE(js_cc_gfx_FormatInfo_name_set)); 
    cls->defineProperty("size", _SE(js_cc_gfx_FormatInfo_size_get), _SE(js_cc_gfx_FormatInfo_size_set)); 
    cls->defineProperty("count", _SE(js_cc_gfx_FormatInfo_count_get), _SE(js_cc_gfx_FormatInfo_count_set)); 
    cls->defineProperty("type", _SE(js_cc_gfx_FormatInfo_type_get), _SE(js_cc_gfx_FormatInfo_type_set)); 
    cls->defineProperty("hasAlpha", _SE(js_cc_gfx_FormatInfo_hasAlpha_get), _SE(js_cc_gfx_FormatInfo_hasAlpha_set)); 
    cls->defineProperty("hasDepth", _SE(js_cc_gfx_FormatInfo_hasDepth_get), _SE(js_cc_gfx_FormatInfo_hasDepth_set)); 
    cls->defineProperty("hasStencil", _SE(js_cc_gfx_FormatInfo_hasStencil_get), _SE(js_cc_gfx_FormatInfo_hasStencil_set)); 
    cls->defineProperty("isCompressed", _SE(js_cc_gfx_FormatInfo_isCompressed_get), _SE(js_cc_gfx_FormatInfo_isCompressed_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_FormatInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::FormatInfo>(cls);
    
    __jsb_cc_gfx_FormatInfo_proto = cls->getProto();
    __jsb_cc_gfx_FormatInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_MemoryStatus_class = nullptr;
se::Object* __jsb_cc_gfx_MemoryStatus_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_MemoryStatus) 

static bool js_cc_gfx_MemoryStatus_bufferSize_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::MemoryStatus *arg1 = (cc::gfx::MemoryStatus *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::MemoryStatus>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->bufferSize, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_MemoryStatus_bufferSize_set) 

static bool js_cc_gfx_MemoryStatus_bufferSize_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::MemoryStatus *arg1 = (cc::gfx::MemoryStatus *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::MemoryStatus>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->bufferSize, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_MemoryStatus_bufferSize_get) 

static bool js_cc_gfx_MemoryStatus_textureSize_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::MemoryStatus *arg1 = (cc::gfx::MemoryStatus *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::MemoryStatus>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->textureSize, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_MemoryStatus_textureSize_set) 

static bool js_cc_gfx_MemoryStatus_textureSize_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::MemoryStatus *arg1 = (cc::gfx::MemoryStatus *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::MemoryStatus>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->textureSize, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_MemoryStatus_textureSize_get) 

static bool js_cc_gfx_MemoryStatus_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::MemoryStatus *arg1 = (cc::gfx::MemoryStatus *) NULL ;
    cc::gfx::MemoryStatus *arg2 = 0 ;
    cc::gfx::MemoryStatus temp2 ;
    cc::gfx::MemoryStatus *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::MemoryStatus>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::MemoryStatus *) &(arg1)->copy((cc::gfx::MemoryStatus const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_MemoryStatus_copy) 

static bool js_new_cc_gfx_MemoryStatus(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::MemoryStatus *result;
    result = (cc::gfx::MemoryStatus *)new cc::gfx::MemoryStatus();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_MemoryStatus, __jsb_cc_gfx_MemoryStatus_class, js_delete_cc_gfx_MemoryStatus)

static bool js_delete_cc_gfx_MemoryStatus(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_MemoryStatus) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::MemoryStatus * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::MemoryStatus*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("bufferSize", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->bufferSize), ctx);
    }
    
    
    json->getProperty("textureSize", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->textureSize), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_MemoryStatus(se::Object* obj) {
    auto* cls = se::Class::create("MemoryStatus", obj, nullptr, _SE(js_new_cc_gfx_MemoryStatus)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("bufferSize", _SE(js_cc_gfx_MemoryStatus_bufferSize_get), _SE(js_cc_gfx_MemoryStatus_bufferSize_set)); 
    cls->defineProperty("textureSize", _SE(js_cc_gfx_MemoryStatus_textureSize_get), _SE(js_cc_gfx_MemoryStatus_textureSize_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_MemoryStatus_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_MemoryStatus));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::MemoryStatus>(cls);
    
    __jsb_cc_gfx_MemoryStatus_proto = cls->getProto();
    __jsb_cc_gfx_MemoryStatus_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DynamicStencilStates_class = nullptr;
se::Object* __jsb_cc_gfx_DynamicStencilStates_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DynamicStencilStates) 

static bool js_cc_gfx_DynamicStencilStates_writeMask_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStencilStates *arg1 = (cc::gfx::DynamicStencilStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStencilStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->writeMask, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStencilStates_writeMask_set) 

static bool js_cc_gfx_DynamicStencilStates_writeMask_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStencilStates *arg1 = (cc::gfx::DynamicStencilStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStencilStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->writeMask, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStencilStates_writeMask_get) 

static bool js_cc_gfx_DynamicStencilStates_compareMask_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStencilStates *arg1 = (cc::gfx::DynamicStencilStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStencilStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->compareMask, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStencilStates_compareMask_set) 

static bool js_cc_gfx_DynamicStencilStates_compareMask_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStencilStates *arg1 = (cc::gfx::DynamicStencilStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStencilStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->compareMask, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStencilStates_compareMask_get) 

static bool js_cc_gfx_DynamicStencilStates_reference_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStencilStates *arg1 = (cc::gfx::DynamicStencilStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStencilStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->reference, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStencilStates_reference_set) 

static bool js_cc_gfx_DynamicStencilStates_reference_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStencilStates *arg1 = (cc::gfx::DynamicStencilStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStencilStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->reference, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStencilStates_reference_get) 

static bool js_cc_gfx_DynamicStencilStates_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStencilStates *arg1 = (cc::gfx::DynamicStencilStates *) NULL ;
    cc::gfx::DynamicStencilStates *arg2 = 0 ;
    cc::gfx::DynamicStencilStates temp2 ;
    cc::gfx::DynamicStencilStates *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStencilStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::DynamicStencilStates *) &(arg1)->copy((cc::gfx::DynamicStencilStates const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DynamicStencilStates_copy) 

static bool js_new_cc_gfx_DynamicStencilStates(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::DynamicStencilStates *result;
    result = (cc::gfx::DynamicStencilStates *)new cc::gfx::DynamicStencilStates();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_DynamicStencilStates, __jsb_cc_gfx_DynamicStencilStates_class, js_delete_cc_gfx_DynamicStencilStates)

static bool js_delete_cc_gfx_DynamicStencilStates(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DynamicStencilStates) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::DynamicStencilStates * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::DynamicStencilStates*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("writeMask", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->writeMask), ctx);
    }
    
    
    json->getProperty("compareMask", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->compareMask), ctx);
    }
    
    
    json->getProperty("reference", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->reference), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_DynamicStencilStates(se::Object* obj) {
    auto* cls = se::Class::create("DynamicStencilStates", obj, nullptr, _SE(js_new_cc_gfx_DynamicStencilStates)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("writeMask", _SE(js_cc_gfx_DynamicStencilStates_writeMask_get), _SE(js_cc_gfx_DynamicStencilStates_writeMask_set)); 
    cls->defineProperty("compareMask", _SE(js_cc_gfx_DynamicStencilStates_compareMask_get), _SE(js_cc_gfx_DynamicStencilStates_compareMask_set)); 
    cls->defineProperty("reference", _SE(js_cc_gfx_DynamicStencilStates_reference_get), _SE(js_cc_gfx_DynamicStencilStates_reference_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_DynamicStencilStates_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DynamicStencilStates));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DynamicStencilStates>(cls);
    
    __jsb_cc_gfx_DynamicStencilStates_proto = cls->getProto();
    __jsb_cc_gfx_DynamicStencilStates_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DynamicStates_class = nullptr;
se::Object* __jsb_cc_gfx_DynamicStates_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DynamicStates) 

static bool js_cc_gfx_DynamicStates_viewport_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->viewport, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStates_viewport_set) 

static bool js_cc_gfx_DynamicStates_viewport_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->viewport, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->viewport, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStates_viewport_get) 

static bool js_cc_gfx_DynamicStates_scissor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->scissor, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStates_scissor_set) 

static bool js_cc_gfx_DynamicStates_scissor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->scissor, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->scissor, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStates_scissor_get) 

static bool js_cc_gfx_DynamicStates_blendConstant_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blendConstant, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStates_blendConstant_set) 

static bool js_cc_gfx_DynamicStates_blendConstant_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blendConstant, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blendConstant, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStates_blendConstant_get) 

static bool js_cc_gfx_DynamicStates_lineWidth_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->lineWidth, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStates_lineWidth_set) 

static bool js_cc_gfx_DynamicStates_lineWidth_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->lineWidth, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStates_lineWidth_get) 

static bool js_cc_gfx_DynamicStates_depthBiasConstant_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthBiasConstant, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStates_depthBiasConstant_set) 

static bool js_cc_gfx_DynamicStates_depthBiasConstant_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthBiasConstant, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStates_depthBiasConstant_get) 

static bool js_cc_gfx_DynamicStates_depthBiasClamp_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthBiasClamp, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStates_depthBiasClamp_set) 

static bool js_cc_gfx_DynamicStates_depthBiasClamp_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthBiasClamp, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStates_depthBiasClamp_get) 

static bool js_cc_gfx_DynamicStates_depthBiasSlope_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthBiasSlope, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStates_depthBiasSlope_set) 

static bool js_cc_gfx_DynamicStates_depthBiasSlope_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthBiasSlope, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStates_depthBiasSlope_get) 

static bool js_cc_gfx_DynamicStates_depthMinBounds_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthMinBounds, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStates_depthMinBounds_set) 

static bool js_cc_gfx_DynamicStates_depthMinBounds_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthMinBounds, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStates_depthMinBounds_get) 

static bool js_cc_gfx_DynamicStates_depthMaxBounds_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthMaxBounds, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStates_depthMaxBounds_set) 

static bool js_cc_gfx_DynamicStates_depthMaxBounds_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthMaxBounds, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStates_depthMaxBounds_get) 

static bool js_cc_gfx_DynamicStates_stencilStatesFront_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilStatesFront, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStates_stencilStatesFront_set) 

static bool js_cc_gfx_DynamicStates_stencilStatesFront_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilStatesFront, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilStatesFront, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStates_stencilStatesFront_get) 

static bool js_cc_gfx_DynamicStates_stencilStatesBack_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stencilStatesBack, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_DynamicStates_stencilStatesBack_set) 

static bool js_cc_gfx_DynamicStates_stencilStatesBack_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stencilStatesBack, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stencilStatesBack, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DynamicStates_stencilStatesBack_get) 

static bool js_cc_gfx_DynamicStates_copy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DynamicStates *arg1 = (cc::gfx::DynamicStates *) NULL ;
    cc::gfx::DynamicStates *arg2 = 0 ;
    cc::gfx::DynamicStates temp2 ;
    cc::gfx::DynamicStates *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DynamicStates>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::DynamicStates *) &(arg1)->copy((cc::gfx::DynamicStates const &)*arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DynamicStates_copy) 

static bool js_new_cc_gfx_DynamicStates(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::DynamicStates *result;
    result = (cc::gfx::DynamicStates *)new cc::gfx::DynamicStates();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_DynamicStates, __jsb_cc_gfx_DynamicStates_class, js_delete_cc_gfx_DynamicStates)

static bool js_delete_cc_gfx_DynamicStates(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DynamicStates) 

template<>
bool sevalue_to_native(const se::Value &from, cc::gfx::DynamicStates * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::gfx::DynamicStates*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("viewport", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->viewport), ctx);
    }
    
    
    json->getProperty("scissor", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->scissor), ctx);
    }
    
    
    json->getProperty("blendConstant", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blendConstant), ctx);
    }
    
    
    json->getProperty("lineWidth", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->lineWidth), ctx);
    }
    
    
    json->getProperty("depthBiasConstant", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthBiasConstant), ctx);
    }
    
    
    json->getProperty("depthBiasClamp", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthBiasClamp), ctx);
    }
    
    
    json->getProperty("depthBiasSlope", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthBiasSlope), ctx);
    }
    
    
    json->getProperty("depthMinBounds", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthMinBounds), ctx);
    }
    
    
    json->getProperty("depthMaxBounds", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthMaxBounds), ctx);
    }
    
    
    json->getProperty("stencilStatesFront", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilStatesFront), ctx);
    }
    
    
    json->getProperty("stencilStatesBack", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stencilStatesBack), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_gfx_DynamicStates(se::Object* obj) {
    auto* cls = se::Class::create("DynamicStates", obj, nullptr, _SE(js_new_cc_gfx_DynamicStates)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("viewport", _SE(js_cc_gfx_DynamicStates_viewport_get), _SE(js_cc_gfx_DynamicStates_viewport_set)); 
    cls->defineProperty("scissor", _SE(js_cc_gfx_DynamicStates_scissor_get), _SE(js_cc_gfx_DynamicStates_scissor_set)); 
    cls->defineProperty("blendConstant", _SE(js_cc_gfx_DynamicStates_blendConstant_get), _SE(js_cc_gfx_DynamicStates_blendConstant_set)); 
    cls->defineProperty("lineWidth", _SE(js_cc_gfx_DynamicStates_lineWidth_get), _SE(js_cc_gfx_DynamicStates_lineWidth_set)); 
    cls->defineProperty("depthBiasConstant", _SE(js_cc_gfx_DynamicStates_depthBiasConstant_get), _SE(js_cc_gfx_DynamicStates_depthBiasConstant_set)); 
    cls->defineProperty("depthBiasClamp", _SE(js_cc_gfx_DynamicStates_depthBiasClamp_get), _SE(js_cc_gfx_DynamicStates_depthBiasClamp_set)); 
    cls->defineProperty("depthBiasSlope", _SE(js_cc_gfx_DynamicStates_depthBiasSlope_get), _SE(js_cc_gfx_DynamicStates_depthBiasSlope_set)); 
    cls->defineProperty("depthMinBounds", _SE(js_cc_gfx_DynamicStates_depthMinBounds_get), _SE(js_cc_gfx_DynamicStates_depthMinBounds_set)); 
    cls->defineProperty("depthMaxBounds", _SE(js_cc_gfx_DynamicStates_depthMaxBounds_get), _SE(js_cc_gfx_DynamicStates_depthMaxBounds_set)); 
    cls->defineProperty("stencilStatesFront", _SE(js_cc_gfx_DynamicStates_stencilStatesFront_get), _SE(js_cc_gfx_DynamicStates_stencilStatesFront_set)); 
    cls->defineProperty("stencilStatesBack", _SE(js_cc_gfx_DynamicStates_stencilStatesBack_get), _SE(js_cc_gfx_DynamicStates_stencilStatesBack_set)); 
    
    cls->defineFunction("copy", _SE(js_cc_gfx_DynamicStates_copy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DynamicStates));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DynamicStates>(cls);
    
    __jsb_cc_gfx_DynamicStates_proto = cls->getProto();
    __jsb_cc_gfx_DynamicStates_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_GFXObject_class = nullptr;
se::Object* __jsb_cc_gfx_GFXObject_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_GFXObject) 

static bool js_new_cc_gfx_GFXObject(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    cc::gfx::ObjectType arg1 ;
    cc::gfx::GFXObject *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = (cc::gfx::GFXObject *)new cc::gfx::GFXObject(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_GFXObject, __jsb_cc_gfx_GFXObject_class, js_delete_cc_gfx_GFXObject)

static bool js_delete_cc_gfx_GFXObject(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_GFXObject) 

static bool js_cc_gfx_GFXObject_getObjectID_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::GFXObject *arg1 = (cc::gfx::GFXObject *) NULL ;
    uint32_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = cc::gfx::GFXObject::getObjectID((cc::gfx::GFXObject const *)arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_GFXObject_getObjectID_static) 

static bool js_cc_gfx_GFXObject_objectType_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::GFXObject *arg1 = (cc::gfx::GFXObject *) NULL ;
    cc::gfx::ObjectType result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::GFXObject>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::ObjectType)cc_gfx_GFXObject_objectType_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_GFXObject_objectType_get) 

static bool js_cc_gfx_GFXObject_objectID_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::GFXObject *arg1 = (cc::gfx::GFXObject *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::GFXObject>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_GFXObject_objectID_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_GFXObject_objectID_get) 

static bool js_cc_gfx_GFXObject_typedID_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::GFXObject *arg1 = (cc::gfx::GFXObject *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::GFXObject>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_GFXObject_typedID_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_GFXObject_typedID_get) 

bool js_register_cc_gfx_GFXObject(se::Object* obj) {
    auto* cls = se::Class::create("GFXObject", obj, nullptr, _SE(js_new_cc_gfx_GFXObject)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("objectType", _SE(js_cc_gfx_GFXObject_objectType_get), nullptr); 
    cls->defineProperty("objectID", _SE(js_cc_gfx_GFXObject_objectID_get), nullptr); 
    cls->defineProperty("typedID", _SE(js_cc_gfx_GFXObject_typedID_get), nullptr); 
    
    
    
    cls->defineStaticFunction("getObjectID", _SE(js_cc_gfx_GFXObject_getObjectID_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_GFXObject));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::GFXObject>(cls);
    
    __jsb_cc_gfx_GFXObject_proto = cls->getProto();
    __jsb_cc_gfx_GFXObject_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Buffer_class = nullptr;
se::Object* __jsb_cc_gfx_Buffer_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Buffer) 

static bool js_delete_cc_gfx_Buffer(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Buffer) 

static bool js_cc_gfx_Buffer_computeHash_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferInfo *arg1 = 0 ;
    cc::gfx::BufferInfo temp1 ;
    ccstd::hash_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = cc::gfx::Buffer::computeHash((cc::gfx::BufferInfo const &)*arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Buffer_computeHash_static) 

static bool js_cc_gfx_Buffer_resize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Buffer *arg1 = (cc::gfx::Buffer *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Buffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->resize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Buffer_resize) 

static bool js_cc_gfx_Buffer_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Buffer *arg1 = (cc::gfx::Buffer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Buffer>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Buffer_destroy) 

static bool js_cc_gfx_Buffer_isBufferView(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Buffer *arg1 = (cc::gfx::Buffer *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Buffer>(s);
    if (nullptr == arg1) return true;
    result = (bool)((cc::gfx::Buffer const *)arg1)->isBufferView();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Buffer_isBufferView) 

static bool js_cc_gfx_Buffer_usage_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Buffer *arg1 = (cc::gfx::Buffer *) NULL ;
    cc::gfx::BufferUsage result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Buffer>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::BufferUsage)cc_gfx_Buffer_usage_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Buffer_usage_get) 

static bool js_cc_gfx_Buffer_memUsage_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Buffer *arg1 = (cc::gfx::Buffer *) NULL ;
    cc::gfx::MemoryUsage result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Buffer>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::MemoryUsage)cc_gfx_Buffer_memUsage_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Buffer_memUsage_get) 

static bool js_cc_gfx_Buffer_stride_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Buffer *arg1 = (cc::gfx::Buffer *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Buffer>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_Buffer_stride_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Buffer_stride_get) 

static bool js_cc_gfx_Buffer_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Buffer *arg1 = (cc::gfx::Buffer *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Buffer>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_Buffer_count_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Buffer_count_get) 

static bool js_cc_gfx_Buffer_size_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Buffer *arg1 = (cc::gfx::Buffer *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Buffer>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_Buffer_size_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Buffer_size_get) 

static bool js_cc_gfx_Buffer_flags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Buffer *arg1 = (cc::gfx::Buffer *) NULL ;
    cc::gfx::BufferFlags result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Buffer>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::BufferFlags)cc_gfx_Buffer_flags_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Buffer_flags_get) 

bool js_register_cc_gfx_Buffer(se::Object* obj) {
    auto* cls = se::Class::create("Buffer", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("usage", _SE(js_cc_gfx_Buffer_usage_get), nullptr); 
    cls->defineProperty("memUsage", _SE(js_cc_gfx_Buffer_memUsage_get), nullptr); 
    cls->defineProperty("stride", _SE(js_cc_gfx_Buffer_stride_get), nullptr); 
    cls->defineProperty("count", _SE(js_cc_gfx_Buffer_count_get), nullptr); 
    cls->defineProperty("size", _SE(js_cc_gfx_Buffer_size_get), nullptr); 
    cls->defineProperty("flags", _SE(js_cc_gfx_Buffer_flags_get), nullptr); 
    
    cls->defineFunction("resize", _SE(js_cc_gfx_Buffer_resize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_Buffer_destroy)); 
    cls->defineFunction("isBufferView", _SE(js_cc_gfx_Buffer_isBufferView)); 
    
    
    cls->defineStaticFunction("computeHash", _SE(js_cc_gfx_Buffer_computeHash_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Buffer));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Buffer>(cls);
    
    __jsb_cc_gfx_Buffer_proto = cls->getProto();
    __jsb_cc_gfx_Buffer_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_CommandBuffer_class = nullptr;
se::Object* __jsb_cc_gfx_CommandBuffer_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_CommandBuffer) 

static bool js_delete_cc_gfx_CommandBuffer(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_CommandBuffer) 

static bool js_cc_gfx_CommandBuffer_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::CommandBufferInfo *arg2 = 0 ;
    cc::gfx::CommandBufferInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::CommandBufferInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_initialize) 

static bool js_cc_gfx_CommandBuffer_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_destroy) 

static bool js_cc_gfx_CommandBuffer_begin__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::RenderPass *arg2 = (cc::gfx::RenderPass *) NULL ;
    uint32_t arg3 ;
    cc::gfx::Framebuffer *arg4 = (cc::gfx::Framebuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->begin(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_end(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    (arg1)->end();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_end) 

static bool js_cc_gfx_CommandBuffer_beginRenderPass__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::RenderPass *arg2 = (cc::gfx::RenderPass *) NULL ;
    cc::gfx::Framebuffer *arg3 = (cc::gfx::Framebuffer *) NULL ;
    cc::gfx::Rect *arg4 = 0 ;
    cc::gfx::Color *arg5 = (cc::gfx::Color *) NULL ;
    float arg6 ;
    uint32_t arg7 ;
    cc::gfx::CommandBuffer **arg8 = (cc::gfx::CommandBuffer **) NULL ;
    uint32_t arg9 ;
    cc::gfx::Rect temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[6], &arg8, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->beginRenderPass(arg2,arg3,(cc::gfx::Rect const &)*arg4,(cc::gfx::Color const *)arg5,arg6,arg7,(cc::gfx::CommandBuffer *const *)arg8,arg9);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_endRenderPass(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    (arg1)->endRenderPass();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_endRenderPass) 

static bool js_cc_gfx_CommandBuffer_bindPipelineState(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::PipelineState *arg2 = (cc::gfx::PipelineState *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->bindPipelineState(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_bindPipelineState) 

static bool js_cc_gfx_CommandBuffer_bindDescriptorSet__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    uint32_t arg2 ;
    cc::gfx::DescriptorSet *arg3 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg4 ;
    uint32_t *arg5 = (uint32_t *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->bindDescriptorSet(arg2,arg3,arg4,(uint32_t const *)arg5);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_bindInputAssembler(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::InputAssembler *arg2 = (cc::gfx::InputAssembler *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->bindInputAssembler(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_bindInputAssembler) 

static bool js_cc_gfx_CommandBuffer_setViewport(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::Viewport *arg2 = 0 ;
    cc::gfx::Viewport temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setViewport((cc::gfx::Viewport const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_setViewport) 

static bool js_cc_gfx_CommandBuffer_setScissor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::Rect *arg2 = 0 ;
    cc::gfx::Rect temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setScissor((cc::gfx::Rect const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_setScissor) 

static bool js_cc_gfx_CommandBuffer_setLineWidth(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setLineWidth(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_setLineWidth) 

static bool js_cc_gfx_CommandBuffer_setDepthBias(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setDepthBias(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_setDepthBias) 

static bool js_cc_gfx_CommandBuffer_setBlendConstants(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::Color *arg2 = 0 ;
    cc::gfx::Color temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setBlendConstants((cc::gfx::Color const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_setBlendConstants) 

static bool js_cc_gfx_CommandBuffer_setDepthBound(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    float arg2 ;
    float arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setDepthBound(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_setDepthBound) 

static bool js_cc_gfx_CommandBuffer_setStencilWriteMask(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::StencilFace arg2 ;
    uint32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setStencilWriteMask(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_setStencilWriteMask) 

static bool js_cc_gfx_CommandBuffer_setStencilCompareMask(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::StencilFace arg2 ;
    uint32_t arg3 ;
    uint32_t arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setStencilCompareMask(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_setStencilCompareMask) 

static bool js_cc_gfx_CommandBuffer_nextSubpass(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    (arg1)->nextSubpass();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_nextSubpass) 

static bool js_cc_gfx_CommandBuffer_drawWithInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::DrawInfo *arg2 = 0 ;
    cc::gfx::DrawInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->draw((cc::gfx::DrawInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_drawWithInfo) 

static bool js_cc_gfx_CommandBuffer_blitTexture__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::Texture *arg2 = (cc::gfx::Texture *) NULL ;
    cc::gfx::Texture *arg3 = (cc::gfx::Texture *) NULL ;
    cc::gfx::TextureBlit *arg4 = (cc::gfx::TextureBlit *) NULL ;
    uint32_t arg5 ;
    cc::gfx::Filter arg6 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->blitTexture(arg2,arg3,(cc::gfx::TextureBlit const *)arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_dispatch(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::DispatchInfo *arg2 = 0 ;
    cc::gfx::DispatchInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->dispatch((cc::gfx::DispatchInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_dispatch) 

static bool js_cc_gfx_CommandBuffer_beginQuery(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::QueryPool *arg2 = (cc::gfx::QueryPool *) NULL ;
    uint32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->beginQuery(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_beginQuery) 

static bool js_cc_gfx_CommandBuffer_endQuery(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::QueryPool *arg2 = (cc::gfx::QueryPool *) NULL ;
    uint32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->endQuery(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_endQuery) 

static bool js_cc_gfx_CommandBuffer_resetQueryPool(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::QueryPool *arg2 = (cc::gfx::QueryPool *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->resetQueryPool(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_resetQueryPool) 

static bool js_cc_gfx_CommandBuffer_completeQueryPool(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::QueryPool *arg2 = (cc::gfx::QueryPool *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->completeQueryPool(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_completeQueryPool) 

static bool js_cc_gfx_CommandBuffer_pipelineBarrier__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::GeneralBarrier *arg2 = (cc::gfx::GeneralBarrier *) NULL ;
    cc::gfx::BufferBarrier **arg3 = (cc::gfx::BufferBarrier **) NULL ;
    cc::gfx::Buffer **arg4 = (cc::gfx::Buffer **) NULL ;
    uint32_t arg5 ;
    cc::gfx::TextureBarrier **arg6 = (cc::gfx::TextureBarrier **) NULL ;
    cc::gfx::Texture **arg7 = (cc::gfx::Texture **) NULL ;
    uint32_t arg8 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->pipelineBarrier((cc::gfx::GeneralBarrier const *)arg2,(cc::gfx::BufferBarrier const *const *)arg3,(cc::gfx::Buffer const *const *)arg4,arg5,(cc::gfx::TextureBarrier const *const *)arg6,(cc::gfx::Texture const *const *)arg7,arg8);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_begin__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    (arg1)->begin();
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_begin__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::RenderPass *arg2 = (cc::gfx::RenderPass *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->begin(arg2);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_begin__SWIG_3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::RenderPass *arg2 = (cc::gfx::RenderPass *) NULL ;
    uint32_t arg3 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->begin(arg2,arg3);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_begin(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_gfx_CommandBuffer_begin__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 0) {
        ok = js_cc_gfx_CommandBuffer_begin__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_gfx_CommandBuffer_begin__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_gfx_CommandBuffer_begin__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_begin) 

static bool js_cc_gfx_CommandBuffer_bindDescriptorSet__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    uint32_t arg2 ;
    cc::gfx::DescriptorSet *arg3 = (cc::gfx::DescriptorSet *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->bindDescriptorSet(arg2,arg3);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_bindDescriptorSet__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    uint32_t arg2 ;
    cc::gfx::DescriptorSet *arg3 = (cc::gfx::DescriptorSet *) NULL ;
    ccstd::vector< uint32_t > *arg4 = 0 ;
    ccstd::vector< uint32_t > temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    (arg1)->bindDescriptorSet(arg2,arg3,(ccstd::vector< uint32_t > const &)*arg4);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_bindDescriptorSet(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 4) {
        ok = js_cc_gfx_CommandBuffer_bindDescriptorSet__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_gfx_CommandBuffer_bindDescriptorSet__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 3) {
        ok = js_cc_gfx_CommandBuffer_bindDescriptorSet__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_bindDescriptorSet) 

static bool js_cc_gfx_CommandBuffer_beginRenderPass__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::RenderPass *arg2 = (cc::gfx::RenderPass *) NULL ;
    cc::gfx::Framebuffer *arg3 = (cc::gfx::Framebuffer *) NULL ;
    cc::gfx::Rect *arg4 = 0 ;
    cc::gfx::ColorList *arg5 = 0 ;
    float arg6 ;
    uint32_t arg7 ;
    cc::gfx::CommandBufferList *arg8 = 0 ;
    cc::gfx::Rect temp4 ;
    cc::gfx::ColorList temp5 ;
    cc::gfx::CommandBufferList temp8 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg5 = &temp5;
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[6], &temp8, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg8 = &temp8;
    
    (arg1)->beginRenderPass(arg2,arg3,(cc::gfx::Rect const &)*arg4,(cc::gfx::ColorList const &)*arg5,arg6,arg7,(cc::gfx::CommandBufferList const &)*arg8);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_beginRenderPass__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::RenderPass *arg2 = (cc::gfx::RenderPass *) NULL ;
    cc::gfx::Framebuffer *arg3 = (cc::gfx::Framebuffer *) NULL ;
    cc::gfx::Rect *arg4 = 0 ;
    cc::gfx::ColorList *arg5 = 0 ;
    float arg6 ;
    uint32_t arg7 ;
    cc::gfx::Rect temp4 ;
    cc::gfx::ColorList temp5 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg5 = &temp5;
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->beginRenderPass(arg2,arg3,(cc::gfx::Rect const &)*arg4,(cc::gfx::ColorList const &)*arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_beginRenderPass__SWIG_3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::RenderPass *arg2 = (cc::gfx::RenderPass *) NULL ;
    cc::gfx::Framebuffer *arg3 = (cc::gfx::Framebuffer *) NULL ;
    cc::gfx::Rect *arg4 = 0 ;
    cc::gfx::Color *arg5 = (cc::gfx::Color *) NULL ;
    float arg6 ;
    uint32_t arg7 ;
    cc::gfx::Rect temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->beginRenderPass(arg2,arg3,(cc::gfx::Rect const &)*arg4,(cc::gfx::Color const *)arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_beginRenderPass(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 8) {
        ok = js_cc_gfx_CommandBuffer_beginRenderPass__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 7) {
        ok = js_cc_gfx_CommandBuffer_beginRenderPass__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 6) {
        ok = js_cc_gfx_CommandBuffer_beginRenderPass__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 6) {
        ok = js_cc_gfx_CommandBuffer_beginRenderPass__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_beginRenderPass) 

static bool js_cc_gfx_CommandBuffer_draw(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::InputAssembler *arg2 = (cc::gfx::InputAssembler *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->draw(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_draw) 

static bool js_cc_gfx_CommandBuffer_blitTexture__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::Texture *arg2 = (cc::gfx::Texture *) NULL ;
    cc::gfx::Texture *arg3 = (cc::gfx::Texture *) NULL ;
    cc::gfx::TextureBlitList *arg4 = 0 ;
    cc::gfx::Filter arg5 ;
    cc::gfx::TextureBlitList temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->blitTexture(arg2,arg3,(cc::gfx::TextureBlitList const &)*arg4,arg5);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_blitTexture(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 5) {
        ok = js_cc_gfx_CommandBuffer_blitTexture__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 4) {
        ok = js_cc_gfx_CommandBuffer_blitTexture__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_blitTexture) 

static bool js_cc_gfx_CommandBuffer_pipelineBarrier__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::GeneralBarrier *arg2 = (cc::gfx::GeneralBarrier *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->pipelineBarrier((cc::gfx::GeneralBarrier const *)arg2);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_pipelineBarrier__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::GeneralBarrier *arg2 = (cc::gfx::GeneralBarrier *) NULL ;
    cc::gfx::BufferBarrierList *arg3 = 0 ;
    cc::gfx::BufferList *arg4 = 0 ;
    cc::gfx::TextureBarrierList *arg5 = 0 ;
    cc::gfx::TextureList *arg6 = 0 ;
    cc::gfx::BufferBarrierList temp3 ;
    cc::gfx::BufferList temp4 ;
    cc::gfx::TextureBarrierList temp5 ;
    cc::gfx::TextureList temp6 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg5 = &temp5;
    
    
    ok &= sevalue_to_native(args[4], &temp6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg6 = &temp6;
    
    (arg1)->pipelineBarrier((cc::gfx::GeneralBarrier const *)arg2,(cc::gfx::BufferBarrierList const &)*arg3,(cc::gfx::BufferList const &)*arg4,(cc::gfx::TextureBarrierList const &)*arg5,(cc::gfx::TextureList const &)*arg6);
    
    
    return true;
}

static bool js_cc_gfx_CommandBuffer_pipelineBarrier(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 7) {
        ok = js_cc_gfx_CommandBuffer_pipelineBarrier__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_gfx_CommandBuffer_pipelineBarrier__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 5) {
        ok = js_cc_gfx_CommandBuffer_pipelineBarrier__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_CommandBuffer_pipelineBarrier) 

static bool js_cc_gfx_CommandBuffer_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::CommandBufferType result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::CommandBufferType)cc_gfx_CommandBuffer_type_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_CommandBuffer_type_get) 

static bool js_cc_gfx_CommandBuffer_queue_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    cc::gfx::Queue *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Queue *)cc_gfx_CommandBuffer_queue_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_CommandBuffer_queue_get) 

static bool js_cc_gfx_CommandBuffer_numDrawCalls_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_CommandBuffer_numDrawCalls_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_CommandBuffer_numDrawCalls_get) 

static bool js_cc_gfx_CommandBuffer_numInstances_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_CommandBuffer_numInstances_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_CommandBuffer_numInstances_get) 

static bool js_cc_gfx_CommandBuffer_numTris_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::CommandBuffer *arg1 = (cc::gfx::CommandBuffer *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::CommandBuffer>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_CommandBuffer_numTris_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_CommandBuffer_numTris_get) 

bool js_register_cc_gfx_CommandBuffer(se::Object* obj) {
    auto* cls = se::Class::create("CommandBuffer", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("type", _SE(js_cc_gfx_CommandBuffer_type_get), nullptr); 
    cls->defineProperty("queue", _SE(js_cc_gfx_CommandBuffer_queue_get), nullptr); 
    cls->defineProperty("numDrawCalls", _SE(js_cc_gfx_CommandBuffer_numDrawCalls_get), nullptr); 
    cls->defineProperty("numInstances", _SE(js_cc_gfx_CommandBuffer_numInstances_get), nullptr); 
    cls->defineProperty("numTris", _SE(js_cc_gfx_CommandBuffer_numTris_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_CommandBuffer_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_CommandBuffer_destroy)); 
    cls->defineFunction("end", _SE(js_cc_gfx_CommandBuffer_end)); 
    cls->defineFunction("endRenderPass", _SE(js_cc_gfx_CommandBuffer_endRenderPass)); 
    cls->defineFunction("bindPipelineState", _SE(js_cc_gfx_CommandBuffer_bindPipelineState)); 
    cls->defineFunction("bindInputAssembler", _SE(js_cc_gfx_CommandBuffer_bindInputAssembler)); 
    cls->defineFunction("setViewport", _SE(js_cc_gfx_CommandBuffer_setViewport)); 
    cls->defineFunction("setScissor", _SE(js_cc_gfx_CommandBuffer_setScissor)); 
    cls->defineFunction("setLineWidth", _SE(js_cc_gfx_CommandBuffer_setLineWidth)); 
    cls->defineFunction("setDepthBias", _SE(js_cc_gfx_CommandBuffer_setDepthBias)); 
    cls->defineFunction("setBlendConstants", _SE(js_cc_gfx_CommandBuffer_setBlendConstants)); 
    cls->defineFunction("setDepthBound", _SE(js_cc_gfx_CommandBuffer_setDepthBound)); 
    cls->defineFunction("setStencilWriteMask", _SE(js_cc_gfx_CommandBuffer_setStencilWriteMask)); 
    cls->defineFunction("setStencilCompareMask", _SE(js_cc_gfx_CommandBuffer_setStencilCompareMask)); 
    cls->defineFunction("nextSubpass", _SE(js_cc_gfx_CommandBuffer_nextSubpass)); 
    cls->defineFunction("drawWithInfo", _SE(js_cc_gfx_CommandBuffer_drawWithInfo)); 
    cls->defineFunction("dispatch", _SE(js_cc_gfx_CommandBuffer_dispatch)); 
    cls->defineFunction("beginQuery", _SE(js_cc_gfx_CommandBuffer_beginQuery)); 
    cls->defineFunction("endQuery", _SE(js_cc_gfx_CommandBuffer_endQuery)); 
    cls->defineFunction("resetQueryPool", _SE(js_cc_gfx_CommandBuffer_resetQueryPool)); 
    cls->defineFunction("completeQueryPool", _SE(js_cc_gfx_CommandBuffer_completeQueryPool)); 
    cls->defineFunction("begin", _SE(js_cc_gfx_CommandBuffer_begin)); 
    cls->defineFunction("bindDescriptorSet", _SE(js_cc_gfx_CommandBuffer_bindDescriptorSet)); 
    cls->defineFunction("beginRenderPass", _SE(js_cc_gfx_CommandBuffer_beginRenderPass)); 
    cls->defineFunction("draw", _SE(js_cc_gfx_CommandBuffer_draw)); 
    cls->defineFunction("blitTexture", _SE(js_cc_gfx_CommandBuffer_blitTexture)); 
    cls->defineFunction("pipelineBarrier", _SE(js_cc_gfx_CommandBuffer_pipelineBarrier)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_CommandBuffer));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::CommandBuffer>(cls);
    
    __jsb_cc_gfx_CommandBuffer_proto = cls->getProto();
    __jsb_cc_gfx_CommandBuffer_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DescriptorSet_class = nullptr;
se::Object* __jsb_cc_gfx_DescriptorSet_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DescriptorSet) 

static bool js_delete_cc_gfx_DescriptorSet(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DescriptorSet) 

static bool js_cc_gfx_DescriptorSet_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    cc::gfx::DescriptorSetInfo *arg2 = 0 ;
    cc::gfx::DescriptorSetInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::DescriptorSetInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSet_initialize) 

static bool js_cc_gfx_DescriptorSet_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSet_destroy) 

static bool js_cc_gfx_DescriptorSet_update(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    if (nullptr == arg1) return true;
    (arg1)->update();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSet_update) 

static bool js_cc_gfx_DescriptorSet_bindBuffer__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Buffer *arg3 = (cc::gfx::Buffer *) NULL ;
    uint32_t arg4 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->bindBuffer(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_gfx_DescriptorSet_bindTexture__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Texture *arg3 = (cc::gfx::Texture *) NULL ;
    uint32_t arg4 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->bindTexture(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_gfx_DescriptorSet_bindSampler__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Sampler *arg3 = (cc::gfx::Sampler *) NULL ;
    uint32_t arg4 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->bindSampler(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_gfx_DescriptorSet_bindBufferJSB(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Buffer *arg3 = (cc::gfx::Buffer *) NULL ;
    uint32_t arg4 ;
    bool result;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (bool)(arg1)->bindBufferJSB(arg2,arg3,arg4);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSet_bindBufferJSB) 

static bool js_cc_gfx_DescriptorSet_bindTextureJSB(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Texture *arg3 = (cc::gfx::Texture *) NULL ;
    uint32_t arg4 ;
    bool result;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (bool)(arg1)->bindTextureJSB(arg2,arg3,arg4);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSet_bindTextureJSB) 

static bool js_cc_gfx_DescriptorSet_bindSamplerJSB(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Sampler *arg3 = (cc::gfx::Sampler *) NULL ;
    uint32_t arg4 ;
    bool result;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (bool)(arg1)->bindSamplerJSB(arg2,arg3,arg4);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSet_bindSamplerJSB) 

static bool js_cc_gfx_DescriptorSet_getBuffer__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    cc::gfx::Buffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (cc::gfx::Buffer *)((cc::gfx::DescriptorSet const *)arg1)->getBuffer(arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_gfx_DescriptorSet_getTexture__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    cc::gfx::Texture *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (cc::gfx::Texture *)((cc::gfx::DescriptorSet const *)arg1)->getTexture(arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_gfx_DescriptorSet_getSampler__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    cc::gfx::Sampler *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (cc::gfx::Sampler *)((cc::gfx::DescriptorSet const *)arg1)->getSampler(arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_gfx_DescriptorSet_bindBuffer__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Buffer *arg3 = (cc::gfx::Buffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->bindBuffer(arg2,arg3);
    
    
    return true;
}

static bool js_cc_gfx_DescriptorSet_bindBuffer(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_gfx_DescriptorSet_bindBuffer__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_gfx_DescriptorSet_bindBuffer__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSet_bindBuffer) 

static bool js_cc_gfx_DescriptorSet_bindTexture__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Texture *arg3 = (cc::gfx::Texture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->bindTexture(arg2,arg3);
    
    
    return true;
}

static bool js_cc_gfx_DescriptorSet_bindTexture(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_gfx_DescriptorSet_bindTexture__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_gfx_DescriptorSet_bindTexture__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSet_bindTexture) 

static bool js_cc_gfx_DescriptorSet_bindSampler__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Sampler *arg3 = (cc::gfx::Sampler *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->bindSampler(arg2,arg3);
    
    
    return true;
}

static bool js_cc_gfx_DescriptorSet_bindSampler(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_gfx_DescriptorSet_bindSampler__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_gfx_DescriptorSet_bindSampler__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSet_bindSampler) 

static bool js_cc_gfx_DescriptorSet_getBuffer__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Buffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (cc::gfx::Buffer *)((cc::gfx::DescriptorSet const *)arg1)->getBuffer(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_gfx_DescriptorSet_getBuffer(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_cc_gfx_DescriptorSet_getBuffer__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_gfx_DescriptorSet_getBuffer__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSet_getBuffer) 

static bool js_cc_gfx_DescriptorSet_getTexture__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Texture *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (cc::gfx::Texture *)((cc::gfx::DescriptorSet const *)arg1)->getTexture(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_gfx_DescriptorSet_getTexture(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_cc_gfx_DescriptorSet_getTexture__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_gfx_DescriptorSet_getTexture__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSet_getTexture) 

static bool js_cc_gfx_DescriptorSet_getSampler__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Sampler *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (cc::gfx::Sampler *)((cc::gfx::DescriptorSet const *)arg1)->getSampler(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_gfx_DescriptorSet_getSampler(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_cc_gfx_DescriptorSet_getSampler__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_gfx_DescriptorSet_getSampler__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSet_getSampler) 

static bool js_cc_gfx_DescriptorSet_layout_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSet *arg1 = (cc::gfx::DescriptorSet *) NULL ;
    cc::gfx::DescriptorSetLayout *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSet>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::DescriptorSetLayout *)cc_gfx_DescriptorSet_layout_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DescriptorSet_layout_get) 

bool js_register_cc_gfx_DescriptorSet(se::Object* obj) {
    auto* cls = se::Class::create("DescriptorSet", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("layout", _SE(js_cc_gfx_DescriptorSet_layout_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_DescriptorSet_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_DescriptorSet_destroy)); 
    cls->defineFunction("update", _SE(js_cc_gfx_DescriptorSet_update)); 
    cls->defineFunction("bindBufferJSB", _SE(js_cc_gfx_DescriptorSet_bindBufferJSB)); 
    cls->defineFunction("bindTextureJSB", _SE(js_cc_gfx_DescriptorSet_bindTextureJSB)); 
    cls->defineFunction("bindSamplerJSB", _SE(js_cc_gfx_DescriptorSet_bindSamplerJSB)); 
    cls->defineFunction("bindBuffer", _SE(js_cc_gfx_DescriptorSet_bindBuffer)); 
    cls->defineFunction("bindTexture", _SE(js_cc_gfx_DescriptorSet_bindTexture)); 
    cls->defineFunction("bindSampler", _SE(js_cc_gfx_DescriptorSet_bindSampler)); 
    cls->defineFunction("getBuffer", _SE(js_cc_gfx_DescriptorSet_getBuffer)); 
    cls->defineFunction("getTexture", _SE(js_cc_gfx_DescriptorSet_getTexture)); 
    cls->defineFunction("getSampler", _SE(js_cc_gfx_DescriptorSet_getSampler)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DescriptorSet));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DescriptorSet>(cls);
    
    __jsb_cc_gfx_DescriptorSet_proto = cls->getProto();
    __jsb_cc_gfx_DescriptorSet_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DescriptorSetLayout_class = nullptr;
se::Object* __jsb_cc_gfx_DescriptorSetLayout_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DescriptorSetLayout) 

static bool js_delete_cc_gfx_DescriptorSetLayout(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DescriptorSetLayout) 

static bool js_cc_gfx_DescriptorSetLayout_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetLayout *arg1 = (cc::gfx::DescriptorSetLayout *) NULL ;
    cc::gfx::DescriptorSetLayoutInfo *arg2 = 0 ;
    cc::gfx::DescriptorSetLayoutInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::DescriptorSetLayoutInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSetLayout_initialize) 

static bool js_cc_gfx_DescriptorSetLayout_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetLayout *arg1 = (cc::gfx::DescriptorSetLayout *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayout>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSetLayout_destroy) 

static bool js_cc_gfx_DescriptorSetLayout_getDynamicBindings(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetLayout *arg1 = (cc::gfx::DescriptorSetLayout *) NULL ;
    ccstd::vector< uint32_t > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayout>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< uint32_t > *) &((cc::gfx::DescriptorSetLayout const *)arg1)->getDynamicBindings();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSetLayout_getDynamicBindings) 

static bool js_cc_gfx_DescriptorSetLayout_getDescriptorCount(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::DescriptorSetLayout *arg1 = (cc::gfx::DescriptorSetLayout *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayout>(s);
    if (nullptr == arg1) return true;
    result = ((cc::gfx::DescriptorSetLayout const *)arg1)->getDescriptorCount();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_DescriptorSetLayout_getDescriptorCount) 

static bool js_cc_gfx_DescriptorSetLayout_bindings_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayout *arg1 = (cc::gfx::DescriptorSetLayout *) NULL ;
    cc::gfx::DescriptorSetLayoutBindingList result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::DescriptorSetLayout>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_DescriptorSetLayout_bindings_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_DescriptorSetLayout_bindings_get) 

bool js_register_cc_gfx_DescriptorSetLayout(se::Object* obj) {
    auto* cls = se::Class::create("DescriptorSetLayout", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("bindings", _SE(js_cc_gfx_DescriptorSetLayout_bindings_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_DescriptorSetLayout_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_DescriptorSetLayout_destroy)); 
    cls->defineFunction("getDynamicBindings", _SE(js_cc_gfx_DescriptorSetLayout_getDynamicBindings)); 
    cls->defineFunction("getDescriptorCount", _SE(js_cc_gfx_DescriptorSetLayout_getDescriptorCount)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DescriptorSetLayout));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DescriptorSetLayout>(cls);
    
    __jsb_cc_gfx_DescriptorSetLayout_proto = cls->getProto();
    __jsb_cc_gfx_DescriptorSetLayout_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Framebuffer_class = nullptr;
se::Object* __jsb_cc_gfx_Framebuffer_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Framebuffer) 

static bool js_delete_cc_gfx_Framebuffer(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Framebuffer) 

static bool js_cc_gfx_Framebuffer_computeHash_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::FramebufferInfo *arg1 = 0 ;
    cc::gfx::FramebufferInfo temp1 ;
    ccstd::hash_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = cc::gfx::Framebuffer::computeHash((cc::gfx::FramebufferInfo const &)*arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Framebuffer_computeHash_static) 

static bool js_cc_gfx_Framebuffer_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Framebuffer *arg1 = (cc::gfx::Framebuffer *) NULL ;
    cc::gfx::FramebufferInfo *arg2 = 0 ;
    cc::gfx::FramebufferInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Framebuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::FramebufferInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Framebuffer_initialize) 

static bool js_cc_gfx_Framebuffer_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Framebuffer *arg1 = (cc::gfx::Framebuffer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Framebuffer>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Framebuffer_destroy) 

static bool js_cc_gfx_Framebuffer_renderPass_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Framebuffer *arg1 = (cc::gfx::Framebuffer *) NULL ;
    cc::gfx::RenderPass *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Framebuffer>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::RenderPass *)cc_gfx_Framebuffer_renderPass_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Framebuffer_renderPass_get) 

static bool js_cc_gfx_Framebuffer_colorTextures_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Framebuffer *arg1 = (cc::gfx::Framebuffer *) NULL ;
    cc::gfx::TextureList *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Framebuffer>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::TextureList *) &cc_gfx_Framebuffer_colorTextures_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Framebuffer_colorTextures_get) 

static bool js_cc_gfx_Framebuffer_depthStencilTexture_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Framebuffer *arg1 = (cc::gfx::Framebuffer *) NULL ;
    cc::gfx::Texture *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Framebuffer>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Texture *)cc_gfx_Framebuffer_depthStencilTexture_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Framebuffer_depthStencilTexture_get) 

bool js_register_cc_gfx_Framebuffer(se::Object* obj) {
    auto* cls = se::Class::create("Framebuffer", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("renderPass", _SE(js_cc_gfx_Framebuffer_renderPass_get), nullptr); 
    cls->defineProperty("colorTextures", _SE(js_cc_gfx_Framebuffer_colorTextures_get), nullptr); 
    cls->defineProperty("depthStencilTexture", _SE(js_cc_gfx_Framebuffer_depthStencilTexture_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_Framebuffer_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_Framebuffer_destroy)); 
    
    
    cls->defineStaticFunction("computeHash", _SE(js_cc_gfx_Framebuffer_computeHash_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Framebuffer));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Framebuffer>(cls);
    
    __jsb_cc_gfx_Framebuffer_proto = cls->getProto();
    __jsb_cc_gfx_Framebuffer_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_InputAssembler_class = nullptr;
se::Object* __jsb_cc_gfx_InputAssembler_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_InputAssembler) 

static bool js_delete_cc_gfx_InputAssembler(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_InputAssembler) 

static bool js_cc_gfx_InputAssembler_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    cc::gfx::InputAssemblerInfo *arg2 = 0 ;
    cc::gfx::InputAssemblerInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::InputAssemblerInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_InputAssembler_initialize) 

static bool js_cc_gfx_InputAssembler_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_InputAssembler_destroy) 

static bool js_cc_gfx_InputAssembler_vertexBuffers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    cc::gfx::BufferList *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::BufferList *) &cc_gfx_InputAssembler_vertexBuffers_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssembler_vertexBuffers_get) 

static bool js_cc_gfx_InputAssembler_attributes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    cc::gfx::AttributeList *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::AttributeList *) &cc_gfx_InputAssembler_attributes_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssembler_attributes_get) 

static bool js_cc_gfx_InputAssembler_indexBuffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    cc::gfx::Buffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Buffer *)cc_gfx_InputAssembler_indexBuffer_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssembler_indexBuffer_get) 

static bool js_cc_gfx_InputAssembler_indirectBuffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    cc::gfx::Buffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Buffer *)cc_gfx_InputAssembler_indirectBuffer_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssembler_indirectBuffer_get) 

static bool js_cc_gfx_InputAssembler_attributesHash_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_InputAssembler_attributesHash_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssembler_attributesHash_get) 

static bool js_cc_gfx_InputAssembler_drawInfo_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    cc::gfx::DrawInfo *arg2 = 0 ;
    cc::gfx::DrawInfo temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_gfx_InputAssembler_drawInfo_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_InputAssembler_drawInfo_set) 

static bool js_cc_gfx_InputAssembler_drawInfo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    cc::gfx::DrawInfo *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::DrawInfo *) &cc_gfx_InputAssembler_drawInfo_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssembler_drawInfo_get) 

static bool js_cc_gfx_InputAssembler_vertexCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_gfx_InputAssembler_vertexCount_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_InputAssembler_vertexCount_set) 

static bool js_cc_gfx_InputAssembler_vertexCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_InputAssembler_vertexCount_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssembler_vertexCount_get) 

static bool js_cc_gfx_InputAssembler_firstVertex_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_gfx_InputAssembler_firstVertex_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_InputAssembler_firstVertex_set) 

static bool js_cc_gfx_InputAssembler_firstVertex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_InputAssembler_firstVertex_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssembler_firstVertex_get) 

static bool js_cc_gfx_InputAssembler_indexCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_gfx_InputAssembler_indexCount_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_InputAssembler_indexCount_set) 

static bool js_cc_gfx_InputAssembler_indexCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_InputAssembler_indexCount_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssembler_indexCount_get) 

static bool js_cc_gfx_InputAssembler_firstIndex_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_gfx_InputAssembler_firstIndex_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_InputAssembler_firstIndex_set) 

static bool js_cc_gfx_InputAssembler_firstIndex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_InputAssembler_firstIndex_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssembler_firstIndex_get) 

static bool js_cc_gfx_InputAssembler_vertexOffset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_gfx_InputAssembler_vertexOffset_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_InputAssembler_vertexOffset_set) 

static bool js_cc_gfx_InputAssembler_vertexOffset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_InputAssembler_vertexOffset_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssembler_vertexOffset_get) 

static bool js_cc_gfx_InputAssembler_instanceCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_gfx_InputAssembler_instanceCount_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_InputAssembler_instanceCount_set) 

static bool js_cc_gfx_InputAssembler_instanceCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_InputAssembler_instanceCount_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssembler_instanceCount_get) 

static bool js_cc_gfx_InputAssembler_firstInstance_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_gfx_InputAssembler_firstInstance_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_gfx_InputAssembler_firstInstance_set) 

static bool js_cc_gfx_InputAssembler_firstInstance_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::InputAssembler *arg1 = (cc::gfx::InputAssembler *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::InputAssembler>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_InputAssembler_firstInstance_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_InputAssembler_firstInstance_get) 

bool js_register_cc_gfx_InputAssembler(se::Object* obj) {
    auto* cls = se::Class::create("InputAssembler", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("vertexBuffers", _SE(js_cc_gfx_InputAssembler_vertexBuffers_get), nullptr); 
    cls->defineProperty("attributes", _SE(js_cc_gfx_InputAssembler_attributes_get), nullptr); 
    cls->defineProperty("indexBuffer", _SE(js_cc_gfx_InputAssembler_indexBuffer_get), nullptr); 
    cls->defineProperty("indirectBuffer", _SE(js_cc_gfx_InputAssembler_indirectBuffer_get), nullptr); 
    cls->defineProperty("attributesHash", _SE(js_cc_gfx_InputAssembler_attributesHash_get), nullptr); 
    cls->defineProperty("drawInfo", _SE(js_cc_gfx_InputAssembler_drawInfo_get), _SE(js_cc_gfx_InputAssembler_drawInfo_set)); 
    cls->defineProperty("vertexCount", _SE(js_cc_gfx_InputAssembler_vertexCount_get), _SE(js_cc_gfx_InputAssembler_vertexCount_set)); 
    cls->defineProperty("firstVertex", _SE(js_cc_gfx_InputAssembler_firstVertex_get), _SE(js_cc_gfx_InputAssembler_firstVertex_set)); 
    cls->defineProperty("indexCount", _SE(js_cc_gfx_InputAssembler_indexCount_get), _SE(js_cc_gfx_InputAssembler_indexCount_set)); 
    cls->defineProperty("firstIndex", _SE(js_cc_gfx_InputAssembler_firstIndex_get), _SE(js_cc_gfx_InputAssembler_firstIndex_set)); 
    cls->defineProperty("vertexOffset", _SE(js_cc_gfx_InputAssembler_vertexOffset_get), _SE(js_cc_gfx_InputAssembler_vertexOffset_set)); 
    cls->defineProperty("instanceCount", _SE(js_cc_gfx_InputAssembler_instanceCount_get), _SE(js_cc_gfx_InputAssembler_instanceCount_set)); 
    cls->defineProperty("firstInstance", _SE(js_cc_gfx_InputAssembler_firstInstance_get), _SE(js_cc_gfx_InputAssembler_firstInstance_set)); 
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_InputAssembler_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_InputAssembler_destroy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_InputAssembler));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::InputAssembler>(cls);
    
    __jsb_cc_gfx_InputAssembler_proto = cls->getProto();
    __jsb_cc_gfx_InputAssembler_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_PipelineLayout_class = nullptr;
se::Object* __jsb_cc_gfx_PipelineLayout_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_PipelineLayout) 

static bool js_delete_cc_gfx_PipelineLayout(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_PipelineLayout) 

static bool js_cc_gfx_PipelineLayout_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineLayout *arg1 = (cc::gfx::PipelineLayout *) NULL ;
    cc::gfx::PipelineLayoutInfo *arg2 = 0 ;
    cc::gfx::PipelineLayoutInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::PipelineLayoutInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_PipelineLayout_initialize) 

static bool js_cc_gfx_PipelineLayout_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineLayout *arg1 = (cc::gfx::PipelineLayout *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineLayout>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_PipelineLayout_destroy) 

static bool js_cc_gfx_PipelineLayout_getSetLayouts(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineLayout *arg1 = (cc::gfx::PipelineLayout *) NULL ;
    cc::gfx::DescriptorSetLayoutList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineLayout>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::DescriptorSetLayoutList *) &((cc::gfx::PipelineLayout const *)arg1)->getSetLayouts();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_PipelineLayout_getSetLayouts) 

bool js_register_cc_gfx_PipelineLayout(se::Object* obj) {
    auto* cls = se::Class::create("PipelineLayout", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_PipelineLayout_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_PipelineLayout_destroy)); 
    cls->defineFunction("getSetLayouts", _SE(js_cc_gfx_PipelineLayout_getSetLayouts)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_PipelineLayout));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::PipelineLayout>(cls);
    
    __jsb_cc_gfx_PipelineLayout_proto = cls->getProto();
    __jsb_cc_gfx_PipelineLayout_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_PipelineState_class = nullptr;
se::Object* __jsb_cc_gfx_PipelineState_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_PipelineState) 

static bool js_delete_cc_gfx_PipelineState(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_PipelineState) 

static bool js_cc_gfx_PipelineState_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineState *arg1 = (cc::gfx::PipelineState *) NULL ;
    cc::gfx::PipelineStateInfo *arg2 = 0 ;
    cc::gfx::PipelineStateInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineState>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::PipelineStateInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_PipelineState_initialize) 

static bool js_cc_gfx_PipelineState_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineState *arg1 = (cc::gfx::PipelineState *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineState>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_PipelineState_destroy) 

static bool js_cc_gfx_PipelineState_getDynamicStates(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineState *arg1 = (cc::gfx::PipelineState *) NULL ;
    cc::gfx::DynamicStateFlags result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineState>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::DynamicStateFlags)((cc::gfx::PipelineState const *)arg1)->getDynamicStates();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_PipelineState_getDynamicStates) 

static bool js_cc_gfx_PipelineState_getPipelineLayout(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::PipelineState *arg1 = (cc::gfx::PipelineState *) NULL ;
    cc::gfx::PipelineLayout *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineState>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::PipelineLayout *)((cc::gfx::PipelineState const *)arg1)->getPipelineLayout();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_PipelineState_getPipelineLayout) 

static bool js_cc_gfx_PipelineState_shader_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineState *arg1 = (cc::gfx::PipelineState *) NULL ;
    cc::gfx::Shader *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineState>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Shader *)cc_gfx_PipelineState_shader_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineState_shader_get) 

static bool js_cc_gfx_PipelineState_primitive_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineState *arg1 = (cc::gfx::PipelineState *) NULL ;
    cc::gfx::PrimitiveMode result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineState>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::PrimitiveMode)cc_gfx_PipelineState_primitive_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineState_primitive_get) 

static bool js_cc_gfx_PipelineState_bindPoint_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineState *arg1 = (cc::gfx::PipelineState *) NULL ;
    cc::gfx::PipelineBindPoint result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineState>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::PipelineBindPoint)cc_gfx_PipelineState_bindPoint_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineState_bindPoint_get) 

static bool js_cc_gfx_PipelineState_inputState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineState *arg1 = (cc::gfx::PipelineState *) NULL ;
    cc::gfx::InputState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineState>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::InputState *) &cc_gfx_PipelineState_inputState_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineState_inputState_get) 

static bool js_cc_gfx_PipelineState_rasterizerState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineState *arg1 = (cc::gfx::PipelineState *) NULL ;
    cc::gfx::RasterizerState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineState>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::RasterizerState *) &cc_gfx_PipelineState_rasterizerState_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineState_rasterizerState_get) 

static bool js_cc_gfx_PipelineState_depthStencilState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineState *arg1 = (cc::gfx::PipelineState *) NULL ;
    cc::gfx::DepthStencilState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineState>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::DepthStencilState *) &cc_gfx_PipelineState_depthStencilState_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineState_depthStencilState_get) 

static bool js_cc_gfx_PipelineState_blendState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineState *arg1 = (cc::gfx::PipelineState *) NULL ;
    cc::gfx::BlendState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineState>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::BlendState *) &cc_gfx_PipelineState_blendState_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineState_blendState_get) 

static bool js_cc_gfx_PipelineState_renderPass_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::PipelineState *arg1 = (cc::gfx::PipelineState *) NULL ;
    cc::gfx::RenderPass *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::PipelineState>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::RenderPass *)cc_gfx_PipelineState_renderPass_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_PipelineState_renderPass_get) 

bool js_register_cc_gfx_PipelineState(se::Object* obj) {
    auto* cls = se::Class::create("PipelineState", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("shader", _SE(js_cc_gfx_PipelineState_shader_get), nullptr); 
    cls->defineProperty("primitive", _SE(js_cc_gfx_PipelineState_primitive_get), nullptr); 
    cls->defineProperty("bindPoint", _SE(js_cc_gfx_PipelineState_bindPoint_get), nullptr); 
    cls->defineProperty("inputState", _SE(js_cc_gfx_PipelineState_inputState_get), nullptr); 
    cls->defineProperty("rasterizerState", _SE(js_cc_gfx_PipelineState_rasterizerState_get), nullptr); 
    cls->defineProperty("depthStencilState", _SE(js_cc_gfx_PipelineState_depthStencilState_get), nullptr); 
    cls->defineProperty("blendState", _SE(js_cc_gfx_PipelineState_blendState_get), nullptr); 
    cls->defineProperty("renderPass", _SE(js_cc_gfx_PipelineState_renderPass_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_PipelineState_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_PipelineState_destroy)); 
    cls->defineFunction("getDynamicStates", _SE(js_cc_gfx_PipelineState_getDynamicStates)); 
    cls->defineFunction("getPipelineLayout", _SE(js_cc_gfx_PipelineState_getPipelineLayout)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_PipelineState));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::PipelineState>(cls);
    
    __jsb_cc_gfx_PipelineState_proto = cls->getProto();
    __jsb_cc_gfx_PipelineState_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_QueryPool_class = nullptr;
se::Object* __jsb_cc_gfx_QueryPool_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_QueryPool) 

static bool js_delete_cc_gfx_QueryPool(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_QueryPool) 

static bool js_cc_gfx_QueryPool_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::QueryPool *arg1 = (cc::gfx::QueryPool *) NULL ;
    cc::gfx::QueryPoolInfo *arg2 = 0 ;
    cc::gfx::QueryPoolInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPool>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::QueryPoolInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_QueryPool_initialize) 

static bool js_cc_gfx_QueryPool_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::QueryPool *arg1 = (cc::gfx::QueryPool *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPool>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_QueryPool_destroy) 

static bool js_cc_gfx_QueryPool_hasResult(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::QueryPool *arg1 = (cc::gfx::QueryPool *) NULL ;
    uint32_t arg2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPool>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (bool)(arg1)->hasResult(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_QueryPool_hasResult) 

static bool js_cc_gfx_QueryPool_getResult(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::QueryPool *arg1 = (cc::gfx::QueryPool *) NULL ;
    uint32_t arg2 ;
    uint64_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPool>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (arg1)->getResult(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_QueryPool_getResult) 

static bool js_cc_gfx_QueryPool_getType(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::QueryPool *arg1 = (cc::gfx::QueryPool *) NULL ;
    cc::gfx::QueryType result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPool>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::QueryType)((cc::gfx::QueryPool const *)arg1)->getType();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_QueryPool_getType) 

static bool js_cc_gfx_QueryPool_getMaxQueryObjects(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::QueryPool *arg1 = (cc::gfx::QueryPool *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPool>(s);
    if (nullptr == arg1) return true;
    result = ((cc::gfx::QueryPool const *)arg1)->getMaxQueryObjects();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_QueryPool_getMaxQueryObjects) 

static bool js_cc_gfx_QueryPool_getForceWait(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::QueryPool *arg1 = (cc::gfx::QueryPool *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::QueryPool>(s);
    if (nullptr == arg1) return true;
    result = (bool)((cc::gfx::QueryPool const *)arg1)->getForceWait();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_QueryPool_getForceWait) 

bool js_register_cc_gfx_QueryPool(se::Object* obj) {
    auto* cls = se::Class::create("QueryPool", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_QueryPool_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_QueryPool_destroy)); 
    cls->defineFunction("hasResult", _SE(js_cc_gfx_QueryPool_hasResult)); 
    cls->defineFunction("getResult", _SE(js_cc_gfx_QueryPool_getResult)); 
    cls->defineFunction("getType", _SE(js_cc_gfx_QueryPool_getType)); 
    cls->defineFunction("getMaxQueryObjects", _SE(js_cc_gfx_QueryPool_getMaxQueryObjects)); 
    cls->defineFunction("getForceWait", _SE(js_cc_gfx_QueryPool_getForceWait)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_QueryPool));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::QueryPool>(cls);
    
    __jsb_cc_gfx_QueryPool_proto = cls->getProto();
    __jsb_cc_gfx_QueryPool_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Queue_class = nullptr;
se::Object* __jsb_cc_gfx_Queue_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Queue) 

static bool js_delete_cc_gfx_Queue(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Queue) 

static bool js_cc_gfx_Queue_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Queue *arg1 = (cc::gfx::Queue *) NULL ;
    cc::gfx::QueueInfo *arg2 = 0 ;
    cc::gfx::QueueInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Queue>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::QueueInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Queue_initialize) 

static bool js_cc_gfx_Queue_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Queue *arg1 = (cc::gfx::Queue *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Queue>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Queue_destroy) 

static bool js_cc_gfx_Queue_submit__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::Queue *arg1 = (cc::gfx::Queue *) NULL ;
    cc::gfx::CommandBuffer **arg2 = (cc::gfx::CommandBuffer **) NULL ;
    uint32_t arg3 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Queue>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->submit((cc::gfx::CommandBuffer *const *)arg2,arg3);
    
    
    return true;
}

static bool js_cc_gfx_Queue_submit__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::Queue *arg1 = (cc::gfx::Queue *) NULL ;
    cc::gfx::CommandBufferList *arg2 = 0 ;
    cc::gfx::CommandBufferList temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Queue>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->submit((cc::gfx::CommandBufferList const &)*arg2);
    
    
    return true;
}

static bool js_cc_gfx_Queue_submit(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_cc_gfx_Queue_submit__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_gfx_Queue_submit__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_Queue_submit) 

static bool js_cc_gfx_Queue_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Queue *arg1 = (cc::gfx::Queue *) NULL ;
    cc::gfx::QueueType result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Queue>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::QueueType)cc_gfx_Queue_type_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Queue_type_get) 

bool js_register_cc_gfx_Queue(se::Object* obj) {
    auto* cls = se::Class::create("Queue", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("type", _SE(js_cc_gfx_Queue_type_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_Queue_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_Queue_destroy)); 
    cls->defineFunction("submit", _SE(js_cc_gfx_Queue_submit)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Queue));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Queue>(cls);
    
    __jsb_cc_gfx_Queue_proto = cls->getProto();
    __jsb_cc_gfx_Queue_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_RenderPass_class = nullptr;
se::Object* __jsb_cc_gfx_RenderPass_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_RenderPass) 

static bool js_delete_cc_gfx_RenderPass(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_RenderPass) 

static bool js_cc_gfx_RenderPass_computeHash_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RenderPassInfo *arg1 = 0 ;
    cc::gfx::RenderPassInfo temp1 ;
    ccstd::hash_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = cc::gfx::RenderPass::computeHash((cc::gfx::RenderPassInfo const &)*arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_RenderPass_computeHash_static) 

static bool js_cc_gfx_RenderPass_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RenderPass *arg1 = (cc::gfx::RenderPass *) NULL ;
    cc::gfx::RenderPassInfo *arg2 = 0 ;
    cc::gfx::RenderPassInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::RenderPassInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_RenderPass_initialize) 

static bool js_cc_gfx_RenderPass_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RenderPass *arg1 = (cc::gfx::RenderPass *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPass>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_RenderPass_destroy) 

static bool js_cc_gfx_RenderPass_getColorAttachments(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RenderPass *arg1 = (cc::gfx::RenderPass *) NULL ;
    cc::gfx::ColorAttachmentList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPass>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::ColorAttachmentList *) &((cc::gfx::RenderPass const *)arg1)->getColorAttachments();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_RenderPass_getColorAttachments) 

static bool js_cc_gfx_RenderPass_getDepthStencilAttachment(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RenderPass *arg1 = (cc::gfx::RenderPass *) NULL ;
    cc::gfx::DepthStencilAttachment *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPass>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::DepthStencilAttachment *) &((cc::gfx::RenderPass const *)arg1)->getDepthStencilAttachment();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_RenderPass_getDepthStencilAttachment) 

static bool js_cc_gfx_RenderPass_getSubpasses(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RenderPass *arg1 = (cc::gfx::RenderPass *) NULL ;
    cc::gfx::SubpassInfoList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPass>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::SubpassInfoList *) &((cc::gfx::RenderPass const *)arg1)->getSubpasses();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_RenderPass_getSubpasses) 

static bool js_cc_gfx_RenderPass_getDependencies(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::RenderPass *arg1 = (cc::gfx::RenderPass *) NULL ;
    cc::gfx::SubpassDependencyList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPass>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::SubpassDependencyList *) &((cc::gfx::RenderPass const *)arg1)->getDependencies();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_RenderPass_getDependencies) 

static bool js_cc_gfx_RenderPass_hash_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::RenderPass *arg1 = (cc::gfx::RenderPass *) NULL ;
    ccstd::hash_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::RenderPass>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_RenderPass_hash_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_RenderPass_hash_get) 

bool js_register_cc_gfx_RenderPass(se::Object* obj) {
    auto* cls = se::Class::create("RenderPass", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("hash", _SE(js_cc_gfx_RenderPass_hash_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_RenderPass_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_RenderPass_destroy)); 
    cls->defineFunction("getColorAttachments", _SE(js_cc_gfx_RenderPass_getColorAttachments)); 
    cls->defineFunction("getDepthStencilAttachment", _SE(js_cc_gfx_RenderPass_getDepthStencilAttachment)); 
    cls->defineFunction("getSubpasses", _SE(js_cc_gfx_RenderPass_getSubpasses)); 
    cls->defineFunction("getDependencies", _SE(js_cc_gfx_RenderPass_getDependencies)); 
    
    
    cls->defineStaticFunction("computeHash", _SE(js_cc_gfx_RenderPass_computeHash_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_RenderPass));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::RenderPass>(cls);
    
    __jsb_cc_gfx_RenderPass_proto = cls->getProto();
    __jsb_cc_gfx_RenderPass_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Shader_class = nullptr;
se::Object* __jsb_cc_gfx_Shader_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Shader) 

static bool js_delete_cc_gfx_Shader(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Shader) 

static bool js_cc_gfx_Shader_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Shader *arg1 = (cc::gfx::Shader *) NULL ;
    cc::gfx::ShaderInfo *arg2 = 0 ;
    cc::gfx::ShaderInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Shader>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::ShaderInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Shader_initialize) 

static bool js_cc_gfx_Shader_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Shader *arg1 = (cc::gfx::Shader *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Shader>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Shader_destroy) 

static bool js_cc_gfx_Shader_getBuffers(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Shader *arg1 = (cc::gfx::Shader *) NULL ;
    cc::gfx::UniformStorageBufferList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Shader>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::UniformStorageBufferList *) &((cc::gfx::Shader const *)arg1)->getBuffers();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Shader_getBuffers) 

static bool js_cc_gfx_Shader_getSamplerTextures(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Shader *arg1 = (cc::gfx::Shader *) NULL ;
    cc::gfx::UniformSamplerTextureList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Shader>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::UniformSamplerTextureList *) &((cc::gfx::Shader const *)arg1)->getSamplerTextures();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Shader_getSamplerTextures) 

static bool js_cc_gfx_Shader_getTextures(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Shader *arg1 = (cc::gfx::Shader *) NULL ;
    cc::gfx::UniformTextureList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Shader>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::UniformTextureList *) &((cc::gfx::Shader const *)arg1)->getTextures();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Shader_getTextures) 

static bool js_cc_gfx_Shader_getImages(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Shader *arg1 = (cc::gfx::Shader *) NULL ;
    cc::gfx::UniformStorageImageList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Shader>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::UniformStorageImageList *) &((cc::gfx::Shader const *)arg1)->getImages();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Shader_getImages) 

static bool js_cc_gfx_Shader_getSubpassInputs(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Shader *arg1 = (cc::gfx::Shader *) NULL ;
    cc::gfx::UniformInputAttachmentList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Shader>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::UniformInputAttachmentList *) &((cc::gfx::Shader const *)arg1)->getSubpassInputs();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Shader_getSubpassInputs) 

static bool js_cc_gfx_Shader_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Shader *arg1 = (cc::gfx::Shader *) NULL ;
    ccstd::string *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Shader>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::string *) &cc_gfx_Shader_name_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Shader_name_get) 

static bool js_cc_gfx_Shader_stages_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Shader *arg1 = (cc::gfx::Shader *) NULL ;
    cc::gfx::ShaderStageList *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Shader>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::ShaderStageList *) &cc_gfx_Shader_stages_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Shader_stages_get) 

static bool js_cc_gfx_Shader_attributes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Shader *arg1 = (cc::gfx::Shader *) NULL ;
    cc::gfx::AttributeList *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Shader>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::AttributeList *) &cc_gfx_Shader_attributes_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Shader_attributes_get) 

static bool js_cc_gfx_Shader_blocks_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Shader *arg1 = (cc::gfx::Shader *) NULL ;
    cc::gfx::UniformBlockList *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Shader>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::UniformBlockList *) &cc_gfx_Shader_blocks_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Shader_blocks_get) 

static bool js_cc_gfx_Shader_samplers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Shader *arg1 = (cc::gfx::Shader *) NULL ;
    cc::gfx::UniformSamplerList *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Shader>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::UniformSamplerList *) &cc_gfx_Shader_samplers_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Shader_samplers_get) 

bool js_register_cc_gfx_Shader(se::Object* obj) {
    auto* cls = se::Class::create("Shader", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("name", _SE(js_cc_gfx_Shader_name_get), nullptr); 
    cls->defineProperty("stages", _SE(js_cc_gfx_Shader_stages_get), nullptr); 
    cls->defineProperty("attributes", _SE(js_cc_gfx_Shader_attributes_get), nullptr); 
    cls->defineProperty("blocks", _SE(js_cc_gfx_Shader_blocks_get), nullptr); 
    cls->defineProperty("samplers", _SE(js_cc_gfx_Shader_samplers_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_Shader_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_Shader_destroy)); 
    cls->defineFunction("getBuffers", _SE(js_cc_gfx_Shader_getBuffers)); 
    cls->defineFunction("getSamplerTextures", _SE(js_cc_gfx_Shader_getSamplerTextures)); 
    cls->defineFunction("getTextures", _SE(js_cc_gfx_Shader_getTextures)); 
    cls->defineFunction("getImages", _SE(js_cc_gfx_Shader_getImages)); 
    cls->defineFunction("getSubpassInputs", _SE(js_cc_gfx_Shader_getSubpassInputs)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Shader));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Shader>(cls);
    
    __jsb_cc_gfx_Shader_proto = cls->getProto();
    __jsb_cc_gfx_Shader_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Swapchain_class = nullptr;
se::Object* __jsb_cc_gfx_Swapchain_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Swapchain) 

static bool js_delete_cc_gfx_Swapchain(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Swapchain) 

static bool js_cc_gfx_Swapchain_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Swapchain *arg1 = (cc::gfx::Swapchain *) NULL ;
    cc::gfx::SwapchainInfo *arg2 = 0 ;
    cc::gfx::SwapchainInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Swapchain>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::SwapchainInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Swapchain_initialize) 

static bool js_cc_gfx_Swapchain_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Swapchain *arg1 = (cc::gfx::Swapchain *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Swapchain>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Swapchain_destroy) 

static bool js_cc_gfx_Swapchain_resize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Swapchain *arg1 = (cc::gfx::Swapchain *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    cc::gfx::SurfaceTransform arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Swapchain>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->resize(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Swapchain_resize) 

static bool js_cc_gfx_Swapchain_destroySurface(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Swapchain *arg1 = (cc::gfx::Swapchain *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Swapchain>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroySurface();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Swapchain_destroySurface) 

static bool js_cc_gfx_Swapchain_createSurface(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Swapchain *arg1 = (cc::gfx::Swapchain *) NULL ;
    void *arg2 = (void *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Swapchain>(s);
    if (nullptr == arg1) return true;
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    (arg1)->createSurface(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Swapchain_createSurface) 

static bool js_cc_gfx_Swapchain_getWindowId(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Swapchain *arg1 = (cc::gfx::Swapchain *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Swapchain>(s);
    if (nullptr == arg1) return true;
    result = ((cc::gfx::Swapchain const *)arg1)->getWindowId();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Swapchain_getWindowId) 

static bool js_cc_gfx_Swapchain_getWindowHandle(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Swapchain *arg1 = (cc::gfx::Swapchain *) NULL ;
    void *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Swapchain>(s);
    if (nullptr == arg1) return true;
    result = (void *)((cc::gfx::Swapchain const *)arg1)->getWindowHandle();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Swapchain_getWindowHandle) 

static bool js_cc_gfx_Swapchain_getVSyncMode(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Swapchain *arg1 = (cc::gfx::Swapchain *) NULL ;
    cc::gfx::VsyncMode result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Swapchain>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::VsyncMode)((cc::gfx::Swapchain const *)arg1)->getVSyncMode();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Swapchain_getVSyncMode) 

static bool js_cc_gfx_Swapchain_getGeneration(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Swapchain *arg1 = (cc::gfx::Swapchain *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Swapchain>(s);
    if (nullptr == arg1) return true;
    result = ((cc::gfx::Swapchain const *)arg1)->getGeneration();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Swapchain_getGeneration) 

static bool js_cc_gfx_Swapchain_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Swapchain *arg1 = (cc::gfx::Swapchain *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Swapchain>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_Swapchain_width_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Swapchain_width_get) 

static bool js_cc_gfx_Swapchain_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Swapchain *arg1 = (cc::gfx::Swapchain *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Swapchain>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_Swapchain_height_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Swapchain_height_get) 

static bool js_cc_gfx_Swapchain_surfaceTransform_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Swapchain *arg1 = (cc::gfx::Swapchain *) NULL ;
    cc::gfx::SurfaceTransform result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Swapchain>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::SurfaceTransform)cc_gfx_Swapchain_surfaceTransform_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Swapchain_surfaceTransform_get) 

static bool js_cc_gfx_Swapchain_colorTexture_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Swapchain *arg1 = (cc::gfx::Swapchain *) NULL ;
    cc::gfx::Texture *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Swapchain>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Texture *)cc_gfx_Swapchain_colorTexture_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Swapchain_colorTexture_get) 

static bool js_cc_gfx_Swapchain_depthStencilTexture_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Swapchain *arg1 = (cc::gfx::Swapchain *) NULL ;
    cc::gfx::Texture *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Swapchain>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Texture *)cc_gfx_Swapchain_depthStencilTexture_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Swapchain_depthStencilTexture_get) 

bool js_register_cc_gfx_Swapchain(se::Object* obj) {
    auto* cls = se::Class::create("Swapchain", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("width", _SE(js_cc_gfx_Swapchain_width_get), nullptr); 
    cls->defineProperty("height", _SE(js_cc_gfx_Swapchain_height_get), nullptr); 
    cls->defineProperty("surfaceTransform", _SE(js_cc_gfx_Swapchain_surfaceTransform_get), nullptr); 
    cls->defineProperty("colorTexture", _SE(js_cc_gfx_Swapchain_colorTexture_get), nullptr); 
    cls->defineProperty("depthStencilTexture", _SE(js_cc_gfx_Swapchain_depthStencilTexture_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_Swapchain_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_Swapchain_destroy)); 
    cls->defineFunction("resize", _SE(js_cc_gfx_Swapchain_resize)); 
    cls->defineFunction("destroySurface", _SE(js_cc_gfx_Swapchain_destroySurface)); 
    cls->defineFunction("createSurface", _SE(js_cc_gfx_Swapchain_createSurface)); 
    cls->defineFunction("getWindowId", _SE(js_cc_gfx_Swapchain_getWindowId)); 
    cls->defineFunction("getWindowHandle", _SE(js_cc_gfx_Swapchain_getWindowHandle)); 
    cls->defineFunction("getVSyncMode", _SE(js_cc_gfx_Swapchain_getVSyncMode)); 
    cls->defineFunction("getGeneration", _SE(js_cc_gfx_Swapchain_getGeneration)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Swapchain));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Swapchain>(cls);
    
    __jsb_cc_gfx_Swapchain_proto = cls->getProto();
    __jsb_cc_gfx_Swapchain_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Texture_class = nullptr;
se::Object* __jsb_cc_gfx_Texture_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Texture) 

static bool js_delete_cc_gfx_Texture(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Texture) 

static bool js_cc_gfx_Texture_computeHash_static__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::TextureInfo *arg1 = 0 ;
    cc::gfx::TextureInfo temp1 ;
    ccstd::hash_t result;
    
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = cc::gfx::Texture::computeHash((cc::gfx::TextureInfo const &)*arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_gfx_Texture_computeHash_static__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::TextureViewInfo *arg1 = 0 ;
    cc::gfx::TextureViewInfo temp1 ;
    ccstd::hash_t result;
    
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = cc::gfx::Texture::computeHash((cc::gfx::TextureViewInfo const &)*arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_gfx_Texture_computeHash_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_cc_gfx_Texture_computeHash_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_gfx_Texture_computeHash_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_Texture_computeHash_static) 

static bool js_cc_gfx_Texture_initialize__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::Texture *arg1 = (cc::gfx::Texture *) NULL ;
    cc::gfx::TextureInfo *arg2 = 0 ;
    cc::gfx::TextureInfo temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Texture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::TextureInfo const &)*arg2);
    
    
    return true;
}

static bool js_cc_gfx_Texture_initialize__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::Texture *arg1 = (cc::gfx::Texture *) NULL ;
    cc::gfx::TextureViewInfo *arg2 = 0 ;
    cc::gfx::TextureViewInfo temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Texture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::gfx::TextureViewInfo const &)*arg2);
    
    
    return true;
}

static bool js_cc_gfx_Texture_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_cc_gfx_Texture_initialize__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_gfx_Texture_initialize__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_Texture_initialize) 

static bool js_cc_gfx_Texture_resize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Texture *arg1 = (cc::gfx::Texture *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Texture>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->resize(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Texture_resize) 

static bool js_cc_gfx_Texture_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Texture *arg1 = (cc::gfx::Texture *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Texture>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Texture_destroy) 

static bool js_cc_gfx_Texture_isTextureView(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Texture *arg1 = (cc::gfx::Texture *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Texture>(s);
    if (nullptr == arg1) return true;
    result = (bool)((cc::gfx::Texture const *)arg1)->isTextureView();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Texture_isTextureView) 

static bool js_cc_gfx_Texture_getRaw(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Texture *arg1 = (cc::gfx::Texture *) NULL ;
    cc::gfx::Texture *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Texture>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Texture *)((cc::gfx::Texture const *)arg1)->getRaw();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Texture_getRaw) 

static bool js_cc_gfx_Texture_getGLTextureHandle(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Texture *arg1 = (cc::gfx::Texture *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Texture>(s);
    if (nullptr == arg1) return true;
    result = ((cc::gfx::Texture const *)arg1)->getGLTextureHandle();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Texture_getGLTextureHandle) 

static bool js_cc_gfx_Texture_info_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Texture *arg1 = (cc::gfx::Texture *) NULL ;
    cc::gfx::TextureInfo *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Texture>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::TextureInfo *) &cc_gfx_Texture_info_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Texture_info_get) 

static bool js_cc_gfx_Texture_viewInfo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Texture *arg1 = (cc::gfx::Texture *) NULL ;
    cc::gfx::TextureViewInfo *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Texture>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::TextureViewInfo *) &cc_gfx_Texture_viewInfo_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Texture_viewInfo_get) 

static bool js_cc_gfx_Texture_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Texture *arg1 = (cc::gfx::Texture *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Texture>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_Texture_width_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Texture_width_get) 

static bool js_cc_gfx_Texture_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Texture *arg1 = (cc::gfx::Texture *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Texture>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_Texture_height_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Texture_height_get) 

static bool js_cc_gfx_Texture_format_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Texture *arg1 = (cc::gfx::Texture *) NULL ;
    cc::gfx::Format result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Texture>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Format)cc_gfx_Texture_format_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Texture_format_get) 

static bool js_cc_gfx_Texture_size_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Texture *arg1 = (cc::gfx::Texture *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Texture>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_Texture_size_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Texture_size_get) 

static bool js_cc_gfx_Texture_hash_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Texture *arg1 = (cc::gfx::Texture *) NULL ;
    ccstd::hash_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Texture>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_Texture_hash_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Texture_hash_get) 

bool js_register_cc_gfx_Texture(se::Object* obj) {
    auto* cls = se::Class::create("Texture", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("info", _SE(js_cc_gfx_Texture_info_get), nullptr); 
    cls->defineProperty("viewInfo", _SE(js_cc_gfx_Texture_viewInfo_get), nullptr); 
    cls->defineProperty("width", _SE(js_cc_gfx_Texture_width_get), nullptr); 
    cls->defineProperty("height", _SE(js_cc_gfx_Texture_height_get), nullptr); 
    cls->defineProperty("format", _SE(js_cc_gfx_Texture_format_get), nullptr); 
    cls->defineProperty("size", _SE(js_cc_gfx_Texture_size_get), nullptr); 
    cls->defineProperty("hash", _SE(js_cc_gfx_Texture_hash_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_Texture_initialize)); 
    cls->defineFunction("resize", _SE(js_cc_gfx_Texture_resize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_Texture_destroy)); 
    cls->defineFunction("isTextureView", _SE(js_cc_gfx_Texture_isTextureView)); 
    cls->defineFunction("getRaw", _SE(js_cc_gfx_Texture_getRaw)); 
    cls->defineFunction("getGLTextureHandle", _SE(js_cc_gfx_Texture_getGLTextureHandle)); 
    
    
    cls->defineStaticFunction("computeHash", _SE(js_cc_gfx_Texture_computeHash_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Texture));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Texture>(cls);
    
    __jsb_cc_gfx_Texture_proto = cls->getProto();
    __jsb_cc_gfx_Texture_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_GeneralBarrier_class = nullptr;
se::Object* __jsb_cc_gfx_GeneralBarrier_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_GeneralBarrier) 

static bool js_new_cc_gfx_GeneralBarrier(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    cc::gfx::GeneralBarrierInfo *arg1 = 0 ;
    cc::gfx::GeneralBarrierInfo temp1 ;
    cc::gfx::GeneralBarrier *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = (cc::gfx::GeneralBarrier *)new cc::gfx::GeneralBarrier((cc::gfx::GeneralBarrierInfo const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_GeneralBarrier, __jsb_cc_gfx_GeneralBarrier_class, js_delete_cc_gfx_GeneralBarrier)

static bool js_cc_gfx_GeneralBarrier_computeHash_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::GeneralBarrierInfo *arg1 = 0 ;
    cc::gfx::GeneralBarrierInfo temp1 ;
    ccstd::hash_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = cc::gfx::GeneralBarrier::computeHash((cc::gfx::GeneralBarrierInfo const &)*arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_GeneralBarrier_computeHash_static) 

static bool js_cc_gfx_GeneralBarrier_getInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::GeneralBarrier *arg1 = (cc::gfx::GeneralBarrier *) NULL ;
    cc::gfx::GeneralBarrierInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::GeneralBarrier>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::GeneralBarrierInfo *) &((cc::gfx::GeneralBarrier const *)arg1)->getInfo();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_GeneralBarrier_getInfo) 

static bool js_cc_gfx_GeneralBarrier_getHash(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::GeneralBarrier *arg1 = (cc::gfx::GeneralBarrier *) NULL ;
    ccstd::hash_t *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::GeneralBarrier>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::hash_t *) &((cc::gfx::GeneralBarrier const *)arg1)->getHash();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_GeneralBarrier_getHash) 

static bool js_delete_cc_gfx_GeneralBarrier(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_GeneralBarrier) 

bool js_register_cc_gfx_GeneralBarrier(se::Object* obj) {
    auto* cls = se::Class::create("GeneralBarrier", obj, __jsb_cc_gfx_GFXObject_proto, _SE(js_new_cc_gfx_GeneralBarrier)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getInfo", _SE(js_cc_gfx_GeneralBarrier_getInfo)); 
    cls->defineFunction("getHash", _SE(js_cc_gfx_GeneralBarrier_getHash)); 
    
    
    cls->defineStaticFunction("computeHash", _SE(js_cc_gfx_GeneralBarrier_computeHash_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_GeneralBarrier));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::GeneralBarrier>(cls);
    
    __jsb_cc_gfx_GeneralBarrier_proto = cls->getProto();
    __jsb_cc_gfx_GeneralBarrier_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Sampler_class = nullptr;
se::Object* __jsb_cc_gfx_Sampler_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Sampler) 

static bool js_new_cc_gfx_Sampler(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    cc::gfx::SamplerInfo *arg1 = 0 ;
    cc::gfx::SamplerInfo temp1 ;
    cc::gfx::Sampler *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = (cc::gfx::Sampler *)new cc::gfx::Sampler((cc::gfx::SamplerInfo const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_Sampler, __jsb_cc_gfx_Sampler_class, js_delete_cc_gfx_Sampler)

static bool js_cc_gfx_Sampler_computeHash_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::SamplerInfo *arg1 = 0 ;
    cc::gfx::SamplerInfo temp1 ;
    ccstd::hash_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = cc::gfx::Sampler::computeHash((cc::gfx::SamplerInfo const &)*arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Sampler_computeHash_static) 

static bool js_cc_gfx_Sampler_unpackFromHash_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    ccstd::hash_t arg1 ;
    cc::gfx::SamplerInfo result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = cc::gfx::Sampler::unpackFromHash(SWIG_STD_MOVE(arg1));
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Sampler_unpackFromHash_static) 

static bool js_cc_gfx_Sampler_info_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Sampler *arg1 = (cc::gfx::Sampler *) NULL ;
    cc::gfx::SamplerInfo *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Sampler>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::SamplerInfo *) &cc_gfx_Sampler_info_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Sampler_info_get) 

static bool js_cc_gfx_Sampler_hash_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Sampler *arg1 = (cc::gfx::Sampler *) NULL ;
    ccstd::hash_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Sampler>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_Sampler_hash_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Sampler_hash_get) 

static bool js_delete_cc_gfx_Sampler(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Sampler) 

bool js_register_cc_gfx_Sampler(se::Object* obj) {
    auto* cls = se::Class::create("Sampler", obj, __jsb_cc_gfx_GFXObject_proto, _SE(js_new_cc_gfx_Sampler)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("info", _SE(js_cc_gfx_Sampler_info_get), nullptr); 
    cls->defineProperty("hash", _SE(js_cc_gfx_Sampler_hash_get), nullptr); 
    
    
    
    cls->defineStaticFunction("computeHash", _SE(js_cc_gfx_Sampler_computeHash_static)); 
    cls->defineStaticFunction("unpackFromHash", _SE(js_cc_gfx_Sampler_unpackFromHash_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Sampler));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Sampler>(cls);
    
    __jsb_cc_gfx_Sampler_proto = cls->getProto();
    __jsb_cc_gfx_Sampler_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_TextureBarrier_class = nullptr;
se::Object* __jsb_cc_gfx_TextureBarrier_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_TextureBarrier) 

static bool js_new_cc_gfx_TextureBarrier(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    cc::gfx::TextureBarrierInfo *arg1 = 0 ;
    cc::gfx::TextureBarrierInfo temp1 ;
    cc::gfx::TextureBarrier *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = (cc::gfx::TextureBarrier *)new cc::gfx::TextureBarrier((cc::gfx::TextureBarrierInfo const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_TextureBarrier, __jsb_cc_gfx_TextureBarrier_class, js_delete_cc_gfx_TextureBarrier)

static bool js_cc_gfx_TextureBarrier_computeHash_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrierInfo *arg1 = 0 ;
    cc::gfx::TextureBarrierInfo temp1 ;
    ccstd::hash_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = cc::gfx::TextureBarrier::computeHash((cc::gfx::TextureBarrierInfo const &)*arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_TextureBarrier_computeHash_static) 

static bool js_cc_gfx_TextureBarrier_getInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrier *arg1 = (cc::gfx::TextureBarrier *) NULL ;
    cc::gfx::TextureBarrierInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrier>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::TextureBarrierInfo *) &((cc::gfx::TextureBarrier const *)arg1)->getInfo();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_TextureBarrier_getInfo) 

static bool js_cc_gfx_TextureBarrier_getHash(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::TextureBarrier *arg1 = (cc::gfx::TextureBarrier *) NULL ;
    ccstd::hash_t *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::TextureBarrier>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::hash_t *) &((cc::gfx::TextureBarrier const *)arg1)->getHash();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_TextureBarrier_getHash) 

static bool js_delete_cc_gfx_TextureBarrier(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_TextureBarrier) 

bool js_register_cc_gfx_TextureBarrier(se::Object* obj) {
    auto* cls = se::Class::create("TextureBarrier", obj, __jsb_cc_gfx_GFXObject_proto, _SE(js_new_cc_gfx_TextureBarrier)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getInfo", _SE(js_cc_gfx_TextureBarrier_getInfo)); 
    cls->defineFunction("getHash", _SE(js_cc_gfx_TextureBarrier_getHash)); 
    
    
    cls->defineStaticFunction("computeHash", _SE(js_cc_gfx_TextureBarrier_computeHash_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_TextureBarrier));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::TextureBarrier>(cls);
    
    __jsb_cc_gfx_TextureBarrier_proto = cls->getProto();
    __jsb_cc_gfx_TextureBarrier_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_BufferBarrier_class = nullptr;
se::Object* __jsb_cc_gfx_BufferBarrier_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_BufferBarrier) 

static bool js_cc_gfx_BufferBarrier_computeHash_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferBarrierInfo *arg1 = 0 ;
    cc::gfx::BufferBarrierInfo temp1 ;
    ccstd::hash_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = cc::gfx::BufferBarrier::computeHash((cc::gfx::BufferBarrierInfo const &)*arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BufferBarrier_computeHash_static) 

static bool js_cc_gfx_BufferBarrier_getInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferBarrier *arg1 = (cc::gfx::BufferBarrier *) NULL ;
    cc::gfx::BufferBarrierInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrier>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::BufferBarrierInfo *) &((cc::gfx::BufferBarrier const *)arg1)->getInfo();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BufferBarrier_getInfo) 

static bool js_cc_gfx_BufferBarrier_getHash(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::BufferBarrier *arg1 = (cc::gfx::BufferBarrier *) NULL ;
    ccstd::hash_t *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::BufferBarrier>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::hash_t *) &((cc::gfx::BufferBarrier const *)arg1)->getHash();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_BufferBarrier_getHash) 

static bool js_delete_cc_gfx_BufferBarrier(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_BufferBarrier) 

bool js_register_cc_gfx_BufferBarrier(se::Object* obj) {
    auto* cls = se::Class::create("BufferBarrier", obj, __jsb_cc_gfx_GFXObject_proto, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getInfo", _SE(js_cc_gfx_BufferBarrier_getInfo)); 
    cls->defineFunction("getHash", _SE(js_cc_gfx_BufferBarrier_getHash)); 
    
    
    cls->defineStaticFunction("computeHash", _SE(js_cc_gfx_BufferBarrier_computeHash_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_BufferBarrier));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::BufferBarrier>(cls);
    
    __jsb_cc_gfx_BufferBarrier_proto = cls->getProto();
    __jsb_cc_gfx_BufferBarrier_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_Device_class = nullptr;
se::Object* __jsb_cc_gfx_Device_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_Device) 

static bool js_delete_cc_gfx_Device(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_Device) 

static bool js_cc_gfx_Device_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::DeviceInfo *arg2 = 0 ;
    cc::gfx::DeviceInfo temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (bool)(arg1)->initialize((cc::gfx::DeviceInfo const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_initialize) 

static bool js_cc_gfx_Device_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_destroy) 

static bool js_cc_gfx_Device_acquire__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::Swapchain **arg2 = (cc::gfx::Swapchain **) NULL ;
    uint32_t arg3 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->acquire((cc::gfx::Swapchain *const *)arg2,arg3);
    
    
    return true;
}

static bool js_cc_gfx_Device_present(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    (arg1)->present();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_present) 

static bool js_cc_gfx_Device_flushCommands__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::CommandBuffer **arg2 = (cc::gfx::CommandBuffer **) NULL ;
    uint32_t arg3 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->flushCommands((cc::gfx::CommandBuffer *const *)arg2,arg3);
    
    
    return true;
}

static bool js_cc_gfx_Device_createCommandBuffer(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::CommandBufferInfo *arg2 = 0 ;
    cc::gfx::CommandBufferInfo temp2 ;
    cc::gfx::CommandBuffer *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::CommandBuffer *)(arg1)->createCommandBuffer((cc::gfx::CommandBufferInfo const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_createCommandBuffer) 

static bool js_cc_gfx_Device_createQueue(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::QueueInfo *arg2 = 0 ;
    cc::gfx::QueueInfo temp2 ;
    cc::gfx::Queue *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::Queue *)(arg1)->createQueue((cc::gfx::QueueInfo const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_createQueue) 

static bool js_cc_gfx_Device_createQueryPool(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::QueryPoolInfo *arg2 = 0 ;
    cc::gfx::QueryPoolInfo temp2 ;
    cc::gfx::QueryPool *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::QueryPool *)(arg1)->createQueryPool((cc::gfx::QueryPoolInfo const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_createQueryPool) 

static bool js_cc_gfx_Device_createSwapchain(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::SwapchainInfo *arg2 = 0 ;
    cc::gfx::SwapchainInfo temp2 ;
    cc::gfx::Swapchain *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::Swapchain *)(arg1)->createSwapchain((cc::gfx::SwapchainInfo const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_createSwapchain) 

static bool js_cc_gfx_Device_getSwapchains(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    ccstd::vector< cc::gfx::Swapchain * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::gfx::Swapchain * > *) &((cc::gfx::Device const *)arg1)->getSwapchains();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_getSwapchains) 

static bool js_cc_gfx_Device_createShader(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::ShaderInfo *arg2 = 0 ;
    cc::gfx::ShaderInfo temp2 ;
    cc::gfx::Shader *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::Shader *)(arg1)->createShader((cc::gfx::ShaderInfo const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_createShader) 

static bool js_cc_gfx_Device_createInputAssembler(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::InputAssemblerInfo *arg2 = 0 ;
    cc::gfx::InputAssemblerInfo temp2 ;
    cc::gfx::InputAssembler *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::InputAssembler *)(arg1)->createInputAssembler((cc::gfx::InputAssemblerInfo const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_createInputAssembler) 

static bool js_cc_gfx_Device_createRenderPass(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::RenderPassInfo *arg2 = 0 ;
    cc::gfx::RenderPassInfo temp2 ;
    cc::gfx::RenderPass *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::RenderPass *)(arg1)->createRenderPass((cc::gfx::RenderPassInfo const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_createRenderPass) 

static bool js_cc_gfx_Device_createFramebuffer(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::FramebufferInfo *arg2 = 0 ;
    cc::gfx::FramebufferInfo temp2 ;
    cc::gfx::Framebuffer *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::Framebuffer *)(arg1)->createFramebuffer((cc::gfx::FramebufferInfo const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_createFramebuffer) 

static bool js_cc_gfx_Device_createDescriptorSet(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::DescriptorSetInfo *arg2 = 0 ;
    cc::gfx::DescriptorSetInfo temp2 ;
    cc::gfx::DescriptorSet *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::DescriptorSet *)(arg1)->createDescriptorSet((cc::gfx::DescriptorSetInfo const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_createDescriptorSet) 

static bool js_cc_gfx_Device_createDescriptorSetLayout(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::DescriptorSetLayoutInfo *arg2 = 0 ;
    cc::gfx::DescriptorSetLayoutInfo temp2 ;
    cc::gfx::DescriptorSetLayout *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::DescriptorSetLayout *)(arg1)->createDescriptorSetLayout((cc::gfx::DescriptorSetLayoutInfo const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_createDescriptorSetLayout) 

static bool js_cc_gfx_Device_createPipelineLayout(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::PipelineLayoutInfo *arg2 = 0 ;
    cc::gfx::PipelineLayoutInfo temp2 ;
    cc::gfx::PipelineLayout *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::PipelineLayout *)(arg1)->createPipelineLayout((cc::gfx::PipelineLayoutInfo const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_createPipelineLayout) 

static bool js_cc_gfx_Device_createPipelineState(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::PipelineStateInfo *arg2 = 0 ;
    cc::gfx::PipelineStateInfo temp2 ;
    cc::gfx::PipelineState *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::PipelineState *)(arg1)->createPipelineState((cc::gfx::PipelineStateInfo const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_createPipelineState) 

static bool js_cc_gfx_Device_getSampler(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::SamplerInfo *arg2 = 0 ;
    cc::gfx::SamplerInfo temp2 ;
    cc::gfx::Sampler *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::Sampler *)(arg1)->getSampler((cc::gfx::SamplerInfo const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_getSampler) 

static bool js_cc_gfx_Device_getGeneralBarrier(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::GeneralBarrierInfo *arg2 = 0 ;
    cc::gfx::GeneralBarrierInfo temp2 ;
    cc::gfx::GeneralBarrier *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::GeneralBarrier *)(arg1)->getGeneralBarrier((cc::gfx::GeneralBarrierInfo const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_getGeneralBarrier) 

static bool js_cc_gfx_Device_getTextureBarrier(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::TextureBarrierInfo *arg2 = 0 ;
    cc::gfx::TextureBarrierInfo temp2 ;
    cc::gfx::TextureBarrier *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::TextureBarrier *)(arg1)->getTextureBarrier((cc::gfx::TextureBarrierInfo const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_getTextureBarrier) 

static bool js_cc_gfx_Device_getBufferBarrier(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::BufferBarrierInfo *arg2 = 0 ;
    cc::gfx::BufferBarrierInfo temp2 ;
    cc::gfx::BufferBarrier *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::BufferBarrier *)(arg1)->getBufferBarrier((cc::gfx::BufferBarrierInfo const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_getBufferBarrier) 

static bool js_cc_gfx_Device_getQueryPoolResults(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::QueryPool *arg2 = (cc::gfx::QueryPool *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->getQueryPoolResults(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_getQueryPoolResults) 

static bool js_cc_gfx_Device_flushCommands__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    ccstd::vector< cc::gfx::CommandBuffer * > *arg2 = 0 ;
    ccstd::vector< cc::gfx::CommandBuffer * > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->flushCommands((ccstd::vector< cc::gfx::CommandBuffer * > const &)*arg2);
    
    
    return true;
}

static bool js_cc_gfx_Device_flushCommands(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_cc_gfx_Device_flushCommands__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_gfx_Device_flushCommands__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_Device_flushCommands) 

static bool js_cc_gfx_Device_acquire__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    ccstd::vector< cc::gfx::Swapchain * > *arg2 = 0 ;
    ccstd::vector< cc::gfx::Swapchain * > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->acquire((ccstd::vector< cc::gfx::Swapchain * > const &)*arg2);
    
    
    return true;
}

static bool js_cc_gfx_Device_acquire(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_cc_gfx_Device_acquire__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_gfx_Device_acquire__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_Device_acquire) 

static bool js_cc_gfx_Device_getQueryPool(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::QueryPool *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::QueryPool *)((cc::gfx::Device const *)arg1)->getQueryPool();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_getQueryPool) 

static bool js_cc_gfx_Device_hasFeature(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::Feature arg2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = (bool)((cc::gfx::Device const *)arg1)->hasFeature(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_hasFeature) 

static bool js_cc_gfx_Device_getFormatFeatures(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::Format arg2 ;
    cc::gfx::FormatFeature result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = (cc::gfx::FormatFeature)((cc::gfx::Device const *)arg1)->getFormatFeatures(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_getFormatFeatures) 

static bool js_cc_gfx_Device_bindingMappingInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::BindingMappingInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::BindingMappingInfo *) &((cc::gfx::Device const *)arg1)->bindingMappingInfo();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_bindingMappingInfo) 

static bool js_cc_gfx_Device_enableAutoBarrier(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->enableAutoBarrier(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_gfx_Device_enableAutoBarrier) 

static bool js_cc_gfx_Device_gfxAPI_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::API result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::API)cc_gfx_Device_gfxAPI_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Device_gfxAPI_get) 

static bool js_cc_gfx_Device_deviceName_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    ccstd::string *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::string *) &cc_gfx_Device_deviceName_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Device_deviceName_get) 

static bool js_cc_gfx_Device_memoryStatus_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::MemoryStatus *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::MemoryStatus *) &cc_gfx_Device_memoryStatus_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Device_memoryStatus_get) 

static bool js_cc_gfx_Device_queue_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::Queue *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Queue *)cc_gfx_Device_queue_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Device_queue_get) 

static bool js_cc_gfx_Device_commandBuffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::CommandBuffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::CommandBuffer *)cc_gfx_Device_commandBuffer_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Device_commandBuffer_get) 

static bool js_cc_gfx_Device_renderer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    ccstd::string *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::string *) &cc_gfx_Device_renderer_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Device_renderer_get) 

static bool js_cc_gfx_Device_vendor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    ccstd::string *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::string *) &cc_gfx_Device_vendor_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Device_vendor_get) 

static bool js_cc_gfx_Device_numDrawCalls_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_Device_numDrawCalls_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Device_numDrawCalls_get) 

static bool js_cc_gfx_Device_numInstances_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_Device_numInstances_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Device_numInstances_get) 

static bool js_cc_gfx_Device_numTris_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    result = cc_gfx_Device_numTris_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Device_numTris_get) 

static bool js_cc_gfx_Device_capabilities_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::gfx::DeviceCaps *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::gfx::Device>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::DeviceCaps *) &cc_gfx_Device_capabilities_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_gfx_Device_capabilities_get) 

bool js_register_cc_gfx_Device(se::Object* obj) {
    auto* cls = se::Class::create("Device", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("gfxAPI", _SE(js_cc_gfx_Device_gfxAPI_get), nullptr); 
    cls->defineProperty("deviceName", _SE(js_cc_gfx_Device_deviceName_get), nullptr); 
    cls->defineProperty("memoryStatus", _SE(js_cc_gfx_Device_memoryStatus_get), nullptr); 
    cls->defineProperty("queue", _SE(js_cc_gfx_Device_queue_get), nullptr); 
    cls->defineProperty("commandBuffer", _SE(js_cc_gfx_Device_commandBuffer_get), nullptr); 
    cls->defineProperty("renderer", _SE(js_cc_gfx_Device_renderer_get), nullptr); 
    cls->defineProperty("vendor", _SE(js_cc_gfx_Device_vendor_get), nullptr); 
    cls->defineProperty("numDrawCalls", _SE(js_cc_gfx_Device_numDrawCalls_get), nullptr); 
    cls->defineProperty("numInstances", _SE(js_cc_gfx_Device_numInstances_get), nullptr); 
    cls->defineProperty("numTris", _SE(js_cc_gfx_Device_numTris_get), nullptr); 
    cls->defineProperty("capabilities", _SE(js_cc_gfx_Device_capabilities_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_gfx_Device_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_gfx_Device_destroy)); 
    cls->defineFunction("present", _SE(js_cc_gfx_Device_present)); 
    cls->defineFunction("createCommandBuffer", _SE(js_cc_gfx_Device_createCommandBuffer)); 
    cls->defineFunction("createQueue", _SE(js_cc_gfx_Device_createQueue)); 
    cls->defineFunction("createQueryPool", _SE(js_cc_gfx_Device_createQueryPool)); 
    cls->defineFunction("createSwapchain", _SE(js_cc_gfx_Device_createSwapchain)); 
    cls->defineFunction("getSwapchains", _SE(js_cc_gfx_Device_getSwapchains)); 
    cls->defineFunction("createShader", _SE(js_cc_gfx_Device_createShader)); 
    cls->defineFunction("createInputAssembler", _SE(js_cc_gfx_Device_createInputAssembler)); 
    cls->defineFunction("createRenderPass", _SE(js_cc_gfx_Device_createRenderPass)); 
    cls->defineFunction("createFramebuffer", _SE(js_cc_gfx_Device_createFramebuffer)); 
    cls->defineFunction("createDescriptorSet", _SE(js_cc_gfx_Device_createDescriptorSet)); 
    cls->defineFunction("createDescriptorSetLayout", _SE(js_cc_gfx_Device_createDescriptorSetLayout)); 
    cls->defineFunction("createPipelineLayout", _SE(js_cc_gfx_Device_createPipelineLayout)); 
    cls->defineFunction("createPipelineState", _SE(js_cc_gfx_Device_createPipelineState)); 
    cls->defineFunction("getSampler", _SE(js_cc_gfx_Device_getSampler)); 
    cls->defineFunction("getGeneralBarrier", _SE(js_cc_gfx_Device_getGeneralBarrier)); 
    cls->defineFunction("getTextureBarrier", _SE(js_cc_gfx_Device_getTextureBarrier)); 
    cls->defineFunction("getBufferBarrier", _SE(js_cc_gfx_Device_getBufferBarrier)); 
    cls->defineFunction("getQueryPoolResults", _SE(js_cc_gfx_Device_getQueryPoolResults)); 
    cls->defineFunction("flushCommands", _SE(js_cc_gfx_Device_flushCommands)); 
    cls->defineFunction("acquire", _SE(js_cc_gfx_Device_acquire)); 
    cls->defineFunction("getQueryPool", _SE(js_cc_gfx_Device_getQueryPool)); 
    cls->defineFunction("hasFeature", _SE(js_cc_gfx_Device_hasFeature)); 
    cls->defineFunction("getFormatFeatures", _SE(js_cc_gfx_Device_getFormatFeatures)); 
    cls->defineFunction("bindingMappingInfo", _SE(js_cc_gfx_Device_bindingMappingInfo)); 
    cls->defineFunction("enableAutoBarrier", _SE(js_cc_gfx_Device_enableAutoBarrier)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_Device));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::Device>(cls);
    
    __jsb_cc_gfx_Device_proto = cls->getProto();
    __jsb_cc_gfx_Device_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_gfx_DeviceManager_class = nullptr;
se::Object* __jsb_cc_gfx_DeviceManager_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_gfx_DeviceManager) 

static bool js_cc_gfx_DeviceManager_create_static__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::Device *result = 0 ;
    
    result = (cc::gfx::Device *)cc::gfx::DeviceManager::create();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_gfx_DeviceManager_create_static__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::gfx::DeviceInfo *arg1 = 0 ;
    cc::gfx::DeviceInfo temp1 ;
    cc::gfx::Device *result = 0 ;
    
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = (cc::gfx::Device *)cc::gfx::DeviceManager::create((cc::gfx::DeviceInfo const &)*arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_gfx_DeviceManager_create_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 0) {
        ok = js_cc_gfx_DeviceManager_create_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_gfx_DeviceManager_create_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_gfx_DeviceManager_create_static) 

static bool js_new_cc_gfx_DeviceManager(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::gfx::DeviceManager *result;
    result = (cc::gfx::DeviceManager *)new cc::gfx::DeviceManager();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_gfx_DeviceManager, __jsb_cc_gfx_DeviceManager_class, js_delete_cc_gfx_DeviceManager)

static bool js_delete_cc_gfx_DeviceManager(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_gfx_DeviceManager) 

bool js_register_cc_gfx_DeviceManager(se::Object* obj) {
    auto* cls = se::Class::create("DeviceManager", obj, nullptr, _SE(js_new_cc_gfx_DeviceManager)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    
    cls->defineStaticFunction("create", _SE(js_cc_gfx_DeviceManager_create_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_gfx_DeviceManager));
    
    
    cls->install();
    JSBClassType::registerClass<cc::gfx::DeviceManager>(cls);
    
    __jsb_cc_gfx_DeviceManager_proto = cls->getProto();
    __jsb_cc_gfx_DeviceManager_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}




bool register_all_gfx(se::Object* obj) {
    // Get the ns
    se::Value nsVal;
    if (!obj->getProperty("gfx", &nsVal, true))
    {
        se::HandleObject jsobj(se::Object::createPlainObject());
        nsVal.setObject(jsobj);
        obj->setProperty("gfx", nsVal);
    }
    se::Object* ns = nsVal.toObject();
    /* Register classes */
    js_register_cc_gfx_Size(ns); 
    js_register_cc_gfx_DeviceCaps(ns); 
    js_register_cc_gfx_DeviceOptions(ns); 
    js_register_cc_gfx_Offset(ns); 
    js_register_cc_gfx_Rect(ns); 
    js_register_cc_gfx_Extent(ns); 
    js_register_cc_gfx_TextureSubresLayers(ns); 
    js_register_cc_gfx_TextureSubresRange(ns); 
    js_register_cc_gfx_TextureCopy(ns); 
    js_register_cc_gfx_TextureBlit(ns); 
    js_register_cc_gfx_BufferTextureCopy(ns); 
    js_register_cc_gfx_Viewport(ns); 
    js_register_cc_gfx_Color(ns); 
    js_register_cc_gfx_BindingMappingInfo(ns); 
    js_register_cc_gfx_SwapchainInfo(ns); 
    js_register_cc_gfx_DeviceInfo(ns); 
    js_register_cc_gfx_BufferInfo(ns); 
    js_register_cc_gfx_BufferViewInfo(ns); 
    js_register_cc_gfx_DrawInfo(ns); 
    js_register_cc_gfx_DispatchInfo(ns); 
    js_register_cc_gfx_IndirectBuffer(ns); 
    js_register_cc_gfx_TextureInfo(ns); 
    js_register_cc_gfx_TextureViewInfo(ns); 
    js_register_cc_gfx_SamplerInfo(ns); 
    js_register_cc_gfx_Uniform(ns); 
    js_register_cc_gfx_UniformBlock(ns); 
    js_register_cc_gfx_UniformSamplerTexture(ns); 
    js_register_cc_gfx_UniformSampler(ns); 
    js_register_cc_gfx_UniformTexture(ns); 
    js_register_cc_gfx_UniformStorageImage(ns); 
    js_register_cc_gfx_UniformStorageBuffer(ns); 
    js_register_cc_gfx_UniformInputAttachment(ns); 
    js_register_cc_gfx_ShaderStage(ns); 
    js_register_cc_gfx_Attribute(ns); 
    js_register_cc_gfx_ShaderInfo(ns); 
    js_register_cc_gfx_InputAssemblerInfo(ns); 
    js_register_cc_gfx_ColorAttachment(ns); 
    js_register_cc_gfx_DepthStencilAttachment(ns); 
    js_register_cc_gfx_SubpassInfo(ns); 
    js_register_cc_gfx_SubpassDependency(ns); 
    js_register_cc_gfx_RenderPassInfo(ns); 
    js_register_cc_gfx_GeneralBarrierInfo(ns); 
    js_register_cc_gfx_TextureBarrierInfo(ns); 
    js_register_cc_gfx_BufferBarrierInfo(ns); 
    js_register_cc_gfx_FramebufferInfo(ns); 
    js_register_cc_gfx_DescriptorSetLayoutBinding(ns); 
    js_register_cc_gfx_DescriptorSetLayoutInfo(ns); 
    js_register_cc_gfx_DescriptorSetInfo(ns); 
    js_register_cc_gfx_PipelineLayoutInfo(ns); 
    js_register_cc_gfx_InputState(ns); 
    js_register_cc_gfx_RasterizerState(ns); 
    js_register_cc_gfx_DepthStencilState(ns); 
    js_register_cc_gfx_BlendTarget(ns); 
    js_register_cc_gfx_BlendState(ns); 
    js_register_cc_gfx_PipelineStateInfo(ns); 
    js_register_cc_gfx_CommandBufferInfo(ns); 
    js_register_cc_gfx_QueueInfo(ns); 
    js_register_cc_gfx_QueryPoolInfo(ns); 
    js_register_cc_gfx_FormatInfo(ns); 
    js_register_cc_gfx_MemoryStatus(ns); 
    js_register_cc_gfx_DynamicStencilStates(ns); 
    js_register_cc_gfx_DynamicStates(ns); 
    js_register_cc_gfx_GFXObject(ns); 
    js_register_cc_gfx_Buffer(ns); 
    js_register_cc_gfx_CommandBuffer(ns); 
    js_register_cc_gfx_DescriptorSet(ns); 
    js_register_cc_gfx_DescriptorSetLayout(ns); 
    js_register_cc_gfx_Framebuffer(ns); 
    js_register_cc_gfx_InputAssembler(ns); 
    js_register_cc_gfx_PipelineLayout(ns); 
    js_register_cc_gfx_PipelineState(ns); 
    js_register_cc_gfx_QueryPool(ns); 
    js_register_cc_gfx_Queue(ns); 
    js_register_cc_gfx_RenderPass(ns); 
    js_register_cc_gfx_Shader(ns); 
    js_register_cc_gfx_Swapchain(ns); 
    js_register_cc_gfx_Texture(ns); 
    js_register_cc_gfx_GeneralBarrier(ns); 
    js_register_cc_gfx_Sampler(ns); 
    js_register_cc_gfx_TextureBarrier(ns); 
    js_register_cc_gfx_BufferBarrier(ns); 
    js_register_cc_gfx_Device(ns); 
    js_register_cc_gfx_DeviceManager(ns); 
    
    /* Register global variables & global functions */
    
    
    
    return true;
}


#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif
// clang-format on
