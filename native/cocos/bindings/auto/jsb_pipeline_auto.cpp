// clang-format off

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.1.0
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

/****************************************************************************
 Copyright (c) 2022 Xiamen Yaji Software Co., Ltd.

 http://www.cocos.com

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated engine source code (the "Software"), a limited,
 worldwide, royalty-free, non-assignable, revocable and non-exclusive license
 to use Cocos Creator solely to develop games on your target platforms. You shall
 not use Cocos Creator software for developing other software or tools that's
 used for developing games. You are not granted to publish, distribute,
 sublicense, and/or sell copies of Cocos Creator.

 The software or tools in this License Agreement are licensed, not sold.
 Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
****************************************************************************/

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static 
#endif



#include <stdio.h>


#include "bindings/jswrapper/SeApi.h"
#include "bindings/manual/jsb_conversions.h"
#include "bindings/manual/jsb_global.h"


#include "bindings/auto/jsb_pipeline_auto.h"
#include "bindings/auto/jsb_scene_auto.h"
#include "bindings/auto/jsb_gfx_auto.h"
#include "renderer/pipeline/PipelineUBO.h"

using namespace cc;


#define cc_pipeline_RenderPipeline_globalDSManager_get(self_) self_->getGlobalDSManager()
  

#define cc_pipeline_RenderPipeline_descriptorSet_get(self_) self_->getDescriptorSet()
  

#define cc_pipeline_RenderPipeline_descriptorSetLayout_get(self_) self_->getDescriptorSetLayout()
  

#define cc_pipeline_RenderPipeline_constantMacros_get(self_) self_->getConstantMacros()
  

#define cc_pipeline_RenderPipeline_clusterEnabled_get(self_) self_->isClusterEnabled()
#define cc_pipeline_RenderPipeline_clusterEnabled_set(self_, val_) self_->setClusterEnabled(val_)
  

#define cc_pipeline_RenderPipeline_bloomEnabled_get(self_) self_->isBloomEnabled()
#define cc_pipeline_RenderPipeline_bloomEnabled_set(self_, val_) self_->setBloomEnabled(val_)
  

#define cc_pipeline_RenderPipeline_pipelineSceneData_get(self_) self_->getPipelineSceneData()
  

#define cc_pipeline_RenderPipeline_geometryRenderer_get(self_) self_->getGeometryRenderer()
  

#define cc_pipeline_RenderPipeline_profiler_get(self_) self_->getProfiler()
#define cc_pipeline_RenderPipeline_profiler_set(self_, val_) self_->setProfiler(val_)
  

#define cc_pipeline_RenderPipeline_shadingScale_get(self_) self_->getShadingScale()
#define cc_pipeline_RenderPipeline_shadingScale_set(self_, val_) self_->setShadingScale(val_)
  

#define cc_pipeline_PipelineSceneData_isHDR_get(self_) self_->isHDR()
#define cc_pipeline_PipelineSceneData_isHDR_set(self_, val_) self_->setHDR(val_)
  

#define cc_pipeline_PipelineSceneData_shadingScale_get(self_) self_->getShadingScale()
#define cc_pipeline_PipelineSceneData_shadingScale_set(self_, val_) self_->setShadingScale(val_)
  

#define cc_pipeline_PipelineSceneData_fog_get(self_) self_->getFog()
  

#define cc_pipeline_PipelineSceneData_ambient_get(self_) self_->getAmbient()
  

#define cc_pipeline_PipelineSceneData_skybox_get(self_) self_->getSkybox()
  

#define cc_pipeline_PipelineSceneData_shadows_get(self_) self_->getShadows()
  

#define cc_pipeline_BloomStage_threshold_get(self_) self_->getThreshold()
#define cc_pipeline_BloomStage_threshold_set(self_, val_) self_->setThreshold(val_)
  

#define cc_pipeline_BloomStage_intensity_get(self_) self_->getIntensity()
#define cc_pipeline_BloomStage_intensity_set(self_, val_) self_->setIntensity(val_)
  

#define cc_pipeline_BloomStage_iterations_get(self_) self_->getIterations()
#define cc_pipeline_BloomStage_iterations_set(self_, val_) self_->setIterations(val_)
  


se::Class* __jsb_cc_pipeline_SkinningJointCapacity_class = nullptr;
se::Object* __jsb_cc_pipeline_SkinningJointCapacity_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_SkinningJointCapacity) 

static bool js_cc_pipeline_SkinningJointCapacity_jointUniformCapacity_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    uint32_t arg1 ;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkinningJointCapacity_jointUniformCapacity_set,1,SWIGTYPE_uint32_t"); 
    
    cc::pipeline::SkinningJointCapacity::jointUniformCapacity = arg1;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_SkinningJointCapacity_jointUniformCapacity_set) 

static bool js_cc_pipeline_SkinningJointCapacity_jointUniformCapacity_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    uint32_t result;
    
    result = cc::pipeline::SkinningJointCapacity::jointUniformCapacity;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkinningJointCapacity_jointUniformCapacity_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_SkinningJointCapacity_jointUniformCapacity_get) 

// js_ctor
static bool js_new_cc_pipeline_SkinningJointCapacity(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::SkinningJointCapacity *result;
    result = (cc::pipeline::SkinningJointCapacity *)new cc::pipeline::SkinningJointCapacity();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_SkinningJointCapacity, __jsb_cc_pipeline_SkinningJointCapacity_class, js_delete_cc_pipeline_SkinningJointCapacity)

static bool js_delete_cc_pipeline_SkinningJointCapacity(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_SkinningJointCapacity) 

bool js_register_cc_pipeline_SkinningJointCapacity(se::Object* obj) {
    auto* cls = se::Class::create("SkinningJointCapacity", obj, nullptr, _SE(js_new_cc_pipeline_SkinningJointCapacity)); 
    
    
    
    cls->defineStaticProperty("jointUniformCapacity", _SE(js_cc_pipeline_SkinningJointCapacity_jointUniformCapacity_get), _SE(js_cc_pipeline_SkinningJointCapacity_jointUniformCapacity_set)); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_SkinningJointCapacity));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::SkinningJointCapacity>(cls);
    
    __jsb_cc_pipeline_SkinningJointCapacity_proto = cls->getProto();
    __jsb_cc_pipeline_SkinningJointCapacity_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_RenderObject_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderObject_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderObject) 

static bool js_cc_pipeline_RenderObject_depth_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderObject *arg1 = (cc::pipeline::RenderObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->depth, nullptr);
    SE_PRECONDITION2(ok, false, "RenderObject_depth_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderObject_depth_set) 

static bool js_cc_pipeline_RenderObject_depth_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderObject *arg1 = (cc::pipeline::RenderObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->depth, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderObject_depth_get) 

static bool js_cc_pipeline_RenderObject_model_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderObject *arg1 = (cc::pipeline::RenderObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->model, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderObject_model_set,2,SWIGTYPE_p_cc__scene__Model"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderObject_model_set) 

static bool js_cc_pipeline_RenderObject_model_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderObject *arg1 = (cc::pipeline::RenderObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->model, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderObject_model_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->model, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderObject_model_get) 

// js_ctor
static bool js_new_cc_pipeline_RenderObject(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::RenderObject *result;
    result = (cc::pipeline::RenderObject *)new cc::pipeline::RenderObject();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_RenderObject, __jsb_cc_pipeline_RenderObject_class, js_delete_cc_pipeline_RenderObject)

static bool js_delete_cc_pipeline_RenderObject(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderObject) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::RenderObject * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::RenderObject*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("depth", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depth), ctx);
    }
    
    
    json->getProperty("model", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->model), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_RenderObject(se::Object* obj) {
    auto* cls = se::Class::create("RenderObject", obj, nullptr, _SE(js_new_cc_pipeline_RenderObject)); 
    
    cls->defineProperty("depth", _SE(js_cc_pipeline_RenderObject_depth_get), _SE(js_cc_pipeline_RenderObject_depth_set)); 
    cls->defineProperty("model", _SE(js_cc_pipeline_RenderObject_model_get), _SE(js_cc_pipeline_RenderObject_model_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderObject));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderObject>(cls);
    
    __jsb_cc_pipeline_RenderObject_proto = cls->getProto();
    __jsb_cc_pipeline_RenderObject_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_RenderTargetInfo_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderTargetInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderTargetInfo) 

static bool js_cc_pipeline_RenderTargetInfo_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderTargetInfo *arg1 = (cc::pipeline::RenderTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTargetInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->width, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderTargetInfo_width_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderTargetInfo_width_set) 

static bool js_cc_pipeline_RenderTargetInfo_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderTargetInfo *arg1 = (cc::pipeline::RenderTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTargetInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->width, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderTargetInfo_width_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->width, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderTargetInfo_width_get) 

static bool js_cc_pipeline_RenderTargetInfo_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderTargetInfo *arg1 = (cc::pipeline::RenderTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTargetInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->height, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderTargetInfo_height_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderTargetInfo_height_set) 

static bool js_cc_pipeline_RenderTargetInfo_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderTargetInfo *arg1 = (cc::pipeline::RenderTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTargetInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->height, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderTargetInfo_height_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->height, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderTargetInfo_height_get) 

// js_ctor
static bool js_new_cc_pipeline_RenderTargetInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::RenderTargetInfo *result;
    result = (cc::pipeline::RenderTargetInfo *)new cc::pipeline::RenderTargetInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_RenderTargetInfo, __jsb_cc_pipeline_RenderTargetInfo_class, js_delete_cc_pipeline_RenderTargetInfo)

static bool js_delete_cc_pipeline_RenderTargetInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderTargetInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::RenderTargetInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::RenderTargetInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("width", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->width), ctx);
    }
    
    
    json->getProperty("height", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->height), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_RenderTargetInfo(se::Object* obj) {
    auto* cls = se::Class::create("RenderTargetInfo", obj, nullptr, _SE(js_new_cc_pipeline_RenderTargetInfo)); 
    
    cls->defineProperty("width", _SE(js_cc_pipeline_RenderTargetInfo_width_get), _SE(js_cc_pipeline_RenderTargetInfo_width_set)); 
    cls->defineProperty("height", _SE(js_cc_pipeline_RenderTargetInfo_height_get), _SE(js_cc_pipeline_RenderTargetInfo_height_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderTargetInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderTargetInfo>(cls);
    
    __jsb_cc_pipeline_RenderTargetInfo_proto = cls->getProto();
    __jsb_cc_pipeline_RenderTargetInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_RenderPass_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderPass_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderPass) 

static bool js_cc_pipeline_RenderPass_priority_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPass *arg1 = (cc::pipeline::RenderPass *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->priority, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPass_priority_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPass_priority_set) 

static bool js_cc_pipeline_RenderPass_priority_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPass *arg1 = (cc::pipeline::RenderPass *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->priority, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPass_priority_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->priority, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPass_priority_get) 

static bool js_cc_pipeline_RenderPass_hash_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPass *arg1 = (cc::pipeline::RenderPass *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->hash, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPass_hash_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPass_hash_set) 

static bool js_cc_pipeline_RenderPass_hash_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPass *arg1 = (cc::pipeline::RenderPass *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->hash, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPass_hash_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->hash, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPass_hash_get) 

static bool js_cc_pipeline_RenderPass_depth_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPass *arg1 = (cc::pipeline::RenderPass *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->depth, nullptr);
    SE_PRECONDITION2(ok, false, "RenderPass_depth_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPass_depth_set) 

static bool js_cc_pipeline_RenderPass_depth_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPass *arg1 = (cc::pipeline::RenderPass *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->depth, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPass_depth_get) 

static bool js_cc_pipeline_RenderPass_shaderID_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPass *arg1 = (cc::pipeline::RenderPass *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->shaderID, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPass_shaderID_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPass_shaderID_set) 

static bool js_cc_pipeline_RenderPass_shaderID_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPass *arg1 = (cc::pipeline::RenderPass *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->shaderID, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPass_shaderID_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->shaderID, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPass_shaderID_get) 

static bool js_cc_pipeline_RenderPass_passIndex_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPass *arg1 = (cc::pipeline::RenderPass *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->passIndex, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPass_passIndex_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPass_passIndex_set) 

static bool js_cc_pipeline_RenderPass_passIndex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPass *arg1 = (cc::pipeline::RenderPass *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->passIndex, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPass_passIndex_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->passIndex, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPass_passIndex_get) 

static bool js_cc_pipeline_RenderPass_subModel_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPass *arg1 = (cc::pipeline::RenderPass *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->subModel, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPass_subModel_set,2,SWIGTYPE_p_cc__scene__SubModel"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPass_subModel_set) 

static bool js_cc_pipeline_RenderPass_subModel_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPass *arg1 = (cc::pipeline::RenderPass *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->subModel, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPass_subModel_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->subModel, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPass_subModel_get) 

// js_ctor
static bool js_new_cc_pipeline_RenderPass(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::RenderPass *result;
    result = (cc::pipeline::RenderPass *)new cc::pipeline::RenderPass();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_RenderPass, __jsb_cc_pipeline_RenderPass_class, js_delete_cc_pipeline_RenderPass)

static bool js_delete_cc_pipeline_RenderPass(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderPass) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::RenderPass * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::RenderPass*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("priority", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->priority), ctx);
    }
    
    
    json->getProperty("hash", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->hash), ctx);
    }
    
    
    json->getProperty("depth", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depth), ctx);
    }
    
    
    json->getProperty("shaderID", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->shaderID), ctx);
    }
    
    
    json->getProperty("passIndex", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->passIndex), ctx);
    }
    
    
    json->getProperty("subModel", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->subModel), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_RenderPass(se::Object* obj) {
    auto* cls = se::Class::create("RenderPass", obj, nullptr, _SE(js_new_cc_pipeline_RenderPass)); 
    
    cls->defineProperty("priority", _SE(js_cc_pipeline_RenderPass_priority_get), _SE(js_cc_pipeline_RenderPass_priority_set)); 
    cls->defineProperty("hash", _SE(js_cc_pipeline_RenderPass_hash_get), _SE(js_cc_pipeline_RenderPass_hash_set)); 
    cls->defineProperty("depth", _SE(js_cc_pipeline_RenderPass_depth_get), _SE(js_cc_pipeline_RenderPass_depth_set)); 
    cls->defineProperty("shaderID", _SE(js_cc_pipeline_RenderPass_shaderID_get), _SE(js_cc_pipeline_RenderPass_shaderID_set)); 
    cls->defineProperty("passIndex", _SE(js_cc_pipeline_RenderPass_passIndex_get), _SE(js_cc_pipeline_RenderPass_passIndex_set)); 
    cls->defineProperty("subModel", _SE(js_cc_pipeline_RenderPass_subModel_get), _SE(js_cc_pipeline_RenderPass_subModel_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderPass));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderPass>(cls);
    
    __jsb_cc_pipeline_RenderPass_proto = cls->getProto();
    __jsb_cc_pipeline_RenderPass_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_RenderPassDesc_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderPassDesc_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderPassDesc) 

static bool js_cc_pipeline_RenderPassDesc_index_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPassDesc *arg1 = (cc::pipeline::RenderPassDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPassDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->index, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPassDesc_index_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPassDesc_index_set) 

static bool js_cc_pipeline_RenderPassDesc_index_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPassDesc *arg1 = (cc::pipeline::RenderPassDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPassDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->index, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPassDesc_index_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->index, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPassDesc_index_get) 

static bool js_cc_pipeline_RenderPassDesc_colorAttachments_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPassDesc *arg1 = (cc::pipeline::RenderPassDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPassDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->colorAttachments, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPassDesc_colorAttachments_set,2,SWIGTYPE_ccstd__vectorT_cc__pipeline__ColorDesc_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPassDesc_colorAttachments_set) 

static bool js_cc_pipeline_RenderPassDesc_colorAttachments_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPassDesc *arg1 = (cc::pipeline::RenderPassDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPassDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->colorAttachments, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPassDesc_colorAttachments_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->colorAttachments, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPassDesc_colorAttachments_get) 

static bool js_cc_pipeline_RenderPassDesc_depthStencilAttachment_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPassDesc *arg1 = (cc::pipeline::RenderPassDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPassDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->depthStencilAttachment, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPassDesc_depthStencilAttachment_set,2,SWIGTYPE_cc__gfx__DepthStencilAttachment"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPassDesc_depthStencilAttachment_set) 

static bool js_cc_pipeline_RenderPassDesc_depthStencilAttachment_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPassDesc *arg1 = (cc::pipeline::RenderPassDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPassDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->depthStencilAttachment, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPassDesc_depthStencilAttachment_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthStencilAttachment, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPassDesc_depthStencilAttachment_get) 

// js_ctor
static bool js_new_cc_pipeline_RenderPassDesc(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::RenderPassDesc *result;
    result = (cc::pipeline::RenderPassDesc *)new cc::pipeline::RenderPassDesc();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_RenderPassDesc, __jsb_cc_pipeline_RenderPassDesc_class, js_delete_cc_pipeline_RenderPassDesc)

static bool js_delete_cc_pipeline_RenderPassDesc(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderPassDesc) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::RenderPassDesc * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::RenderPassDesc*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("index", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->index), ctx);
    }
    
    
    json->getProperty("colorAttachments", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->colorAttachments), ctx);
    }
    
    
    json->getProperty("depthStencilAttachment", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthStencilAttachment), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_RenderPassDesc(se::Object* obj) {
    auto* cls = se::Class::create("RenderPassDesc", obj, nullptr, _SE(js_new_cc_pipeline_RenderPassDesc)); 
    
    cls->defineProperty("index", _SE(js_cc_pipeline_RenderPassDesc_index_get), _SE(js_cc_pipeline_RenderPassDesc_index_set)); 
    cls->defineProperty("colorAttachments", _SE(js_cc_pipeline_RenderPassDesc_colorAttachments_get), _SE(js_cc_pipeline_RenderPassDesc_colorAttachments_set)); 
    cls->defineProperty("depthStencilAttachment", _SE(js_cc_pipeline_RenderPassDesc_depthStencilAttachment_get), _SE(js_cc_pipeline_RenderPassDesc_depthStencilAttachment_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderPassDesc));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderPassDesc>(cls);
    
    __jsb_cc_pipeline_RenderPassDesc_proto = cls->getProto();
    __jsb_cc_pipeline_RenderPassDesc_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_RenderTextureDesc_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderTextureDesc_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderTextureDesc) 

static bool js_cc_pipeline_RenderTextureDesc_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderTextureDesc *arg1 = (cc::pipeline::RenderTextureDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTextureDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderTextureDesc_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderTextureDesc_name_set) 

static bool js_cc_pipeline_RenderTextureDesc_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderTextureDesc *arg1 = (cc::pipeline::RenderTextureDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTextureDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderTextureDesc_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderTextureDesc_name_get) 

static bool js_cc_pipeline_RenderTextureDesc_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderTextureDesc *arg1 = (cc::pipeline::RenderTextureDesc *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTextureDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "RenderTextureDesc_type_set,2,SWIGTYPE_cc__gfx__TextureType");
    arg1->type = (cc::gfx::TextureType)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderTextureDesc_type_set) 

static bool js_cc_pipeline_RenderTextureDesc_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderTextureDesc *arg1 = (cc::pipeline::RenderTextureDesc *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTextureDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->type));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderTextureDesc_type_get) 

static bool js_cc_pipeline_RenderTextureDesc_usage_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderTextureDesc *arg1 = (cc::pipeline::RenderTextureDesc *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTextureDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "RenderTextureDesc_usage_set,2,SWIGTYPE_cc__gfx__TextureUsageBit");
    arg1->usage = (cc::gfx::TextureUsage)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderTextureDesc_usage_set) 

static bool js_cc_pipeline_RenderTextureDesc_usage_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderTextureDesc *arg1 = (cc::pipeline::RenderTextureDesc *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTextureDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->usage));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderTextureDesc_usage_get) 

static bool js_cc_pipeline_RenderTextureDesc_format_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderTextureDesc *arg1 = (cc::pipeline::RenderTextureDesc *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTextureDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "RenderTextureDesc_format_set,2,SWIGTYPE_cc__gfx__Format");
    arg1->format = (cc::gfx::Format)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderTextureDesc_format_set) 

static bool js_cc_pipeline_RenderTextureDesc_format_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderTextureDesc *arg1 = (cc::pipeline::RenderTextureDesc *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTextureDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->format));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderTextureDesc_format_get) 

static bool js_cc_pipeline_RenderTextureDesc_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderTextureDesc *arg1 = (cc::pipeline::RenderTextureDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTextureDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->width, nullptr);
    SE_PRECONDITION2(ok, false, "RenderTextureDesc_width_set,2,SWIGTYPE_int"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderTextureDesc_width_set) 

static bool js_cc_pipeline_RenderTextureDesc_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderTextureDesc *arg1 = (cc::pipeline::RenderTextureDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTextureDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->width, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderTextureDesc_width_get) 

static bool js_cc_pipeline_RenderTextureDesc_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderTextureDesc *arg1 = (cc::pipeline::RenderTextureDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTextureDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->height, nullptr);
    SE_PRECONDITION2(ok, false, "RenderTextureDesc_height_set,2,SWIGTYPE_int"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderTextureDesc_height_set) 

static bool js_cc_pipeline_RenderTextureDesc_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderTextureDesc *arg1 = (cc::pipeline::RenderTextureDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTextureDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->height, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderTextureDesc_height_get) 

// js_ctor
static bool js_new_cc_pipeline_RenderTextureDesc(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::RenderTextureDesc *result;
    result = (cc::pipeline::RenderTextureDesc *)new cc::pipeline::RenderTextureDesc();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_RenderTextureDesc, __jsb_cc_pipeline_RenderTextureDesc_class, js_delete_cc_pipeline_RenderTextureDesc)

static bool js_delete_cc_pipeline_RenderTextureDesc(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderTextureDesc) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::RenderTextureDesc * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::RenderTextureDesc*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("usage", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->usage), ctx);
    }
    
    
    json->getProperty("format", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->format), ctx);
    }
    
    
    json->getProperty("width", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->width), ctx);
    }
    
    
    json->getProperty("height", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->height), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_RenderTextureDesc(se::Object* obj) {
    auto* cls = se::Class::create("RenderTextureDesc", obj, nullptr, _SE(js_new_cc_pipeline_RenderTextureDesc)); 
    
    cls->defineProperty("name", _SE(js_cc_pipeline_RenderTextureDesc_name_get), _SE(js_cc_pipeline_RenderTextureDesc_name_set)); 
    cls->defineProperty("type", _SE(js_cc_pipeline_RenderTextureDesc_type_get), _SE(js_cc_pipeline_RenderTextureDesc_type_set)); 
    cls->defineProperty("usage", _SE(js_cc_pipeline_RenderTextureDesc_usage_get), _SE(js_cc_pipeline_RenderTextureDesc_usage_set)); 
    cls->defineProperty("format", _SE(js_cc_pipeline_RenderTextureDesc_format_get), _SE(js_cc_pipeline_RenderTextureDesc_format_set)); 
    cls->defineProperty("width", _SE(js_cc_pipeline_RenderTextureDesc_width_get), _SE(js_cc_pipeline_RenderTextureDesc_width_set)); 
    cls->defineProperty("height", _SE(js_cc_pipeline_RenderTextureDesc_height_get), _SE(js_cc_pipeline_RenderTextureDesc_height_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderTextureDesc));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderTextureDesc>(cls);
    
    __jsb_cc_pipeline_RenderTextureDesc_proto = cls->getProto();
    __jsb_cc_pipeline_RenderTextureDesc_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_FrameBufferDesc_class = nullptr;
se::Object* __jsb_cc_pipeline_FrameBufferDesc_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_FrameBufferDesc) 

static bool js_cc_pipeline_FrameBufferDesc_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::FrameBufferDesc *arg1 = (cc::pipeline::FrameBufferDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::FrameBufferDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "FrameBufferDesc_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_FrameBufferDesc_name_set) 

static bool js_cc_pipeline_FrameBufferDesc_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::FrameBufferDesc *arg1 = (cc::pipeline::FrameBufferDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::FrameBufferDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FrameBufferDesc_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_FrameBufferDesc_name_get) 

static bool js_cc_pipeline_FrameBufferDesc_renderPass_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::FrameBufferDesc *arg1 = (cc::pipeline::FrameBufferDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::FrameBufferDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->renderPass, s.thisObject());
    SE_PRECONDITION2(ok, false, "FrameBufferDesc_renderPass_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_FrameBufferDesc_renderPass_set) 

static bool js_cc_pipeline_FrameBufferDesc_renderPass_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::FrameBufferDesc *arg1 = (cc::pipeline::FrameBufferDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::FrameBufferDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->renderPass, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FrameBufferDesc_renderPass_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->renderPass, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_FrameBufferDesc_renderPass_get) 

static bool js_cc_pipeline_FrameBufferDesc_colorTextures_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::FrameBufferDesc *arg1 = (cc::pipeline::FrameBufferDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::FrameBufferDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->colorTextures, s.thisObject());
    SE_PRECONDITION2(ok, false, "FrameBufferDesc_colorTextures_set,2,SWIGTYPE_ccstd__vectorT_ccstd__string_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_FrameBufferDesc_colorTextures_set) 

static bool js_cc_pipeline_FrameBufferDesc_colorTextures_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::FrameBufferDesc *arg1 = (cc::pipeline::FrameBufferDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::FrameBufferDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->colorTextures, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FrameBufferDesc_colorTextures_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->colorTextures, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_FrameBufferDesc_colorTextures_get) 

static bool js_cc_pipeline_FrameBufferDesc_depthStencilTexture_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::FrameBufferDesc *arg1 = (cc::pipeline::FrameBufferDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::FrameBufferDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->depthStencilTexture, s.thisObject());
    SE_PRECONDITION2(ok, false, "FrameBufferDesc_depthStencilTexture_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_FrameBufferDesc_depthStencilTexture_set) 

static bool js_cc_pipeline_FrameBufferDesc_depthStencilTexture_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::FrameBufferDesc *arg1 = (cc::pipeline::FrameBufferDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::FrameBufferDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->depthStencilTexture, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FrameBufferDesc_depthStencilTexture_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthStencilTexture, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_FrameBufferDesc_depthStencilTexture_get) 

// js_ctor
static bool js_new_cc_pipeline_FrameBufferDesc(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::FrameBufferDesc *result;
    result = (cc::pipeline::FrameBufferDesc *)new cc::pipeline::FrameBufferDesc();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_FrameBufferDesc, __jsb_cc_pipeline_FrameBufferDesc_class, js_delete_cc_pipeline_FrameBufferDesc)

static bool js_delete_cc_pipeline_FrameBufferDesc(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_FrameBufferDesc) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::FrameBufferDesc * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::FrameBufferDesc*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("renderPass", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->renderPass), ctx);
    }
    
    
    json->getProperty("colorTextures", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->colorTextures), ctx);
    }
    
    
    json->getProperty("depthStencilTexture", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthStencilTexture), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_FrameBufferDesc(se::Object* obj) {
    auto* cls = se::Class::create("FrameBufferDesc", obj, nullptr, _SE(js_new_cc_pipeline_FrameBufferDesc)); 
    
    cls->defineProperty("name", _SE(js_cc_pipeline_FrameBufferDesc_name_get), _SE(js_cc_pipeline_FrameBufferDesc_name_set)); 
    cls->defineProperty("renderPass", _SE(js_cc_pipeline_FrameBufferDesc_renderPass_get), _SE(js_cc_pipeline_FrameBufferDesc_renderPass_set)); 
    cls->defineProperty("colorTextures", _SE(js_cc_pipeline_FrameBufferDesc_colorTextures_get), _SE(js_cc_pipeline_FrameBufferDesc_colorTextures_set)); 
    cls->defineProperty("depthStencilTexture", _SE(js_cc_pipeline_FrameBufferDesc_depthStencilTexture_get), _SE(js_cc_pipeline_FrameBufferDesc_depthStencilTexture_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_FrameBufferDesc));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::FrameBufferDesc>(cls);
    
    __jsb_cc_pipeline_FrameBufferDesc_proto = cls->getProto();
    __jsb_cc_pipeline_FrameBufferDesc_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


static bool js_cc_pipeline_toNumber__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::RenderFlowType arg1 ;
    int32_t temp1 ;
    std::underlying_type< cc::pipeline::RenderFlowType >::type result;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "toNumber,1,SWIGTYPE_cc__pipeline__RenderFlowType");
    arg1 = (cc::pipeline::RenderFlowType)temp1;
    result = cc::pipeline::toNumber(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "toNumber, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_pipeline_toNumber__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::RenderPassStage arg1 ;
    int32_t temp1 ;
    std::underlying_type< cc::pipeline::RenderPassStage >::type result;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "toNumber,1,SWIGTYPE_cc__pipeline__RenderPassStage");
    arg1 = (cc::pipeline::RenderPassStage)temp1;
    result = cc::pipeline::toNumber(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "toNumber, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

se::Class* __jsb_cc_pipeline_InternalBindingDesc_class = nullptr;
se::Object* __jsb_cc_pipeline_InternalBindingDesc_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_InternalBindingDesc) 

static bool js_cc_pipeline_InternalBindingDesc_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InternalBindingDesc *arg1 = (cc::pipeline::InternalBindingDesc *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "InternalBindingDesc_type_set,2,SWIGTYPE_cc__gfx__DescriptorType");
    arg1->type = (cc::gfx::DescriptorType)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InternalBindingDesc_type_set) 

static bool js_cc_pipeline_InternalBindingDesc_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InternalBindingDesc *arg1 = (cc::pipeline::InternalBindingDesc *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->type));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InternalBindingDesc_type_get) 

static bool js_cc_pipeline_InternalBindingDesc_blockInfo_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InternalBindingDesc *arg1 = (cc::pipeline::InternalBindingDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->blockInfo, s.thisObject());
    SE_PRECONDITION2(ok, false, "InternalBindingDesc_blockInfo_set,2,SWIGTYPE_cc__gfx__UniformBlock"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InternalBindingDesc_blockInfo_set) 

static bool js_cc_pipeline_InternalBindingDesc_blockInfo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InternalBindingDesc *arg1 = (cc::pipeline::InternalBindingDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->blockInfo, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InternalBindingDesc_blockInfo_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blockInfo, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InternalBindingDesc_blockInfo_get) 

static bool js_cc_pipeline_InternalBindingDesc_samplerInfo_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InternalBindingDesc *arg1 = (cc::pipeline::InternalBindingDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->samplerInfo, s.thisObject());
    SE_PRECONDITION2(ok, false, "InternalBindingDesc_samplerInfo_set,2,SWIGTYPE_cc__gfx__UniformSamplerTexture"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InternalBindingDesc_samplerInfo_set) 

static bool js_cc_pipeline_InternalBindingDesc_samplerInfo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InternalBindingDesc *arg1 = (cc::pipeline::InternalBindingDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->samplerInfo, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InternalBindingDesc_samplerInfo_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->samplerInfo, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InternalBindingDesc_samplerInfo_get) 

static bool js_cc_pipeline_InternalBindingDesc_defaultValue_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InternalBindingDesc *arg1 = (cc::pipeline::InternalBindingDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->defaultValue, s.thisObject());
    SE_PRECONDITION2(ok, false, "InternalBindingDesc_defaultValue_set,2,SWIGTYPE_Value"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InternalBindingDesc_defaultValue_set) 

static bool js_cc_pipeline_InternalBindingDesc_defaultValue_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InternalBindingDesc *arg1 = (cc::pipeline::InternalBindingDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->defaultValue, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InternalBindingDesc_defaultValue_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->defaultValue, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InternalBindingDesc_defaultValue_get) 

// js_ctor
static bool js_new_cc_pipeline_InternalBindingDesc(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::InternalBindingDesc *result;
    result = (cc::pipeline::InternalBindingDesc *)new cc::pipeline::InternalBindingDesc();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_InternalBindingDesc, __jsb_cc_pipeline_InternalBindingDesc_class, js_delete_cc_pipeline_InternalBindingDesc)

static bool js_delete_cc_pipeline_InternalBindingDesc(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_InternalBindingDesc) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::InternalBindingDesc * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::InternalBindingDesc*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("blockInfo", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blockInfo), ctx);
    }
    
    
    json->getProperty("samplerInfo", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->samplerInfo), ctx);
    }
    
    
    json->getProperty("defaultValue", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->defaultValue), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_InternalBindingDesc(se::Object* obj) {
    auto* cls = se::Class::create("InternalBindingDesc", obj, nullptr, _SE(js_new_cc_pipeline_InternalBindingDesc)); 
    
    cls->defineProperty("type", _SE(js_cc_pipeline_InternalBindingDesc_type_get), _SE(js_cc_pipeline_InternalBindingDesc_type_set)); 
    cls->defineProperty("blockInfo", _SE(js_cc_pipeline_InternalBindingDesc_blockInfo_get), _SE(js_cc_pipeline_InternalBindingDesc_blockInfo_set)); 
    cls->defineProperty("samplerInfo", _SE(js_cc_pipeline_InternalBindingDesc_samplerInfo_get), _SE(js_cc_pipeline_InternalBindingDesc_samplerInfo_set)); 
    cls->defineProperty("defaultValue", _SE(js_cc_pipeline_InternalBindingDesc_defaultValue_get), _SE(js_cc_pipeline_InternalBindingDesc_defaultValue_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_InternalBindingDesc));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::InternalBindingDesc>(cls);
    
    __jsb_cc_pipeline_InternalBindingDesc_proto = cls->getProto();
    __jsb_cc_pipeline_InternalBindingDesc_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_InternalBindingInst_class = nullptr;
se::Object* __jsb_cc_pipeline_InternalBindingInst_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_InternalBindingInst) 

static bool js_cc_pipeline_InternalBindingInst_buffer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InternalBindingInst *arg1 = (cc::pipeline::InternalBindingInst *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingInst>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->buffer, s.thisObject());
    SE_PRECONDITION2(ok, false, "InternalBindingInst_buffer_set,2,SWIGTYPE_p_cc__gfx__Buffer"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InternalBindingInst_buffer_set) 

static bool js_cc_pipeline_InternalBindingInst_buffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InternalBindingInst *arg1 = (cc::pipeline::InternalBindingInst *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingInst>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->buffer, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InternalBindingInst_buffer_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->buffer, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InternalBindingInst_buffer_get) 

static bool js_cc_pipeline_InternalBindingInst_sampler_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InternalBindingInst *arg1 = (cc::pipeline::InternalBindingInst *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingInst>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->sampler, s.thisObject());
    SE_PRECONDITION2(ok, false, "InternalBindingInst_sampler_set,2,SWIGTYPE_p_cc__gfx__Sampler"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InternalBindingInst_sampler_set) 

static bool js_cc_pipeline_InternalBindingInst_sampler_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InternalBindingInst *arg1 = (cc::pipeline::InternalBindingInst *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingInst>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->sampler, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InternalBindingInst_sampler_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->sampler, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InternalBindingInst_sampler_get) 

static bool js_cc_pipeline_InternalBindingInst_texture_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InternalBindingInst *arg1 = (cc::pipeline::InternalBindingInst *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingInst>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->texture, s.thisObject());
    SE_PRECONDITION2(ok, false, "InternalBindingInst_texture_set,2,SWIGTYPE_p_cc__gfx__Texture"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InternalBindingInst_texture_set) 

static bool js_cc_pipeline_InternalBindingInst_texture_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InternalBindingInst *arg1 = (cc::pipeline::InternalBindingInst *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingInst>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->texture, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InternalBindingInst_texture_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->texture, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InternalBindingInst_texture_get) 

// js_ctor
static bool js_new_cc_pipeline_InternalBindingInst(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::InternalBindingInst *result;
    result = (cc::pipeline::InternalBindingInst *)new cc::pipeline::InternalBindingInst();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_InternalBindingInst, __jsb_cc_pipeline_InternalBindingInst_class, js_delete_cc_pipeline_InternalBindingInst)

static bool js_delete_cc_pipeline_InternalBindingInst(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_InternalBindingInst) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::InternalBindingInst * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::InternalBindingInst*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("buffer", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->buffer), ctx);
    }
    
    
    json->getProperty("sampler", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->sampler), ctx);
    }
    
    
    json->getProperty("texture", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->texture), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_InternalBindingInst(se::Object* obj) {
    auto* cls = se::Class::create("InternalBindingInst", obj, __jsb_cc_pipeline_InternalBindingDesc_proto, _SE(js_new_cc_pipeline_InternalBindingInst)); 
    
    cls->defineProperty("buffer", _SE(js_cc_pipeline_InternalBindingInst_buffer_get), _SE(js_cc_pipeline_InternalBindingInst_buffer_set)); 
    cls->defineProperty("sampler", _SE(js_cc_pipeline_InternalBindingInst_sampler_get), _SE(js_cc_pipeline_InternalBindingInst_sampler_set)); 
    cls->defineProperty("texture", _SE(js_cc_pipeline_InternalBindingInst_texture_get), _SE(js_cc_pipeline_InternalBindingInst_texture_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_InternalBindingInst));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::InternalBindingInst>(cls);
    
    __jsb_cc_pipeline_InternalBindingInst_proto = cls->getProto();
    __jsb_cc_pipeline_InternalBindingInst_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_RenderQueueCreateInfo_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderQueueCreateInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderQueueCreateInfo) 

static bool js_cc_pipeline_RenderQueueCreateInfo_isTransparent_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderQueueCreateInfo *arg1 = (cc::pipeline::RenderQueueCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderQueueCreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->isTransparent);
    SE_PRECONDITION2(ok, false, "RenderQueueCreateInfo_isTransparent_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderQueueCreateInfo_isTransparent_set) 

static bool js_cc_pipeline_RenderQueueCreateInfo_isTransparent_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderQueueCreateInfo *arg1 = (cc::pipeline::RenderQueueCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderQueueCreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->isTransparent, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderQueueCreateInfo_isTransparent_get) 

static bool js_cc_pipeline_RenderQueueCreateInfo_phases_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderQueueCreateInfo *arg1 = (cc::pipeline::RenderQueueCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderQueueCreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->phases, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderQueueCreateInfo_phases_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderQueueCreateInfo_phases_set) 

static bool js_cc_pipeline_RenderQueueCreateInfo_phases_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderQueueCreateInfo *arg1 = (cc::pipeline::RenderQueueCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderQueueCreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->phases, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderQueueCreateInfo_phases_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->phases, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderQueueCreateInfo_phases_get) 

static bool js_cc_pipeline_RenderQueueCreateInfo_sortFunc_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderQueueCreateInfo *arg1 = (cc::pipeline::RenderQueueCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderQueueCreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->sortFunc, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderQueueCreateInfo_sortFunc_set,2,SWIGTYPE_std__functionT_bool_fcc__pipeline__RenderPass_const_R_cc__pipeline__RenderPass_const_RF_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderQueueCreateInfo_sortFunc_set) 

static bool js_cc_pipeline_RenderQueueCreateInfo_sortFunc_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderQueueCreateInfo *arg1 = (cc::pipeline::RenderQueueCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderQueueCreateInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->sortFunc, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderQueueCreateInfo_sortFunc_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->sortFunc, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderQueueCreateInfo_sortFunc_get) 

// js_ctor
static bool js_new_cc_pipeline_RenderQueueCreateInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::RenderQueueCreateInfo *result;
    result = (cc::pipeline::RenderQueueCreateInfo *)new cc::pipeline::RenderQueueCreateInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_RenderQueueCreateInfo, __jsb_cc_pipeline_RenderQueueCreateInfo_class, js_delete_cc_pipeline_RenderQueueCreateInfo)

static bool js_delete_cc_pipeline_RenderQueueCreateInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderQueueCreateInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::RenderQueueCreateInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::RenderQueueCreateInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("isTransparent", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isTransparent), ctx);
    }
    
    
    json->getProperty("phases", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->phases), ctx);
    }
    
    
    json->getProperty("sortFunc", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->sortFunc), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_RenderQueueCreateInfo(se::Object* obj) {
    auto* cls = se::Class::create("RenderQueueCreateInfo", obj, nullptr, _SE(js_new_cc_pipeline_RenderQueueCreateInfo)); 
    
    cls->defineProperty("isTransparent", _SE(js_cc_pipeline_RenderQueueCreateInfo_isTransparent_get), _SE(js_cc_pipeline_RenderQueueCreateInfo_isTransparent_set)); 
    cls->defineProperty("phases", _SE(js_cc_pipeline_RenderQueueCreateInfo_phases_get), _SE(js_cc_pipeline_RenderQueueCreateInfo_phases_set)); 
    cls->defineProperty("sortFunc", _SE(js_cc_pipeline_RenderQueueCreateInfo_sortFunc_get), _SE(js_cc_pipeline_RenderQueueCreateInfo_sortFunc_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderQueueCreateInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderQueueCreateInfo>(cls);
    
    __jsb_cc_pipeline_RenderQueueCreateInfo_proto = cls->getProto();
    __jsb_cc_pipeline_RenderQueueCreateInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


static bool js_cc_pipeline_toNumber__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::RenderPriority arg1 ;
    int32_t temp1 ;
    std::underlying_type< cc::pipeline::RenderPriority >::type result;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "toNumber,1,SWIGTYPE_cc__pipeline__RenderPriority");
    arg1 = (cc::pipeline::RenderPriority)temp1;
    result = cc::pipeline::toNumber(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "toNumber, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_pipeline_toNumber__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::RenderQueueSortMode arg1 ;
    int32_t temp1 ;
    std::underlying_type< cc::pipeline::RenderQueueSortMode >::type result;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "toNumber,1,SWIGTYPE_cc__pipeline__RenderQueueSortMode");
    arg1 = (cc::pipeline::RenderQueueSortMode)temp1;
    result = cc::pipeline::toNumber(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "toNumber, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

se::Class* __jsb_cc_pipeline_RenderQueueDesc_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderQueueDesc_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderQueueDesc) 

static bool js_cc_pipeline_RenderQueueDesc_isTransparent_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderQueueDesc *arg1 = (cc::pipeline::RenderQueueDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderQueueDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->isTransparent);
    SE_PRECONDITION2(ok, false, "RenderQueueDesc_isTransparent_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderQueueDesc_isTransparent_set) 

static bool js_cc_pipeline_RenderQueueDesc_isTransparent_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderQueueDesc *arg1 = (cc::pipeline::RenderQueueDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderQueueDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->isTransparent, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderQueueDesc_isTransparent_get) 

static bool js_cc_pipeline_RenderQueueDesc_sortMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderQueueDesc *arg1 = (cc::pipeline::RenderQueueDesc *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderQueueDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "RenderQueueDesc_sortMode_set,2,SWIGTYPE_cc__pipeline__RenderQueueSortMode");
    arg1->sortMode = (cc::pipeline::RenderQueueSortMode)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderQueueDesc_sortMode_set) 

static bool js_cc_pipeline_RenderQueueDesc_sortMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderQueueDesc *arg1 = (cc::pipeline::RenderQueueDesc *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderQueueDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->sortMode));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderQueueDesc_sortMode_get) 

static bool js_cc_pipeline_RenderQueueDesc_stages_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderQueueDesc *arg1 = (cc::pipeline::RenderQueueDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderQueueDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stages, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderQueueDesc_stages_set,2,SWIGTYPE_ccstd__vectorT_ccstd__string_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderQueueDesc_stages_set) 

static bool js_cc_pipeline_RenderQueueDesc_stages_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderQueueDesc *arg1 = (cc::pipeline::RenderQueueDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderQueueDesc>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stages, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderQueueDesc_stages_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stages, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderQueueDesc_stages_get) 

// js_ctor
static bool js_new_cc_pipeline_RenderQueueDesc(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::RenderQueueDesc *result;
    result = (cc::pipeline::RenderQueueDesc *)new cc::pipeline::RenderQueueDesc();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_RenderQueueDesc, __jsb_cc_pipeline_RenderQueueDesc_class, js_delete_cc_pipeline_RenderQueueDesc)

static bool js_delete_cc_pipeline_RenderQueueDesc(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderQueueDesc) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::RenderQueueDesc * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::RenderQueueDesc*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("isTransparent", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isTransparent), ctx);
    }
    
    
    json->getProperty("sortMode", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->sortMode), ctx);
    }
    
    
    json->getProperty("stages", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stages), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_RenderQueueDesc(se::Object* obj) {
    auto* cls = se::Class::create("RenderQueueDesc", obj, nullptr, _SE(js_new_cc_pipeline_RenderQueueDesc)); 
    
    cls->defineProperty("isTransparent", _SE(js_cc_pipeline_RenderQueueDesc_isTransparent_get), _SE(js_cc_pipeline_RenderQueueDesc_isTransparent_set)); 
    cls->defineProperty("sortMode", _SE(js_cc_pipeline_RenderQueueDesc_sortMode_get), _SE(js_cc_pipeline_RenderQueueDesc_sortMode_set)); 
    cls->defineProperty("stages", _SE(js_cc_pipeline_RenderQueueDesc_stages_get), _SE(js_cc_pipeline_RenderQueueDesc_stages_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderQueueDesc));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderQueueDesc>(cls);
    
    __jsb_cc_pipeline_RenderQueueDesc_proto = cls->getProto();
    __jsb_cc_pipeline_RenderQueueDesc_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


static bool js_cc_pipeline_getPhaseID(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    ccstd::string *arg1 = 0 ;
    ccstd::string temp1 ;
    uint32_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "getPhaseID,1,SWIGTYPE_p_ccstd__string");
    arg1 = &temp1;
    
    result = cc::pipeline::getPhaseID((ccstd::string const &)*arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "getPhaseID, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_getPhaseID) 

static bool js_cc_pipeline_opaqueCompareFn(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPass *arg1 = 0 ;
    cc::pipeline::RenderPass *arg2 = 0 ;
    cc::pipeline::RenderPass temp1 ;
    cc::pipeline::RenderPass temp2 ;
    bool result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "opaqueCompareFn,1,SWIGTYPE_p_cc__pipeline__RenderPass");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "opaqueCompareFn,2,SWIGTYPE_p_cc__pipeline__RenderPass");
    arg2 = &temp2;
    
    result = (bool)cc::pipeline::opaqueCompareFn((cc::pipeline::RenderPass const &)*arg1,(cc::pipeline::RenderPass const &)*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_opaqueCompareFn) 

static bool js_cc_pipeline_transparentCompareFn(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPass *arg1 = 0 ;
    cc::pipeline::RenderPass *arg2 = 0 ;
    cc::pipeline::RenderPass temp1 ;
    cc::pipeline::RenderPass temp2 ;
    bool result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "transparentCompareFn,1,SWIGTYPE_p_cc__pipeline__RenderPass");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "transparentCompareFn,2,SWIGTYPE_p_cc__pipeline__RenderPass");
    arg2 = &temp2;
    
    result = (bool)cc::pipeline::transparentCompareFn((cc::pipeline::RenderPass const &)*arg1,(cc::pipeline::RenderPass const &)*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_transparentCompareFn) 

static bool js_cc_pipeline_convertPhase(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    ccstd::vector< ccstd::string > *arg1 = 0 ;
    ccstd::vector< ccstd::string > temp1 ;
    uint32_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "convertPhase,1,SWIGTYPE_p_ccstd__vectorT_ccstd__string_t");
    arg1 = &temp1;
    
    result = cc::pipeline::convertPhase((ccstd::vector< ccstd::string > const &)*arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "convertPhase, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_convertPhase) 

static bool js_cc_pipeline_toNumber__SWIG_4(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::PipelineGlobalBindings arg1 ;
    int32_t temp1 ;
    std::underlying_type< cc::pipeline::PipelineGlobalBindings >::type result;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "toNumber,1,SWIGTYPE_cc__pipeline__PipelineGlobalBindings");
    arg1 = (cc::pipeline::PipelineGlobalBindings)temp1;
    result = cc::pipeline::toNumber(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "toNumber, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_pipeline_toNumber__SWIG_5(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::ModelLocalBindings arg1 ;
    int32_t temp1 ;
    std::underlying_type< cc::pipeline::ModelLocalBindings >::type result;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "toNumber,1,SWIGTYPE_cc__pipeline__ModelLocalBindings");
    arg1 = (cc::pipeline::ModelLocalBindings)temp1;
    result = cc::pipeline::toNumber(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "toNumber, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_pipeline_toNumber__SWIG_6(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::SetIndex arg1 ;
    int32_t temp1 ;
    std::underlying_type< cc::pipeline::SetIndex >::type result;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "toNumber,1,SWIGTYPE_cc__pipeline__SetIndex");
    arg1 = (cc::pipeline::SetIndex)temp1;
    result = cc::pipeline::toNumber(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "toNumber, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

se::Class* __jsb_cc_pipeline_UBOLocalBatched_class = nullptr;
se::Object* __jsb_cc_pipeline_UBOLocalBatched_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBOLocalBatched) 

static bool js_cc_pipeline_UBOLocalBatched_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::UBOLocalBatched::DESCRIPTOR;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOLocalBatched_DESCRIPTOR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOLocalBatched_DESCRIPTOR_get) 

static bool js_cc_pipeline_UBOLocalBatched_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock result;
    
    result = cc::pipeline::UBOLocalBatched::LAYOUT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOLocalBatched_LAYOUT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOLocalBatched_LAYOUT_get) 

static bool js_cc_pipeline_UBOLocalBatched_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::UBOLocalBatched::NAME;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOLocalBatched_NAME_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOLocalBatched_NAME_get) 

// js_ctor
static bool js_new_cc_pipeline_UBOLocalBatched(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBOLocalBatched *result;
    result = (cc::pipeline::UBOLocalBatched *)new cc::pipeline::UBOLocalBatched();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBOLocalBatched, __jsb_cc_pipeline_UBOLocalBatched_class, js_delete_cc_pipeline_UBOLocalBatched)

static bool js_delete_cc_pipeline_UBOLocalBatched(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBOLocalBatched) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBOLocalBatched * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBOLocalBatched*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBOLocalBatched(se::Object* obj) {
    auto* cls = se::Class::create("UBOLocalBatched", obj, nullptr, _SE(js_new_cc_pipeline_UBOLocalBatched)); 
    
    
    
    cls->defineStaticProperty("BATCHING_COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("MAT_WORLDS_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("SIZE", nullptr, nullptr); 
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_UBOLocalBatched_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_UBOLocalBatched_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_UBOLocalBatched_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBOLocalBatched));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBOLocalBatched>(cls);
    
    __jsb_cc_pipeline_UBOLocalBatched_proto = cls->getProto();
    __jsb_cc_pipeline_UBOLocalBatched_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_UBOLocal_class = nullptr;
se::Object* __jsb_cc_pipeline_UBOLocal_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBOLocal) 

static bool js_cc_pipeline_UBOLocal_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::UBOLocal::DESCRIPTOR;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOLocal_DESCRIPTOR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOLocal_DESCRIPTOR_get) 

static bool js_cc_pipeline_UBOLocal_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock result;
    
    result = cc::pipeline::UBOLocal::LAYOUT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOLocal_LAYOUT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOLocal_LAYOUT_get) 

static bool js_cc_pipeline_UBOLocal_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::UBOLocal::NAME;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOLocal_NAME_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOLocal_NAME_get) 

// js_ctor
static bool js_new_cc_pipeline_UBOLocal(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBOLocal *result;
    result = (cc::pipeline::UBOLocal *)new cc::pipeline::UBOLocal();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBOLocal, __jsb_cc_pipeline_UBOLocal_class, js_delete_cc_pipeline_UBOLocal)

static bool js_delete_cc_pipeline_UBOLocal(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBOLocal) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBOLocal * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBOLocal*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBOLocal(se::Object* obj) {
    auto* cls = se::Class::create("UBOLocal", obj, nullptr, _SE(js_new_cc_pipeline_UBOLocal)); 
    
    
    
    cls->defineStaticProperty("MAT_WORLD_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("MAT_WORLD_IT_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("LIGHTINGMAP_UVPARAM", nullptr, nullptr); 
    cls->defineStaticProperty("LOCAL_SHADOW_BIAS", nullptr, nullptr); 
    cls->defineStaticProperty("COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("SIZE", nullptr, nullptr); 
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_UBOLocal_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_UBOLocal_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_UBOLocal_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBOLocal));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBOLocal>(cls);
    
    __jsb_cc_pipeline_UBOLocal_proto = cls->getProto();
    __jsb_cc_pipeline_UBOLocal_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_UBOWorldBound_class = nullptr;
se::Object* __jsb_cc_pipeline_UBOWorldBound_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBOWorldBound) 

static bool js_cc_pipeline_UBOWorldBound_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::UBOWorldBound::DESCRIPTOR;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOWorldBound_DESCRIPTOR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOWorldBound_DESCRIPTOR_get) 

static bool js_cc_pipeline_UBOWorldBound_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock result;
    
    result = cc::pipeline::UBOWorldBound::LAYOUT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOWorldBound_LAYOUT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOWorldBound_LAYOUT_get) 

static bool js_cc_pipeline_UBOWorldBound_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::UBOWorldBound::NAME;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOWorldBound_NAME_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOWorldBound_NAME_get) 

// js_ctor
static bool js_new_cc_pipeline_UBOWorldBound(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBOWorldBound *result;
    result = (cc::pipeline::UBOWorldBound *)new cc::pipeline::UBOWorldBound();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBOWorldBound, __jsb_cc_pipeline_UBOWorldBound_class, js_delete_cc_pipeline_UBOWorldBound)

static bool js_delete_cc_pipeline_UBOWorldBound(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBOWorldBound) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBOWorldBound * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBOWorldBound*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBOWorldBound(se::Object* obj) {
    auto* cls = se::Class::create("UBOWorldBound", obj, nullptr, _SE(js_new_cc_pipeline_UBOWorldBound)); 
    
    
    
    cls->defineStaticProperty("WORLD_BOUND_CENTER", nullptr, nullptr); 
    cls->defineStaticProperty("WORLD_BOUND_HALF_EXTENTS", nullptr, nullptr); 
    cls->defineStaticProperty("COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("SIZE", nullptr, nullptr); 
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_UBOWorldBound_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_UBOWorldBound_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_UBOWorldBound_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBOWorldBound));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBOWorldBound>(cls);
    
    __jsb_cc_pipeline_UBOWorldBound_proto = cls->getProto();
    __jsb_cc_pipeline_UBOWorldBound_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_UBOForwardLight_class = nullptr;
se::Object* __jsb_cc_pipeline_UBOForwardLight_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBOForwardLight) 

static bool js_cc_pipeline_UBOForwardLight_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::UBOForwardLight::DESCRIPTOR;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOForwardLight_DESCRIPTOR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOForwardLight_DESCRIPTOR_get) 

static bool js_cc_pipeline_UBOForwardLight_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock result;
    
    result = cc::pipeline::UBOForwardLight::LAYOUT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOForwardLight_LAYOUT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOForwardLight_LAYOUT_get) 

static bool js_cc_pipeline_UBOForwardLight_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::UBOForwardLight::NAME;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOForwardLight_NAME_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOForwardLight_NAME_get) 

// js_ctor
static bool js_new_cc_pipeline_UBOForwardLight(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBOForwardLight *result;
    result = (cc::pipeline::UBOForwardLight *)new cc::pipeline::UBOForwardLight();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBOForwardLight, __jsb_cc_pipeline_UBOForwardLight_class, js_delete_cc_pipeline_UBOForwardLight)

static bool js_delete_cc_pipeline_UBOForwardLight(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBOForwardLight) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBOForwardLight * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBOForwardLight*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBOForwardLight(se::Object* obj) {
    auto* cls = se::Class::create("UBOForwardLight", obj, nullptr, _SE(js_new_cc_pipeline_UBOForwardLight)); 
    
    
    
    cls->defineStaticProperty("LIGHTS_PER_PASS", nullptr, nullptr); 
    cls->defineStaticProperty("LIGHT_POS_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("LIGHT_COLOR_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("LIGHT_SIZE_RANGE_ANGLE_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("LIGHT_DIR_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("SIZE", nullptr, nullptr); 
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_UBOForwardLight_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_UBOForwardLight_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_UBOForwardLight_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBOForwardLight));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBOForwardLight>(cls);
    
    __jsb_cc_pipeline_UBOForwardLight_proto = cls->getProto();
    __jsb_cc_pipeline_UBOForwardLight_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_UBODeferredLight_class = nullptr;
se::Object* __jsb_cc_pipeline_UBODeferredLight_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBODeferredLight) 

// js_ctor
static bool js_new_cc_pipeline_UBODeferredLight(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBODeferredLight *result;
    result = (cc::pipeline::UBODeferredLight *)new cc::pipeline::UBODeferredLight();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBODeferredLight, __jsb_cc_pipeline_UBODeferredLight_class, js_delete_cc_pipeline_UBODeferredLight)

static bool js_delete_cc_pipeline_UBODeferredLight(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBODeferredLight) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBODeferredLight * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBODeferredLight*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBODeferredLight(se::Object* obj) {
    auto* cls = se::Class::create("UBODeferredLight", obj, nullptr, _SE(js_new_cc_pipeline_UBODeferredLight)); 
    
    
    
    cls->defineStaticProperty("LIGHTS_PER_PASS", nullptr, nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBODeferredLight));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBODeferredLight>(cls);
    
    __jsb_cc_pipeline_UBODeferredLight_proto = cls->getProto();
    __jsb_cc_pipeline_UBODeferredLight_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_UBOSkinningTexture_class = nullptr;
se::Object* __jsb_cc_pipeline_UBOSkinningTexture_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBOSkinningTexture) 

static bool js_cc_pipeline_UBOSkinningTexture_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::UBOSkinningTexture::DESCRIPTOR;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOSkinningTexture_DESCRIPTOR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOSkinningTexture_DESCRIPTOR_get) 

static bool js_cc_pipeline_UBOSkinningTexture_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock result;
    
    result = cc::pipeline::UBOSkinningTexture::LAYOUT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOSkinningTexture_LAYOUT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOSkinningTexture_LAYOUT_get) 

static bool js_cc_pipeline_UBOSkinningTexture_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::UBOSkinningTexture::NAME;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOSkinningTexture_NAME_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOSkinningTexture_NAME_get) 

// js_ctor
static bool js_new_cc_pipeline_UBOSkinningTexture(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBOSkinningTexture *result;
    result = (cc::pipeline::UBOSkinningTexture *)new cc::pipeline::UBOSkinningTexture();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBOSkinningTexture, __jsb_cc_pipeline_UBOSkinningTexture_class, js_delete_cc_pipeline_UBOSkinningTexture)

static bool js_delete_cc_pipeline_UBOSkinningTexture(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBOSkinningTexture) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBOSkinningTexture * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBOSkinningTexture*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBOSkinningTexture(se::Object* obj) {
    auto* cls = se::Class::create("UBOSkinningTexture", obj, nullptr, _SE(js_new_cc_pipeline_UBOSkinningTexture)); 
    
    
    
    cls->defineStaticProperty("JOINTS_TEXTURE_INFO_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("SIZE", nullptr, nullptr); 
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_UBOSkinningTexture_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_UBOSkinningTexture_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_UBOSkinningTexture_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBOSkinningTexture));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBOSkinningTexture>(cls);
    
    __jsb_cc_pipeline_UBOSkinningTexture_proto = cls->getProto();
    __jsb_cc_pipeline_UBOSkinningTexture_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_UBOSkinningAnimation_class = nullptr;
se::Object* __jsb_cc_pipeline_UBOSkinningAnimation_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBOSkinningAnimation) 

static bool js_cc_pipeline_UBOSkinningAnimation_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::UBOSkinningAnimation::DESCRIPTOR;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOSkinningAnimation_DESCRIPTOR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOSkinningAnimation_DESCRIPTOR_get) 

static bool js_cc_pipeline_UBOSkinningAnimation_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock result;
    
    result = cc::pipeline::UBOSkinningAnimation::LAYOUT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOSkinningAnimation_LAYOUT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOSkinningAnimation_LAYOUT_get) 

static bool js_cc_pipeline_UBOSkinningAnimation_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::UBOSkinningAnimation::NAME;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOSkinningAnimation_NAME_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOSkinningAnimation_NAME_get) 

// js_ctor
static bool js_new_cc_pipeline_UBOSkinningAnimation(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBOSkinningAnimation *result;
    result = (cc::pipeline::UBOSkinningAnimation *)new cc::pipeline::UBOSkinningAnimation();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBOSkinningAnimation, __jsb_cc_pipeline_UBOSkinningAnimation_class, js_delete_cc_pipeline_UBOSkinningAnimation)

static bool js_delete_cc_pipeline_UBOSkinningAnimation(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBOSkinningAnimation) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBOSkinningAnimation * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBOSkinningAnimation*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBOSkinningAnimation(se::Object* obj) {
    auto* cls = se::Class::create("UBOSkinningAnimation", obj, nullptr, _SE(js_new_cc_pipeline_UBOSkinningAnimation)); 
    
    
    
    cls->defineStaticProperty("JOINTS_ANIM_INFO_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("SIZE", nullptr, nullptr); 
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_UBOSkinningAnimation_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_UBOSkinningAnimation_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_UBOSkinningAnimation_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBOSkinningAnimation));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBOSkinningAnimation>(cls);
    
    __jsb_cc_pipeline_UBOSkinningAnimation_proto = cls->getProto();
    __jsb_cc_pipeline_UBOSkinningAnimation_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_UBOSkinning_class = nullptr;
se::Object* __jsb_cc_pipeline_UBOSkinning_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBOSkinning) 

static bool js_cc_pipeline_UBOSkinning_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    uint32_t arg1 ;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "UBOSkinning_count_set,1,SWIGTYPE_uint32_t"); 
    
    cc::pipeline::UBOSkinning::count = arg1;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_UBOSkinning_count_set) 

static bool js_cc_pipeline_UBOSkinning_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    uint32_t result;
    
    result = cc::pipeline::UBOSkinning::count;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOSkinning_count_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOSkinning_count_get) 

static bool js_cc_pipeline_UBOSkinning_size_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    uint32_t arg1 ;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "UBOSkinning_size_set,1,SWIGTYPE_uint32_t"); 
    
    cc::pipeline::UBOSkinning::size = arg1;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_UBOSkinning_size_set) 

static bool js_cc_pipeline_UBOSkinning_size_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    uint32_t result;
    
    result = cc::pipeline::UBOSkinning::size;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOSkinning_size_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOSkinning_size_get) 

static bool js_cc_pipeline_UBOSkinning_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::UBOSkinning::DESCRIPTOR;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOSkinning_DESCRIPTOR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOSkinning_DESCRIPTOR_get) 

static bool js_cc_pipeline_UBOSkinning_layout_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformBlock arg1 ;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "UBOSkinning_layout_set,1,SWIGTYPE_cc__gfx__UniformBlock"); 
    
    cc::pipeline::UBOSkinning::layout = arg1;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_UBOSkinning_layout_set) 

static bool js_cc_pipeline_UBOSkinning_layout_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock result;
    
    result = cc::pipeline::UBOSkinning::layout;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOSkinning_layout_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOSkinning_layout_get) 

static bool js_cc_pipeline_UBOSkinning_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::UBOSkinning::NAME;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOSkinning_NAME_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOSkinning_NAME_get) 

static bool js_cc_pipeline_UBOSkinning_initLayout_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    uint arg1 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "UBOSkinning_initLayout,1,SWIGTYPE_std__uint32_t"); 
    
    cc::pipeline::UBOSkinning::initLayout(arg1);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_UBOSkinning_initLayout_static) 

// js_ctor
static bool js_new_cc_pipeline_UBOSkinning(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBOSkinning *result;
    result = (cc::pipeline::UBOSkinning *)new cc::pipeline::UBOSkinning();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBOSkinning, __jsb_cc_pipeline_UBOSkinning_class, js_delete_cc_pipeline_UBOSkinning)

static bool js_delete_cc_pipeline_UBOSkinning(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBOSkinning) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBOSkinning * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBOSkinning*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBOSkinning(se::Object* obj) {
    auto* cls = se::Class::create("UBOSkinning", obj, nullptr, _SE(js_new_cc_pipeline_UBOSkinning)); 
    
    
    
    cls->defineStaticProperty("count", _SE(js_cc_pipeline_UBOSkinning_count_get), _SE(js_cc_pipeline_UBOSkinning_count_set)); 
    cls->defineStaticProperty("size", _SE(js_cc_pipeline_UBOSkinning_size_get), _SE(js_cc_pipeline_UBOSkinning_size_set)); 
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_UBOSkinning_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("layout", _SE(js_cc_pipeline_UBOSkinning_layout_get), _SE(js_cc_pipeline_UBOSkinning_layout_set)); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_UBOSkinning_NAME_get), nullptr); 
    
    cls->defineStaticFunction("initLayout", _SE(js_cc_pipeline_UBOSkinning_initLayout_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBOSkinning));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBOSkinning>(cls);
    
    __jsb_cc_pipeline_UBOSkinning_proto = cls->getProto();
    __jsb_cc_pipeline_UBOSkinning_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_UBOMorph_class = nullptr;
se::Object* __jsb_cc_pipeline_UBOMorph_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBOMorph) 

static bool js_cc_pipeline_UBOMorph_COUNT_BASE_4_BYTES_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    uint32_t result;
    
    result = (uint32_t)cc::pipeline::UBOMorph::COUNT_BASE_4_BYTES;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOMorph_COUNT_BASE_4_BYTES_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOMorph_COUNT_BASE_4_BYTES_get) 

static bool js_cc_pipeline_UBOMorph_SIZE_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    uint32_t result;
    
    result = (uint32_t)cc::pipeline::UBOMorph::SIZE;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOMorph_SIZE_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOMorph_SIZE_get) 

static bool js_cc_pipeline_UBOMorph_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::UBOMorph::DESCRIPTOR;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOMorph_DESCRIPTOR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOMorph_DESCRIPTOR_get) 

static bool js_cc_pipeline_UBOMorph_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock result;
    
    result = cc::pipeline::UBOMorph::LAYOUT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOMorph_LAYOUT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOMorph_LAYOUT_get) 

static bool js_cc_pipeline_UBOMorph_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::UBOMorph::NAME;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOMorph_NAME_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOMorph_NAME_get) 

// js_ctor
static bool js_new_cc_pipeline_UBOMorph(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBOMorph *result;
    result = (cc::pipeline::UBOMorph *)new cc::pipeline::UBOMorph();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBOMorph, __jsb_cc_pipeline_UBOMorph_class, js_delete_cc_pipeline_UBOMorph)

static bool js_delete_cc_pipeline_UBOMorph(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBOMorph) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBOMorph * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBOMorph*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBOMorph(se::Object* obj) {
    auto* cls = se::Class::create("UBOMorph", obj, nullptr, _SE(js_new_cc_pipeline_UBOMorph)); 
    
    
    
    cls->defineStaticProperty("MAX_MORPH_TARGET_COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("OFFSET_OF_WEIGHTS", nullptr, nullptr); 
    cls->defineStaticProperty("OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH", nullptr, nullptr); 
    cls->defineStaticProperty("OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT", nullptr, nullptr); 
    cls->defineStaticProperty("OFFSET_OF_VERTICES_COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("COUNT_BASE_4_BYTES", _SE(js_cc_pipeline_UBOMorph_COUNT_BASE_4_BYTES_get), nullptr); 
    cls->defineStaticProperty("SIZE", _SE(js_cc_pipeline_UBOMorph_SIZE_get), nullptr); 
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_UBOMorph_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_UBOMorph_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_UBOMorph_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBOMorph));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBOMorph>(cls);
    
    __jsb_cc_pipeline_UBOMorph_proto = cls->getProto();
    __jsb_cc_pipeline_UBOMorph_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_UBOUILocal_class = nullptr;
se::Object* __jsb_cc_pipeline_UBOUILocal_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBOUILocal) 

static bool js_cc_pipeline_UBOUILocal_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::UBOUILocal::DESCRIPTOR;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOUILocal_DESCRIPTOR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOUILocal_DESCRIPTOR_get) 

static bool js_cc_pipeline_UBOUILocal_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock result;
    
    result = cc::pipeline::UBOUILocal::LAYOUT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOUILocal_LAYOUT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOUILocal_LAYOUT_get) 

static bool js_cc_pipeline_UBOUILocal_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::UBOUILocal::NAME;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOUILocal_NAME_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOUILocal_NAME_get) 

// js_ctor
static bool js_new_cc_pipeline_UBOUILocal(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBOUILocal *result;
    result = (cc::pipeline::UBOUILocal *)new cc::pipeline::UBOUILocal();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBOUILocal, __jsb_cc_pipeline_UBOUILocal_class, js_delete_cc_pipeline_UBOUILocal)

static bool js_delete_cc_pipeline_UBOUILocal(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBOUILocal) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBOUILocal * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBOUILocal*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBOUILocal(se::Object* obj) {
    auto* cls = se::Class::create("UBOUILocal", obj, nullptr, _SE(js_new_cc_pipeline_UBOUILocal)); 
    
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_UBOUILocal_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_UBOUILocal_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_UBOUILocal_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBOUILocal));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBOUILocal>(cls);
    
    __jsb_cc_pipeline_UBOUILocal_proto = cls->getProto();
    __jsb_cc_pipeline_UBOUILocal_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


static bool js_cc_pipeline_toNumber__SWIG_7(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::ForwardStagePriority arg1 ;
    int32_t temp1 ;
    std::underlying_type< cc::pipeline::ForwardStagePriority >::type result;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "toNumber,1,SWIGTYPE_cc__pipeline__ForwardStagePriority");
    arg1 = (cc::pipeline::ForwardStagePriority)temp1;
    result = cc::pipeline::toNumber(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "toNumber, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_pipeline_toNumber__SWIG_8(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::ForwardFlowPriority arg1 ;
    int32_t temp1 ;
    std::underlying_type< cc::pipeline::ForwardFlowPriority >::type result;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "toNumber,1,SWIGTYPE_cc__pipeline__ForwardFlowPriority");
    arg1 = (cc::pipeline::ForwardFlowPriority)temp1;
    result = cc::pipeline::toNumber(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "toNumber, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_pipeline_toNumber__SWIG_9(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::RenderFlowTag arg1 ;
    int32_t temp1 ;
    std::underlying_type< cc::pipeline::RenderFlowTag >::type result;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "toNumber,1,SWIGTYPE_cc__pipeline__RenderFlowTag");
    arg1 = (cc::pipeline::RenderFlowTag)temp1;
    result = cc::pipeline::toNumber(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "toNumber, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_pipeline_toNumber__SWIG_10(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::DeferredStagePriority arg1 ;
    int32_t temp1 ;
    std::underlying_type< cc::pipeline::DeferredStagePriority >::type result;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "toNumber,1,SWIGTYPE_cc__pipeline__DeferredStagePriority");
    arg1 = (cc::pipeline::DeferredStagePriority)temp1;
    result = cc::pipeline::toNumber(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "toNumber, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_pipeline_toNumber__SWIG_11(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::DeferredFlowPriority arg1 ;
    int32_t temp1 ;
    std::underlying_type< cc::pipeline::DeferredFlowPriority >::type result;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "toNumber,1,SWIGTYPE_cc__pipeline__DeferredFlowPriority");
    arg1 = (cc::pipeline::DeferredFlowPriority)temp1;
    result = cc::pipeline::toNumber(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "toNumber, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

se::Class* __jsb_cc_pipeline_UBOGlobal_class = nullptr;
se::Object* __jsb_cc_pipeline_UBOGlobal_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBOGlobal) 

static bool js_cc_pipeline_UBOGlobal_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::UBOGlobal::DESCRIPTOR;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOGlobal_DESCRIPTOR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOGlobal_DESCRIPTOR_get) 

static bool js_cc_pipeline_UBOGlobal_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock result;
    
    result = cc::pipeline::UBOGlobal::LAYOUT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOGlobal_LAYOUT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOGlobal_LAYOUT_get) 

static bool js_cc_pipeline_UBOGlobal_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::UBOGlobal::NAME;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOGlobal_NAME_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOGlobal_NAME_get) 

// js_ctor
static bool js_new_cc_pipeline_UBOGlobal(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBOGlobal *result;
    result = (cc::pipeline::UBOGlobal *)new cc::pipeline::UBOGlobal();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBOGlobal, __jsb_cc_pipeline_UBOGlobal_class, js_delete_cc_pipeline_UBOGlobal)

static bool js_delete_cc_pipeline_UBOGlobal(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBOGlobal) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBOGlobal * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBOGlobal*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBOGlobal(se::Object* obj) {
    auto* cls = se::Class::create("UBOGlobal", obj, nullptr, _SE(js_new_cc_pipeline_UBOGlobal)); 
    
    
    
    cls->defineStaticProperty("TIME_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("SCREEN_SIZE_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("NATIVE_SIZE_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("DEBUG_VIEW_MODE_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("DEBUG_VIEW_COMPOSITE_PACK_1_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("DEBUG_VIEW_COMPOSITE_PACK_2_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("DEBUG_VIEW_COMPOSITE_PACK_3_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("SIZE", nullptr, nullptr); 
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_UBOGlobal_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_UBOGlobal_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_UBOGlobal_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBOGlobal));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBOGlobal>(cls);
    
    __jsb_cc_pipeline_UBOGlobal_proto = cls->getProto();
    __jsb_cc_pipeline_UBOGlobal_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_UBOCamera_class = nullptr;
se::Object* __jsb_cc_pipeline_UBOCamera_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBOCamera) 

static bool js_cc_pipeline_UBOCamera_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::UBOCamera::DESCRIPTOR;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOCamera_DESCRIPTOR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOCamera_DESCRIPTOR_get) 

static bool js_cc_pipeline_UBOCamera_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock result;
    
    result = cc::pipeline::UBOCamera::LAYOUT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOCamera_LAYOUT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOCamera_LAYOUT_get) 

static bool js_cc_pipeline_UBOCamera_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::UBOCamera::NAME;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOCamera_NAME_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOCamera_NAME_get) 

// js_ctor
static bool js_new_cc_pipeline_UBOCamera(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBOCamera *result;
    result = (cc::pipeline::UBOCamera *)new cc::pipeline::UBOCamera();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBOCamera, __jsb_cc_pipeline_UBOCamera_class, js_delete_cc_pipeline_UBOCamera)

static bool js_delete_cc_pipeline_UBOCamera(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBOCamera) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBOCamera * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBOCamera*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBOCamera(se::Object* obj) {
    auto* cls = se::Class::create("UBOCamera", obj, nullptr, _SE(js_new_cc_pipeline_UBOCamera)); 
    
    
    
    cls->defineStaticProperty("MAT_VIEW_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("MAT_VIEW_INV_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("MAT_PROJ_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("MAT_PROJ_INV_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("MAT_VIEW_PROJ_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("MAT_VIEW_PROJ_INV_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("CAMERA_POS_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("SURFACE_TRANSFORM_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("SCREEN_SCALE_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("EXPOSURE_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("MAIN_LIT_DIR_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("MAIN_LIT_COLOR_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("AMBIENT_SKY_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("AMBIENT_GROUND_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("GLOBAL_FOG_COLOR_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("GLOBAL_FOG_BASE_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("GLOBAL_FOG_ADD_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("GLOBAL_NEAR_FAR_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("GLOBAL_VIEW_PORT_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("SIZE", nullptr, nullptr); 
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_UBOCamera_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_UBOCamera_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_UBOCamera_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBOCamera));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBOCamera>(cls);
    
    __jsb_cc_pipeline_UBOCamera_proto = cls->getProto();
    __jsb_cc_pipeline_UBOCamera_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_UBOShadow_class = nullptr;
se::Object* __jsb_cc_pipeline_UBOShadow_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBOShadow) 

static bool js_cc_pipeline_UBOShadow_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::UBOShadow::DESCRIPTOR;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOShadow_DESCRIPTOR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOShadow_DESCRIPTOR_get) 

static bool js_cc_pipeline_UBOShadow_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock result;
    
    result = cc::pipeline::UBOShadow::LAYOUT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOShadow_LAYOUT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOShadow_LAYOUT_get) 

static bool js_cc_pipeline_UBOShadow_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::UBOShadow::NAME;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOShadow_NAME_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOShadow_NAME_get) 

// js_ctor
static bool js_new_cc_pipeline_UBOShadow(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBOShadow *result;
    result = (cc::pipeline::UBOShadow *)new cc::pipeline::UBOShadow();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBOShadow, __jsb_cc_pipeline_UBOShadow_class, js_delete_cc_pipeline_UBOShadow)

static bool js_delete_cc_pipeline_UBOShadow(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBOShadow) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBOShadow * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBOShadow*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBOShadow(se::Object* obj) {
    auto* cls = se::Class::create("UBOShadow", obj, nullptr, _SE(js_new_cc_pipeline_UBOShadow)); 
    
    
    
    cls->defineStaticProperty("MAT_LIGHT_VIEW_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("MAT_LIGHT_VIEW_PROJ_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("SHADOW_INV_PROJ_DEPTH_INFO_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("SHADOW_PROJ_DEPTH_INFO_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("SHADOW_PROJ_INFO_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("SHADOW_COLOR_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("PLANAR_NORMAL_DISTANCE_INFO_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("SIZE", nullptr, nullptr); 
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_UBOShadow_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_UBOShadow_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_UBOShadow_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBOShadow));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBOShadow>(cls);
    
    __jsb_cc_pipeline_UBOShadow_proto = cls->getProto();
    __jsb_cc_pipeline_UBOShadow_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_UBOCSM_class = nullptr;
se::Object* __jsb_cc_pipeline_UBOCSM_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBOCSM) 

static bool js_cc_pipeline_UBOCSM_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::UBOCSM::DESCRIPTOR;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOCSM_DESCRIPTOR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOCSM_DESCRIPTOR_get) 

static bool js_cc_pipeline_UBOCSM_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock result;
    
    result = cc::pipeline::UBOCSM::LAYOUT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOCSM_LAYOUT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOCSM_LAYOUT_get) 

static bool js_cc_pipeline_UBOCSM_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::UBOCSM::NAME;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "UBOCSM_NAME_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOCSM_NAME_get) 

// js_ctor
static bool js_new_cc_pipeline_UBOCSM(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBOCSM *result;
    result = (cc::pipeline::UBOCSM *)new cc::pipeline::UBOCSM();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBOCSM, __jsb_cc_pipeline_UBOCSM_class, js_delete_cc_pipeline_UBOCSM)

static bool js_delete_cc_pipeline_UBOCSM(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBOCSM) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBOCSM * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBOCSM*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBOCSM(se::Object* obj) {
    auto* cls = se::Class::create("UBOCSM", obj, nullptr, _SE(js_new_cc_pipeline_UBOCSM)); 
    
    
    
    cls->defineStaticProperty("CSM_LEVEL_COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("CSM_VIEW_DIR_0_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("CSM_VIEW_DIR_1_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("CSM_VIEW_DIR_2_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("CSM_ATLAS_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("MAT_CSM_VIEW_PROJ_LEVELS_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("CSM_PROJ_DEPTH_INFO_LEVELS_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("CSM_PROJ_INFO_LEVELS_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("CSM_SPLITS_INFO_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("SIZE", nullptr, nullptr); 
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_UBOCSM_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_UBOCSM_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_UBOCSM_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBOCSM));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBOCSM>(cls);
    
    __jsb_cc_pipeline_UBOCSM_proto = cls->getProto();
    __jsb_cc_pipeline_UBOCSM_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_DescriptorSetLayoutInfos_class = nullptr;
se::Object* __jsb_cc_pipeline_DescriptorSetLayoutInfos_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_DescriptorSetLayoutInfos) 

static bool js_cc_pipeline_DescriptorSetLayoutInfos_bindings_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::DescriptorSetLayoutInfos *arg1 = (cc::pipeline::DescriptorSetLayoutInfos *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::DescriptorSetLayoutInfos>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->bindings, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSetLayoutInfos_bindings_set,2,SWIGTYPE_ccstd__vectorT_cc__gfx__DescriptorSetLayoutBinding_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_DescriptorSetLayoutInfos_bindings_set) 

static bool js_cc_pipeline_DescriptorSetLayoutInfos_bindings_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::DescriptorSetLayoutInfos *arg1 = (cc::pipeline::DescriptorSetLayoutInfos *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::DescriptorSetLayoutInfos>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->bindings, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DescriptorSetLayoutInfos_bindings_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->bindings, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_DescriptorSetLayoutInfos_bindings_get) 

static bool js_cc_pipeline_DescriptorSetLayoutInfos_blocks_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::DescriptorSetLayoutInfos *arg1 = (cc::pipeline::DescriptorSetLayoutInfos *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::DescriptorSetLayoutInfos>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->blocks, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSetLayoutInfos_blocks_set,2,SWIGTYPE_ccstd__unordered_mapT_ccstd__string_cc__gfx__UniformBlock_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_DescriptorSetLayoutInfos_blocks_set) 

static bool js_cc_pipeline_DescriptorSetLayoutInfos_blocks_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::DescriptorSetLayoutInfos *arg1 = (cc::pipeline::DescriptorSetLayoutInfos *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::DescriptorSetLayoutInfos>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->blocks, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DescriptorSetLayoutInfos_blocks_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blocks, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_DescriptorSetLayoutInfos_blocks_get) 

static bool js_cc_pipeline_DescriptorSetLayoutInfos_samplers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::DescriptorSetLayoutInfos *arg1 = (cc::pipeline::DescriptorSetLayoutInfos *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::DescriptorSetLayoutInfos>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->samplers, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSetLayoutInfos_samplers_set,2,SWIGTYPE_ccstd__unordered_mapT_ccstd__string_cc__gfx__UniformSamplerTexture_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_DescriptorSetLayoutInfos_samplers_set) 

static bool js_cc_pipeline_DescriptorSetLayoutInfos_samplers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::DescriptorSetLayoutInfos *arg1 = (cc::pipeline::DescriptorSetLayoutInfos *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::DescriptorSetLayoutInfos>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->samplers, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DescriptorSetLayoutInfos_samplers_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->samplers, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_DescriptorSetLayoutInfos_samplers_get) 

static bool js_cc_pipeline_DescriptorSetLayoutInfos_storeImages_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::DescriptorSetLayoutInfos *arg1 = (cc::pipeline::DescriptorSetLayoutInfos *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::DescriptorSetLayoutInfos>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->storeImages, s.thisObject());
    SE_PRECONDITION2(ok, false, "DescriptorSetLayoutInfos_storeImages_set,2,SWIGTYPE_ccstd__unordered_mapT_ccstd__string_cc__gfx__UniformStorageImage_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_DescriptorSetLayoutInfos_storeImages_set) 

static bool js_cc_pipeline_DescriptorSetLayoutInfos_storeImages_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::DescriptorSetLayoutInfos *arg1 = (cc::pipeline::DescriptorSetLayoutInfos *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::DescriptorSetLayoutInfos>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->storeImages, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DescriptorSetLayoutInfos_storeImages_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->storeImages, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_DescriptorSetLayoutInfos_storeImages_get) 

// js_ctor
static bool js_new_cc_pipeline_DescriptorSetLayoutInfos(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::DescriptorSetLayoutInfos *result;
    result = (cc::pipeline::DescriptorSetLayoutInfos *)new cc::pipeline::DescriptorSetLayoutInfos();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_DescriptorSetLayoutInfos, __jsb_cc_pipeline_DescriptorSetLayoutInfos_class, js_delete_cc_pipeline_DescriptorSetLayoutInfos)

static bool js_delete_cc_pipeline_DescriptorSetLayoutInfos(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_DescriptorSetLayoutInfos) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::DescriptorSetLayoutInfos * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::DescriptorSetLayoutInfos*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("bindings", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->bindings), ctx);
    }
    
    
    json->getProperty("blocks", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blocks), ctx);
    }
    
    
    json->getProperty("samplers", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->samplers), ctx);
    }
    
    
    json->getProperty("storeImages", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->storeImages), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_DescriptorSetLayoutInfos(se::Object* obj) {
    auto* cls = se::Class::create("DescriptorSetLayoutInfos", obj, nullptr, _SE(js_new_cc_pipeline_DescriptorSetLayoutInfos)); 
    
    cls->defineProperty("bindings", _SE(js_cc_pipeline_DescriptorSetLayoutInfos_bindings_get), _SE(js_cc_pipeline_DescriptorSetLayoutInfos_bindings_set)); 
    cls->defineProperty("blocks", _SE(js_cc_pipeline_DescriptorSetLayoutInfos_blocks_get), _SE(js_cc_pipeline_DescriptorSetLayoutInfos_blocks_set)); 
    cls->defineProperty("samplers", _SE(js_cc_pipeline_DescriptorSetLayoutInfos_samplers_get), _SE(js_cc_pipeline_DescriptorSetLayoutInfos_samplers_set)); 
    cls->defineProperty("storeImages", _SE(js_cc_pipeline_DescriptorSetLayoutInfos_storeImages_get), _SE(js_cc_pipeline_DescriptorSetLayoutInfos_storeImages_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_DescriptorSetLayoutInfos));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::DescriptorSetLayoutInfos>(cls);
    
    __jsb_cc_pipeline_DescriptorSetLayoutInfos_proto = cls->getProto();
    __jsb_cc_pipeline_DescriptorSetLayoutInfos_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


static bool js_cc_pipeline_toNumber__SWIG_12(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::LayerList arg1 ;
    int32_t temp1 ;
    std::underlying_type< cc::pipeline::LayerList >::type result;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "toNumber,1,SWIGTYPE_cc__pipeline__LayerList");
    arg1 = (cc::pipeline::LayerList)temp1;
    result = cc::pipeline::toNumber(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "toNumber, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_pipeline_toNumber(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_pipeline_toNumber__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_pipeline_toNumber__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_pipeline_toNumber__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_pipeline_toNumber__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_pipeline_toNumber__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_pipeline_toNumber__SWIG_5(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_pipeline_toNumber__SWIG_6(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_pipeline_toNumber__SWIG_7(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_pipeline_toNumber__SWIG_8(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_pipeline_toNumber__SWIG_9(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_pipeline_toNumber__SWIG_10(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_pipeline_toNumber__SWIG_11(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_pipeline_toNumber__SWIG_12(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_toNumber) 

static bool js_cc_pipeline_nextPow2(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    uint32_t arg1 ;
    uint32_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "nextPow2,1,SWIGTYPE_uint32_t"); 
    
    result = cc::pipeline::nextPow2(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "nextPow2, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_nextPow2) 

static bool js_cc_pipeline_supportsR16HalfFloatTexture(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "supportsR16HalfFloatTexture,1,SWIGTYPE_p_cc__gfx__Device"); 
    result = (bool)cc::pipeline::supportsR16HalfFloatTexture((cc::gfx::Device const *)arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_supportsR16HalfFloatTexture) 

static bool js_cc_pipeline_supportsR32FloatTexture(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "supportsR32FloatTexture,1,SWIGTYPE_p_cc__gfx__Device"); 
    result = (bool)cc::pipeline::supportsR32FloatTexture((cc::gfx::Device const *)arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_supportsR32FloatTexture) 

se::Class* __jsb_cc_pipeline_SHADOWMAP_class = nullptr;
se::Object* __jsb_cc_pipeline_SHADOWMAP_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_SHADOWMAP) 

static bool js_cc_pipeline_SHADOWMAP_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::SHADOWMAP::DESCRIPTOR;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SHADOWMAP_DESCRIPTOR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_SHADOWMAP_DESCRIPTOR_get) 

static bool js_cc_pipeline_SHADOWMAP_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture result;
    
    result = cc::pipeline::SHADOWMAP::LAYOUT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SHADOWMAP_LAYOUT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_SHADOWMAP_LAYOUT_get) 

static bool js_cc_pipeline_SHADOWMAP_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::SHADOWMAP::NAME;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SHADOWMAP_NAME_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_SHADOWMAP_NAME_get) 

// js_ctor
static bool js_new_cc_pipeline_SHADOWMAP(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::SHADOWMAP *result;
    result = (cc::pipeline::SHADOWMAP *)new cc::pipeline::SHADOWMAP();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_SHADOWMAP, __jsb_cc_pipeline_SHADOWMAP_class, js_delete_cc_pipeline_SHADOWMAP)

static bool js_delete_cc_pipeline_SHADOWMAP(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_SHADOWMAP) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::SHADOWMAP * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::SHADOWMAP*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_SHADOWMAP(se::Object* obj) {
    auto* cls = se::Class::create("SHADOWMAP", obj, nullptr, _SE(js_new_cc_pipeline_SHADOWMAP)); 
    
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_SHADOWMAP_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_SHADOWMAP_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_SHADOWMAP_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_SHADOWMAP));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::SHADOWMAP>(cls);
    
    __jsb_cc_pipeline_SHADOWMAP_proto = cls->getProto();
    __jsb_cc_pipeline_SHADOWMAP_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_ENVIRONMENT_class = nullptr;
se::Object* __jsb_cc_pipeline_ENVIRONMENT_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_ENVIRONMENT) 

static bool js_cc_pipeline_ENVIRONMENT_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::ENVIRONMENT::DESCRIPTOR;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ENVIRONMENT_DESCRIPTOR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_ENVIRONMENT_DESCRIPTOR_get) 

static bool js_cc_pipeline_ENVIRONMENT_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture result;
    
    result = cc::pipeline::ENVIRONMENT::LAYOUT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ENVIRONMENT_LAYOUT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_ENVIRONMENT_LAYOUT_get) 

static bool js_cc_pipeline_ENVIRONMENT_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::ENVIRONMENT::NAME;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ENVIRONMENT_NAME_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_ENVIRONMENT_NAME_get) 

// js_ctor
static bool js_new_cc_pipeline_ENVIRONMENT(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::ENVIRONMENT *result;
    result = (cc::pipeline::ENVIRONMENT *)new cc::pipeline::ENVIRONMENT();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_ENVIRONMENT, __jsb_cc_pipeline_ENVIRONMENT_class, js_delete_cc_pipeline_ENVIRONMENT)

static bool js_delete_cc_pipeline_ENVIRONMENT(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_ENVIRONMENT) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::ENVIRONMENT * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::ENVIRONMENT*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_ENVIRONMENT(se::Object* obj) {
    auto* cls = se::Class::create("ENVIRONMENT", obj, nullptr, _SE(js_new_cc_pipeline_ENVIRONMENT)); 
    
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_ENVIRONMENT_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_ENVIRONMENT_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_ENVIRONMENT_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_ENVIRONMENT));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::ENVIRONMENT>(cls);
    
    __jsb_cc_pipeline_ENVIRONMENT_proto = cls->getProto();
    __jsb_cc_pipeline_ENVIRONMENT_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_SPOTSHADOWMAP_class = nullptr;
se::Object* __jsb_cc_pipeline_SPOTSHADOWMAP_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_SPOTSHADOWMAP) 

static bool js_cc_pipeline_SPOTSHADOWMAP_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::SPOTSHADOWMAP::DESCRIPTOR;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SPOTSHADOWMAP_DESCRIPTOR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_SPOTSHADOWMAP_DESCRIPTOR_get) 

static bool js_cc_pipeline_SPOTSHADOWMAP_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture result;
    
    result = cc::pipeline::SPOTSHADOWMAP::LAYOUT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SPOTSHADOWMAP_LAYOUT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_SPOTSHADOWMAP_LAYOUT_get) 

static bool js_cc_pipeline_SPOTSHADOWMAP_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::SPOTSHADOWMAP::NAME;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SPOTSHADOWMAP_NAME_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_SPOTSHADOWMAP_NAME_get) 

// js_ctor
static bool js_new_cc_pipeline_SPOTSHADOWMAP(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::SPOTSHADOWMAP *result;
    result = (cc::pipeline::SPOTSHADOWMAP *)new cc::pipeline::SPOTSHADOWMAP();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_SPOTSHADOWMAP, __jsb_cc_pipeline_SPOTSHADOWMAP_class, js_delete_cc_pipeline_SPOTSHADOWMAP)

static bool js_delete_cc_pipeline_SPOTSHADOWMAP(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_SPOTSHADOWMAP) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::SPOTSHADOWMAP * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::SPOTSHADOWMAP*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_SPOTSHADOWMAP(se::Object* obj) {
    auto* cls = se::Class::create("SPOTSHADOWMAP", obj, nullptr, _SE(js_new_cc_pipeline_SPOTSHADOWMAP)); 
    
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_SPOTSHADOWMAP_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_SPOTSHADOWMAP_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_SPOTSHADOWMAP_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_SPOTSHADOWMAP));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::SPOTSHADOWMAP>(cls);
    
    __jsb_cc_pipeline_SPOTSHADOWMAP_proto = cls->getProto();
    __jsb_cc_pipeline_SPOTSHADOWMAP_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_DIFFUSEMAP_class = nullptr;
se::Object* __jsb_cc_pipeline_DIFFUSEMAP_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_DIFFUSEMAP) 

static bool js_cc_pipeline_DIFFUSEMAP_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::DIFFUSEMAP::DESCRIPTOR;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DIFFUSEMAP_DESCRIPTOR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_DIFFUSEMAP_DESCRIPTOR_get) 

static bool js_cc_pipeline_DIFFUSEMAP_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture result;
    
    result = cc::pipeline::DIFFUSEMAP::LAYOUT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DIFFUSEMAP_LAYOUT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_DIFFUSEMAP_LAYOUT_get) 

static bool js_cc_pipeline_DIFFUSEMAP_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::DIFFUSEMAP::NAME;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DIFFUSEMAP_NAME_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_DIFFUSEMAP_NAME_get) 

// js_ctor
static bool js_new_cc_pipeline_DIFFUSEMAP(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::DIFFUSEMAP *result;
    result = (cc::pipeline::DIFFUSEMAP *)new cc::pipeline::DIFFUSEMAP();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_DIFFUSEMAP, __jsb_cc_pipeline_DIFFUSEMAP_class, js_delete_cc_pipeline_DIFFUSEMAP)

static bool js_delete_cc_pipeline_DIFFUSEMAP(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_DIFFUSEMAP) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::DIFFUSEMAP * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::DIFFUSEMAP*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_DIFFUSEMAP(se::Object* obj) {
    auto* cls = se::Class::create("DIFFUSEMAP", obj, nullptr, _SE(js_new_cc_pipeline_DIFFUSEMAP)); 
    
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_DIFFUSEMAP_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_DIFFUSEMAP_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_DIFFUSEMAP_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_DIFFUSEMAP));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::DIFFUSEMAP>(cls);
    
    __jsb_cc_pipeline_DIFFUSEMAP_proto = cls->getProto();
    __jsb_cc_pipeline_DIFFUSEMAP_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_JOINTTEXTURE_class = nullptr;
se::Object* __jsb_cc_pipeline_JOINTTEXTURE_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_JOINTTEXTURE) 

static bool js_cc_pipeline_JOINTTEXTURE_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::JOINTTEXTURE::DESCRIPTOR;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "JOINTTEXTURE_DESCRIPTOR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_JOINTTEXTURE_DESCRIPTOR_get) 

static bool js_cc_pipeline_JOINTTEXTURE_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture result;
    
    result = cc::pipeline::JOINTTEXTURE::LAYOUT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "JOINTTEXTURE_LAYOUT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_JOINTTEXTURE_LAYOUT_get) 

static bool js_cc_pipeline_JOINTTEXTURE_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::JOINTTEXTURE::NAME;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "JOINTTEXTURE_NAME_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_JOINTTEXTURE_NAME_get) 

// js_ctor
static bool js_new_cc_pipeline_JOINTTEXTURE(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::JOINTTEXTURE *result;
    result = (cc::pipeline::JOINTTEXTURE *)new cc::pipeline::JOINTTEXTURE();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_JOINTTEXTURE, __jsb_cc_pipeline_JOINTTEXTURE_class, js_delete_cc_pipeline_JOINTTEXTURE)

static bool js_delete_cc_pipeline_JOINTTEXTURE(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_JOINTTEXTURE) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::JOINTTEXTURE * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::JOINTTEXTURE*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_JOINTTEXTURE(se::Object* obj) {
    auto* cls = se::Class::create("JOINTTEXTURE", obj, nullptr, _SE(js_new_cc_pipeline_JOINTTEXTURE)); 
    
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_JOINTTEXTURE_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_JOINTTEXTURE_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_JOINTTEXTURE_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_JOINTTEXTURE));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::JOINTTEXTURE>(cls);
    
    __jsb_cc_pipeline_JOINTTEXTURE_proto = cls->getProto();
    __jsb_cc_pipeline_JOINTTEXTURE_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_REALTIMEJOINTTEXTURE_class = nullptr;
se::Object* __jsb_cc_pipeline_REALTIMEJOINTTEXTURE_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_REALTIMEJOINTTEXTURE) 

static bool js_cc_pipeline_REALTIMEJOINTTEXTURE_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::REALTIMEJOINTTEXTURE::DESCRIPTOR;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "REALTIMEJOINTTEXTURE_DESCRIPTOR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_REALTIMEJOINTTEXTURE_DESCRIPTOR_get) 

static bool js_cc_pipeline_REALTIMEJOINTTEXTURE_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture result;
    
    result = cc::pipeline::REALTIMEJOINTTEXTURE::LAYOUT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "REALTIMEJOINTTEXTURE_LAYOUT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_REALTIMEJOINTTEXTURE_LAYOUT_get) 

static bool js_cc_pipeline_REALTIMEJOINTTEXTURE_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::REALTIMEJOINTTEXTURE::NAME;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "REALTIMEJOINTTEXTURE_NAME_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_REALTIMEJOINTTEXTURE_NAME_get) 

// js_ctor
static bool js_new_cc_pipeline_REALTIMEJOINTTEXTURE(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::REALTIMEJOINTTEXTURE *result;
    result = (cc::pipeline::REALTIMEJOINTTEXTURE *)new cc::pipeline::REALTIMEJOINTTEXTURE();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_REALTIMEJOINTTEXTURE, __jsb_cc_pipeline_REALTIMEJOINTTEXTURE_class, js_delete_cc_pipeline_REALTIMEJOINTTEXTURE)

static bool js_delete_cc_pipeline_REALTIMEJOINTTEXTURE(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_REALTIMEJOINTTEXTURE) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::REALTIMEJOINTTEXTURE * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::REALTIMEJOINTTEXTURE*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_REALTIMEJOINTTEXTURE(se::Object* obj) {
    auto* cls = se::Class::create("REALTIMEJOINTTEXTURE", obj, nullptr, _SE(js_new_cc_pipeline_REALTIMEJOINTTEXTURE)); 
    
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_REALTIMEJOINTTEXTURE_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_REALTIMEJOINTTEXTURE_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_REALTIMEJOINTTEXTURE_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_REALTIMEJOINTTEXTURE));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::REALTIMEJOINTTEXTURE>(cls);
    
    __jsb_cc_pipeline_REALTIMEJOINTTEXTURE_proto = cls->getProto();
    __jsb_cc_pipeline_REALTIMEJOINTTEXTURE_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_POSITIONMORPH_class = nullptr;
se::Object* __jsb_cc_pipeline_POSITIONMORPH_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_POSITIONMORPH) 

static bool js_cc_pipeline_POSITIONMORPH_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::POSITIONMORPH::DESCRIPTOR;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "POSITIONMORPH_DESCRIPTOR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_POSITIONMORPH_DESCRIPTOR_get) 

static bool js_cc_pipeline_POSITIONMORPH_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture result;
    
    result = cc::pipeline::POSITIONMORPH::LAYOUT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "POSITIONMORPH_LAYOUT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_POSITIONMORPH_LAYOUT_get) 

static bool js_cc_pipeline_POSITIONMORPH_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::POSITIONMORPH::NAME;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "POSITIONMORPH_NAME_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_POSITIONMORPH_NAME_get) 

// js_ctor
static bool js_new_cc_pipeline_POSITIONMORPH(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::POSITIONMORPH *result;
    result = (cc::pipeline::POSITIONMORPH *)new cc::pipeline::POSITIONMORPH();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_POSITIONMORPH, __jsb_cc_pipeline_POSITIONMORPH_class, js_delete_cc_pipeline_POSITIONMORPH)

static bool js_delete_cc_pipeline_POSITIONMORPH(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_POSITIONMORPH) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::POSITIONMORPH * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::POSITIONMORPH*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_POSITIONMORPH(se::Object* obj) {
    auto* cls = se::Class::create("POSITIONMORPH", obj, nullptr, _SE(js_new_cc_pipeline_POSITIONMORPH)); 
    
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_POSITIONMORPH_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_POSITIONMORPH_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_POSITIONMORPH_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_POSITIONMORPH));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::POSITIONMORPH>(cls);
    
    __jsb_cc_pipeline_POSITIONMORPH_proto = cls->getProto();
    __jsb_cc_pipeline_POSITIONMORPH_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_NORMALMORPH_class = nullptr;
se::Object* __jsb_cc_pipeline_NORMALMORPH_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_NORMALMORPH) 

static bool js_cc_pipeline_NORMALMORPH_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::NORMALMORPH::DESCRIPTOR;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "NORMALMORPH_DESCRIPTOR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_NORMALMORPH_DESCRIPTOR_get) 

static bool js_cc_pipeline_NORMALMORPH_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture result;
    
    result = cc::pipeline::NORMALMORPH::LAYOUT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "NORMALMORPH_LAYOUT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_NORMALMORPH_LAYOUT_get) 

static bool js_cc_pipeline_NORMALMORPH_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::NORMALMORPH::NAME;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "NORMALMORPH_NAME_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_NORMALMORPH_NAME_get) 

// js_ctor
static bool js_new_cc_pipeline_NORMALMORPH(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::NORMALMORPH *result;
    result = (cc::pipeline::NORMALMORPH *)new cc::pipeline::NORMALMORPH();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_NORMALMORPH, __jsb_cc_pipeline_NORMALMORPH_class, js_delete_cc_pipeline_NORMALMORPH)

static bool js_delete_cc_pipeline_NORMALMORPH(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_NORMALMORPH) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::NORMALMORPH * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::NORMALMORPH*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_NORMALMORPH(se::Object* obj) {
    auto* cls = se::Class::create("NORMALMORPH", obj, nullptr, _SE(js_new_cc_pipeline_NORMALMORPH)); 
    
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_NORMALMORPH_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_NORMALMORPH_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_NORMALMORPH_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_NORMALMORPH));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::NORMALMORPH>(cls);
    
    __jsb_cc_pipeline_NORMALMORPH_proto = cls->getProto();
    __jsb_cc_pipeline_NORMALMORPH_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_TANGENTMORPH_class = nullptr;
se::Object* __jsb_cc_pipeline_TANGENTMORPH_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_TANGENTMORPH) 

static bool js_cc_pipeline_TANGENTMORPH_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::TANGENTMORPH::DESCRIPTOR;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TANGENTMORPH_DESCRIPTOR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_TANGENTMORPH_DESCRIPTOR_get) 

static bool js_cc_pipeline_TANGENTMORPH_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture result;
    
    result = cc::pipeline::TANGENTMORPH::LAYOUT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TANGENTMORPH_LAYOUT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_TANGENTMORPH_LAYOUT_get) 

static bool js_cc_pipeline_TANGENTMORPH_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::TANGENTMORPH::NAME;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "TANGENTMORPH_NAME_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_TANGENTMORPH_NAME_get) 

// js_ctor
static bool js_new_cc_pipeline_TANGENTMORPH(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::TANGENTMORPH *result;
    result = (cc::pipeline::TANGENTMORPH *)new cc::pipeline::TANGENTMORPH();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_TANGENTMORPH, __jsb_cc_pipeline_TANGENTMORPH_class, js_delete_cc_pipeline_TANGENTMORPH)

static bool js_delete_cc_pipeline_TANGENTMORPH(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_TANGENTMORPH) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::TANGENTMORPH * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::TANGENTMORPH*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_TANGENTMORPH(se::Object* obj) {
    auto* cls = se::Class::create("TANGENTMORPH", obj, nullptr, _SE(js_new_cc_pipeline_TANGENTMORPH)); 
    
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_TANGENTMORPH_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_TANGENTMORPH_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_TANGENTMORPH_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_TANGENTMORPH));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::TANGENTMORPH>(cls);
    
    __jsb_cc_pipeline_TANGENTMORPH_proto = cls->getProto();
    __jsb_cc_pipeline_TANGENTMORPH_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_LIGHTMAPTEXTURE_class = nullptr;
se::Object* __jsb_cc_pipeline_LIGHTMAPTEXTURE_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_LIGHTMAPTEXTURE) 

static bool js_cc_pipeline_LIGHTMAPTEXTURE_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::LIGHTMAPTEXTURE::DESCRIPTOR;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "LIGHTMAPTEXTURE_DESCRIPTOR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_LIGHTMAPTEXTURE_DESCRIPTOR_get) 

static bool js_cc_pipeline_LIGHTMAPTEXTURE_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture result;
    
    result = cc::pipeline::LIGHTMAPTEXTURE::LAYOUT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "LIGHTMAPTEXTURE_LAYOUT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_LIGHTMAPTEXTURE_LAYOUT_get) 

static bool js_cc_pipeline_LIGHTMAPTEXTURE_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::LIGHTMAPTEXTURE::NAME;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "LIGHTMAPTEXTURE_NAME_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_LIGHTMAPTEXTURE_NAME_get) 

// js_ctor
static bool js_new_cc_pipeline_LIGHTMAPTEXTURE(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::LIGHTMAPTEXTURE *result;
    result = (cc::pipeline::LIGHTMAPTEXTURE *)new cc::pipeline::LIGHTMAPTEXTURE();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_LIGHTMAPTEXTURE, __jsb_cc_pipeline_LIGHTMAPTEXTURE_class, js_delete_cc_pipeline_LIGHTMAPTEXTURE)

static bool js_delete_cc_pipeline_LIGHTMAPTEXTURE(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_LIGHTMAPTEXTURE) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::LIGHTMAPTEXTURE * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::LIGHTMAPTEXTURE*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_LIGHTMAPTEXTURE(se::Object* obj) {
    auto* cls = se::Class::create("LIGHTMAPTEXTURE", obj, nullptr, _SE(js_new_cc_pipeline_LIGHTMAPTEXTURE)); 
    
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_LIGHTMAPTEXTURE_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_LIGHTMAPTEXTURE_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_LIGHTMAPTEXTURE_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_LIGHTMAPTEXTURE));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::LIGHTMAPTEXTURE>(cls);
    
    __jsb_cc_pipeline_LIGHTMAPTEXTURE_proto = cls->getProto();
    __jsb_cc_pipeline_LIGHTMAPTEXTURE_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_SPRITETEXTURE_class = nullptr;
se::Object* __jsb_cc_pipeline_SPRITETEXTURE_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_SPRITETEXTURE) 

static bool js_cc_pipeline_SPRITETEXTURE_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::SPRITETEXTURE::DESCRIPTOR;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SPRITETEXTURE_DESCRIPTOR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_SPRITETEXTURE_DESCRIPTOR_get) 

static bool js_cc_pipeline_SPRITETEXTURE_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture result;
    
    result = cc::pipeline::SPRITETEXTURE::LAYOUT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SPRITETEXTURE_LAYOUT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_SPRITETEXTURE_LAYOUT_get) 

static bool js_cc_pipeline_SPRITETEXTURE_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::SPRITETEXTURE::NAME;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SPRITETEXTURE_NAME_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_SPRITETEXTURE_NAME_get) 

// js_ctor
static bool js_new_cc_pipeline_SPRITETEXTURE(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::SPRITETEXTURE *result;
    result = (cc::pipeline::SPRITETEXTURE *)new cc::pipeline::SPRITETEXTURE();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_SPRITETEXTURE, __jsb_cc_pipeline_SPRITETEXTURE_class, js_delete_cc_pipeline_SPRITETEXTURE)

static bool js_delete_cc_pipeline_SPRITETEXTURE(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_SPRITETEXTURE) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::SPRITETEXTURE * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::SPRITETEXTURE*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_SPRITETEXTURE(se::Object* obj) {
    auto* cls = se::Class::create("SPRITETEXTURE", obj, nullptr, _SE(js_new_cc_pipeline_SPRITETEXTURE)); 
    
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_SPRITETEXTURE_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_SPRITETEXTURE_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_SPRITETEXTURE_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_SPRITETEXTURE));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::SPRITETEXTURE>(cls);
    
    __jsb_cc_pipeline_SPRITETEXTURE_proto = cls->getProto();
    __jsb_cc_pipeline_SPRITETEXTURE_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_REFLECTIONTEXTURE_class = nullptr;
se::Object* __jsb_cc_pipeline_REFLECTIONTEXTURE_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_REFLECTIONTEXTURE) 

static bool js_cc_pipeline_REFLECTIONTEXTURE_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::REFLECTIONTEXTURE::DESCRIPTOR;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "REFLECTIONTEXTURE_DESCRIPTOR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_REFLECTIONTEXTURE_DESCRIPTOR_get) 

static bool js_cc_pipeline_REFLECTIONTEXTURE_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture result;
    
    result = cc::pipeline::REFLECTIONTEXTURE::LAYOUT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "REFLECTIONTEXTURE_LAYOUT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_REFLECTIONTEXTURE_LAYOUT_get) 

static bool js_cc_pipeline_REFLECTIONTEXTURE_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::REFLECTIONTEXTURE::NAME;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "REFLECTIONTEXTURE_NAME_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_REFLECTIONTEXTURE_NAME_get) 

// js_ctor
static bool js_new_cc_pipeline_REFLECTIONTEXTURE(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::REFLECTIONTEXTURE *result;
    result = (cc::pipeline::REFLECTIONTEXTURE *)new cc::pipeline::REFLECTIONTEXTURE();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_REFLECTIONTEXTURE, __jsb_cc_pipeline_REFLECTIONTEXTURE_class, js_delete_cc_pipeline_REFLECTIONTEXTURE)

static bool js_delete_cc_pipeline_REFLECTIONTEXTURE(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_REFLECTIONTEXTURE) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::REFLECTIONTEXTURE * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::REFLECTIONTEXTURE*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_REFLECTIONTEXTURE(se::Object* obj) {
    auto* cls = se::Class::create("REFLECTIONTEXTURE", obj, nullptr, _SE(js_new_cc_pipeline_REFLECTIONTEXTURE)); 
    
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_REFLECTIONTEXTURE_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_REFLECTIONTEXTURE_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_REFLECTIONTEXTURE_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_REFLECTIONTEXTURE));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::REFLECTIONTEXTURE>(cls);
    
    __jsb_cc_pipeline_REFLECTIONTEXTURE_proto = cls->getProto();
    __jsb_cc_pipeline_REFLECTIONTEXTURE_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_REFLECTIONSTORAGE_class = nullptr;
se::Object* __jsb_cc_pipeline_REFLECTIONSTORAGE_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_REFLECTIONSTORAGE) 

static bool js_cc_pipeline_REFLECTIONSTORAGE_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::REFLECTIONSTORAGE::DESCRIPTOR;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "REFLECTIONSTORAGE_DESCRIPTOR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_REFLECTIONSTORAGE_DESCRIPTOR_get) 

static bool js_cc_pipeline_REFLECTIONSTORAGE_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformStorageImage result;
    
    result = cc::pipeline::REFLECTIONSTORAGE::LAYOUT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "REFLECTIONSTORAGE_LAYOUT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_REFLECTIONSTORAGE_LAYOUT_get) 

static bool js_cc_pipeline_REFLECTIONSTORAGE_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::REFLECTIONSTORAGE::NAME;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "REFLECTIONSTORAGE_NAME_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_REFLECTIONSTORAGE_NAME_get) 

// js_ctor
static bool js_new_cc_pipeline_REFLECTIONSTORAGE(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::REFLECTIONSTORAGE *result;
    result = (cc::pipeline::REFLECTIONSTORAGE *)new cc::pipeline::REFLECTIONSTORAGE();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_REFLECTIONSTORAGE, __jsb_cc_pipeline_REFLECTIONSTORAGE_class, js_delete_cc_pipeline_REFLECTIONSTORAGE)

static bool js_delete_cc_pipeline_REFLECTIONSTORAGE(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_REFLECTIONSTORAGE) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::REFLECTIONSTORAGE * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::REFLECTIONSTORAGE*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_REFLECTIONSTORAGE(se::Object* obj) {
    auto* cls = se::Class::create("REFLECTIONSTORAGE", obj, nullptr, _SE(js_new_cc_pipeline_REFLECTIONSTORAGE)); 
    
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_REFLECTIONSTORAGE_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_REFLECTIONSTORAGE_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_REFLECTIONSTORAGE_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_REFLECTIONSTORAGE));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::REFLECTIONSTORAGE>(cls);
    
    __jsb_cc_pipeline_REFLECTIONSTORAGE_proto = cls->getProto();
    __jsb_cc_pipeline_REFLECTIONSTORAGE_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_RenderPipelineInfo_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderPipelineInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderPipelineInfo) 

static bool js_cc_pipeline_RenderPipelineInfo_tag_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipelineInfo *arg1 = (cc::pipeline::RenderPipelineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipelineInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->tag, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPipelineInfo_tag_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPipelineInfo_tag_set) 

static bool js_cc_pipeline_RenderPipelineInfo_tag_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPipelineInfo *arg1 = (cc::pipeline::RenderPipelineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipelineInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->tag, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPipelineInfo_tag_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->tag, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPipelineInfo_tag_get) 

static bool js_cc_pipeline_RenderPipelineInfo_flows_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipelineInfo *arg1 = (cc::pipeline::RenderPipelineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipelineInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->flows, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPipelineInfo_flows_set,2,SWIGTYPE_ccstd__vectorT_cc__IntrusivePtrT_cc__pipeline__RenderFlow_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPipelineInfo_flows_set) 

static bool js_cc_pipeline_RenderPipelineInfo_flows_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPipelineInfo *arg1 = (cc::pipeline::RenderPipelineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipelineInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->flows, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPipelineInfo_flows_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->flows, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPipelineInfo_flows_get) 

// js_ctor
static bool js_new_cc_pipeline_RenderPipelineInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::RenderPipelineInfo *result;
    result = (cc::pipeline::RenderPipelineInfo *)new cc::pipeline::RenderPipelineInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_RenderPipelineInfo, __jsb_cc_pipeline_RenderPipelineInfo_class, js_delete_cc_pipeline_RenderPipelineInfo)

static bool js_delete_cc_pipeline_RenderPipelineInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderPipelineInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::RenderPipelineInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::RenderPipelineInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("tag", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->tag), ctx);
    }
    
    
    json->getProperty("flows", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->flows), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_RenderPipelineInfo(se::Object* obj) {
    auto* cls = se::Class::create("RenderPipelineInfo", obj, nullptr, _SE(js_new_cc_pipeline_RenderPipelineInfo)); 
    
    cls->defineProperty("tag", _SE(js_cc_pipeline_RenderPipelineInfo_tag_get), _SE(js_cc_pipeline_RenderPipelineInfo_tag_set)); 
    cls->defineProperty("flows", _SE(js_cc_pipeline_RenderPipelineInfo_flows_get), _SE(js_cc_pipeline_RenderPipelineInfo_flows_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderPipelineInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderPipelineInfo>(cls);
    
    __jsb_cc_pipeline_RenderPipelineInfo_proto = cls->getProto();
    __jsb_cc_pipeline_RenderPipelineInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_RenderPipeline_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderPipeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderPipeline) 

static bool js_cc_pipeline_RenderPipeline_getInstance_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::pipeline::RenderPipeline *)cc::pipeline::RenderPipeline::getInstance();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPipeline_getInstance, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getInstance_static) 

static bool js_cc_pipeline_RenderPipeline_getRenderArea_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::gfx::Rect result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPipeline_getRenderArea,1,SWIGTYPE_p_cc__scene__Camera"); 
    result = cc::pipeline::RenderPipeline::getRenderArea(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPipeline_getRenderArea, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getRenderArea_static) 

// js_ctor
static bool js_new_cc_pipeline_RenderPipeline(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::RenderPipeline *result;
    result = (cc::pipeline::RenderPipeline *)new cc::pipeline::RenderPipeline();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_RenderPipeline, __jsb_cc_pipeline_RenderPipeline_class, js_delete_cc_pipeline_RenderPipeline)

static bool js_delete_cc_pipeline_RenderPipeline(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderPipeline) 

static bool js_cc_pipeline_RenderPipeline_activate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::gfx::Swapchain *arg2 = (cc::gfx::Swapchain *) NULL ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPipeline_activate,2,SWIGTYPE_p_cc__gfx__Swapchain"); 
    result = (bool)(arg1)->activate(arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_activate) 

static bool js_cc_pipeline_RenderPipeline_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->destroy();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_destroy) 

static bool js_cc_pipeline_RenderPipeline_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::pipeline::RenderPipelineInfo *arg2 = 0 ;
    cc::pipeline::RenderPipelineInfo temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPipeline_initialize,2,SWIGTYPE_p_cc__pipeline__RenderPipelineInfo");
    arg2 = &temp2;
    
    result = (bool)(arg1)->initialize((cc::pipeline::RenderPipelineInfo const &)*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_initialize) 

static bool js_cc_pipeline_RenderPipeline_render(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    ccstd::vector< cc::scene::Camera * > *arg2 = 0 ;
    ccstd::vector< cc::scene::Camera * > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPipeline_render,2,SWIGTYPE_p_ccstd__vectorT_cc__scene__Camera_p_t");
    arg2 = &temp2;
    
    (arg1)->render((ccstd::vector< cc::scene::Camera * > const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_render) 

static bool js_cc_pipeline_RenderPipeline_onGlobalPipelineStateChanged(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onGlobalPipelineStateChanged();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_onGlobalPipelineStateChanged) 

static bool js_cc_pipeline_RenderPipeline_getFlows(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::pipeline::RenderFlowList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::pipeline::RenderFlowList *) &((cc::pipeline::RenderPipeline const *)arg1)->getFlows();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPipeline_getFlows, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getFlows) 

static bool js_cc_pipeline_RenderPipeline_getTag(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::pipeline::RenderPipeline const *)arg1)->getTag();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPipeline_getTag, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getTag) 

static bool js_cc_pipeline_RenderPipeline_getGlobalBindings(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    ccstd::unordered_map< ccstd::string,cc::pipeline::InternalBindingInst > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::unordered_map< ccstd::string,cc::pipeline::InternalBindingInst > *) &((cc::pipeline::RenderPipeline const *)arg1)->getGlobalBindings();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPipeline_getGlobalBindings, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getGlobalBindings) 

static bool js_cc_pipeline_RenderPipeline_getMacros(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::MacroRecord *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::MacroRecord *) &((cc::pipeline::RenderPipeline const *)arg1)->getMacros();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPipeline_getMacros, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getMacros) 

static bool js_cc_pipeline_RenderPipeline_setValue__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    ccstd::string *arg2 = 0 ;
    int32_t arg3 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPipeline_setValue,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPipeline_setValue,3,SWIGTYPE_int32_t"); 
    
    (arg1)->setValue((ccstd::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_pipeline_RenderPipeline_setValue__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    ccstd::string *arg2 = 0 ;
    bool arg3 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPipeline_setValue,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "RenderPipeline_setValue,3,SWIGTYPE_bool"); 
    (arg1)->setValue((ccstd::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_pipeline_RenderPipeline_setValue__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string *arg3 = 0 ;
    ccstd::string temp2 ;
    ccstd::string temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPipeline_setValue,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPipeline_setValue,3,SWIGTYPE_p_ccstd__string");
    arg3 = &temp3;
    
    (arg1)->setValue((ccstd::string const &)*arg2,(ccstd::string const &)*arg3);
    
    
    return true;
}

static bool js_cc_pipeline_RenderPipeline_setValue(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_pipeline_RenderPipeline_setValue__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_pipeline_RenderPipeline_setValue__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_pipeline_RenderPipeline_setValue__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_setValue) 

static bool js_cc_pipeline_RenderPipeline_getCommandBuffers(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::gfx::CommandBufferList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::CommandBufferList *) &((cc::pipeline::RenderPipeline const *)arg1)->getCommandBuffers();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPipeline_getCommandBuffers, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getCommandBuffers) 

static bool js_cc_pipeline_RenderPipeline_getQueryPools(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::gfx::QueryPoolList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::QueryPoolList *) &((cc::pipeline::RenderPipeline const *)arg1)->getQueryPools();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPipeline_getQueryPools, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getQueryPools) 

static bool js_cc_pipeline_RenderPipeline_getPipelineUBO(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::pipeline::PipelineUBO *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::pipeline::PipelineUBO *)((cc::pipeline::RenderPipeline const *)arg1)->getPipelineUBO();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPipeline_getPipelineUBO, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getPipelineUBO) 

static bool js_cc_pipeline_RenderPipeline_getDevice(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::gfx::Device *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Device *)((cc::pipeline::RenderPipeline const *)arg1)->getDevice();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPipeline_getDevice, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getDevice) 

static bool js_cc_pipeline_RenderPipeline_getRenderstageByName(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    cc::pipeline::RenderStage *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPipeline_getRenderstageByName,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = (cc::pipeline::RenderStage *)((cc::pipeline::RenderPipeline const *)arg1)->getRenderstageByName((ccstd::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPipeline_getRenderstageByName, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getRenderstageByName) 

static bool js_cc_pipeline_RenderPipeline_isOccluded(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    cc::scene::SubModel *arg3 = (cc::scene::SubModel *) NULL ;
    bool result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPipeline_isOccluded,2,SWIGTYPE_p_cc__scene__Camera"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPipeline_isOccluded,3,SWIGTYPE_p_cc__scene__SubModel"); 
    result = (bool)(arg1)->isOccluded((cc::scene::Camera const *)arg2,(cc::scene::SubModel const *)arg3);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_isOccluded) 

static bool js_cc_pipeline_RenderPipeline_isOcclusionQueryEnabled(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((cc::pipeline::RenderPipeline const *)arg1)->isOcclusionQueryEnabled();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_isOcclusionQueryEnabled) 

static bool js_cc_pipeline_RenderPipeline_setOcclusionQueryEnabled(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "RenderPipeline_setOcclusionQueryEnabled,2,SWIGTYPE_bool"); 
    (arg1)->setOcclusionQueryEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_setOcclusionQueryEnabled) 

static bool js_cc_pipeline_RenderPipeline_isEnvmapEnabled(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((cc::pipeline::RenderPipeline const *)arg1)->isEnvmapEnabled();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_isEnvmapEnabled) 

static bool js_cc_pipeline_RenderPipeline_getViewport(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    cc::gfx::Viewport result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPipeline_getViewport,2,SWIGTYPE_p_cc__scene__Camera"); 
    result = (arg1)->getViewport(arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPipeline_getViewport, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getViewport) 

static bool js_cc_pipeline_RenderPipeline_getScissor(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    cc::gfx::Rect result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPipeline_getScissor,2,SWIGTYPE_p_cc__scene__Camera"); 
    result = (arg1)->getScissor(arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPipeline_getScissor, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getScissor) 

static bool js_cc_pipeline_RenderPipeline_genQuadVertexData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::Vec4 *arg2 = 0 ;
    float *arg3 = (float *) NULL ;
    cc::Vec4 temp2 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPipeline_genQuadVertexData,2,SWIGTYPE_p_cc__Vec4");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPipeline_genQuadVertexData,3,SWIGTYPE_p_float"); 
    (arg1)->genQuadVertexData((cc::Vec4 const &)*arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_genQuadVertexData) 

static bool js_cc_pipeline_RenderPipeline_getWidth(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::pipeline::RenderPipeline const *)arg1)->getWidth();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPipeline_getWidth, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getWidth) 

static bool js_cc_pipeline_RenderPipeline_getHeight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::pipeline::RenderPipeline const *)arg1)->getHeight();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPipeline_getHeight, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getHeight) 

static bool js_cc_pipeline_RenderPipeline_getClearcolor(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    cc::gfx::Color result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPipeline_getClearcolor,2,SWIGTYPE_p_cc__scene__Camera"); 
    result = ((cc::pipeline::RenderPipeline const *)arg1)->getClearcolor(arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPipeline_getClearcolor, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getClearcolor) 

static bool js_cc_pipeline_RenderPipeline_getIAByRenderArea(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::gfx::Rect *arg2 = 0 ;
    cc::gfx::Rect temp2 ;
    cc::gfx::InputAssembler *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPipeline_getIAByRenderArea,2,SWIGTYPE_p_cc__gfx__Rect");
    arg2 = &temp2;
    
    result = (cc::gfx::InputAssembler *)(arg1)->getIAByRenderArea((cc::gfx::Rect const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPipeline_getIAByRenderArea, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getIAByRenderArea) 

static bool js_cc_pipeline_RenderPipeline_updateQuadVertexData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::Vec4 *arg2 = 0 ;
    cc::gfx::Buffer *arg3 = (cc::gfx::Buffer *) NULL ;
    cc::Vec4 temp2 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPipeline_updateQuadVertexData,2,SWIGTYPE_p_cc__Vec4");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPipeline_updateQuadVertexData,3,SWIGTYPE_p_cc__gfx__Buffer"); 
    (arg1)->updateQuadVertexData((cc::Vec4 const &)*arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_updateQuadVertexData) 

static bool js_cc_pipeline_RenderPipeline_ensureEnoughSize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    ccstd::vector< cc::scene::Camera * > *arg2 = 0 ;
    ccstd::vector< cc::scene::Camera * > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPipeline_ensureEnoughSize,2,SWIGTYPE_p_ccstd__vectorT_cc__scene__Camera_p_t");
    arg2 = &temp2;
    
    (arg1)->ensureEnoughSize((ccstd::vector< cc::scene::Camera * > const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_ensureEnoughSize) 

static bool js_cc_pipeline_RenderPipeline_createQuadInputAssembler(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::gfx::Buffer *arg2 = (cc::gfx::Buffer *) NULL ;
    cc::gfx::Buffer **arg3 = (cc::gfx::Buffer **) NULL ;
    cc::gfx::InputAssembler **arg4 = (cc::gfx::InputAssembler **) NULL ;
    bool result;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPipeline_createQuadInputAssembler,2,SWIGTYPE_p_cc__gfx__Buffer"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPipeline_createQuadInputAssembler,3,SWIGTYPE_p_p_cc__gfx__Buffer"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPipeline_createQuadInputAssembler,4,SWIGTYPE_p_p_cc__gfx__InputAssembler"); 
    result = (bool)(arg1)->createQuadInputAssembler(arg2,arg3,arg4);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_createQuadInputAssembler) 

static bool js_cc_pipeline_RenderPipeline_globalDSManager_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::pipeline::GlobalDSManager *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::pipeline::GlobalDSManager *)cc_pipeline_RenderPipeline_globalDSManager_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPipeline_globalDSManager_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPipeline_globalDSManager_get) 

static bool js_cc_pipeline_RenderPipeline_descriptorSet_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::gfx::DescriptorSet *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::DescriptorSet *)cc_pipeline_RenderPipeline_descriptorSet_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPipeline_descriptorSet_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPipeline_descriptorSet_get) 

static bool js_cc_pipeline_RenderPipeline_descriptorSetLayout_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::gfx::DescriptorSetLayout *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::DescriptorSetLayout *)cc_pipeline_RenderPipeline_descriptorSetLayout_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPipeline_descriptorSetLayout_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPipeline_descriptorSetLayout_get) 

static bool js_cc_pipeline_RenderPipeline_constantMacros_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    ccstd::string *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::string *) &cc_pipeline_RenderPipeline_constantMacros_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPipeline_constantMacros_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPipeline_constantMacros_get) 

static bool js_cc_pipeline_RenderPipeline_clusterEnabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "RenderPipeline_clusterEnabled_set,2,SWIGTYPE_bool"); 
    cc_pipeline_RenderPipeline_clusterEnabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPipeline_clusterEnabled_set) 

static bool js_cc_pipeline_RenderPipeline_clusterEnabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_pipeline_RenderPipeline_clusterEnabled_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPipeline_clusterEnabled_get) 

static bool js_cc_pipeline_RenderPipeline_bloomEnabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "RenderPipeline_bloomEnabled_set,2,SWIGTYPE_bool"); 
    cc_pipeline_RenderPipeline_bloomEnabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPipeline_bloomEnabled_set) 

static bool js_cc_pipeline_RenderPipeline_bloomEnabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_pipeline_RenderPipeline_bloomEnabled_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPipeline_bloomEnabled_get) 

static bool js_cc_pipeline_RenderPipeline_pipelineSceneData_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::pipeline::PipelineSceneData *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::pipeline::PipelineSceneData *)cc_pipeline_RenderPipeline_pipelineSceneData_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPipeline_pipelineSceneData_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPipeline_pipelineSceneData_get) 

static bool js_cc_pipeline_RenderPipeline_geometryRenderer_get(se::State& s)
{
#if CC_USE_GEOMETRY_RENDERER
    
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::pipeline::GeometryRenderer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::pipeline::GeometryRenderer *)cc_pipeline_RenderPipeline_geometryRenderer_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPipeline_geometryRenderer_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
#endif // CC_USE_GEOMETRY_RENDERER
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPipeline_geometryRenderer_get) 

static bool js_cc_pipeline_RenderPipeline_profiler_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::scene::Model *arg2 = (cc::scene::Model *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderPipeline_profiler_set,2,SWIGTYPE_p_cc__scene__Model"); 
    cc_pipeline_RenderPipeline_profiler_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPipeline_profiler_set) 

static bool js_cc_pipeline_RenderPipeline_profiler_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::scene::Model *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::Model *)cc_pipeline_RenderPipeline_profiler_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderPipeline_profiler_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPipeline_profiler_get) 

static bool js_cc_pipeline_RenderPipeline_shadingScale_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "RenderPipeline_shadingScale_set,2,SWIGTYPE_float"); 
    cc_pipeline_RenderPipeline_shadingScale_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPipeline_shadingScale_set) 

static bool js_cc_pipeline_RenderPipeline_shadingScale_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_pipeline_RenderPipeline_shadingScale_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPipeline_shadingScale_get) 

bool js_register_cc_pipeline_RenderPipeline(se::Object* obj) {
    auto* cls = se::Class::create("RenderPipeline", obj, nullptr, _SE(js_new_cc_pipeline_RenderPipeline)); 
    
    cls->defineProperty("globalDSManager", _SE(js_cc_pipeline_RenderPipeline_globalDSManager_get), nullptr); 
    cls->defineProperty("descriptorSet", _SE(js_cc_pipeline_RenderPipeline_descriptorSet_get), nullptr); 
    cls->defineProperty("descriptorSetLayout", _SE(js_cc_pipeline_RenderPipeline_descriptorSetLayout_get), nullptr); 
    cls->defineProperty("constantMacros", _SE(js_cc_pipeline_RenderPipeline_constantMacros_get), nullptr); 
    cls->defineProperty("clusterEnabled", _SE(js_cc_pipeline_RenderPipeline_clusterEnabled_get), _SE(js_cc_pipeline_RenderPipeline_clusterEnabled_set)); 
    cls->defineProperty("bloomEnabled", _SE(js_cc_pipeline_RenderPipeline_bloomEnabled_get), _SE(js_cc_pipeline_RenderPipeline_bloomEnabled_set)); 
    cls->defineProperty("pipelineSceneData", _SE(js_cc_pipeline_RenderPipeline_pipelineSceneData_get), nullptr); 
    cls->defineProperty("geometryRenderer", _SE(js_cc_pipeline_RenderPipeline_geometryRenderer_get), nullptr); 
    cls->defineProperty("profiler", _SE(js_cc_pipeline_RenderPipeline_profiler_get), _SE(js_cc_pipeline_RenderPipeline_profiler_set)); 
    cls->defineProperty("shadingScale", _SE(js_cc_pipeline_RenderPipeline_shadingScale_get), _SE(js_cc_pipeline_RenderPipeline_shadingScale_set)); 
    
    cls->defineFunction("activate", _SE(js_cc_pipeline_RenderPipeline_activate)); 
    cls->defineFunction("destroy", _SE(js_cc_pipeline_RenderPipeline_destroy)); 
    cls->defineFunction("initialize", _SE(js_cc_pipeline_RenderPipeline_initialize)); 
    cls->defineFunction("render", _SE(js_cc_pipeline_RenderPipeline_render)); 
    cls->defineFunction("onGlobalPipelineStateChanged", _SE(js_cc_pipeline_RenderPipeline_onGlobalPipelineStateChanged)); 
    cls->defineFunction("getFlows", _SE(js_cc_pipeline_RenderPipeline_getFlows)); 
    cls->defineFunction("getTag", _SE(js_cc_pipeline_RenderPipeline_getTag)); 
    cls->defineFunction("getGlobalBindings", _SE(js_cc_pipeline_RenderPipeline_getGlobalBindings)); 
    cls->defineFunction("getMacros", _SE(js_cc_pipeline_RenderPipeline_getMacros)); 
    cls->defineFunction("setValue", _SE(js_cc_pipeline_RenderPipeline_setValue)); 
    cls->defineFunction("getCommandBuffers", _SE(js_cc_pipeline_RenderPipeline_getCommandBuffers)); 
    cls->defineFunction("getQueryPools", _SE(js_cc_pipeline_RenderPipeline_getQueryPools)); 
    cls->defineFunction("getPipelineUBO", _SE(js_cc_pipeline_RenderPipeline_getPipelineUBO)); 
    cls->defineFunction("getDevice", _SE(js_cc_pipeline_RenderPipeline_getDevice)); 
    cls->defineFunction("getRenderstageByName", _SE(js_cc_pipeline_RenderPipeline_getRenderstageByName)); 
    cls->defineFunction("isOccluded", _SE(js_cc_pipeline_RenderPipeline_isOccluded)); 
    cls->defineFunction("isOcclusionQueryEnabled", _SE(js_cc_pipeline_RenderPipeline_isOcclusionQueryEnabled)); 
    cls->defineFunction("setOcclusionQueryEnabled", _SE(js_cc_pipeline_RenderPipeline_setOcclusionQueryEnabled)); 
    cls->defineFunction("isEnvmapEnabled", _SE(js_cc_pipeline_RenderPipeline_isEnvmapEnabled)); 
    cls->defineFunction("getViewport", _SE(js_cc_pipeline_RenderPipeline_getViewport)); 
    cls->defineFunction("getScissor", _SE(js_cc_pipeline_RenderPipeline_getScissor)); 
    cls->defineFunction("genQuadVertexData", _SE(js_cc_pipeline_RenderPipeline_genQuadVertexData)); 
    cls->defineFunction("getWidth", _SE(js_cc_pipeline_RenderPipeline_getWidth)); 
    cls->defineFunction("getHeight", _SE(js_cc_pipeline_RenderPipeline_getHeight)); 
    cls->defineFunction("getClearcolor", _SE(js_cc_pipeline_RenderPipeline_getClearcolor)); 
    cls->defineFunction("getIAByRenderArea", _SE(js_cc_pipeline_RenderPipeline_getIAByRenderArea)); 
    cls->defineFunction("updateQuadVertexData", _SE(js_cc_pipeline_RenderPipeline_updateQuadVertexData)); 
    cls->defineFunction("ensureEnoughSize", _SE(js_cc_pipeline_RenderPipeline_ensureEnoughSize)); 
    cls->defineFunction("createQuadInputAssembler", _SE(js_cc_pipeline_RenderPipeline_createQuadInputAssembler)); 
    
    
    cls->defineStaticFunction("getInstance", _SE(js_cc_pipeline_RenderPipeline_getInstance_static)); 
    cls->defineStaticFunction("getRenderArea", _SE(js_cc_pipeline_RenderPipeline_getRenderArea_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderPipeline));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderPipeline>(cls);
    
    __jsb_cc_pipeline_RenderPipeline_proto = cls->getProto();
    __jsb_cc_pipeline_RenderPipeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_RenderFlowInfo_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderFlowInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderFlowInfo) 

static bool js_cc_pipeline_RenderFlowInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlowInfo *arg1 = (cc::pipeline::RenderFlowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlowInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderFlowInfo_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderFlowInfo_name_set) 

static bool js_cc_pipeline_RenderFlowInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderFlowInfo *arg1 = (cc::pipeline::RenderFlowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlowInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderFlowInfo_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderFlowInfo_name_get) 

static bool js_cc_pipeline_RenderFlowInfo_priority_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlowInfo *arg1 = (cc::pipeline::RenderFlowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlowInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->priority, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderFlowInfo_priority_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderFlowInfo_priority_set) 

static bool js_cc_pipeline_RenderFlowInfo_priority_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderFlowInfo *arg1 = (cc::pipeline::RenderFlowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlowInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->priority, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderFlowInfo_priority_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->priority, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderFlowInfo_priority_get) 

static bool js_cc_pipeline_RenderFlowInfo_tag_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlowInfo *arg1 = (cc::pipeline::RenderFlowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlowInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->tag, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderFlowInfo_tag_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderFlowInfo_tag_set) 

static bool js_cc_pipeline_RenderFlowInfo_tag_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderFlowInfo *arg1 = (cc::pipeline::RenderFlowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlowInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->tag, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderFlowInfo_tag_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->tag, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderFlowInfo_tag_get) 

static bool js_cc_pipeline_RenderFlowInfo_stages_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlowInfo *arg1 = (cc::pipeline::RenderFlowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlowInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stages, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderFlowInfo_stages_set,2,SWIGTYPE_ccstd__vectorT_cc__IntrusivePtrT_cc__pipeline__RenderStage_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderFlowInfo_stages_set) 

static bool js_cc_pipeline_RenderFlowInfo_stages_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderFlowInfo *arg1 = (cc::pipeline::RenderFlowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlowInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stages, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderFlowInfo_stages_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stages, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderFlowInfo_stages_get) 

// js_ctor
static bool js_new_cc_pipeline_RenderFlowInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::RenderFlowInfo *result;
    result = (cc::pipeline::RenderFlowInfo *)new cc::pipeline::RenderFlowInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_RenderFlowInfo, __jsb_cc_pipeline_RenderFlowInfo_class, js_delete_cc_pipeline_RenderFlowInfo)

static bool js_delete_cc_pipeline_RenderFlowInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderFlowInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::RenderFlowInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::RenderFlowInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("priority", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->priority), ctx);
    }
    
    
    json->getProperty("tag", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->tag), ctx);
    }
    
    
    json->getProperty("stages", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stages), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_RenderFlowInfo(se::Object* obj) {
    auto* cls = se::Class::create("RenderFlowInfo", obj, nullptr, _SE(js_new_cc_pipeline_RenderFlowInfo)); 
    
    cls->defineProperty("name", _SE(js_cc_pipeline_RenderFlowInfo_name_get), _SE(js_cc_pipeline_RenderFlowInfo_name_set)); 
    cls->defineProperty("priority", _SE(js_cc_pipeline_RenderFlowInfo_priority_get), _SE(js_cc_pipeline_RenderFlowInfo_priority_set)); 
    cls->defineProperty("tag", _SE(js_cc_pipeline_RenderFlowInfo_tag_get), _SE(js_cc_pipeline_RenderFlowInfo_tag_set)); 
    cls->defineProperty("stages", _SE(js_cc_pipeline_RenderFlowInfo_stages_get), _SE(js_cc_pipeline_RenderFlowInfo_stages_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderFlowInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderFlowInfo>(cls);
    
    __jsb_cc_pipeline_RenderFlowInfo_proto = cls->getProto();
    __jsb_cc_pipeline_RenderFlowInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_RenderFlow_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderFlow_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderFlow) 

// js_ctor
static bool js_new_cc_pipeline_RenderFlow(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::RenderFlow *result;
    result = (cc::pipeline::RenderFlow *)new cc::pipeline::RenderFlow();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_RenderFlow, __jsb_cc_pipeline_RenderFlow_class, js_delete_cc_pipeline_RenderFlow)

static bool js_delete_cc_pipeline_RenderFlow(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderFlow) 

static bool js_cc_pipeline_RenderFlow_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlow *arg1 = (cc::pipeline::RenderFlow *) NULL ;
    cc::pipeline::RenderFlowInfo *arg2 = 0 ;
    cc::pipeline::RenderFlowInfo temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlow>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderFlow_initialize,2,SWIGTYPE_p_cc__pipeline__RenderFlowInfo");
    arg2 = &temp2;
    
    result = (bool)(arg1)->initialize((cc::pipeline::RenderFlowInfo const &)*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderFlow_initialize) 

static bool js_cc_pipeline_RenderFlow_activate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlow *arg1 = (cc::pipeline::RenderFlow *) NULL ;
    cc::pipeline::RenderPipeline *arg2 = (cc::pipeline::RenderPipeline *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlow>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderFlow_activate,2,SWIGTYPE_p_cc__pipeline__RenderPipeline"); 
    (arg1)->activate(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderFlow_activate) 

static bool js_cc_pipeline_RenderFlow_render(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlow *arg1 = (cc::pipeline::RenderFlow *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlow>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderFlow_render,2,SWIGTYPE_p_cc__scene__Camera"); 
    (arg1)->render(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderFlow_render) 

static bool js_cc_pipeline_RenderFlow_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlow *arg1 = (cc::pipeline::RenderFlow *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlow>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderFlow_destroy) 

static bool js_cc_pipeline_RenderFlow_getName(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlow *arg1 = (cc::pipeline::RenderFlow *) NULL ;
    ccstd::string *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlow>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::string *) &((cc::pipeline::RenderFlow const *)arg1)->getName();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderFlow_getName, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderFlow_getName) 

static bool js_cc_pipeline_RenderFlow_getPriority(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlow *arg1 = (cc::pipeline::RenderFlow *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlow>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::pipeline::RenderFlow const *)arg1)->getPriority();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderFlow_getPriority, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderFlow_getPriority) 

static bool js_cc_pipeline_RenderFlow_getTag(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlow *arg1 = (cc::pipeline::RenderFlow *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlow>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::pipeline::RenderFlow const *)arg1)->getTag();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderFlow_getTag, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderFlow_getTag) 

static bool js_cc_pipeline_RenderFlow_getRenderstageByName(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlow *arg1 = (cc::pipeline::RenderFlow *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    cc::pipeline::RenderStage *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlow>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderFlow_getRenderstageByName,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = (cc::pipeline::RenderStage *)((cc::pipeline::RenderFlow const *)arg1)->getRenderstageByName((ccstd::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderFlow_getRenderstageByName, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderFlow_getRenderstageByName) 

bool js_register_cc_pipeline_RenderFlow(se::Object* obj) {
    auto* cls = se::Class::create("RenderFlow", obj, nullptr, _SE(js_new_cc_pipeline_RenderFlow)); 
    
    
    cls->defineFunction("initialize", _SE(js_cc_pipeline_RenderFlow_initialize)); 
    cls->defineFunction("activate", _SE(js_cc_pipeline_RenderFlow_activate)); 
    cls->defineFunction("render", _SE(js_cc_pipeline_RenderFlow_render)); 
    cls->defineFunction("destroy", _SE(js_cc_pipeline_RenderFlow_destroy)); 
    cls->defineFunction("getName", _SE(js_cc_pipeline_RenderFlow_getName)); 
    cls->defineFunction("getPriority", _SE(js_cc_pipeline_RenderFlow_getPriority)); 
    cls->defineFunction("getTag", _SE(js_cc_pipeline_RenderFlow_getTag)); 
    cls->defineFunction("getRenderstageByName", _SE(js_cc_pipeline_RenderFlow_getRenderstageByName)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderFlow));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderFlow>(cls);
    
    __jsb_cc_pipeline_RenderFlow_proto = cls->getProto();
    __jsb_cc_pipeline_RenderFlow_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_RenderStageInfo_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderStageInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderStageInfo) 

static bool js_cc_pipeline_RenderStageInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStageInfo *arg1 = (cc::pipeline::RenderStageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStageInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderStageInfo_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderStageInfo_name_set) 

static bool js_cc_pipeline_RenderStageInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderStageInfo *arg1 = (cc::pipeline::RenderStageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStageInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderStageInfo_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderStageInfo_name_get) 

static bool js_cc_pipeline_RenderStageInfo_priority_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStageInfo *arg1 = (cc::pipeline::RenderStageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStageInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->priority, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderStageInfo_priority_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderStageInfo_priority_set) 

static bool js_cc_pipeline_RenderStageInfo_priority_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderStageInfo *arg1 = (cc::pipeline::RenderStageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStageInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->priority, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderStageInfo_priority_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->priority, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderStageInfo_priority_get) 

static bool js_cc_pipeline_RenderStageInfo_tag_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStageInfo *arg1 = (cc::pipeline::RenderStageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStageInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->tag, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderStageInfo_tag_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderStageInfo_tag_set) 

static bool js_cc_pipeline_RenderStageInfo_tag_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderStageInfo *arg1 = (cc::pipeline::RenderStageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStageInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->tag, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderStageInfo_tag_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->tag, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderStageInfo_tag_get) 

static bool js_cc_pipeline_RenderStageInfo_renderQueues_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStageInfo *arg1 = (cc::pipeline::RenderStageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStageInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->renderQueues, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderStageInfo_renderQueues_set,2,SWIGTYPE_ccstd__vectorT_cc__pipeline__RenderQueueDesc_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderStageInfo_renderQueues_set) 

static bool js_cc_pipeline_RenderStageInfo_renderQueues_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderStageInfo *arg1 = (cc::pipeline::RenderStageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStageInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->renderQueues, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderStageInfo_renderQueues_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->renderQueues, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderStageInfo_renderQueues_get) 

// js_ctor
static bool js_new_cc_pipeline_RenderStageInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::RenderStageInfo *result;
    result = (cc::pipeline::RenderStageInfo *)new cc::pipeline::RenderStageInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_RenderStageInfo, __jsb_cc_pipeline_RenderStageInfo_class, js_delete_cc_pipeline_RenderStageInfo)

static bool js_delete_cc_pipeline_RenderStageInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderStageInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::RenderStageInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::RenderStageInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("priority", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->priority), ctx);
    }
    
    
    json->getProperty("tag", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->tag), ctx);
    }
    
    
    json->getProperty("renderQueues", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->renderQueues), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_RenderStageInfo(se::Object* obj) {
    auto* cls = se::Class::create("RenderStageInfo", obj, nullptr, _SE(js_new_cc_pipeline_RenderStageInfo)); 
    
    cls->defineProperty("name", _SE(js_cc_pipeline_RenderStageInfo_name_get), _SE(js_cc_pipeline_RenderStageInfo_name_set)); 
    cls->defineProperty("priority", _SE(js_cc_pipeline_RenderStageInfo_priority_get), _SE(js_cc_pipeline_RenderStageInfo_priority_set)); 
    cls->defineProperty("tag", _SE(js_cc_pipeline_RenderStageInfo_tag_get), _SE(js_cc_pipeline_RenderStageInfo_tag_set)); 
    cls->defineProperty("renderQueues", _SE(js_cc_pipeline_RenderStageInfo_renderQueues_get), _SE(js_cc_pipeline_RenderStageInfo_renderQueues_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderStageInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderStageInfo>(cls);
    
    __jsb_cc_pipeline_RenderStageInfo_proto = cls->getProto();
    __jsb_cc_pipeline_RenderStageInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_RenderStage_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderStage_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderStage) 

static bool js_delete_cc_pipeline_RenderStage(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderStage) 

static bool js_cc_pipeline_RenderStage_activate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStage *arg1 = (cc::pipeline::RenderStage *) NULL ;
    cc::pipeline::RenderPipeline *arg2 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::pipeline::RenderFlow *arg3 = (cc::pipeline::RenderFlow *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderStage_activate,2,SWIGTYPE_p_cc__pipeline__RenderPipeline"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderStage_activate,3,SWIGTYPE_p_cc__pipeline__RenderFlow"); 
    (arg1)->activate(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderStage_activate) 

static bool js_cc_pipeline_RenderStage_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStage *arg1 = (cc::pipeline::RenderStage *) NULL ;
    cc::pipeline::RenderStageInfo *arg2 = 0 ;
    cc::pipeline::RenderStageInfo temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderStage_initialize,2,SWIGTYPE_p_cc__pipeline__RenderStageInfo");
    arg2 = &temp2;
    
    result = (bool)(arg1)->initialize((cc::pipeline::RenderStageInfo const &)*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderStage_initialize) 

static bool js_cc_pipeline_RenderStage_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStage *arg1 = (cc::pipeline::RenderStage *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderStage_destroy) 

static bool js_cc_pipeline_RenderStage_render(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStage *arg1 = (cc::pipeline::RenderStage *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderStage_render,2,SWIGTYPE_p_cc__scene__Camera"); 
    (arg1)->render(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderStage_render) 

static bool js_cc_pipeline_RenderStage_getName(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStage *arg1 = (cc::pipeline::RenderStage *) NULL ;
    ccstd::string *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::string *) &((cc::pipeline::RenderStage const *)arg1)->getName();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderStage_getName, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderStage_getName) 

static bool js_cc_pipeline_RenderStage_getPriority(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStage *arg1 = (cc::pipeline::RenderStage *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::pipeline::RenderStage const *)arg1)->getPriority();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderStage_getPriority, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderStage_getPriority) 

static bool js_cc_pipeline_RenderStage_getTag(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStage *arg1 = (cc::pipeline::RenderStage *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::pipeline::RenderStage const *)arg1)->getTag();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderStage_getTag, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderStage_getTag) 

static bool js_cc_pipeline_RenderStage_getFlow(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStage *arg1 = (cc::pipeline::RenderStage *) NULL ;
    cc::pipeline::RenderFlow *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::pipeline::RenderFlow *)((cc::pipeline::RenderStage const *)arg1)->getFlow();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderStage_getFlow, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderStage_getFlow) 

bool js_register_cc_pipeline_RenderStage(se::Object* obj) {
    auto* cls = se::Class::create("RenderStage", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("activate", _SE(js_cc_pipeline_RenderStage_activate)); 
    cls->defineFunction("initialize", _SE(js_cc_pipeline_RenderStage_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_pipeline_RenderStage_destroy)); 
    cls->defineFunction("render", _SE(js_cc_pipeline_RenderStage_render)); 
    cls->defineFunction("getName", _SE(js_cc_pipeline_RenderStage_getName)); 
    cls->defineFunction("getPriority", _SE(js_cc_pipeline_RenderStage_getPriority)); 
    cls->defineFunction("getTag", _SE(js_cc_pipeline_RenderStage_getTag)); 
    cls->defineFunction("getFlow", _SE(js_cc_pipeline_RenderStage_getFlow)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderStage));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderStage>(cls);
    
    __jsb_cc_pipeline_RenderStage_proto = cls->getProto();
    __jsb_cc_pipeline_RenderStage_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_ForwardPipeline_class = nullptr;
se::Object* __jsb_cc_pipeline_ForwardPipeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_ForwardPipeline) 

// js_ctor
static bool js_new_cc_pipeline_ForwardPipeline(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::ForwardPipeline *result;
    result = (cc::pipeline::ForwardPipeline *)new cc::pipeline::ForwardPipeline();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_ForwardPipeline, __jsb_cc_pipeline_ForwardPipeline_class, js_delete_cc_pipeline_ForwardPipeline)

static bool js_delete_cc_pipeline_ForwardPipeline(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_ForwardPipeline) 

static bool js_cc_pipeline_ForwardPipeline_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ForwardPipeline *arg1 = (cc::pipeline::ForwardPipeline *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ForwardPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->destroy();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ForwardPipeline_destroy) 

static bool js_cc_pipeline_ForwardPipeline_getValidLights(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ForwardPipeline *arg1 = (cc::pipeline::ForwardPipeline *) NULL ;
    cc::pipeline::LightList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ForwardPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::pipeline::LightList *) &((cc::pipeline::ForwardPipeline const *)arg1)->getValidLights();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ForwardPipeline_getValidLights, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ForwardPipeline_getValidLights) 

static bool js_cc_pipeline_ForwardPipeline_getLightBuffers(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ForwardPipeline *arg1 = (cc::pipeline::ForwardPipeline *) NULL ;
    cc::gfx::BufferList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ForwardPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::BufferList *) &((cc::pipeline::ForwardPipeline const *)arg1)->getLightBuffers();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ForwardPipeline_getLightBuffers, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ForwardPipeline_getLightBuffers) 

static bool js_cc_pipeline_ForwardPipeline_getLightIndexOffsets(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ForwardPipeline *arg1 = (cc::pipeline::ForwardPipeline *) NULL ;
    cc::pipeline::UintList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ForwardPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::pipeline::UintList *) &((cc::pipeline::ForwardPipeline const *)arg1)->getLightIndexOffsets();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ForwardPipeline_getLightIndexOffsets, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ForwardPipeline_getLightIndexOffsets) 

static bool js_cc_pipeline_ForwardPipeline_getLightIndices(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ForwardPipeline *arg1 = (cc::pipeline::ForwardPipeline *) NULL ;
    cc::pipeline::UintList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ForwardPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::pipeline::UintList *) &((cc::pipeline::ForwardPipeline const *)arg1)->getLightIndices();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ForwardPipeline_getLightIndices, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ForwardPipeline_getLightIndices) 

bool js_register_cc_pipeline_ForwardPipeline(se::Object* obj) {
    auto* cls = se::Class::create("ForwardPipeline", obj, __jsb_cc_pipeline_RenderPipeline_proto, _SE(js_new_cc_pipeline_ForwardPipeline)); 
    
    
    cls->defineFunction("destroy", _SE(js_cc_pipeline_ForwardPipeline_destroy)); 
    cls->defineFunction("getValidLights", _SE(js_cc_pipeline_ForwardPipeline_getValidLights)); 
    cls->defineFunction("getLightBuffers", _SE(js_cc_pipeline_ForwardPipeline_getLightBuffers)); 
    cls->defineFunction("getLightIndexOffsets", _SE(js_cc_pipeline_ForwardPipeline_getLightIndexOffsets)); 
    cls->defineFunction("getLightIndices", _SE(js_cc_pipeline_ForwardPipeline_getLightIndices)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_ForwardPipeline));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::ForwardPipeline>(cls);
    
    __jsb_cc_pipeline_ForwardPipeline_proto = cls->getProto();
    __jsb_cc_pipeline_ForwardPipeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_ForwardFlow_class = nullptr;
se::Object* __jsb_cc_pipeline_ForwardFlow_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_ForwardFlow) 

static bool js_cc_pipeline_ForwardFlow_getInitializeInfo_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlowInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::pipeline::RenderFlowInfo *) &cc::pipeline::ForwardFlow::getInitializeInfo();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ForwardFlow_getInitializeInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ForwardFlow_getInitializeInfo_static) 

// js_ctor
static bool js_new_cc_pipeline_ForwardFlow(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::ForwardFlow *result;
    result = (cc::pipeline::ForwardFlow *)new cc::pipeline::ForwardFlow();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_ForwardFlow, __jsb_cc_pipeline_ForwardFlow_class, js_delete_cc_pipeline_ForwardFlow)

static bool js_delete_cc_pipeline_ForwardFlow(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_ForwardFlow) 

bool js_register_cc_pipeline_ForwardFlow(se::Object* obj) {
    auto* cls = se::Class::create("ForwardFlow", obj, __jsb_cc_pipeline_RenderFlow_proto, _SE(js_new_cc_pipeline_ForwardFlow)); 
    
    
    
    
    cls->defineStaticFunction("getInitializeInfo", _SE(js_cc_pipeline_ForwardFlow_getInitializeInfo_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_ForwardFlow));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::ForwardFlow>(cls);
    
    __jsb_cc_pipeline_ForwardFlow_proto = cls->getProto();
    __jsb_cc_pipeline_ForwardFlow_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_ForwardStage_class = nullptr;
se::Object* __jsb_cc_pipeline_ForwardStage_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_ForwardStage) 

static bool js_cc_pipeline_ForwardStage_getInitializeInfo_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStageInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::pipeline::RenderStageInfo *) &cc::pipeline::ForwardStage::getInitializeInfo();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ForwardStage_getInitializeInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ForwardStage_getInitializeInfo_static) 

// js_ctor
static bool js_new_cc_pipeline_ForwardStage(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::ForwardStage *result;
    result = (cc::pipeline::ForwardStage *)new cc::pipeline::ForwardStage();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_ForwardStage, __jsb_cc_pipeline_ForwardStage_class, js_delete_cc_pipeline_ForwardStage)

static bool js_delete_cc_pipeline_ForwardStage(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_ForwardStage) 

bool js_register_cc_pipeline_ForwardStage(se::Object* obj) {
    auto* cls = se::Class::create("ForwardStage", obj, __jsb_cc_pipeline_RenderStage_proto, _SE(js_new_cc_pipeline_ForwardStage)); 
    
    
    
    
    cls->defineStaticFunction("getInitializeInfo", _SE(js_cc_pipeline_ForwardStage_getInitializeInfo_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_ForwardStage));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::ForwardStage>(cls);
    
    __jsb_cc_pipeline_ForwardStage_proto = cls->getProto();
    __jsb_cc_pipeline_ForwardStage_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_ShadowFlow_class = nullptr;
se::Object* __jsb_cc_pipeline_ShadowFlow_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_ShadowFlow) 

// js_ctor
static bool js_new_cc_pipeline_ShadowFlow(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::ShadowFlow *result;
    result = (cc::pipeline::ShadowFlow *)new cc::pipeline::ShadowFlow();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_ShadowFlow, __jsb_cc_pipeline_ShadowFlow_class, js_delete_cc_pipeline_ShadowFlow)

static bool js_delete_cc_pipeline_ShadowFlow(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_ShadowFlow) 

static bool js_cc_pipeline_ShadowFlow_getInitializeInfo_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlowInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::pipeline::RenderFlowInfo *) &cc::pipeline::ShadowFlow::getInitializeInfo();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShadowFlow_getInitializeInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowFlow_getInitializeInfo_static) 

bool js_register_cc_pipeline_ShadowFlow(se::Object* obj) {
    auto* cls = se::Class::create("ShadowFlow", obj, __jsb_cc_pipeline_RenderFlow_proto, _SE(js_new_cc_pipeline_ShadowFlow)); 
    
    
    
    
    cls->defineStaticFunction("getInitializeInfo", _SE(js_cc_pipeline_ShadowFlow_getInitializeInfo_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_ShadowFlow));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::ShadowFlow>(cls);
    
    __jsb_cc_pipeline_ShadowFlow_proto = cls->getProto();
    __jsb_cc_pipeline_ShadowFlow_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_ShadowStage_class = nullptr;
se::Object* __jsb_cc_pipeline_ShadowStage_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_ShadowStage) 

// js_ctor
static bool js_new_cc_pipeline_ShadowStage(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::ShadowStage *result;
    result = (cc::pipeline::ShadowStage *)new cc::pipeline::ShadowStage();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_ShadowStage, __jsb_cc_pipeline_ShadowStage_class, js_delete_cc_pipeline_ShadowStage)

static bool js_delete_cc_pipeline_ShadowStage(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_ShadowStage) 

static bool js_cc_pipeline_ShadowStage_getInitializeInfo_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStageInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::pipeline::RenderStageInfo *) &cc::pipeline::ShadowStage::getInitializeInfo();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShadowStage_getInitializeInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowStage_getInitializeInfo_static) 

static bool js_cc_pipeline_ShadowStage_setFramebuffer(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowStage *arg1 = (cc::pipeline::ShadowStage *) NULL ;
    cc::gfx::Framebuffer *arg2 = (cc::gfx::Framebuffer *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowStage_setFramebuffer,2,SWIGTYPE_p_cc__gfx__Framebuffer"); 
    (arg1)->setFramebuffer(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowStage_setFramebuffer) 

static bool js_cc_pipeline_ShadowStage_setUsage__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::ShadowStage *arg1 = (cc::pipeline::ShadowStage *) NULL ;
    cc::gfx::DescriptorSet *arg2 = (cc::gfx::DescriptorSet *) NULL ;
    cc::scene::Light *arg3 = (cc::scene::Light *) NULL ;
    cc::gfx::Framebuffer *arg4 = (cc::gfx::Framebuffer *) NULL ;
    uint32_t arg5 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowStage_setUsage,2,SWIGTYPE_p_cc__gfx__DescriptorSet"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowStage_setUsage,3,SWIGTYPE_p_cc__scene__Light"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowStage_setUsage,4,SWIGTYPE_p_cc__gfx__Framebuffer"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowStage_setUsage,5,SWIGTYPE_uint32_t"); 
    
    (arg1)->setUsage(arg2,(cc::scene::Light const *)arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_ShadowStage_setUsage__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::ShadowStage *arg1 = (cc::pipeline::ShadowStage *) NULL ;
    cc::gfx::DescriptorSet *arg2 = (cc::gfx::DescriptorSet *) NULL ;
    cc::scene::Light *arg3 = (cc::scene::Light *) NULL ;
    cc::gfx::Framebuffer *arg4 = (cc::gfx::Framebuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowStage_setUsage,2,SWIGTYPE_p_cc__gfx__DescriptorSet"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowStage_setUsage,3,SWIGTYPE_p_cc__scene__Light"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowStage_setUsage,4,SWIGTYPE_p_cc__gfx__Framebuffer"); 
    (arg1)->setUsage(arg2,(cc::scene::Light const *)arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_ShadowStage_setUsage(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_pipeline_ShadowStage_setUsage__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_pipeline_ShadowStage_setUsage__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowStage_setUsage) 

static bool js_cc_pipeline_ShadowStage_clearFramebuffer(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowStage *arg1 = (cc::pipeline::ShadowStage *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowStage_clearFramebuffer,2,SWIGTYPE_p_cc__scene__Camera"); 
    (arg1)->clearFramebuffer((cc::scene::Camera const *)arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowStage_clearFramebuffer) 

bool js_register_cc_pipeline_ShadowStage(se::Object* obj) {
    auto* cls = se::Class::create("ShadowStage", obj, __jsb_cc_pipeline_RenderStage_proto, _SE(js_new_cc_pipeline_ShadowStage)); 
    
    
    cls->defineFunction("setFramebuffer", _SE(js_cc_pipeline_ShadowStage_setFramebuffer)); 
    cls->defineFunction("setUsage", _SE(js_cc_pipeline_ShadowStage_setUsage)); 
    cls->defineFunction("clearFramebuffer", _SE(js_cc_pipeline_ShadowStage_clearFramebuffer)); 
    
    
    cls->defineStaticFunction("getInitializeInfo", _SE(js_cc_pipeline_ShadowStage_getInitializeInfo_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_ShadowStage));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::ShadowStage>(cls);
    
    __jsb_cc_pipeline_ShadowStage_proto = cls->getProto();
    __jsb_cc_pipeline_ShadowStage_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_ShadowTransformInfo_class = nullptr;
se::Object* __jsb_cc_pipeline_ShadowTransformInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_ShadowTransformInfo) 

// js_ctor
static bool js_new_cc_pipeline_ShadowTransformInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 1) {
        SE_REPORT_ERROR("js_new_cc_pipeline_ShadowTransformInfo: wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    uint32_t arg1 ;
    cc::pipeline::ShadowTransformInfo *result;
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_ShadowTransformInfo,1,SWIGTYPE_uint32_t"); 
    
    result = (cc::pipeline::ShadowTransformInfo *)new cc::pipeline::ShadowTransformInfo(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_ShadowTransformInfo, __jsb_cc_pipeline_ShadowTransformInfo_class, js_delete_cc_pipeline_ShadowTransformInfo)

static bool js_delete_cc_pipeline_ShadowTransformInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_ShadowTransformInfo) 

static bool js_cc_pipeline_ShadowTransformInfo_getLevel(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::pipeline::ShadowTransformInfo const *)arg1)->getLevel();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_getLevel, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_getLevel) 

static bool js_cc_pipeline_ShadowTransformInfo_getShadowObjects(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    cc::pipeline::RenderObjectList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::pipeline::RenderObjectList *) &(arg1)->getShadowObjects();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_getShadowObjects, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_getShadowObjects) 

static bool js_cc_pipeline_ShadowTransformInfo_setShadowObjects(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    cc::pipeline::RenderObjectList *arg2 = 0 ;
    cc::pipeline::RenderObjectList temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_setShadowObjects,2,SWIGTYPE_p_ccstd__vectorT_cc__pipeline__RenderObject_t");
    arg2 = &temp2;
    
    (arg1)->setShadowObjects((cc::pipeline::RenderObjectList &&)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_setShadowObjects) 

static bool js_cc_pipeline_ShadowTransformInfo_addShadowObject(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    cc::pipeline::RenderObject *arg2 = 0 ;
    cc::pipeline::RenderObject temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_addShadowObject,2,SWIGTYPE_p_cc__pipeline__RenderObject");
    arg2 = &temp2;
    
    (arg1)->addShadowObject((cc::pipeline::RenderObject &&)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_addShadowObject) 

static bool js_cc_pipeline_ShadowTransformInfo_clearShadowObjects(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->clearShadowObjects();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_clearShadowObjects) 

static bool js_cc_pipeline_ShadowTransformInfo_getShadowCameraFar(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)((cc::pipeline::ShadowTransformInfo const *)arg1)->getShadowCameraFar();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_getShadowCameraFar) 

static bool js_cc_pipeline_ShadowTransformInfo_setShadowCameraFar(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_setShadowCameraFar,2,SWIGTYPE_float"); 
    (arg1)->setShadowCameraFar(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_setShadowCameraFar) 

static bool js_cc_pipeline_ShadowTransformInfo_getMatShadowView(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    cc::Mat4 *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Mat4 *) &((cc::pipeline::ShadowTransformInfo const *)arg1)->getMatShadowView();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_getMatShadowView, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_getMatShadowView) 

static bool js_cc_pipeline_ShadowTransformInfo_setMatShadowView(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    cc::Mat4 *arg2 = 0 ;
    cc::Mat4 temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_setMatShadowView,2,SWIGTYPE_p_cc__Mat4");
    arg2 = &temp2;
    
    (arg1)->setMatShadowView((cc::Mat4 const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_setMatShadowView) 

static bool js_cc_pipeline_ShadowTransformInfo_getMatShadowProj(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    cc::Mat4 *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Mat4 *) &((cc::pipeline::ShadowTransformInfo const *)arg1)->getMatShadowProj();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_getMatShadowProj, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_getMatShadowProj) 

static bool js_cc_pipeline_ShadowTransformInfo_setMatShadowProj(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    cc::Mat4 *arg2 = 0 ;
    cc::Mat4 temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_setMatShadowProj,2,SWIGTYPE_p_cc__Mat4");
    arg2 = &temp2;
    
    (arg1)->setMatShadowProj((cc::Mat4 const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_setMatShadowProj) 

static bool js_cc_pipeline_ShadowTransformInfo_getMatShadowViewProj(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    cc::Mat4 *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Mat4 *) &((cc::pipeline::ShadowTransformInfo const *)arg1)->getMatShadowViewProj();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_getMatShadowViewProj, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_getMatShadowViewProj) 

static bool js_cc_pipeline_ShadowTransformInfo_setMatShadowViewProj(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    cc::Mat4 *arg2 = 0 ;
    cc::Mat4 temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_setMatShadowViewProj,2,SWIGTYPE_p_cc__Mat4");
    arg2 = &temp2;
    
    (arg1)->setMatShadowViewProj((cc::Mat4 const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_setMatShadowViewProj) 

static bool js_cc_pipeline_ShadowTransformInfo_getValidFrustum(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    geometry::Frustum *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (geometry::Frustum *) &((cc::pipeline::ShadowTransformInfo const *)arg1)->getValidFrustum();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_getValidFrustum, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_getValidFrustum) 

static bool js_cc_pipeline_ShadowTransformInfo_getSplitFrustum(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    geometry::Frustum *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (geometry::Frustum *) &((cc::pipeline::ShadowTransformInfo const *)arg1)->getSplitFrustum();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_getSplitFrustum, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_getSplitFrustum) 

static bool js_cc_pipeline_ShadowTransformInfo_getLightViewFrustum(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    geometry::Frustum *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (geometry::Frustum *) &((cc::pipeline::ShadowTransformInfo const *)arg1)->getLightViewFrustum();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_getLightViewFrustum, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_getLightViewFrustum) 

static bool js_cc_pipeline_ShadowTransformInfo_getCastLightViewBoundingBox(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    geometry::AABB *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (geometry::AABB *) &((cc::pipeline::ShadowTransformInfo const *)arg1)->getCastLightViewBoundingBox();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_getCastLightViewBoundingBox, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_getCastLightViewBoundingBox) 

static bool js_cc_pipeline_ShadowTransformInfo_createMatrix(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    geometry::Frustum *arg2 = 0 ;
    cc::scene::DirectionalLight *arg3 = (cc::scene::DirectionalLight *) NULL ;
    float arg4 ;
    bool arg5 ;
    geometry::Frustum temp2 ;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_createMatrix,2,SWIGTYPE_p_geometry__Frustum");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_createMatrix,3,SWIGTYPE_p_cc__scene__DirectionalLight"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_createMatrix,4,SWIGTYPE_float"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_createMatrix,5,SWIGTYPE_bool"); 
    (arg1)->createMatrix((geometry::Frustum const &)*arg2,(cc::scene::DirectionalLight const *)arg3,arg4,arg5);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_createMatrix) 

static bool js_cc_pipeline_ShadowTransformInfo_copyToValidFrustum(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    geometry::Frustum *arg2 = 0 ;
    geometry::Frustum temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_copyToValidFrustum,2,SWIGTYPE_p_geometry__Frustum");
    arg2 = &temp2;
    
    (arg1)->copyToValidFrustum((geometry::Frustum const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_copyToValidFrustum) 

static bool js_cc_pipeline_ShadowTransformInfo_calculateValidFrustumOrtho(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    cc::Mat4 *arg6 = 0 ;
    cc::Mat4 temp6 ;
    
    if(argc != 5) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_calculateValidFrustumOrtho,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_calculateValidFrustumOrtho,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_calculateValidFrustumOrtho,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_calculateValidFrustumOrtho,5,SWIGTYPE_float"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[4], &temp6, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_calculateValidFrustumOrtho,6,SWIGTYPE_p_cc__Mat4");
    arg6 = &temp6;
    
    (arg1)->calculateValidFrustumOrtho(arg2,arg3,arg4,arg5,(cc::Mat4 const &)*arg6);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_calculateValidFrustumOrtho) 

static bool js_cc_pipeline_ShadowTransformInfo_calculateSplitFrustum(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    cc::Mat4 *arg6 = 0 ;
    cc::Mat4 temp6 ;
    
    if(argc != 5) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_calculateSplitFrustum,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_calculateSplitFrustum,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_calculateSplitFrustum,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_calculateSplitFrustum,5,SWIGTYPE_float"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[4], &temp6, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowTransformInfo_calculateSplitFrustum,6,SWIGTYPE_p_cc__Mat4");
    arg6 = &temp6;
    
    (arg1)->calculateSplitFrustum(arg2,arg3,arg4,arg5,(cc::Mat4 const &)*arg6);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_calculateSplitFrustum) 

bool js_register_cc_pipeline_ShadowTransformInfo(se::Object* obj) {
    auto* cls = se::Class::create("ShadowTransformInfo", obj, nullptr, _SE(js_new_cc_pipeline_ShadowTransformInfo)); 
    
    
    cls->defineFunction("getLevel", _SE(js_cc_pipeline_ShadowTransformInfo_getLevel)); 
    cls->defineFunction("getShadowObjects", _SE(js_cc_pipeline_ShadowTransformInfo_getShadowObjects)); 
    cls->defineFunction("setShadowObjects", _SE(js_cc_pipeline_ShadowTransformInfo_setShadowObjects)); 
    cls->defineFunction("addShadowObject", _SE(js_cc_pipeline_ShadowTransformInfo_addShadowObject)); 
    cls->defineFunction("clearShadowObjects", _SE(js_cc_pipeline_ShadowTransformInfo_clearShadowObjects)); 
    cls->defineFunction("getShadowCameraFar", _SE(js_cc_pipeline_ShadowTransformInfo_getShadowCameraFar)); 
    cls->defineFunction("setShadowCameraFar", _SE(js_cc_pipeline_ShadowTransformInfo_setShadowCameraFar)); 
    cls->defineFunction("getMatShadowView", _SE(js_cc_pipeline_ShadowTransformInfo_getMatShadowView)); 
    cls->defineFunction("setMatShadowView", _SE(js_cc_pipeline_ShadowTransformInfo_setMatShadowView)); 
    cls->defineFunction("getMatShadowProj", _SE(js_cc_pipeline_ShadowTransformInfo_getMatShadowProj)); 
    cls->defineFunction("setMatShadowProj", _SE(js_cc_pipeline_ShadowTransformInfo_setMatShadowProj)); 
    cls->defineFunction("getMatShadowViewProj", _SE(js_cc_pipeline_ShadowTransformInfo_getMatShadowViewProj)); 
    cls->defineFunction("setMatShadowViewProj", _SE(js_cc_pipeline_ShadowTransformInfo_setMatShadowViewProj)); 
    cls->defineFunction("getValidFrustum", _SE(js_cc_pipeline_ShadowTransformInfo_getValidFrustum)); 
    cls->defineFunction("getSplitFrustum", _SE(js_cc_pipeline_ShadowTransformInfo_getSplitFrustum)); 
    cls->defineFunction("getLightViewFrustum", _SE(js_cc_pipeline_ShadowTransformInfo_getLightViewFrustum)); 
    cls->defineFunction("getCastLightViewBoundingBox", _SE(js_cc_pipeline_ShadowTransformInfo_getCastLightViewBoundingBox)); 
    cls->defineFunction("createMatrix", _SE(js_cc_pipeline_ShadowTransformInfo_createMatrix)); 
    cls->defineFunction("copyToValidFrustum", _SE(js_cc_pipeline_ShadowTransformInfo_copyToValidFrustum)); 
    cls->defineFunction("calculateValidFrustumOrtho", _SE(js_cc_pipeline_ShadowTransformInfo_calculateValidFrustumOrtho)); 
    cls->defineFunction("calculateSplitFrustum", _SE(js_cc_pipeline_ShadowTransformInfo_calculateSplitFrustum)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_ShadowTransformInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::ShadowTransformInfo>(cls);
    
    __jsb_cc_pipeline_ShadowTransformInfo_proto = cls->getProto();
    __jsb_cc_pipeline_ShadowTransformInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_CSMLayerInfo_class = nullptr;
se::Object* __jsb_cc_pipeline_CSMLayerInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_CSMLayerInfo) 

// js_ctor
static bool js_new_cc_pipeline_CSMLayerInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 1) {
        SE_REPORT_ERROR("js_new_cc_pipeline_CSMLayerInfo: wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    uint32_t arg1 ;
    cc::pipeline::CSMLayerInfo *result;
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_CSMLayerInfo,1,SWIGTYPE_uint32_t"); 
    
    result = (cc::pipeline::CSMLayerInfo *)new cc::pipeline::CSMLayerInfo(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_CSMLayerInfo, __jsb_cc_pipeline_CSMLayerInfo_class, js_delete_cc_pipeline_CSMLayerInfo)

static bool js_delete_cc_pipeline_CSMLayerInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_CSMLayerInfo) 

static bool js_cc_pipeline_CSMLayerInfo_getSplitCameraNear(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::CSMLayerInfo *arg1 = (cc::pipeline::CSMLayerInfo *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::CSMLayerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)((cc::pipeline::CSMLayerInfo const *)arg1)->getSplitCameraNear();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_CSMLayerInfo_getSplitCameraNear) 

static bool js_cc_pipeline_CSMLayerInfo_setSplitCameraNear(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::CSMLayerInfo *arg1 = (cc::pipeline::CSMLayerInfo *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::CSMLayerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "CSMLayerInfo_setSplitCameraNear,2,SWIGTYPE_float"); 
    (arg1)->setSplitCameraNear(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_CSMLayerInfo_setSplitCameraNear) 

static bool js_cc_pipeline_CSMLayerInfo_getSplitCameraFar(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::CSMLayerInfo *arg1 = (cc::pipeline::CSMLayerInfo *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::CSMLayerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)((cc::pipeline::CSMLayerInfo const *)arg1)->getSplitCameraFar();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_CSMLayerInfo_getSplitCameraFar) 

static bool js_cc_pipeline_CSMLayerInfo_setSplitCameraFar(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::CSMLayerInfo *arg1 = (cc::pipeline::CSMLayerInfo *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::CSMLayerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "CSMLayerInfo_setSplitCameraFar,2,SWIGTYPE_float"); 
    (arg1)->setSplitCameraFar(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_CSMLayerInfo_setSplitCameraFar) 

static bool js_cc_pipeline_CSMLayerInfo_getCSMAtlas(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::CSMLayerInfo *arg1 = (cc::pipeline::CSMLayerInfo *) NULL ;
    cc::Vec4 *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::CSMLayerInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Vec4 *) &((cc::pipeline::CSMLayerInfo const *)arg1)->getCSMAtlas();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CSMLayerInfo_getCSMAtlas, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_CSMLayerInfo_getCSMAtlas) 

bool js_register_cc_pipeline_CSMLayerInfo(se::Object* obj) {
    auto* cls = se::Class::create("CSMLayerInfo", obj, __jsb_cc_pipeline_ShadowTransformInfo_proto, _SE(js_new_cc_pipeline_CSMLayerInfo)); 
    
    
    cls->defineFunction("getSplitCameraNear", _SE(js_cc_pipeline_CSMLayerInfo_getSplitCameraNear)); 
    cls->defineFunction("setSplitCameraNear", _SE(js_cc_pipeline_CSMLayerInfo_setSplitCameraNear)); 
    cls->defineFunction("getSplitCameraFar", _SE(js_cc_pipeline_CSMLayerInfo_getSplitCameraFar)); 
    cls->defineFunction("setSplitCameraFar", _SE(js_cc_pipeline_CSMLayerInfo_setSplitCameraFar)); 
    cls->defineFunction("getCSMAtlas", _SE(js_cc_pipeline_CSMLayerInfo_getCSMAtlas)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_CSMLayerInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::CSMLayerInfo>(cls);
    
    __jsb_cc_pipeline_CSMLayerInfo_proto = cls->getProto();
    __jsb_cc_pipeline_CSMLayerInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_CSMLayers_class = nullptr;
se::Object* __jsb_cc_pipeline_CSMLayers_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_CSMLayers) 

// js_ctor
static bool js_new_cc_pipeline_CSMLayers(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::CSMLayers *result;
    result = (cc::pipeline::CSMLayers *)new cc::pipeline::CSMLayers();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_CSMLayers, __jsb_cc_pipeline_CSMLayers_class, js_delete_cc_pipeline_CSMLayers)

static bool js_delete_cc_pipeline_CSMLayers(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_CSMLayers) 

bool js_register_cc_pipeline_CSMLayers(se::Object* obj) {
    auto* cls = se::Class::create("CSMLayers", obj, nullptr, _SE(js_new_cc_pipeline_CSMLayers)); 
    
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_CSMLayers));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::CSMLayers>(cls);
    
    __jsb_cc_pipeline_CSMLayers_proto = cls->getProto();
    __jsb_cc_pipeline_CSMLayers_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_GlobalDSManager_class = nullptr;
se::Object* __jsb_cc_pipeline_GlobalDSManager_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_GlobalDSManager) 

// js_ctor
static bool js_new_cc_pipeline_GlobalDSManager(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::GlobalDSManager *result;
    result = (cc::pipeline::GlobalDSManager *)new cc::pipeline::GlobalDSManager();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_GlobalDSManager, __jsb_cc_pipeline_GlobalDSManager_class, js_delete_cc_pipeline_GlobalDSManager)

static bool js_delete_cc_pipeline_GlobalDSManager(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_GlobalDSManager) 

static bool js_cc_pipeline_GlobalDSManager_getLinearSampler(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::GlobalDSManager *arg1 = (cc::pipeline::GlobalDSManager *) NULL ;
    cc::gfx::Sampler *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::GlobalDSManager>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Sampler *)((cc::pipeline::GlobalDSManager const *)arg1)->getLinearSampler();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "GlobalDSManager_getLinearSampler, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GlobalDSManager_getLinearSampler) 

static bool js_cc_pipeline_GlobalDSManager_getPointSampler(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::GlobalDSManager *arg1 = (cc::pipeline::GlobalDSManager *) NULL ;
    cc::gfx::Sampler *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::GlobalDSManager>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Sampler *)((cc::pipeline::GlobalDSManager const *)arg1)->getPointSampler();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "GlobalDSManager_getPointSampler, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GlobalDSManager_getPointSampler) 

static bool js_cc_pipeline_GlobalDSManager_getDescriptorSetLayout(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::GlobalDSManager *arg1 = (cc::pipeline::GlobalDSManager *) NULL ;
    cc::gfx::DescriptorSetLayout *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::GlobalDSManager>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::DescriptorSetLayout *)((cc::pipeline::GlobalDSManager const *)arg1)->getDescriptorSetLayout();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "GlobalDSManager_getDescriptorSetLayout, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GlobalDSManager_getDescriptorSetLayout) 

static bool js_cc_pipeline_GlobalDSManager_getGlobalDescriptorSet(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::GlobalDSManager *arg1 = (cc::pipeline::GlobalDSManager *) NULL ;
    cc::gfx::DescriptorSet *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::GlobalDSManager>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::DescriptorSet *)((cc::pipeline::GlobalDSManager const *)arg1)->getGlobalDescriptorSet();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "GlobalDSManager_getGlobalDescriptorSet, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GlobalDSManager_getGlobalDescriptorSet) 

static bool js_cc_pipeline_GlobalDSManager_activate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::GlobalDSManager *arg1 = (cc::pipeline::GlobalDSManager *) NULL ;
    cc::gfx::Device *arg2 = (cc::gfx::Device *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::GlobalDSManager>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GlobalDSManager_activate,2,SWIGTYPE_p_cc__gfx__Device"); 
    (arg1)->activate(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GlobalDSManager_activate) 

static bool js_cc_pipeline_GlobalDSManager_bindBuffer(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::GlobalDSManager *arg1 = (cc::pipeline::GlobalDSManager *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Buffer *arg3 = (cc::gfx::Buffer *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::GlobalDSManager>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GlobalDSManager_bindBuffer,2,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GlobalDSManager_bindBuffer,3,SWIGTYPE_p_cc__gfx__Buffer"); 
    (arg1)->bindBuffer(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GlobalDSManager_bindBuffer) 

static bool js_cc_pipeline_GlobalDSManager_bindTexture(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::GlobalDSManager *arg1 = (cc::pipeline::GlobalDSManager *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Texture *arg3 = (cc::gfx::Texture *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::GlobalDSManager>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GlobalDSManager_bindTexture,2,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GlobalDSManager_bindTexture,3,SWIGTYPE_p_cc__gfx__Texture"); 
    (arg1)->bindTexture(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GlobalDSManager_bindTexture) 

static bool js_cc_pipeline_GlobalDSManager_bindSampler(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::GlobalDSManager *arg1 = (cc::pipeline::GlobalDSManager *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Sampler *arg3 = (cc::gfx::Sampler *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::GlobalDSManager>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GlobalDSManager_bindSampler,2,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GlobalDSManager_bindSampler,3,SWIGTYPE_p_cc__gfx__Sampler"); 
    (arg1)->bindSampler(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GlobalDSManager_bindSampler) 

static bool js_cc_pipeline_GlobalDSManager_update(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::GlobalDSManager *arg1 = (cc::pipeline::GlobalDSManager *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::GlobalDSManager>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->update();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GlobalDSManager_update) 

static bool js_cc_pipeline_GlobalDSManager_getOrCreateDescriptorSet(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::GlobalDSManager *arg1 = (cc::pipeline::GlobalDSManager *) NULL ;
    cc::scene::Light *arg2 = (cc::scene::Light *) NULL ;
    cc::gfx::DescriptorSet *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::GlobalDSManager>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GlobalDSManager_getOrCreateDescriptorSet,2,SWIGTYPE_p_cc__scene__Light"); 
    result = (cc::gfx::DescriptorSet *)(arg1)->getOrCreateDescriptorSet((cc::scene::Light const *)arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "GlobalDSManager_getOrCreateDescriptorSet, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GlobalDSManager_getOrCreateDescriptorSet) 

static bool js_cc_pipeline_GlobalDSManager_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::GlobalDSManager *arg1 = (cc::pipeline::GlobalDSManager *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::GlobalDSManager>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GlobalDSManager_destroy) 

static bool js_cc_pipeline_GlobalDSManager_setDescriptorSetLayout_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    cc::pipeline::GlobalDSManager::setDescriptorSetLayout();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GlobalDSManager_setDescriptorSetLayout_static) 

bool js_register_cc_pipeline_GlobalDSManager(se::Object* obj) {
    auto* cls = se::Class::create("GlobalDSManager", obj, nullptr, _SE(js_new_cc_pipeline_GlobalDSManager)); 
    
    
    cls->defineFunction("getLinearSampler", _SE(js_cc_pipeline_GlobalDSManager_getLinearSampler)); 
    cls->defineFunction("getPointSampler", _SE(js_cc_pipeline_GlobalDSManager_getPointSampler)); 
    cls->defineFunction("getDescriptorSetLayout", _SE(js_cc_pipeline_GlobalDSManager_getDescriptorSetLayout)); 
    cls->defineFunction("getGlobalDescriptorSet", _SE(js_cc_pipeline_GlobalDSManager_getGlobalDescriptorSet)); 
    cls->defineFunction("activate", _SE(js_cc_pipeline_GlobalDSManager_activate)); 
    cls->defineFunction("bindBuffer", _SE(js_cc_pipeline_GlobalDSManager_bindBuffer)); 
    cls->defineFunction("bindTexture", _SE(js_cc_pipeline_GlobalDSManager_bindTexture)); 
    cls->defineFunction("bindSampler", _SE(js_cc_pipeline_GlobalDSManager_bindSampler)); 
    cls->defineFunction("update", _SE(js_cc_pipeline_GlobalDSManager_update)); 
    cls->defineFunction("getOrCreateDescriptorSet", _SE(js_cc_pipeline_GlobalDSManager_getOrCreateDescriptorSet)); 
    cls->defineFunction("destroy", _SE(js_cc_pipeline_GlobalDSManager_destroy)); 
    
    
    cls->defineStaticFunction("setDescriptorSetLayout", _SE(js_cc_pipeline_GlobalDSManager_setDescriptorSetLayout_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_GlobalDSManager));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::GlobalDSManager>(cls);
    
    __jsb_cc_pipeline_GlobalDSManager_proto = cls->getProto();
    __jsb_cc_pipeline_GlobalDSManager_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_InstancedItem_class = nullptr;
se::Object* __jsb_cc_pipeline_InstancedItem_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_InstancedItem) 

static bool js_cc_pipeline_InstancedItem_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "InstancedItem_count_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InstancedItem_count_set) 

static bool js_cc_pipeline_InstancedItem_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InstancedItem_count_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->count, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InstancedItem_count_get) 

static bool js_cc_pipeline_InstancedItem_capacity_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->capacity, s.thisObject());
    SE_PRECONDITION2(ok, false, "InstancedItem_capacity_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InstancedItem_capacity_set) 

static bool js_cc_pipeline_InstancedItem_capacity_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->capacity, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InstancedItem_capacity_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->capacity, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InstancedItem_capacity_get) 

static bool js_cc_pipeline_InstancedItem_vb_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->vb, s.thisObject());
    SE_PRECONDITION2(ok, false, "InstancedItem_vb_set,2,SWIGTYPE_p_cc__gfx__Buffer"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InstancedItem_vb_set) 

static bool js_cc_pipeline_InstancedItem_vb_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->vb, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InstancedItem_vb_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->vb, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InstancedItem_vb_get) 

static bool js_cc_pipeline_InstancedItem_data_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->data, s.thisObject());
    SE_PRECONDITION2(ok, false, "InstancedItem_data_set,2,SWIGTYPE_p_uint8_t"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InstancedItem_data_set) 

static bool js_cc_pipeline_InstancedItem_data_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->data, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InstancedItem_data_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->data, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InstancedItem_data_get) 

static bool js_cc_pipeline_InstancedItem_ia_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->ia, s.thisObject());
    SE_PRECONDITION2(ok, false, "InstancedItem_ia_set,2,SWIGTYPE_p_cc__gfx__InputAssembler"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InstancedItem_ia_set) 

static bool js_cc_pipeline_InstancedItem_ia_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->ia, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InstancedItem_ia_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->ia, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InstancedItem_ia_get) 

static bool js_cc_pipeline_InstancedItem_stride_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->stride, s.thisObject());
    SE_PRECONDITION2(ok, false, "InstancedItem_stride_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InstancedItem_stride_set) 

static bool js_cc_pipeline_InstancedItem_stride_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->stride, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InstancedItem_stride_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stride, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InstancedItem_stride_get) 

static bool js_cc_pipeline_InstancedItem_shader_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->shader, s.thisObject());
    SE_PRECONDITION2(ok, false, "InstancedItem_shader_set,2,SWIGTYPE_p_cc__gfx__Shader"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InstancedItem_shader_set) 

static bool js_cc_pipeline_InstancedItem_shader_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->shader, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InstancedItem_shader_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->shader, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InstancedItem_shader_get) 

static bool js_cc_pipeline_InstancedItem_descriptorSet_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->descriptorSet, s.thisObject());
    SE_PRECONDITION2(ok, false, "InstancedItem_descriptorSet_set,2,SWIGTYPE_p_cc__gfx__DescriptorSet"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InstancedItem_descriptorSet_set) 

static bool js_cc_pipeline_InstancedItem_descriptorSet_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->descriptorSet, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InstancedItem_descriptorSet_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->descriptorSet, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InstancedItem_descriptorSet_get) 

static bool js_cc_pipeline_InstancedItem_lightingMap_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->lightingMap, s.thisObject());
    SE_PRECONDITION2(ok, false, "InstancedItem_lightingMap_set,2,SWIGTYPE_p_cc__gfx__Texture"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InstancedItem_lightingMap_set) 

static bool js_cc_pipeline_InstancedItem_lightingMap_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->lightingMap, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InstancedItem_lightingMap_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->lightingMap, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InstancedItem_lightingMap_get) 

// js_ctor
static bool js_new_cc_pipeline_InstancedItem(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::InstancedItem *result;
    result = (cc::pipeline::InstancedItem *)new cc::pipeline::InstancedItem();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_InstancedItem, __jsb_cc_pipeline_InstancedItem_class, js_delete_cc_pipeline_InstancedItem)

static bool js_delete_cc_pipeline_InstancedItem(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_InstancedItem) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::InstancedItem * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::InstancedItem*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("capacity", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->capacity), ctx);
    }
    
    
    json->getProperty("vb", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->vb), ctx);
    }
    
    
    json->getProperty("data", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->data), ctx);
    }
    
    
    json->getProperty("ia", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->ia), ctx);
    }
    
    
    json->getProperty("stride", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stride), ctx);
    }
    
    
    json->getProperty("shader", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->shader), ctx);
    }
    
    
    json->getProperty("descriptorSet", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->descriptorSet), ctx);
    }
    
    
    json->getProperty("lightingMap", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->lightingMap), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_InstancedItem(se::Object* obj) {
    auto* cls = se::Class::create("InstancedItem", obj, nullptr, _SE(js_new_cc_pipeline_InstancedItem)); 
    
    cls->defineProperty("count", _SE(js_cc_pipeline_InstancedItem_count_get), _SE(js_cc_pipeline_InstancedItem_count_set)); 
    cls->defineProperty("capacity", _SE(js_cc_pipeline_InstancedItem_capacity_get), _SE(js_cc_pipeline_InstancedItem_capacity_set)); 
    cls->defineProperty("vb", _SE(js_cc_pipeline_InstancedItem_vb_get), _SE(js_cc_pipeline_InstancedItem_vb_set)); 
    cls->defineProperty("data", _SE(js_cc_pipeline_InstancedItem_data_get), _SE(js_cc_pipeline_InstancedItem_data_set)); 
    cls->defineProperty("ia", _SE(js_cc_pipeline_InstancedItem_ia_get), _SE(js_cc_pipeline_InstancedItem_ia_set)); 
    cls->defineProperty("stride", _SE(js_cc_pipeline_InstancedItem_stride_get), _SE(js_cc_pipeline_InstancedItem_stride_set)); 
    cls->defineProperty("shader", _SE(js_cc_pipeline_InstancedItem_shader_get), _SE(js_cc_pipeline_InstancedItem_shader_set)); 
    cls->defineProperty("descriptorSet", _SE(js_cc_pipeline_InstancedItem_descriptorSet_get), _SE(js_cc_pipeline_InstancedItem_descriptorSet_set)); 
    cls->defineProperty("lightingMap", _SE(js_cc_pipeline_InstancedItem_lightingMap_get), _SE(js_cc_pipeline_InstancedItem_lightingMap_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_InstancedItem));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::InstancedItem>(cls);
    
    __jsb_cc_pipeline_InstancedItem_proto = cls->getProto();
    __jsb_cc_pipeline_InstancedItem_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_InstancedBuffer_class = nullptr;
se::Object* __jsb_cc_pipeline_InstancedBuffer_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_InstancedBuffer) 

// js_ctor
static bool js_new_cc_pipeline_InstancedBuffer(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 1) {
        SE_REPORT_ERROR("js_new_cc_pipeline_InstancedBuffer: wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::pipeline::InstancedBuffer *result;
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_InstancedBuffer,1,SWIGTYPE_p_cc__scene__Pass"); 
    result = (cc::pipeline::InstancedBuffer *)new cc::pipeline::InstancedBuffer((cc::scene::Pass const *)arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_InstancedBuffer, __jsb_cc_pipeline_InstancedBuffer_class, js_delete_cc_pipeline_InstancedBuffer)

static bool js_delete_cc_pipeline_InstancedBuffer(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_InstancedBuffer) 

static bool js_cc_pipeline_InstancedBuffer_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedBuffer *arg1 = (cc::pipeline::InstancedBuffer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_InstancedBuffer_destroy) 

static bool js_cc_pipeline_InstancedBuffer_merge__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::InstancedBuffer *arg1 = (cc::pipeline::InstancedBuffer *) NULL ;
    cc::scene::Model *arg2 = (cc::scene::Model *) NULL ;
    cc::scene::SubModel *arg3 = (cc::scene::SubModel *) NULL ;
    uint32_t arg4 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "InstancedBuffer_merge,2,SWIGTYPE_p_cc__scene__Model"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "InstancedBuffer_merge,3,SWIGTYPE_p_cc__scene__SubModel"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "InstancedBuffer_merge,4,SWIGTYPE_uint32_t"); 
    
    (arg1)->merge((cc::scene::Model const *)arg2,(cc::scene::SubModel const *)arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_InstancedBuffer_merge__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::InstancedBuffer *arg1 = (cc::pipeline::InstancedBuffer *) NULL ;
    cc::scene::Model *arg2 = (cc::scene::Model *) NULL ;
    cc::scene::SubModel *arg3 = (cc::scene::SubModel *) NULL ;
    uint32_t arg4 ;
    cc::gfx::Shader *arg5 = (cc::gfx::Shader *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "InstancedBuffer_merge,2,SWIGTYPE_p_cc__scene__Model"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "InstancedBuffer_merge,3,SWIGTYPE_p_cc__scene__SubModel"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "InstancedBuffer_merge,4,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "InstancedBuffer_merge,5,SWIGTYPE_p_cc__gfx__Shader"); 
    (arg1)->merge((cc::scene::Model const *)arg2,(cc::scene::SubModel const *)arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_InstancedBuffer_merge(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_pipeline_InstancedBuffer_merge__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_pipeline_InstancedBuffer_merge__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_InstancedBuffer_merge) 

static bool js_cc_pipeline_InstancedBuffer_uploadBuffers(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedBuffer *arg1 = (cc::pipeline::InstancedBuffer *) NULL ;
    cc::gfx::CommandBuffer *arg2 = (cc::gfx::CommandBuffer *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "InstancedBuffer_uploadBuffers,2,SWIGTYPE_p_cc__gfx__CommandBuffer"); 
    (arg1)->uploadBuffers(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_InstancedBuffer_uploadBuffers) 

static bool js_cc_pipeline_InstancedBuffer_clear(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedBuffer *arg1 = (cc::pipeline::InstancedBuffer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->clear();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_InstancedBuffer_clear) 

static bool js_cc_pipeline_InstancedBuffer_setDynamicOffset(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedBuffer *arg1 = (cc::pipeline::InstancedBuffer *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "InstancedBuffer_setDynamicOffset,2,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "InstancedBuffer_setDynamicOffset,3,SWIGTYPE_uint32_t"); 
    
    (arg1)->setDynamicOffset(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_InstancedBuffer_setDynamicOffset) 

static bool js_cc_pipeline_InstancedBuffer_getInstances(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedBuffer *arg1 = (cc::pipeline::InstancedBuffer *) NULL ;
    cc::pipeline::InstancedItemList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::pipeline::InstancedItemList *) &((cc::pipeline::InstancedBuffer const *)arg1)->getInstances();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InstancedBuffer_getInstances, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_InstancedBuffer_getInstances) 

static bool js_cc_pipeline_InstancedBuffer_getPass(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedBuffer *arg1 = (cc::pipeline::InstancedBuffer *) NULL ;
    cc::scene::Pass *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::Pass *)((cc::pipeline::InstancedBuffer const *)arg1)->getPass();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InstancedBuffer_getPass, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_InstancedBuffer_getPass) 

static bool js_cc_pipeline_InstancedBuffer_hasPendingModels(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedBuffer *arg1 = (cc::pipeline::InstancedBuffer *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((cc::pipeline::InstancedBuffer const *)arg1)->hasPendingModels();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_InstancedBuffer_hasPendingModels) 

static bool js_cc_pipeline_InstancedBuffer_dynamicOffsets(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedBuffer *arg1 = (cc::pipeline::InstancedBuffer *) NULL ;
    cc::pipeline::DynamicOffsetList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::pipeline::DynamicOffsetList *) &((cc::pipeline::InstancedBuffer const *)arg1)->dynamicOffsets();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "InstancedBuffer_dynamicOffsets, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_InstancedBuffer_dynamicOffsets) 

bool js_register_cc_pipeline_InstancedBuffer(se::Object* obj) {
    auto* cls = se::Class::create("InstancedBuffer", obj, nullptr, _SE(js_new_cc_pipeline_InstancedBuffer)); 
    
    
    cls->defineFunction("destroy", _SE(js_cc_pipeline_InstancedBuffer_destroy)); 
    cls->defineFunction("merge", _SE(js_cc_pipeline_InstancedBuffer_merge)); 
    cls->defineFunction("uploadBuffers", _SE(js_cc_pipeline_InstancedBuffer_uploadBuffers)); 
    cls->defineFunction("clear", _SE(js_cc_pipeline_InstancedBuffer_clear)); 
    cls->defineFunction("setDynamicOffset", _SE(js_cc_pipeline_InstancedBuffer_setDynamicOffset)); 
    cls->defineFunction("getInstances", _SE(js_cc_pipeline_InstancedBuffer_getInstances)); 
    cls->defineFunction("getPass", _SE(js_cc_pipeline_InstancedBuffer_getPass)); 
    cls->defineFunction("hasPendingModels", _SE(js_cc_pipeline_InstancedBuffer_hasPendingModels)); 
    cls->defineFunction("dynamicOffsets", _SE(js_cc_pipeline_InstancedBuffer_dynamicOffsets)); 
    
    cls->defineStaticProperty("INITIAL_CAPACITY", nullptr, nullptr); 
    cls->defineStaticProperty("MAX_CAPACITY", nullptr, nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_InstancedBuffer));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::InstancedBuffer>(cls);
    
    __jsb_cc_pipeline_InstancedBuffer_proto = cls->getProto();
    __jsb_cc_pipeline_InstancedBuffer_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_DeferredPipeline_class = nullptr;
se::Object* __jsb_cc_pipeline_DeferredPipeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_DeferredPipeline) 

// js_ctor
static bool js_new_cc_pipeline_DeferredPipeline(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::DeferredPipeline *result;
    result = (cc::pipeline::DeferredPipeline *)new cc::pipeline::DeferredPipeline();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_DeferredPipeline, __jsb_cc_pipeline_DeferredPipeline_class, js_delete_cc_pipeline_DeferredPipeline)

static bool js_delete_cc_pipeline_DeferredPipeline(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_DeferredPipeline) 

static bool js_cc_pipeline_DeferredPipeline_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::DeferredPipeline *arg1 = (cc::pipeline::DeferredPipeline *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::DeferredPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->destroy();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_DeferredPipeline_destroy) 

static bool js_cc_pipeline_DeferredPipeline_getLightsUBO(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::DeferredPipeline *arg1 = (cc::pipeline::DeferredPipeline *) NULL ;
    cc::gfx::Buffer *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::DeferredPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Buffer *)((cc::pipeline::DeferredPipeline const *)arg1)->getLightsUBO();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeferredPipeline_getLightsUBO, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_DeferredPipeline_getLightsUBO) 

static bool js_cc_pipeline_DeferredPipeline_getValidLights(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::DeferredPipeline *arg1 = (cc::pipeline::DeferredPipeline *) NULL ;
    cc::pipeline::LightList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::DeferredPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::pipeline::LightList *) &((cc::pipeline::DeferredPipeline const *)arg1)->getValidLights();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeferredPipeline_getValidLights, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_DeferredPipeline_getValidLights) 

static bool js_cc_pipeline_DeferredPipeline_getLightBuffers(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::DeferredPipeline *arg1 = (cc::pipeline::DeferredPipeline *) NULL ;
    cc::gfx::BufferList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::DeferredPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::BufferList *) &((cc::pipeline::DeferredPipeline const *)arg1)->getLightBuffers();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeferredPipeline_getLightBuffers, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_DeferredPipeline_getLightBuffers) 

static bool js_cc_pipeline_DeferredPipeline_getLightIndexOffsets(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::DeferredPipeline *arg1 = (cc::pipeline::DeferredPipeline *) NULL ;
    cc::pipeline::UintList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::DeferredPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::pipeline::UintList *) &((cc::pipeline::DeferredPipeline const *)arg1)->getLightIndexOffsets();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeferredPipeline_getLightIndexOffsets, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_DeferredPipeline_getLightIndexOffsets) 

static bool js_cc_pipeline_DeferredPipeline_getLightIndices(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::DeferredPipeline *arg1 = (cc::pipeline::DeferredPipeline *) NULL ;
    cc::pipeline::UintList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::DeferredPipeline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::pipeline::UintList *) &((cc::pipeline::DeferredPipeline const *)arg1)->getLightIndices();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DeferredPipeline_getLightIndices, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_DeferredPipeline_getLightIndices) 

bool js_register_cc_pipeline_DeferredPipeline(se::Object* obj) {
    auto* cls = se::Class::create("DeferredPipeline", obj, __jsb_cc_pipeline_RenderPipeline_proto, _SE(js_new_cc_pipeline_DeferredPipeline)); 
    
    
    cls->defineFunction("destroy", _SE(js_cc_pipeline_DeferredPipeline_destroy)); 
    cls->defineFunction("getLightsUBO", _SE(js_cc_pipeline_DeferredPipeline_getLightsUBO)); 
    cls->defineFunction("getValidLights", _SE(js_cc_pipeline_DeferredPipeline_getValidLights)); 
    cls->defineFunction("getLightBuffers", _SE(js_cc_pipeline_DeferredPipeline_getLightBuffers)); 
    cls->defineFunction("getLightIndexOffsets", _SE(js_cc_pipeline_DeferredPipeline_getLightIndexOffsets)); 
    cls->defineFunction("getLightIndices", _SE(js_cc_pipeline_DeferredPipeline_getLightIndices)); 
    
    cls->defineStaticProperty("GBUFFER_COUNT", nullptr, nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_DeferredPipeline));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::DeferredPipeline>(cls);
    
    __jsb_cc_pipeline_DeferredPipeline_proto = cls->getProto();
    __jsb_cc_pipeline_DeferredPipeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_MainFlow_class = nullptr;
se::Object* __jsb_cc_pipeline_MainFlow_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_MainFlow) 

static bool js_cc_pipeline_MainFlow_getInitializeInfo_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlowInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::pipeline::RenderFlowInfo *) &cc::pipeline::MainFlow::getInitializeInfo();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "MainFlow_getInitializeInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_MainFlow_getInitializeInfo_static) 

// js_ctor
static bool js_new_cc_pipeline_MainFlow(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::MainFlow *result;
    result = (cc::pipeline::MainFlow *)new cc::pipeline::MainFlow();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_MainFlow, __jsb_cc_pipeline_MainFlow_class, js_delete_cc_pipeline_MainFlow)

static bool js_delete_cc_pipeline_MainFlow(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_MainFlow) 

bool js_register_cc_pipeline_MainFlow(se::Object* obj) {
    auto* cls = se::Class::create("MainFlow", obj, __jsb_cc_pipeline_RenderFlow_proto, _SE(js_new_cc_pipeline_MainFlow)); 
    
    
    
    
    cls->defineStaticFunction("getInitializeInfo", _SE(js_cc_pipeline_MainFlow_getInitializeInfo_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_MainFlow));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::MainFlow>(cls);
    
    __jsb_cc_pipeline_MainFlow_proto = cls->getProto();
    __jsb_cc_pipeline_MainFlow_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_GbufferStage_class = nullptr;
se::Object* __jsb_cc_pipeline_GbufferStage_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_GbufferStage) 

static bool js_cc_pipeline_GbufferStage_getInitializeInfo_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStageInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::pipeline::RenderStageInfo *) &cc::pipeline::GbufferStage::getInitializeInfo();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "GbufferStage_getInitializeInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GbufferStage_getInitializeInfo_static) 

// js_ctor
static bool js_new_cc_pipeline_GbufferStage(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::GbufferStage *result;
    result = (cc::pipeline::GbufferStage *)new cc::pipeline::GbufferStage();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_GbufferStage, __jsb_cc_pipeline_GbufferStage_class, js_delete_cc_pipeline_GbufferStage)

static bool js_delete_cc_pipeline_GbufferStage(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_GbufferStage) 

bool js_register_cc_pipeline_GbufferStage(se::Object* obj) {
    auto* cls = se::Class::create("GbufferStage", obj, __jsb_cc_pipeline_RenderStage_proto, _SE(js_new_cc_pipeline_GbufferStage)); 
    
    
    
    
    cls->defineStaticFunction("getInitializeInfo", _SE(js_cc_pipeline_GbufferStage_getInitializeInfo_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_GbufferStage));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::GbufferStage>(cls);
    
    __jsb_cc_pipeline_GbufferStage_proto = cls->getProto();
    __jsb_cc_pipeline_GbufferStage_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_RenderElem_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderElem_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderElem) 

static bool js_cc_pipeline_RenderElem_renderObject_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderElem *arg1 = (cc::pipeline::RenderElem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderElem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->renderObject, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderElem_renderObject_set,2,SWIGTYPE_cc__pipeline__RenderObject"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderElem_renderObject_set) 

static bool js_cc_pipeline_RenderElem_renderObject_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderElem *arg1 = (cc::pipeline::RenderElem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderElem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->renderObject, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderElem_renderObject_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->renderObject, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderElem_renderObject_get) 

static bool js_cc_pipeline_RenderElem_set_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderElem *arg1 = (cc::pipeline::RenderElem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderElem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->set, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderElem_set_set,2,SWIGTYPE_p_cc__gfx__DescriptorSet"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderElem_set_set) 

static bool js_cc_pipeline_RenderElem_set_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderElem *arg1 = (cc::pipeline::RenderElem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderElem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->set, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderElem_set_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->set, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderElem_set_get) 

static bool js_cc_pipeline_RenderElem_modelIndex_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderElem *arg1 = (cc::pipeline::RenderElem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderElem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->modelIndex, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderElem_modelIndex_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderElem_modelIndex_set) 

static bool js_cc_pipeline_RenderElem_modelIndex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderElem *arg1 = (cc::pipeline::RenderElem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderElem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->modelIndex, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderElem_modelIndex_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->modelIndex, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderElem_modelIndex_get) 

static bool js_cc_pipeline_RenderElem_passIndex_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderElem *arg1 = (cc::pipeline::RenderElem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderElem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->passIndex, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderElem_passIndex_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderElem_passIndex_set) 

static bool js_cc_pipeline_RenderElem_passIndex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderElem *arg1 = (cc::pipeline::RenderElem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderElem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->passIndex, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderElem_passIndex_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->passIndex, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderElem_passIndex_get) 

// js_ctor
static bool js_new_cc_pipeline_RenderElem(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::RenderElem *result;
    result = (cc::pipeline::RenderElem *)new cc::pipeline::RenderElem();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_RenderElem, __jsb_cc_pipeline_RenderElem_class, js_delete_cc_pipeline_RenderElem)

static bool js_delete_cc_pipeline_RenderElem(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderElem) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::RenderElem * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::RenderElem*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("renderObject", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->renderObject), ctx);
    }
    
    
    json->getProperty("set", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->set), ctx);
    }
    
    
    json->getProperty("modelIndex", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->modelIndex), ctx);
    }
    
    
    json->getProperty("passIndex", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->passIndex), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_RenderElem(se::Object* obj) {
    auto* cls = se::Class::create("RenderElem", obj, nullptr, _SE(js_new_cc_pipeline_RenderElem)); 
    
    cls->defineProperty("renderObject", _SE(js_cc_pipeline_RenderElem_renderObject_get), _SE(js_cc_pipeline_RenderElem_renderObject_set)); 
    cls->defineProperty("set", _SE(js_cc_pipeline_RenderElem_set_get), _SE(js_cc_pipeline_RenderElem_set_set)); 
    cls->defineProperty("modelIndex", _SE(js_cc_pipeline_RenderElem_modelIndex_get), _SE(js_cc_pipeline_RenderElem_modelIndex_set)); 
    cls->defineProperty("passIndex", _SE(js_cc_pipeline_RenderElem_passIndex_get), _SE(js_cc_pipeline_RenderElem_passIndex_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderElem));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderElem>(cls);
    
    __jsb_cc_pipeline_RenderElem_proto = cls->getProto();
    __jsb_cc_pipeline_RenderElem_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_LightingStage_class = nullptr;
se::Object* __jsb_cc_pipeline_LightingStage_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_LightingStage) 

static bool js_cc_pipeline_LightingStage_getInitializeInfo_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStageInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::pipeline::RenderStageInfo *) &cc::pipeline::LightingStage::getInitializeInfo();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "LightingStage_getInitializeInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_LightingStage_getInitializeInfo_static) 

// js_ctor
static bool js_new_cc_pipeline_LightingStage(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::LightingStage *result;
    result = (cc::pipeline::LightingStage *)new cc::pipeline::LightingStage();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_LightingStage, __jsb_cc_pipeline_LightingStage_class, js_delete_cc_pipeline_LightingStage)

static bool js_delete_cc_pipeline_LightingStage(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_LightingStage) 

bool js_register_cc_pipeline_LightingStage(se::Object* obj) {
    auto* cls = se::Class::create("LightingStage", obj, __jsb_cc_pipeline_RenderStage_proto, _SE(js_new_cc_pipeline_LightingStage)); 
    
    
    
    
    cls->defineStaticFunction("getInitializeInfo", _SE(js_cc_pipeline_LightingStage_getInitializeInfo_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_LightingStage));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::LightingStage>(cls);
    
    __jsb_cc_pipeline_LightingStage_proto = cls->getProto();
    __jsb_cc_pipeline_LightingStage_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_BloomStage_class = nullptr;
se::Object* __jsb_cc_pipeline_BloomStage_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_BloomStage) 

// js_ctor
static bool js_new_cc_pipeline_BloomStage(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::BloomStage *result;
    result = (cc::pipeline::BloomStage *)new cc::pipeline::BloomStage();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_BloomStage, __jsb_cc_pipeline_BloomStage_class, js_delete_cc_pipeline_BloomStage)

static bool js_delete_cc_pipeline_BloomStage(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_BloomStage) 

static bool js_cc_pipeline_BloomStage_getInitializeInfo_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStageInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::pipeline::RenderStageInfo *) &cc::pipeline::BloomStage::getInitializeInfo();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BloomStage_getInitializeInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_BloomStage_getInitializeInfo_static) 

static bool js_cc_pipeline_BloomStage_getPrefilterUBO(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BloomStage *arg1 = (cc::pipeline::BloomStage *) NULL ;
    cc::gfx::Buffer *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::BloomStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Buffer *)(arg1)->getPrefilterUBO();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BloomStage_getPrefilterUBO, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_BloomStage_getPrefilterUBO) 

static bool js_cc_pipeline_BloomStage_getDownsampleUBO(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BloomStage *arg1 = (cc::pipeline::BloomStage *) NULL ;
    cc::pipeline::BloomStage::SampleUBOArray *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::BloomStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::pipeline::BloomStage::SampleUBOArray *) &(arg1)->getDownsampleUBO();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BloomStage_getDownsampleUBO, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_BloomStage_getDownsampleUBO) 

static bool js_cc_pipeline_BloomStage_getUpsampleUBO(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BloomStage *arg1 = (cc::pipeline::BloomStage *) NULL ;
    cc::pipeline::BloomStage::SampleUBOArray *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::BloomStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::pipeline::BloomStage::SampleUBOArray *) &(arg1)->getUpsampleUBO();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BloomStage_getUpsampleUBO, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_BloomStage_getUpsampleUBO) 

static bool js_cc_pipeline_BloomStage_getCombineUBO(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BloomStage *arg1 = (cc::pipeline::BloomStage *) NULL ;
    cc::gfx::Buffer *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::BloomStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Buffer *)(arg1)->getCombineUBO();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BloomStage_getCombineUBO, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_BloomStage_getCombineUBO) 

static bool js_cc_pipeline_BloomStage_getSampler(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BloomStage *arg1 = (cc::pipeline::BloomStage *) NULL ;
    cc::gfx::Sampler *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::BloomStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Sampler *)((cc::pipeline::BloomStage const *)arg1)->getSampler();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BloomStage_getSampler, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_BloomStage_getSampler) 

static bool js_cc_pipeline_BloomStage_threshold_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BloomStage *arg1 = (cc::pipeline::BloomStage *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BloomStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "BloomStage_threshold_set,2,SWIGTYPE_float"); 
    cc_pipeline_BloomStage_threshold_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BloomStage_threshold_set) 

static bool js_cc_pipeline_BloomStage_threshold_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BloomStage *arg1 = (cc::pipeline::BloomStage *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BloomStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_pipeline_BloomStage_threshold_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BloomStage_threshold_get) 

static bool js_cc_pipeline_BloomStage_intensity_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BloomStage *arg1 = (cc::pipeline::BloomStage *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BloomStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "BloomStage_intensity_set,2,SWIGTYPE_float"); 
    cc_pipeline_BloomStage_intensity_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BloomStage_intensity_set) 

static bool js_cc_pipeline_BloomStage_intensity_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BloomStage *arg1 = (cc::pipeline::BloomStage *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BloomStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_pipeline_BloomStage_intensity_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BloomStage_intensity_get) 

static bool js_cc_pipeline_BloomStage_iterations_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BloomStage *arg1 = (cc::pipeline::BloomStage *) NULL ;
    int arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BloomStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "BloomStage_iterations_set,2,SWIGTYPE_int"); 
    cc_pipeline_BloomStage_iterations_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BloomStage_iterations_set) 

static bool js_cc_pipeline_BloomStage_iterations_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BloomStage *arg1 = (cc::pipeline::BloomStage *) NULL ;
    int result;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BloomStage>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (int)cc_pipeline_BloomStage_iterations_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BloomStage_iterations_get) 

bool js_register_cc_pipeline_BloomStage(se::Object* obj) {
    auto* cls = se::Class::create("BloomStage", obj, __jsb_cc_pipeline_RenderStage_proto, _SE(js_new_cc_pipeline_BloomStage)); 
    
    cls->defineProperty("threshold", _SE(js_cc_pipeline_BloomStage_threshold_get), _SE(js_cc_pipeline_BloomStage_threshold_set)); 
    cls->defineProperty("intensity", _SE(js_cc_pipeline_BloomStage_intensity_get), _SE(js_cc_pipeline_BloomStage_intensity_set)); 
    cls->defineProperty("iterations", _SE(js_cc_pipeline_BloomStage_iterations_get), _SE(js_cc_pipeline_BloomStage_iterations_set)); 
    
    cls->defineFunction("getPrefilterUBO", _SE(js_cc_pipeline_BloomStage_getPrefilterUBO)); 
    cls->defineFunction("getDownsampleUBO", _SE(js_cc_pipeline_BloomStage_getDownsampleUBO)); 
    cls->defineFunction("getUpsampleUBO", _SE(js_cc_pipeline_BloomStage_getUpsampleUBO)); 
    cls->defineFunction("getCombineUBO", _SE(js_cc_pipeline_BloomStage_getCombineUBO)); 
    cls->defineFunction("getSampler", _SE(js_cc_pipeline_BloomStage_getSampler)); 
    
    
    cls->defineStaticFunction("getInitializeInfo", _SE(js_cc_pipeline_BloomStage_getInitializeInfo_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_BloomStage));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::BloomStage>(cls);
    
    __jsb_cc_pipeline_BloomStage_proto = cls->getProto();
    __jsb_cc_pipeline_BloomStage_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_PostProcessStage_class = nullptr;
se::Object* __jsb_cc_pipeline_PostProcessStage_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_PostProcessStage) 

// js_ctor
static bool js_new_cc_pipeline_PostProcessStage(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::PostProcessStage *result;
    result = (cc::pipeline::PostProcessStage *)new cc::pipeline::PostProcessStage();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_PostProcessStage, __jsb_cc_pipeline_PostProcessStage_class, js_delete_cc_pipeline_PostProcessStage)

static bool js_delete_cc_pipeline_PostProcessStage(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_PostProcessStage) 

static bool js_cc_pipeline_PostProcessStage_getInitializeInfo_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStageInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::pipeline::RenderStageInfo *) &cc::pipeline::PostProcessStage::getInitializeInfo();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PostProcessStage_getInitializeInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PostProcessStage_getInitializeInfo_static) 

bool js_register_cc_pipeline_PostProcessStage(se::Object* obj) {
    auto* cls = se::Class::create("PostProcessStage", obj, __jsb_cc_pipeline_RenderStage_proto, _SE(js_new_cc_pipeline_PostProcessStage)); 
    
    
    
    
    cls->defineStaticFunction("getInitializeInfo", _SE(js_cc_pipeline_PostProcessStage_getInitializeInfo_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_PostProcessStage));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::PostProcessStage>(cls);
    
    __jsb_cc_pipeline_PostProcessStage_proto = cls->getProto();
    __jsb_cc_pipeline_PostProcessStage_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_PipelineSceneData_class = nullptr;
se::Object* __jsb_cc_pipeline_PipelineSceneData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_PipelineSceneData) 

// js_ctor
static bool js_new_cc_pipeline_PipelineSceneData(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::PipelineSceneData *result;
    result = (cc::pipeline::PipelineSceneData *)new cc::pipeline::PipelineSceneData();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_PipelineSceneData, __jsb_cc_pipeline_PipelineSceneData_class, js_delete_cc_pipeline_PipelineSceneData)

static bool js_delete_cc_pipeline_PipelineSceneData(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_PipelineSceneData) 

static bool js_cc_pipeline_PipelineSceneData_activate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::gfx::Device *arg2 = (cc::gfx::Device *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "PipelineSceneData_activate,2,SWIGTYPE_p_cc__gfx__Device"); 
    (arg1)->activate(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_activate) 

static bool js_cc_pipeline_PipelineSceneData_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_destroy) 

static bool js_cc_pipeline_PipelineSceneData_updatePipelineSceneData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->updatePipelineSceneData();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_updatePipelineSceneData) 

static bool js_cc_pipeline_PipelineSceneData_setShadowFramebuffer(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::scene::Light *arg2 = (cc::scene::Light *) NULL ;
    cc::gfx::Framebuffer *arg3 = (cc::gfx::Framebuffer *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "PipelineSceneData_setShadowFramebuffer,2,SWIGTYPE_p_cc__scene__Light"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "PipelineSceneData_setShadowFramebuffer,3,SWIGTYPE_p_cc__gfx__Framebuffer"); 
    (arg1)->setShadowFramebuffer((cc::scene::Light const *)arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_setShadowFramebuffer) 

static bool js_cc_pipeline_PipelineSceneData_getValidPunctualLights(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    ccstd::vector< cc::scene::Light const * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::scene::Light const * > *) &((cc::pipeline::PipelineSceneData const *)arg1)->getValidPunctualLights();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineSceneData_getValidPunctualLights, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_getValidPunctualLights) 

static bool js_cc_pipeline_PipelineSceneData_getOctree(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::scene::Octree *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::Octree *)((cc::pipeline::PipelineSceneData const *)arg1)->getOctree();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineSceneData_getOctree, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_getOctree) 

static bool js_cc_pipeline_PipelineSceneData_getOcclusionQueryInputAssembler(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::gfx::InputAssembler *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::InputAssembler *)((cc::pipeline::PipelineSceneData const *)arg1)->getOcclusionQueryInputAssembler();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineSceneData_getOcclusionQueryInputAssembler, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_getOcclusionQueryInputAssembler) 

static bool js_cc_pipeline_PipelineSceneData_getOcclusionQueryPass(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::scene::Pass *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::Pass *)((cc::pipeline::PipelineSceneData const *)arg1)->getOcclusionQueryPass();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineSceneData_getOcclusionQueryPass, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_getOcclusionQueryPass) 

static bool js_cc_pipeline_PipelineSceneData_getOcclusionQueryShader(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::gfx::Shader *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Shader *)((cc::pipeline::PipelineSceneData const *)arg1)->getOcclusionQueryShader();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineSceneData_getOcclusionQueryShader, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_getOcclusionQueryShader) 

static bool js_cc_pipeline_PipelineSceneData_getGeometryRendererMaterials(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::Material > > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::IntrusivePtr< cc::Material > > *) &((cc::pipeline::PipelineSceneData const *)arg1)->getGeometryRendererMaterials();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineSceneData_getGeometryRendererMaterials, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_getGeometryRendererMaterials) 

static bool js_cc_pipeline_PipelineSceneData_getGeometryRendererPasses(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    ccstd::vector< cc::scene::Pass * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::scene::Pass * > *) &((cc::pipeline::PipelineSceneData const *)arg1)->getGeometryRendererPasses();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineSceneData_getGeometryRendererPasses, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_getGeometryRendererPasses) 

static bool js_cc_pipeline_PipelineSceneData_getGeometryRendererShaders(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    ccstd::vector< cc::gfx::Shader * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::gfx::Shader * > *) &((cc::pipeline::PipelineSceneData const *)arg1)->getGeometryRendererShaders();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineSceneData_getGeometryRendererShaders, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_getGeometryRendererShaders) 

static bool js_cc_pipeline_PipelineSceneData_getDebugRendererPass(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::scene::Pass *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::Pass *)((cc::pipeline::PipelineSceneData const *)arg1)->getDebugRendererPass();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineSceneData_getDebugRendererPass, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_getDebugRendererPass) 

static bool js_cc_pipeline_PipelineSceneData_getDebugRendererShader(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::gfx::Shader *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Shader *)((cc::pipeline::PipelineSceneData const *)arg1)->getDebugRendererShader();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineSceneData_getDebugRendererShader, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_getDebugRendererShader) 

static bool js_cc_pipeline_PipelineSceneData_addRenderObject(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::pipeline::RenderObject *arg2 = 0 ;
    cc::pipeline::RenderObject temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "PipelineSceneData_addRenderObject,2,SWIGTYPE_p_cc__pipeline__RenderObject");
    arg2 = &temp2;
    
    (arg1)->addRenderObject((cc::pipeline::RenderObject &&)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_addRenderObject) 

static bool js_cc_pipeline_PipelineSceneData_clearRenderObjects(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->clearRenderObjects();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_clearRenderObjects) 

static bool js_cc_pipeline_PipelineSceneData_addValidPunctualLight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::scene::Light *arg2 = (cc::scene::Light *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "PipelineSceneData_addValidPunctualLight,2,SWIGTYPE_p_cc__scene__Light"); 
    (arg1)->addValidPunctualLight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_addValidPunctualLight) 

static bool js_cc_pipeline_PipelineSceneData_clearValidPunctualLights(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->clearValidPunctualLights();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_clearValidPunctualLights) 

static bool js_cc_pipeline_PipelineSceneData_isHDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "PipelineSceneData_isHDR_set,2,SWIGTYPE_bool"); 
    cc_pipeline_PipelineSceneData_isHDR_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_PipelineSceneData_isHDR_set) 

static bool js_cc_pipeline_PipelineSceneData_isHDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_pipeline_PipelineSceneData_isHDR_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_PipelineSceneData_isHDR_get) 

static bool js_cc_pipeline_PipelineSceneData_shadingScale_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "PipelineSceneData_shadingScale_set,2,SWIGTYPE_float"); 
    cc_pipeline_PipelineSceneData_shadingScale_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_PipelineSceneData_shadingScale_set) 

static bool js_cc_pipeline_PipelineSceneData_shadingScale_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_pipeline_PipelineSceneData_shadingScale_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_PipelineSceneData_shadingScale_get) 

static bool js_cc_pipeline_PipelineSceneData_fog_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::scene::Fog *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::Fog *)cc_pipeline_PipelineSceneData_fog_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineSceneData_fog_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_PipelineSceneData_fog_get) 

static bool js_cc_pipeline_PipelineSceneData_ambient_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::scene::Ambient *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::Ambient *)cc_pipeline_PipelineSceneData_ambient_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineSceneData_ambient_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_PipelineSceneData_ambient_get) 

static bool js_cc_pipeline_PipelineSceneData_skybox_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::scene::Skybox *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::Skybox *)cc_pipeline_PipelineSceneData_skybox_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineSceneData_skybox_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_PipelineSceneData_skybox_get) 

static bool js_cc_pipeline_PipelineSceneData_shadows_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::scene::Shadows *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::Shadows *)cc_pipeline_PipelineSceneData_shadows_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PipelineSceneData_shadows_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_PipelineSceneData_shadows_get) 

bool js_register_cc_pipeline_PipelineSceneData(se::Object* obj) {
    auto* cls = se::Class::create("PipelineSceneData", obj, nullptr, _SE(js_new_cc_pipeline_PipelineSceneData)); 
    
    cls->defineProperty("isHDR", _SE(js_cc_pipeline_PipelineSceneData_isHDR_get), _SE(js_cc_pipeline_PipelineSceneData_isHDR_set)); 
    cls->defineProperty("shadingScale", _SE(js_cc_pipeline_PipelineSceneData_shadingScale_get), _SE(js_cc_pipeline_PipelineSceneData_shadingScale_set)); 
    cls->defineProperty("fog", _SE(js_cc_pipeline_PipelineSceneData_fog_get), nullptr); 
    cls->defineProperty("ambient", _SE(js_cc_pipeline_PipelineSceneData_ambient_get), nullptr); 
    cls->defineProperty("skybox", _SE(js_cc_pipeline_PipelineSceneData_skybox_get), nullptr); 
    cls->defineProperty("shadows", _SE(js_cc_pipeline_PipelineSceneData_shadows_get), nullptr); 
    
    cls->defineFunction("activate", _SE(js_cc_pipeline_PipelineSceneData_activate)); 
    cls->defineFunction("destroy", _SE(js_cc_pipeline_PipelineSceneData_destroy)); 
    cls->defineFunction("updatePipelineSceneData", _SE(js_cc_pipeline_PipelineSceneData_updatePipelineSceneData)); 
    cls->defineFunction("setShadowFramebuffer", _SE(js_cc_pipeline_PipelineSceneData_setShadowFramebuffer)); 
    cls->defineFunction("getValidPunctualLights", _SE(js_cc_pipeline_PipelineSceneData_getValidPunctualLights)); 
    cls->defineFunction("getOctree", _SE(js_cc_pipeline_PipelineSceneData_getOctree)); 
    cls->defineFunction("getOcclusionQueryInputAssembler", _SE(js_cc_pipeline_PipelineSceneData_getOcclusionQueryInputAssembler)); 
    cls->defineFunction("getOcclusionQueryPass", _SE(js_cc_pipeline_PipelineSceneData_getOcclusionQueryPass)); 
    cls->defineFunction("getOcclusionQueryShader", _SE(js_cc_pipeline_PipelineSceneData_getOcclusionQueryShader)); 
    cls->defineFunction("getGeometryRendererMaterials", _SE(js_cc_pipeline_PipelineSceneData_getGeometryRendererMaterials)); 
    cls->defineFunction("getGeometryRendererPasses", _SE(js_cc_pipeline_PipelineSceneData_getGeometryRendererPasses)); 
    cls->defineFunction("getGeometryRendererShaders", _SE(js_cc_pipeline_PipelineSceneData_getGeometryRendererShaders)); 
    cls->defineFunction("getDebugRendererPass", _SE(js_cc_pipeline_PipelineSceneData_getDebugRendererPass)); 
    cls->defineFunction("getDebugRendererShader", _SE(js_cc_pipeline_PipelineSceneData_getDebugRendererShader)); 
    cls->defineFunction("addRenderObject", _SE(js_cc_pipeline_PipelineSceneData_addRenderObject)); 
    cls->defineFunction("clearRenderObjects", _SE(js_cc_pipeline_PipelineSceneData_clearRenderObjects)); 
    cls->defineFunction("addValidPunctualLight", _SE(js_cc_pipeline_PipelineSceneData_addValidPunctualLight)); 
    cls->defineFunction("clearValidPunctualLights", _SE(js_cc_pipeline_PipelineSceneData_clearValidPunctualLights)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_PipelineSceneData));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::PipelineSceneData>(cls);
    
    __jsb_cc_pipeline_PipelineSceneData_proto = cls->getProto();
    __jsb_cc_pipeline_PipelineSceneData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_BatchedItem_class = nullptr;
se::Object* __jsb_cc_pipeline_BatchedItem_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_BatchedItem) 

static bool js_cc_pipeline_BatchedItem_vbs_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->vbs, s.thisObject());
    SE_PRECONDITION2(ok, false, "BatchedItem_vbs_set,2,SWIGTYPE_ccstd__vectorT_cc__gfx__Buffer_p_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BatchedItem_vbs_set) 

static bool js_cc_pipeline_BatchedItem_vbs_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->vbs, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BatchedItem_vbs_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->vbs, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BatchedItem_vbs_get) 

static bool js_cc_pipeline_BatchedItem_vbDatas_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->vbDatas, s.thisObject());
    SE_PRECONDITION2(ok, false, "BatchedItem_vbDatas_set,2,SWIGTYPE_ccstd__vectorT_uint8_t_p_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BatchedItem_vbDatas_set) 

static bool js_cc_pipeline_BatchedItem_vbDatas_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->vbDatas, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BatchedItem_vbDatas_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->vbDatas, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BatchedItem_vbDatas_get) 

static bool js_cc_pipeline_BatchedItem_indexBuffer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->indexBuffer, s.thisObject());
    SE_PRECONDITION2(ok, false, "BatchedItem_indexBuffer_set,2,SWIGTYPE_p_cc__gfx__Buffer"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BatchedItem_indexBuffer_set) 

static bool js_cc_pipeline_BatchedItem_indexBuffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->indexBuffer, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BatchedItem_indexBuffer_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->indexBuffer, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BatchedItem_indexBuffer_get) 

static bool js_cc_pipeline_BatchedItem_indexData_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->indexData, s.thisObject());
    SE_PRECONDITION2(ok, false, "BatchedItem_indexData_set,2,SWIGTYPE_p_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BatchedItem_indexData_set) 

static bool js_cc_pipeline_BatchedItem_indexData_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->indexData, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BatchedItem_indexData_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->indexData, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BatchedItem_indexData_get) 

static bool js_cc_pipeline_BatchedItem_vbCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->vbCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "BatchedItem_vbCount_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BatchedItem_vbCount_set) 

static bool js_cc_pipeline_BatchedItem_vbCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->vbCount, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BatchedItem_vbCount_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->vbCount, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BatchedItem_vbCount_get) 

static bool js_cc_pipeline_BatchedItem_mergeCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->mergeCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "BatchedItem_mergeCount_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BatchedItem_mergeCount_set) 

static bool js_cc_pipeline_BatchedItem_mergeCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->mergeCount, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BatchedItem_mergeCount_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->mergeCount, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BatchedItem_mergeCount_get) 

static bool js_cc_pipeline_BatchedItem_ia_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->ia, s.thisObject());
    SE_PRECONDITION2(ok, false, "BatchedItem_ia_set,2,SWIGTYPE_p_cc__gfx__InputAssembler"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BatchedItem_ia_set) 

static bool js_cc_pipeline_BatchedItem_ia_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->ia, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BatchedItem_ia_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->ia, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BatchedItem_ia_get) 

static bool js_cc_pipeline_BatchedItem_ubo_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->ubo, s.thisObject());
    SE_PRECONDITION2(ok, false, "BatchedItem_ubo_set,2,SWIGTYPE_p_cc__gfx__Buffer"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BatchedItem_ubo_set) 

static bool js_cc_pipeline_BatchedItem_ubo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->ubo, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BatchedItem_ubo_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->ubo, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BatchedItem_ubo_get) 

static bool js_cc_pipeline_BatchedItem_uboData_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->uboData, s.thisObject());
    SE_PRECONDITION2(ok, false, "BatchedItem_uboData_set,2,SWIGTYPE_ccstd__arrayT_float_16pUBOLocalBatched__BATCHING_COUNT_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BatchedItem_uboData_set) 

static bool js_cc_pipeline_BatchedItem_uboData_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->uboData, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BatchedItem_uboData_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->uboData, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BatchedItem_uboData_get) 

static bool js_cc_pipeline_BatchedItem_descriptorSet_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->descriptorSet, s.thisObject());
    SE_PRECONDITION2(ok, false, "BatchedItem_descriptorSet_set,2,SWIGTYPE_p_cc__gfx__DescriptorSet"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BatchedItem_descriptorSet_set) 

static bool js_cc_pipeline_BatchedItem_descriptorSet_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->descriptorSet, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BatchedItem_descriptorSet_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->descriptorSet, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BatchedItem_descriptorSet_get) 

static bool js_cc_pipeline_BatchedItem_pass_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->pass, s.thisObject());
    SE_PRECONDITION2(ok, false, "BatchedItem_pass_set,2,SWIGTYPE_p_cc__scene__Pass"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BatchedItem_pass_set) 

static bool js_cc_pipeline_BatchedItem_pass_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->pass, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BatchedItem_pass_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->pass, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BatchedItem_pass_get) 

static bool js_cc_pipeline_BatchedItem_shader_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->shader, s.thisObject());
    SE_PRECONDITION2(ok, false, "BatchedItem_shader_set,2,SWIGTYPE_p_cc__gfx__Shader"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BatchedItem_shader_set) 

static bool js_cc_pipeline_BatchedItem_shader_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->shader, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BatchedItem_shader_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->shader, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BatchedItem_shader_get) 

// js_ctor
static bool js_new_cc_pipeline_BatchedItem(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::BatchedItem *result;
    result = (cc::pipeline::BatchedItem *)new cc::pipeline::BatchedItem();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_BatchedItem, __jsb_cc_pipeline_BatchedItem_class, js_delete_cc_pipeline_BatchedItem)

static bool js_delete_cc_pipeline_BatchedItem(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_BatchedItem) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::BatchedItem * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::BatchedItem*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("vbs", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->vbs), ctx);
    }
    
    
    json->getProperty("vbDatas", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->vbDatas), ctx);
    }
    
    
    json->getProperty("indexBuffer", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->indexBuffer), ctx);
    }
    
    
    json->getProperty("indexData", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->indexData), ctx);
    }
    
    
    json->getProperty("vbCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->vbCount), ctx);
    }
    
    
    json->getProperty("mergeCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->mergeCount), ctx);
    }
    
    
    json->getProperty("ia", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->ia), ctx);
    }
    
    
    json->getProperty("ubo", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->ubo), ctx);
    }
    
    
    json->getProperty("uboData", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->uboData), ctx);
    }
    
    
    json->getProperty("descriptorSet", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->descriptorSet), ctx);
    }
    
    
    json->getProperty("pass", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->pass), ctx);
    }
    
    
    json->getProperty("shader", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->shader), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_BatchedItem(se::Object* obj) {
    auto* cls = se::Class::create("BatchedItem", obj, nullptr, _SE(js_new_cc_pipeline_BatchedItem)); 
    
    cls->defineProperty("vbs", _SE(js_cc_pipeline_BatchedItem_vbs_get), _SE(js_cc_pipeline_BatchedItem_vbs_set)); 
    cls->defineProperty("vbDatas", _SE(js_cc_pipeline_BatchedItem_vbDatas_get), _SE(js_cc_pipeline_BatchedItem_vbDatas_set)); 
    cls->defineProperty("indexBuffer", _SE(js_cc_pipeline_BatchedItem_indexBuffer_get), _SE(js_cc_pipeline_BatchedItem_indexBuffer_set)); 
    cls->defineProperty("indexData", _SE(js_cc_pipeline_BatchedItem_indexData_get), _SE(js_cc_pipeline_BatchedItem_indexData_set)); 
    cls->defineProperty("vbCount", _SE(js_cc_pipeline_BatchedItem_vbCount_get), _SE(js_cc_pipeline_BatchedItem_vbCount_set)); 
    cls->defineProperty("mergeCount", _SE(js_cc_pipeline_BatchedItem_mergeCount_get), _SE(js_cc_pipeline_BatchedItem_mergeCount_set)); 
    cls->defineProperty("ia", _SE(js_cc_pipeline_BatchedItem_ia_get), _SE(js_cc_pipeline_BatchedItem_ia_set)); 
    cls->defineProperty("ubo", _SE(js_cc_pipeline_BatchedItem_ubo_get), _SE(js_cc_pipeline_BatchedItem_ubo_set)); 
    cls->defineProperty("uboData", _SE(js_cc_pipeline_BatchedItem_uboData_get), _SE(js_cc_pipeline_BatchedItem_uboData_set)); 
    cls->defineProperty("descriptorSet", _SE(js_cc_pipeline_BatchedItem_descriptorSet_get), _SE(js_cc_pipeline_BatchedItem_descriptorSet_set)); 
    cls->defineProperty("pass", _SE(js_cc_pipeline_BatchedItem_pass_get), _SE(js_cc_pipeline_BatchedItem_pass_set)); 
    cls->defineProperty("shader", _SE(js_cc_pipeline_BatchedItem_shader_get), _SE(js_cc_pipeline_BatchedItem_shader_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_BatchedItem));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::BatchedItem>(cls);
    
    __jsb_cc_pipeline_BatchedItem_proto = cls->getProto();
    __jsb_cc_pipeline_BatchedItem_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_BatchedBuffer_class = nullptr;
se::Object* __jsb_cc_pipeline_BatchedBuffer_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_BatchedBuffer) 

// js_ctor
static bool js_new_cc_pipeline_BatchedBuffer(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 1) {
        SE_REPORT_ERROR("js_new_cc_pipeline_BatchedBuffer: wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::pipeline::BatchedBuffer *result;
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_BatchedBuffer,1,SWIGTYPE_p_cc__scene__Pass"); 
    result = (cc::pipeline::BatchedBuffer *)new cc::pipeline::BatchedBuffer((cc::scene::Pass const *)arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_BatchedBuffer, __jsb_cc_pipeline_BatchedBuffer_class, js_delete_cc_pipeline_BatchedBuffer)

static bool js_delete_cc_pipeline_BatchedBuffer(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_BatchedBuffer) 

static bool js_cc_pipeline_BatchedBuffer_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedBuffer *arg1 = (cc::pipeline::BatchedBuffer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_BatchedBuffer_destroy) 

static bool js_cc_pipeline_BatchedBuffer_merge(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedBuffer *arg1 = (cc::pipeline::BatchedBuffer *) NULL ;
    cc::scene::SubModel *arg2 = (cc::scene::SubModel *) NULL ;
    uint32_t arg3 ;
    cc::scene::Model *arg4 = (cc::scene::Model *) NULL ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BatchedBuffer_merge,2,SWIGTYPE_p_cc__scene__SubModel"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "BatchedBuffer_merge,3,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "BatchedBuffer_merge,4,SWIGTYPE_p_cc__scene__Model"); 
    (arg1)->merge((cc::scene::SubModel const *)arg2,arg3,(cc::scene::Model const *)arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_BatchedBuffer_merge) 

static bool js_cc_pipeline_BatchedBuffer_clear(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedBuffer *arg1 = (cc::pipeline::BatchedBuffer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->clear();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_BatchedBuffer_clear) 

static bool js_cc_pipeline_BatchedBuffer_setDynamicOffset(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedBuffer *arg1 = (cc::pipeline::BatchedBuffer *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BatchedBuffer_setDynamicOffset,2,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "BatchedBuffer_setDynamicOffset,3,SWIGTYPE_uint32_t"); 
    
    (arg1)->setDynamicOffset(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_BatchedBuffer_setDynamicOffset) 

static bool js_cc_pipeline_BatchedBuffer_getBatches(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedBuffer *arg1 = (cc::pipeline::BatchedBuffer *) NULL ;
    cc::pipeline::BatchedItemList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::pipeline::BatchedItemList *) &((cc::pipeline::BatchedBuffer const *)arg1)->getBatches();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BatchedBuffer_getBatches, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_BatchedBuffer_getBatches) 

static bool js_cc_pipeline_BatchedBuffer_getPass(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedBuffer *arg1 = (cc::pipeline::BatchedBuffer *) NULL ;
    cc::scene::Pass *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::Pass *)((cc::pipeline::BatchedBuffer const *)arg1)->getPass();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BatchedBuffer_getPass, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_BatchedBuffer_getPass) 

static bool js_cc_pipeline_BatchedBuffer_getDynamicOffset(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedBuffer *arg1 = (cc::pipeline::BatchedBuffer *) NULL ;
    cc::pipeline::DynamicOffsetList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedBuffer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::pipeline::DynamicOffsetList *) &((cc::pipeline::BatchedBuffer const *)arg1)->getDynamicOffset();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BatchedBuffer_getDynamicOffset, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_BatchedBuffer_getDynamicOffset) 

bool js_register_cc_pipeline_BatchedBuffer(se::Object* obj) {
    auto* cls = se::Class::create("BatchedBuffer", obj, nullptr, _SE(js_new_cc_pipeline_BatchedBuffer)); 
    
    
    cls->defineFunction("destroy", _SE(js_cc_pipeline_BatchedBuffer_destroy)); 
    cls->defineFunction("merge", _SE(js_cc_pipeline_BatchedBuffer_merge)); 
    cls->defineFunction("clear", _SE(js_cc_pipeline_BatchedBuffer_clear)); 
    cls->defineFunction("setDynamicOffset", _SE(js_cc_pipeline_BatchedBuffer_setDynamicOffset)); 
    cls->defineFunction("getBatches", _SE(js_cc_pipeline_BatchedBuffer_getBatches)); 
    cls->defineFunction("getPass", _SE(js_cc_pipeline_BatchedBuffer_getPass)); 
    cls->defineFunction("getDynamicOffset", _SE(js_cc_pipeline_BatchedBuffer_getDynamicOffset)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_BatchedBuffer));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::BatchedBuffer>(cls);
    
    __jsb_cc_pipeline_BatchedBuffer_proto = cls->getProto();
    __jsb_cc_pipeline_BatchedBuffer_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

#if CC_USE_GEOMETRY_RENDERER

se::Class* __jsb_cc_pipeline_GeometryRenderer_class = nullptr;
se::Object* __jsb_cc_pipeline_GeometryRenderer_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_GeometryRenderer) 

// js_ctor
static bool js_new_cc_pipeline_GeometryRenderer(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::GeometryRenderer *result;
    result = (cc::pipeline::GeometryRenderer *)new cc::pipeline::GeometryRenderer();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_GeometryRenderer, __jsb_cc_pipeline_GeometryRenderer_class, js_delete_cc_pipeline_GeometryRenderer)

static bool js_delete_cc_pipeline_GeometryRenderer(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_GeometryRenderer) 

static bool js_cc_pipeline_GeometryRenderer_empty(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((cc::pipeline::GeometryRenderer const *)arg1)->empty();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_empty) 

static bool js_cc_pipeline_GeometryRenderer_update(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->update();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_update) 

static bool js_cc_pipeline_GeometryRenderer_addDashedLine__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::gfx::Color arg4 ;
    bool arg5 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDashedLine,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDashedLine,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDashedLine,4,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDashedLine,5,SWIGTYPE_bool"); 
    (arg1)->addDashedLine((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addDashedLine__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::gfx::Color arg4 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDashedLine,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDashedLine,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDashedLine,4,SWIGTYPE_cc__gfx__Color"); 
    
    (arg1)->addDashedLine((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addDashedLine(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addDashedLine__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_pipeline_GeometryRenderer_addDashedLine__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addDashedLine) 

static bool js_cc_pipeline_GeometryRenderer_addLine__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::gfx::Color arg4 ;
    bool arg5 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addLine,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addLine,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addLine,4,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addLine,5,SWIGTYPE_bool"); 
    (arg1)->addLine((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addLine__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::gfx::Color arg4 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addLine,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addLine,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addLine,4,SWIGTYPE_cc__gfx__Color"); 
    
    (arg1)->addLine((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addLine(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addLine__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_pipeline_GeometryRenderer_addLine__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addLine) 

static bool js_cc_pipeline_GeometryRenderer_addTriangle__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::gfx::Color arg5 ;
    bool arg6 ;
    bool arg7 ;
    bool arg8 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTriangle,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTriangle,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTriangle,4,SWIGTYPE_p_cc__Vec3");
    arg4 = &temp4;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTriangle,5,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTriangle,6,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTriangle,7,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTriangle,8,SWIGTYPE_bool"); 
    (arg1)->addTriangle((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4,arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addTriangle__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::gfx::Color arg5 ;
    bool arg6 ;
    bool arg7 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTriangle,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTriangle,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTriangle,4,SWIGTYPE_p_cc__Vec3");
    arg4 = &temp4;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTriangle,5,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTriangle,6,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTriangle,7,SWIGTYPE_bool"); 
    (arg1)->addTriangle((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addTriangle__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::gfx::Color arg5 ;
    bool arg6 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTriangle,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTriangle,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTriangle,4,SWIGTYPE_p_cc__Vec3");
    arg4 = &temp4;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTriangle,5,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTriangle,6,SWIGTYPE_bool"); 
    (arg1)->addTriangle((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addTriangle__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::gfx::Color arg5 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTriangle,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTriangle,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTriangle,4,SWIGTYPE_p_cc__Vec3");
    arg4 = &temp4;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTriangle,5,SWIGTYPE_cc__gfx__Color"); 
    
    (arg1)->addTriangle((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addTriangle(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addTriangle__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addTriangle__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addTriangle__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addTriangle__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addTriangle) 

static bool js_cc_pipeline_GeometryRenderer_addQuad__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::Vec3 *arg5 = 0 ;
    cc::gfx::Color arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    cc::Vec3 temp5 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addQuad,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addQuad,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addQuad,4,SWIGTYPE_p_cc__Vec3");
    arg4 = &temp4;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addQuad,5,SWIGTYPE_p_cc__Vec3");
    arg5 = &temp5;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addQuad,6,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addQuad,7,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addQuad,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addQuad,9,SWIGTYPE_bool"); 
    (arg1)->addQuad((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4,(cc::Vec3 const &)*arg5,arg6,arg7,arg8,arg9);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addQuad__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::Vec3 *arg5 = 0 ;
    cc::gfx::Color arg6 ;
    bool arg7 ;
    bool arg8 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    cc::Vec3 temp5 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addQuad,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addQuad,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addQuad,4,SWIGTYPE_p_cc__Vec3");
    arg4 = &temp4;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addQuad,5,SWIGTYPE_p_cc__Vec3");
    arg5 = &temp5;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addQuad,6,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addQuad,7,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addQuad,8,SWIGTYPE_bool"); 
    (arg1)->addQuad((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4,(cc::Vec3 const &)*arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addQuad__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::Vec3 *arg5 = 0 ;
    cc::gfx::Color arg6 ;
    bool arg7 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    cc::Vec3 temp5 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addQuad,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addQuad,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addQuad,4,SWIGTYPE_p_cc__Vec3");
    arg4 = &temp4;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addQuad,5,SWIGTYPE_p_cc__Vec3");
    arg5 = &temp5;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addQuad,6,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addQuad,7,SWIGTYPE_bool"); 
    (arg1)->addQuad((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4,(cc::Vec3 const &)*arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addQuad__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::Vec3 *arg5 = 0 ;
    cc::gfx::Color arg6 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    cc::Vec3 temp5 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addQuad,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addQuad,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addQuad,4,SWIGTYPE_p_cc__Vec3");
    arg4 = &temp4;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addQuad,5,SWIGTYPE_p_cc__Vec3");
    arg5 = &temp5;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addQuad,6,SWIGTYPE_cc__gfx__Color"); 
    
    (arg1)->addQuad((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4,(cc::Vec3 const &)*arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addQuad(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 8) {
        ok = js_cc_pipeline_GeometryRenderer_addQuad__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addQuad__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addQuad__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addQuad__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addQuad) 

static bool js_cc_pipeline_GeometryRenderer_addBoundingBox__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::geometry::AABB *arg2 = 0 ;
    cc::gfx::Color arg3 ;
    bool arg4 ;
    bool arg5 ;
    bool arg6 ;
    bool arg7 ;
    cc::Mat4 *arg8 = 0 ;
    cc::geometry::AABB temp2 ;
    cc::Mat4 temp8 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBoundingBox,2,SWIGTYPE_p_cc__geometry__AABB");
    arg2 = &temp2;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBoundingBox,3,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBoundingBox,4,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBoundingBox,5,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBoundingBox,6,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBoundingBox,7,SWIGTYPE_bool"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[6], &temp8, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBoundingBox,8,SWIGTYPE_p_cc__Mat4");
    arg8 = &temp8;
    
    (arg1)->addBoundingBox((cc::geometry::AABB const &)*arg2,arg3,arg4,arg5,arg6,arg7,(cc::Mat4 const &)*arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addBoundingBox__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::geometry::AABB *arg2 = 0 ;
    cc::gfx::Color arg3 ;
    bool arg4 ;
    bool arg5 ;
    bool arg6 ;
    bool arg7 ;
    cc::geometry::AABB temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBoundingBox,2,SWIGTYPE_p_cc__geometry__AABB");
    arg2 = &temp2;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBoundingBox,3,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBoundingBox,4,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBoundingBox,5,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBoundingBox,6,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBoundingBox,7,SWIGTYPE_bool"); 
    (arg1)->addBoundingBox((cc::geometry::AABB const &)*arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addBoundingBox__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::geometry::AABB *arg2 = 0 ;
    cc::gfx::Color arg3 ;
    bool arg4 ;
    bool arg5 ;
    bool arg6 ;
    cc::geometry::AABB temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBoundingBox,2,SWIGTYPE_p_cc__geometry__AABB");
    arg2 = &temp2;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBoundingBox,3,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBoundingBox,4,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBoundingBox,5,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBoundingBox,6,SWIGTYPE_bool"); 
    (arg1)->addBoundingBox((cc::geometry::AABB const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addBoundingBox__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::geometry::AABB *arg2 = 0 ;
    cc::gfx::Color arg3 ;
    bool arg4 ;
    bool arg5 ;
    cc::geometry::AABB temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBoundingBox,2,SWIGTYPE_p_cc__geometry__AABB");
    arg2 = &temp2;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBoundingBox,3,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBoundingBox,4,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBoundingBox,5,SWIGTYPE_bool"); 
    (arg1)->addBoundingBox((cc::geometry::AABB const &)*arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addBoundingBox__SWIG_4(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::geometry::AABB *arg2 = 0 ;
    cc::gfx::Color arg3 ;
    bool arg4 ;
    cc::geometry::AABB temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBoundingBox,2,SWIGTYPE_p_cc__geometry__AABB");
    arg2 = &temp2;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBoundingBox,3,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBoundingBox,4,SWIGTYPE_bool"); 
    (arg1)->addBoundingBox((cc::geometry::AABB const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addBoundingBox__SWIG_5(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::geometry::AABB *arg2 = 0 ;
    cc::gfx::Color arg3 ;
    cc::geometry::AABB temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBoundingBox,2,SWIGTYPE_p_cc__geometry__AABB");
    arg2 = &temp2;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBoundingBox,3,SWIGTYPE_cc__gfx__Color"); 
    
    (arg1)->addBoundingBox((cc::geometry::AABB const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addBoundingBox(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addBoundingBox__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addBoundingBox__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addBoundingBox__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addBoundingBox__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_pipeline_GeometryRenderer_addBoundingBox__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_pipeline_GeometryRenderer_addBoundingBox__SWIG_5(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addBoundingBox) 

static bool js_cc_pipeline_GeometryRenderer_addCross__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    bool arg5 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCross,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCross,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCross,4,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCross,5,SWIGTYPE_bool"); 
    (arg1)->addCross((cc::Vec3 const &)*arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCross__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCross,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCross,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCross,4,SWIGTYPE_cc__gfx__Color"); 
    
    (arg1)->addCross((cc::Vec3 const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCross(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addCross__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_pipeline_GeometryRenderer_addCross__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addCross) 

static bool js_cc_pipeline_GeometryRenderer_addFrustum__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::geometry::Frustum *arg2 = 0 ;
    cc::gfx::Color arg3 ;
    bool arg4 ;
    cc::geometry::Frustum temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addFrustum,2,SWIGTYPE_p_cc__geometry__Frustum");
    arg2 = &temp2;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addFrustum,3,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addFrustum,4,SWIGTYPE_bool"); 
    (arg1)->addFrustum((cc::geometry::Frustum const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addFrustum__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::geometry::Frustum *arg2 = 0 ;
    cc::gfx::Color arg3 ;
    cc::geometry::Frustum temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addFrustum,2,SWIGTYPE_p_cc__geometry__Frustum");
    arg2 = &temp2;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addFrustum,3,SWIGTYPE_cc__gfx__Color"); 
    
    (arg1)->addFrustum((cc::geometry::Frustum const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addFrustum(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_pipeline_GeometryRenderer_addFrustum__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_pipeline_GeometryRenderer_addFrustum__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addFrustum) 

static bool js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    bool arg11 ;
    cc::Mat4 *arg12 = 0 ;
    cc::Vec3 temp2 ;
    cc::Mat4 temp12 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,5,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,6,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,7,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,9,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,10,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[9], &arg11);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,11,SWIGTYPE_bool"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[10], &temp12, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,12,SWIGTYPE_p_cc__Mat4");
    arg12 = &temp12;
    
    (arg1)->addCapsule((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,(cc::Mat4 const &)*arg12);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    bool arg11 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,5,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,6,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,7,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,9,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,10,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[9], &arg11);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,11,SWIGTYPE_bool"); 
    (arg1)->addCapsule((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,5,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,6,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,7,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,9,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,10,SWIGTYPE_bool"); 
    (arg1)->addCapsule((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,5,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,6,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,7,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,9,SWIGTYPE_bool"); 
    (arg1)->addCapsule((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_4(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,5,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,6,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,7,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,8,SWIGTYPE_bool"); 
    (arg1)->addCapsule((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_5(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    uint32_t arg7 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,5,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,6,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,7,SWIGTYPE_uint32_t"); 
    
    (arg1)->addCapsule((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_6(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,5,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,6,SWIGTYPE_uint32_t"); 
    
    (arg1)->addCapsule((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_7(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCapsule,5,SWIGTYPE_cc__gfx__Color"); 
    
    (arg1)->addCapsule((cc::Vec3 const &)*arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCapsule(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 11) {
        ok = js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 10) {
        ok = js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 9) {
        ok = js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 8) {
        ok = js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_5(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_6(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_7(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addCapsule) 

static bool js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    cc::Mat4 *arg11 = 0 ;
    cc::Vec3 temp2 ;
    cc::Mat4 temp11 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,5,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,6,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,7,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,9,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,10,SWIGTYPE_bool"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[9], &temp11, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,11,SWIGTYPE_p_cc__Mat4");
    arg11 = &temp11;
    
    (arg1)->addCylinder((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,(cc::Mat4 const &)*arg11);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,5,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,6,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,7,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,9,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,10,SWIGTYPE_bool"); 
    (arg1)->addCylinder((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,5,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,6,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,7,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,9,SWIGTYPE_bool"); 
    (arg1)->addCylinder((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    bool arg8 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,5,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,6,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,7,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,8,SWIGTYPE_bool"); 
    (arg1)->addCylinder((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_4(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,5,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,6,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,7,SWIGTYPE_bool"); 
    (arg1)->addCylinder((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_5(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,5,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,6,SWIGTYPE_uint32_t"); 
    
    (arg1)->addCylinder((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_6(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCylinder,5,SWIGTYPE_cc__gfx__Color"); 
    
    (arg1)->addCylinder((cc::Vec3 const &)*arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCylinder(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 10) {
        ok = js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 9) {
        ok = js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 8) {
        ok = js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_5(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_6(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addCylinder) 

static bool js_cc_pipeline_GeometryRenderer_addCone__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    cc::Mat4 *arg11 = 0 ;
    cc::Vec3 temp2 ;
    cc::Mat4 temp11 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,5,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,6,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,7,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,9,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,10,SWIGTYPE_bool"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[9], &temp11, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,11,SWIGTYPE_p_cc__Mat4");
    arg11 = &temp11;
    
    (arg1)->addCone((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,(cc::Mat4 const &)*arg11);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCone__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,5,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,6,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,7,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,9,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,10,SWIGTYPE_bool"); 
    (arg1)->addCone((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCone__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,5,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,6,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,7,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,9,SWIGTYPE_bool"); 
    (arg1)->addCone((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCone__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    bool arg8 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,5,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,6,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,7,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,8,SWIGTYPE_bool"); 
    (arg1)->addCone((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCone__SWIG_4(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,5,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,6,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,7,SWIGTYPE_bool"); 
    (arg1)->addCone((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCone__SWIG_5(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,5,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,6,SWIGTYPE_uint32_t"); 
    
    (arg1)->addCone((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCone__SWIG_6(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCone,5,SWIGTYPE_cc__gfx__Color"); 
    
    (arg1)->addCone((cc::Vec3 const &)*arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCone(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 10) {
        ok = js_cc_pipeline_GeometryRenderer_addCone__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 9) {
        ok = js_cc_pipeline_GeometryRenderer_addCone__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 8) {
        ok = js_cc_pipeline_GeometryRenderer_addCone__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addCone__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addCone__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addCone__SWIG_5(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addCone__SWIG_6(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addCone) 

static bool js_cc_pipeline_GeometryRenderer_addCircle__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    bool arg6 ;
    bool arg7 ;
    cc::Mat4 *arg8 = 0 ;
    cc::Vec3 temp2 ;
    cc::Mat4 temp8 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCircle,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCircle,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCircle,4,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCircle,5,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCircle,6,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCircle,7,SWIGTYPE_bool"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[6], &temp8, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCircle,8,SWIGTYPE_p_cc__Mat4");
    arg8 = &temp8;
    
    (arg1)->addCircle((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,(cc::Mat4 const &)*arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCircle__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    bool arg6 ;
    bool arg7 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCircle,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCircle,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCircle,4,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCircle,5,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCircle,6,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCircle,7,SWIGTYPE_bool"); 
    (arg1)->addCircle((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCircle__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    bool arg6 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCircle,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCircle,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCircle,4,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCircle,5,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCircle,6,SWIGTYPE_bool"); 
    (arg1)->addCircle((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCircle__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCircle,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCircle,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCircle,4,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCircle,5,SWIGTYPE_uint32_t"); 
    
    (arg1)->addCircle((cc::Vec3 const &)*arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCircle__SWIG_4(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCircle,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCircle,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addCircle,4,SWIGTYPE_cc__gfx__Color"); 
    
    (arg1)->addCircle((cc::Vec3 const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCircle(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addCircle__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addCircle__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addCircle__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addCircle__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_pipeline_GeometryRenderer_addCircle__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addCircle) 

static bool js_cc_pipeline_GeometryRenderer_addArc__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    float arg5 ;
    float arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Mat4 *arg10 = 0 ;
    cc::Vec3 temp2 ;
    cc::Mat4 temp10 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,4,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,6,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,7,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,9,SWIGTYPE_bool"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[8], &temp10, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,10,SWIGTYPE_p_cc__Mat4");
    arg10 = &temp10;
    
    (arg1)->addArc((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,(cc::Mat4 const &)*arg10);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addArc__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    float arg5 ;
    float arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,4,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,6,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,7,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,9,SWIGTYPE_bool"); 
    (arg1)->addArc((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addArc__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    float arg5 ;
    float arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,4,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,6,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,7,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,8,SWIGTYPE_bool"); 
    (arg1)->addArc((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addArc__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    float arg5 ;
    float arg6 ;
    uint32_t arg7 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,4,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,6,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,7,SWIGTYPE_uint32_t"); 
    
    (arg1)->addArc((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addArc__SWIG_4(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    float arg5 ;
    float arg6 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,4,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addArc,6,SWIGTYPE_float"); 
    (arg1)->addArc((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addArc(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 9) {
        ok = js_cc_pipeline_GeometryRenderer_addArc__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 8) {
        ok = js_cc_pipeline_GeometryRenderer_addArc__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addArc__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addArc__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addArc__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addArc) 

static bool js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    bool arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Mat4 *arg10 = 0 ;
    cc::Vec3 temp2 ;
    cc::Mat4 temp10 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,4,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,5,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,6,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,7,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,9,SWIGTYPE_bool"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[8], &temp10, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,10,SWIGTYPE_p_cc__Mat4");
    arg10 = &temp10;
    
    (arg1)->addPolygon((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,(cc::Mat4 const &)*arg10);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    bool arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,4,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,5,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,6,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,7,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,9,SWIGTYPE_bool"); 
    (arg1)->addPolygon((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    bool arg6 ;
    bool arg7 ;
    bool arg8 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,4,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,5,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,6,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,7,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,8,SWIGTYPE_bool"); 
    (arg1)->addPolygon((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    bool arg6 ;
    bool arg7 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,4,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,5,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,6,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,7,SWIGTYPE_bool"); 
    (arg1)->addPolygon((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_4(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    bool arg6 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,4,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,5,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,6,SWIGTYPE_bool"); 
    (arg1)->addPolygon((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_5(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,4,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,5,SWIGTYPE_uint32_t"); 
    
    (arg1)->addPolygon((cc::Vec3 const &)*arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_6(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addPolygon,4,SWIGTYPE_cc__gfx__Color"); 
    
    (arg1)->addPolygon((cc::Vec3 const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addPolygon(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 9) {
        ok = js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 8) {
        ok = js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_5(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_6(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addPolygon) 

static bool js_cc_pipeline_GeometryRenderer_addDisc__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    bool arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Mat4 *arg10 = 0 ;
    cc::Vec3 temp2 ;
    cc::Mat4 temp10 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,4,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,5,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,6,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,7,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,9,SWIGTYPE_bool"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[8], &temp10, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,10,SWIGTYPE_p_cc__Mat4");
    arg10 = &temp10;
    
    (arg1)->addDisc((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,(cc::Mat4 const &)*arg10);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addDisc__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    bool arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,4,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,5,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,6,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,7,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,9,SWIGTYPE_bool"); 
    (arg1)->addDisc((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addDisc__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    bool arg6 ;
    bool arg7 ;
    bool arg8 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,4,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,5,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,6,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,7,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,8,SWIGTYPE_bool"); 
    (arg1)->addDisc((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addDisc__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    bool arg6 ;
    bool arg7 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,4,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,5,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,6,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,7,SWIGTYPE_bool"); 
    (arg1)->addDisc((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addDisc__SWIG_4(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    bool arg6 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,4,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,5,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,6,SWIGTYPE_bool"); 
    (arg1)->addDisc((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addDisc__SWIG_5(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,4,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,5,SWIGTYPE_uint32_t"); 
    
    (arg1)->addDisc((cc::Vec3 const &)*arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addDisc__SWIG_6(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addDisc,4,SWIGTYPE_cc__gfx__Color"); 
    
    (arg1)->addDisc((cc::Vec3 const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addDisc(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 9) {
        ok = js_cc_pipeline_GeometryRenderer_addDisc__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 8) {
        ok = js_cc_pipeline_GeometryRenderer_addDisc__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addDisc__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addDisc__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addDisc__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addDisc__SWIG_5(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_pipeline_GeometryRenderer_addDisc__SWIG_6(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addDisc) 

static bool js_cc_pipeline_GeometryRenderer_addSector__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    float arg5 ;
    float arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    bool arg11 ;
    cc::Mat4 *arg12 = 0 ;
    cc::Vec3 temp2 ;
    cc::Mat4 temp12 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,4,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,6,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,7,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,9,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,10,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[9], &arg11);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,11,SWIGTYPE_bool"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[10], &temp12, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,12,SWIGTYPE_p_cc__Mat4");
    arg12 = &temp12;
    
    (arg1)->addSector((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,(cc::Mat4 const &)*arg12);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSector__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    float arg5 ;
    float arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    bool arg11 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,4,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,6,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,7,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,9,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,10,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[9], &arg11);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,11,SWIGTYPE_bool"); 
    (arg1)->addSector((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSector__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    float arg5 ;
    float arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,4,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,6,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,7,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,9,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,10,SWIGTYPE_bool"); 
    (arg1)->addSector((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSector__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    float arg5 ;
    float arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,4,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,6,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,7,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,9,SWIGTYPE_bool"); 
    (arg1)->addSector((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSector__SWIG_4(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    float arg5 ;
    float arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,4,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,6,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,7,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,8,SWIGTYPE_bool"); 
    (arg1)->addSector((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSector__SWIG_5(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    float arg5 ;
    float arg6 ;
    uint32_t arg7 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,4,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,6,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,7,SWIGTYPE_uint32_t"); 
    
    (arg1)->addSector((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSector__SWIG_6(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    float arg5 ;
    float arg6 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,4,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSector,6,SWIGTYPE_float"); 
    (arg1)->addSector((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSector(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 11) {
        ok = js_cc_pipeline_GeometryRenderer_addSector__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 10) {
        ok = js_cc_pipeline_GeometryRenderer_addSector__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 9) {
        ok = js_cc_pipeline_GeometryRenderer_addSector__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 8) {
        ok = js_cc_pipeline_GeometryRenderer_addSector__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addSector__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addSector__SWIG_5(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addSector__SWIG_6(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addSector) 

static bool js_cc_pipeline_GeometryRenderer_addSphere__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    cc::Mat4 *arg11 = 0 ;
    cc::Vec3 temp2 ;
    cc::Mat4 temp11 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,4,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,5,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,6,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,7,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,9,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,10,SWIGTYPE_bool"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[9], &temp11, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,11,SWIGTYPE_p_cc__Mat4");
    arg11 = &temp11;
    
    (arg1)->addSphere((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,(cc::Mat4 const &)*arg11);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSphere__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,4,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,5,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,6,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,7,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,9,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,10,SWIGTYPE_bool"); 
    (arg1)->addSphere((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSphere__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,4,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,5,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,6,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,7,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,9,SWIGTYPE_bool"); 
    (arg1)->addSphere((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSphere__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    bool arg8 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,4,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,5,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,6,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,7,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,8,SWIGTYPE_bool"); 
    (arg1)->addSphere((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSphere__SWIG_4(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,4,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,5,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,6,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,7,SWIGTYPE_bool"); 
    (arg1)->addSphere((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSphere__SWIG_5(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    uint32_t arg6 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,4,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,5,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,6,SWIGTYPE_uint32_t"); 
    
    (arg1)->addSphere((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSphere__SWIG_6(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,4,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,5,SWIGTYPE_uint32_t"); 
    
    (arg1)->addSphere((cc::Vec3 const &)*arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSphere__SWIG_7(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSphere,4,SWIGTYPE_cc__gfx__Color"); 
    
    (arg1)->addSphere((cc::Vec3 const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSphere(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 10) {
        ok = js_cc_pipeline_GeometryRenderer_addSphere__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 9) {
        ok = js_cc_pipeline_GeometryRenderer_addSphere__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 8) {
        ok = js_cc_pipeline_GeometryRenderer_addSphere__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addSphere__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addSphere__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addSphere__SWIG_5(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addSphere__SWIG_6(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_pipeline_GeometryRenderer_addSphere__SWIG_7(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addSphere) 

static bool js_cc_pipeline_GeometryRenderer_addTorus__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    bool arg11 ;
    cc::Mat4 *arg12 = 0 ;
    cc::Vec3 temp2 ;
    cc::Mat4 temp12 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,5,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,6,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,7,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,9,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,10,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[9], &arg11);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,11,SWIGTYPE_bool"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[10], &temp12, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,12,SWIGTYPE_p_cc__Mat4");
    arg12 = &temp12;
    
    (arg1)->addTorus((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,(cc::Mat4 const &)*arg12);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addTorus__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    bool arg11 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,5,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,6,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,7,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,9,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,10,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[9], &arg11);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,11,SWIGTYPE_bool"); 
    (arg1)->addTorus((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addTorus__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,5,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,6,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,7,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,9,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,10,SWIGTYPE_bool"); 
    (arg1)->addTorus((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addTorus__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,5,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,6,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,7,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,9,SWIGTYPE_bool"); 
    (arg1)->addTorus((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addTorus__SWIG_4(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,5,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,6,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,7,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,8,SWIGTYPE_bool"); 
    (arg1)->addTorus((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addTorus__SWIG_5(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    uint32_t arg7 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,5,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,6,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,7,SWIGTYPE_uint32_t"); 
    
    (arg1)->addTorus((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addTorus__SWIG_6(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,5,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,6,SWIGTYPE_uint32_t"); 
    
    (arg1)->addTorus((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addTorus__SWIG_7(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,4,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addTorus,5,SWIGTYPE_cc__gfx__Color"); 
    
    (arg1)->addTorus((cc::Vec3 const &)*arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addTorus(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 11) {
        ok = js_cc_pipeline_GeometryRenderer_addTorus__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 10) {
        ok = js_cc_pipeline_GeometryRenderer_addTorus__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 9) {
        ok = js_cc_pipeline_GeometryRenderer_addTorus__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 8) {
        ok = js_cc_pipeline_GeometryRenderer_addTorus__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addTorus__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addTorus__SWIG_5(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addTorus__SWIG_6(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addTorus__SWIG_7(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addTorus) 

static bool js_cc_pipeline_GeometryRenderer_addOctahedron__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    bool arg5 ;
    bool arg6 ;
    bool arg7 ;
    bool arg8 ;
    cc::Mat4 *arg9 = 0 ;
    cc::Vec3 temp2 ;
    cc::Mat4 temp9 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,4,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,5,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,6,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,7,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,8,SWIGTYPE_bool"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[7], &temp9, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,9,SWIGTYPE_p_cc__Mat4");
    arg9 = &temp9;
    
    (arg1)->addOctahedron((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,(cc::Mat4 const &)*arg9);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addOctahedron__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    bool arg5 ;
    bool arg6 ;
    bool arg7 ;
    bool arg8 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,4,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,5,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,6,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,7,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,8,SWIGTYPE_bool"); 
    (arg1)->addOctahedron((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addOctahedron__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    bool arg5 ;
    bool arg6 ;
    bool arg7 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,4,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,5,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,6,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,7,SWIGTYPE_bool"); 
    (arg1)->addOctahedron((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addOctahedron__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    bool arg5 ;
    bool arg6 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,4,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,5,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,6,SWIGTYPE_bool"); 
    (arg1)->addOctahedron((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addOctahedron__SWIG_4(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    bool arg5 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,4,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,5,SWIGTYPE_bool"); 
    (arg1)->addOctahedron((cc::Vec3 const &)*arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addOctahedron__SWIG_5(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,3,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addOctahedron,4,SWIGTYPE_cc__gfx__Color"); 
    
    (arg1)->addOctahedron((cc::Vec3 const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addOctahedron(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 8) {
        ok = js_cc_pipeline_GeometryRenderer_addOctahedron__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addOctahedron__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addOctahedron__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addOctahedron__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addOctahedron__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_pipeline_GeometryRenderer_addOctahedron__SWIG_5(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addOctahedron) 

static bool js_cc_pipeline_GeometryRenderer_addBezier__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::Vec3 *arg5 = 0 ;
    cc::gfx::Color arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Mat4 *arg10 = 0 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    cc::Vec3 temp5 ;
    cc::Mat4 temp10 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,4,SWIGTYPE_p_cc__Vec3");
    arg4 = &temp4;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,5,SWIGTYPE_p_cc__Vec3");
    arg5 = &temp5;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,6,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,7,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,9,SWIGTYPE_bool"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[8], &temp10, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,10,SWIGTYPE_p_cc__Mat4");
    arg10 = &temp10;
    
    (arg1)->addBezier((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4,(cc::Vec3 const &)*arg5,arg6,arg7,arg8,arg9,(cc::Mat4 const &)*arg10);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addBezier__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::Vec3 *arg5 = 0 ;
    cc::gfx::Color arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    cc::Vec3 temp5 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,4,SWIGTYPE_p_cc__Vec3");
    arg4 = &temp4;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,5,SWIGTYPE_p_cc__Vec3");
    arg5 = &temp5;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,6,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,7,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,8,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,9,SWIGTYPE_bool"); 
    (arg1)->addBezier((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4,(cc::Vec3 const &)*arg5,arg6,arg7,arg8,arg9);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addBezier__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::Vec3 *arg5 = 0 ;
    cc::gfx::Color arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    cc::Vec3 temp5 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,4,SWIGTYPE_p_cc__Vec3");
    arg4 = &temp4;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,5,SWIGTYPE_p_cc__Vec3");
    arg5 = &temp5;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,6,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,7,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,8,SWIGTYPE_bool"); 
    (arg1)->addBezier((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4,(cc::Vec3 const &)*arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addBezier__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::Vec3 *arg5 = 0 ;
    cc::gfx::Color arg6 ;
    uint32_t arg7 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    cc::Vec3 temp5 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,4,SWIGTYPE_p_cc__Vec3");
    arg4 = &temp4;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,5,SWIGTYPE_p_cc__Vec3");
    arg5 = &temp5;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,6,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,7,SWIGTYPE_uint32_t"); 
    
    (arg1)->addBezier((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4,(cc::Vec3 const &)*arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addBezier__SWIG_4(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::Vec3 *arg5 = 0 ;
    cc::gfx::Color arg6 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    cc::Vec3 temp5 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,4,SWIGTYPE_p_cc__Vec3");
    arg4 = &temp4;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,5,SWIGTYPE_p_cc__Vec3");
    arg5 = &temp5;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addBezier,6,SWIGTYPE_cc__gfx__Color"); 
    
    (arg1)->addBezier((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4,(cc::Vec3 const &)*arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addBezier(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 9) {
        ok = js_cc_pipeline_GeometryRenderer_addBezier__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 8) {
        ok = js_cc_pipeline_GeometryRenderer_addBezier__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addBezier__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addBezier__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addBezier__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addBezier) 

static bool js_cc_pipeline_GeometryRenderer_addSpline__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::geometry::Spline *arg2 = 0 ;
    cc::gfx::Color arg3 ;
    uint32_t arg4 ;
    float arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    cc::geometry::Spline temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSpline,2,SWIGTYPE_p_cc__geometry__Spline");
    arg2 = &temp2;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSpline,3,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSpline,4,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSpline,5,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSpline,6,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSpline,7,SWIGTYPE_bool"); 
    (arg1)->addSpline((cc::geometry::Spline const &)*arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSpline__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::geometry::Spline *arg2 = 0 ;
    cc::gfx::Color arg3 ;
    uint32_t arg4 ;
    float arg5 ;
    uint32_t arg6 ;
    cc::geometry::Spline temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSpline,2,SWIGTYPE_p_cc__geometry__Spline");
    arg2 = &temp2;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSpline,3,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSpline,4,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSpline,5,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSpline,6,SWIGTYPE_uint32_t"); 
    
    (arg1)->addSpline((cc::geometry::Spline const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSpline__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::geometry::Spline *arg2 = 0 ;
    cc::gfx::Color arg3 ;
    uint32_t arg4 ;
    float arg5 ;
    cc::geometry::Spline temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSpline,2,SWIGTYPE_p_cc__geometry__Spline");
    arg2 = &temp2;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSpline,3,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSpline,4,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSpline,5,SWIGTYPE_float"); 
    (arg1)->addSpline((cc::geometry::Spline const &)*arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSpline__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::geometry::Spline *arg2 = 0 ;
    cc::gfx::Color arg3 ;
    uint32_t arg4 ;
    cc::geometry::Spline temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSpline,2,SWIGTYPE_p_cc__geometry__Spline");
    arg2 = &temp2;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSpline,3,SWIGTYPE_cc__gfx__Color"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSpline,4,SWIGTYPE_uint32_t"); 
    
    (arg1)->addSpline((cc::geometry::Spline const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSpline__SWIG_4(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::geometry::Spline *arg2 = 0 ;
    cc::gfx::Color arg3 ;
    cc::geometry::Spline temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSpline,2,SWIGTYPE_p_cc__geometry__Spline");
    arg2 = &temp2;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addSpline,3,SWIGTYPE_cc__gfx__Color"); 
    
    (arg1)->addSpline((cc::geometry::Spline const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSpline(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addSpline__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addSpline__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addSpline__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_pipeline_GeometryRenderer_addSpline__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_pipeline_GeometryRenderer_addSpline__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addSpline) 

static bool js_cc_pipeline_GeometryRenderer_addMesh__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    ccstd::vector< cc::Vec3 > *arg3 = 0 ;
    cc::gfx::Color arg4 ;
    bool arg5 ;
    bool arg6 ;
    cc::Mat4 *arg7 = 0 ;
    cc::Vec3 temp2 ;
    ccstd::vector< cc::Vec3 > temp3 ;
    cc::Mat4 temp7 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addMesh,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addMesh,3,SWIGTYPE_p_ccstd__vectorT_cc__Vec3_t");
    arg3 = &temp3;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addMesh,4,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addMesh,5,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addMesh,6,SWIGTYPE_bool"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[5], &temp7, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addMesh,7,SWIGTYPE_p_cc__Mat4");
    arg7 = &temp7;
    
    (arg1)->addMesh((cc::Vec3 const &)*arg2,(ccstd::vector< cc::Vec3 > const &)*arg3,arg4,arg5,arg6,(cc::Mat4 const &)*arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addMesh__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    ccstd::vector< cc::Vec3 > *arg3 = 0 ;
    cc::gfx::Color arg4 ;
    bool arg5 ;
    bool arg6 ;
    cc::Vec3 temp2 ;
    ccstd::vector< cc::Vec3 > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addMesh,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addMesh,3,SWIGTYPE_p_ccstd__vectorT_cc__Vec3_t");
    arg3 = &temp3;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addMesh,4,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addMesh,5,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addMesh,6,SWIGTYPE_bool"); 
    (arg1)->addMesh((cc::Vec3 const &)*arg2,(ccstd::vector< cc::Vec3 > const &)*arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addMesh__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    ccstd::vector< cc::Vec3 > *arg3 = 0 ;
    cc::gfx::Color arg4 ;
    bool arg5 ;
    cc::Vec3 temp2 ;
    ccstd::vector< cc::Vec3 > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addMesh,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addMesh,3,SWIGTYPE_p_ccstd__vectorT_cc__Vec3_t");
    arg3 = &temp3;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addMesh,4,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addMesh,5,SWIGTYPE_bool"); 
    (arg1)->addMesh((cc::Vec3 const &)*arg2,(ccstd::vector< cc::Vec3 > const &)*arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addMesh__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    ccstd::vector< cc::Vec3 > *arg3 = 0 ;
    cc::gfx::Color arg4 ;
    cc::Vec3 temp2 ;
    ccstd::vector< cc::Vec3 > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addMesh,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addMesh,3,SWIGTYPE_p_ccstd__vectorT_cc__Vec3_t");
    arg3 = &temp3;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addMesh,4,SWIGTYPE_cc__gfx__Color"); 
    
    (arg1)->addMesh((cc::Vec3 const &)*arg2,(ccstd::vector< cc::Vec3 > const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addMesh(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addMesh__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addMesh__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addMesh__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_pipeline_GeometryRenderer_addMesh__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addMesh) 

static bool js_cc_pipeline_GeometryRenderer_addIndexedMesh__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    ccstd::vector< cc::Vec3 > *arg3 = 0 ;
    ccstd::vector< uint32_t > *arg4 = 0 ;
    cc::gfx::Color arg5 ;
    bool arg6 ;
    bool arg7 ;
    cc::Mat4 *arg8 = 0 ;
    cc::Vec3 temp2 ;
    ccstd::vector< cc::Vec3 > temp3 ;
    ccstd::vector< uint32_t > temp4 ;
    cc::Mat4 temp8 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addIndexedMesh,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addIndexedMesh,3,SWIGTYPE_p_ccstd__vectorT_cc__Vec3_t");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addIndexedMesh,4,SWIGTYPE_p_ccstd__vectorT_uint32_t_t");
    arg4 = &temp4;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addIndexedMesh,5,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addIndexedMesh,6,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addIndexedMesh,7,SWIGTYPE_bool"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[6], &temp8, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addIndexedMesh,8,SWIGTYPE_p_cc__Mat4");
    arg8 = &temp8;
    
    (arg1)->addIndexedMesh((cc::Vec3 const &)*arg2,(ccstd::vector< cc::Vec3 > const &)*arg3,(ccstd::vector< uint32_t > const &)*arg4,arg5,arg6,arg7,(cc::Mat4 const &)*arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addIndexedMesh__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    ccstd::vector< cc::Vec3 > *arg3 = 0 ;
    ccstd::vector< uint32_t > *arg4 = 0 ;
    cc::gfx::Color arg5 ;
    bool arg6 ;
    bool arg7 ;
    cc::Vec3 temp2 ;
    ccstd::vector< cc::Vec3 > temp3 ;
    ccstd::vector< uint32_t > temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addIndexedMesh,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addIndexedMesh,3,SWIGTYPE_p_ccstd__vectorT_cc__Vec3_t");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addIndexedMesh,4,SWIGTYPE_p_ccstd__vectorT_uint32_t_t");
    arg4 = &temp4;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addIndexedMesh,5,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addIndexedMesh,6,SWIGTYPE_bool"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addIndexedMesh,7,SWIGTYPE_bool"); 
    (arg1)->addIndexedMesh((cc::Vec3 const &)*arg2,(ccstd::vector< cc::Vec3 > const &)*arg3,(ccstd::vector< uint32_t > const &)*arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addIndexedMesh__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    ccstd::vector< cc::Vec3 > *arg3 = 0 ;
    ccstd::vector< uint32_t > *arg4 = 0 ;
    cc::gfx::Color arg5 ;
    bool arg6 ;
    cc::Vec3 temp2 ;
    ccstd::vector< cc::Vec3 > temp3 ;
    ccstd::vector< uint32_t > temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addIndexedMesh,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addIndexedMesh,3,SWIGTYPE_p_ccstd__vectorT_cc__Vec3_t");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addIndexedMesh,4,SWIGTYPE_p_ccstd__vectorT_uint32_t_t");
    arg4 = &temp4;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addIndexedMesh,5,SWIGTYPE_cc__gfx__Color"); 
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addIndexedMesh,6,SWIGTYPE_bool"); 
    (arg1)->addIndexedMesh((cc::Vec3 const &)*arg2,(ccstd::vector< cc::Vec3 > const &)*arg3,(ccstd::vector< uint32_t > const &)*arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addIndexedMesh__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    ccstd::vector< cc::Vec3 > *arg3 = 0 ;
    ccstd::vector< uint32_t > *arg4 = 0 ;
    cc::gfx::Color arg5 ;
    cc::Vec3 temp2 ;
    ccstd::vector< cc::Vec3 > temp3 ;
    ccstd::vector< uint32_t > temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addIndexedMesh,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addIndexedMesh,3,SWIGTYPE_p_ccstd__vectorT_cc__Vec3_t");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addIndexedMesh,4,SWIGTYPE_p_ccstd__vectorT_uint32_t_t");
    arg4 = &temp4;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "GeometryRenderer_addIndexedMesh,5,SWIGTYPE_cc__gfx__Color"); 
    
    (arg1)->addIndexedMesh((cc::Vec3 const &)*arg2,(ccstd::vector< cc::Vec3 > const &)*arg3,(ccstd::vector< uint32_t > const &)*arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addIndexedMesh(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addIndexedMesh__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addIndexedMesh__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addIndexedMesh__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addIndexedMesh__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addIndexedMesh) 

bool js_register_cc_pipeline_GeometryRenderer(se::Object* obj) {
    auto* cls = se::Class::create("GeometryRenderer", obj, nullptr, _SE(js_new_cc_pipeline_GeometryRenderer)); 
    
    
    cls->defineFunction("empty", _SE(js_cc_pipeline_GeometryRenderer_empty)); 
    cls->defineFunction("update", _SE(js_cc_pipeline_GeometryRenderer_update)); 
    cls->defineFunction("addDashedLine", _SE(js_cc_pipeline_GeometryRenderer_addDashedLine)); 
    cls->defineFunction("addLine", _SE(js_cc_pipeline_GeometryRenderer_addLine)); 
    cls->defineFunction("addTriangle", _SE(js_cc_pipeline_GeometryRenderer_addTriangle)); 
    cls->defineFunction("addQuad", _SE(js_cc_pipeline_GeometryRenderer_addQuad)); 
    cls->defineFunction("addBoundingBox", _SE(js_cc_pipeline_GeometryRenderer_addBoundingBox)); 
    cls->defineFunction("addCross", _SE(js_cc_pipeline_GeometryRenderer_addCross)); 
    cls->defineFunction("addFrustum", _SE(js_cc_pipeline_GeometryRenderer_addFrustum)); 
    cls->defineFunction("addCapsule", _SE(js_cc_pipeline_GeometryRenderer_addCapsule)); 
    cls->defineFunction("addCylinder", _SE(js_cc_pipeline_GeometryRenderer_addCylinder)); 
    cls->defineFunction("addCone", _SE(js_cc_pipeline_GeometryRenderer_addCone)); 
    cls->defineFunction("addCircle", _SE(js_cc_pipeline_GeometryRenderer_addCircle)); 
    cls->defineFunction("addArc", _SE(js_cc_pipeline_GeometryRenderer_addArc)); 
    cls->defineFunction("addPolygon", _SE(js_cc_pipeline_GeometryRenderer_addPolygon)); 
    cls->defineFunction("addDisc", _SE(js_cc_pipeline_GeometryRenderer_addDisc)); 
    cls->defineFunction("addSector", _SE(js_cc_pipeline_GeometryRenderer_addSector)); 
    cls->defineFunction("addSphere", _SE(js_cc_pipeline_GeometryRenderer_addSphere)); 
    cls->defineFunction("addTorus", _SE(js_cc_pipeline_GeometryRenderer_addTorus)); 
    cls->defineFunction("addOctahedron", _SE(js_cc_pipeline_GeometryRenderer_addOctahedron)); 
    cls->defineFunction("addBezier", _SE(js_cc_pipeline_GeometryRenderer_addBezier)); 
    cls->defineFunction("addSpline", _SE(js_cc_pipeline_GeometryRenderer_addSpline)); 
    cls->defineFunction("addMesh", _SE(js_cc_pipeline_GeometryRenderer_addMesh)); 
    cls->defineFunction("addIndexedMesh", _SE(js_cc_pipeline_GeometryRenderer_addIndexedMesh)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_GeometryRenderer));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::GeometryRenderer>(cls);
    
    __jsb_cc_pipeline_GeometryRenderer_proto = cls->getProto();
    __jsb_cc_pipeline_GeometryRenderer_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

#endif // CC_USE_GEOMETRY_RENDERER



bool register_all_pipeline(se::Object* obj) {
    // Get the ns
    se::Value nsVal;
    if (!obj->getProperty("nr", &nsVal, true))
    {
        se::HandleObject jsobj(se::Object::createPlainObject());
        nsVal.setObject(jsobj);
        obj->setProperty("nr", nsVal);
    }
    se::Object* ns = nsVal.toObject();
    /* Register classes */
    js_register_cc_pipeline_SkinningJointCapacity(ns); 
    js_register_cc_pipeline_RenderObject(ns); 
    js_register_cc_pipeline_RenderTargetInfo(ns); 
    js_register_cc_pipeline_RenderPass(ns); 
    js_register_cc_pipeline_RenderPassDesc(ns); 
    js_register_cc_pipeline_RenderTextureDesc(ns); 
    js_register_cc_pipeline_FrameBufferDesc(ns); 
    js_register_cc_pipeline_InternalBindingDesc(ns); 
    js_register_cc_pipeline_InternalBindingInst(ns); 
    js_register_cc_pipeline_RenderQueueCreateInfo(ns); 
    js_register_cc_pipeline_RenderQueueDesc(ns); 
    js_register_cc_pipeline_UBOLocalBatched(ns); 
    js_register_cc_pipeline_UBOLocal(ns); 
    js_register_cc_pipeline_UBOWorldBound(ns); 
    js_register_cc_pipeline_UBOForwardLight(ns); 
    js_register_cc_pipeline_UBODeferredLight(ns); 
    js_register_cc_pipeline_UBOSkinningTexture(ns); 
    js_register_cc_pipeline_UBOSkinningAnimation(ns); 
    js_register_cc_pipeline_UBOSkinning(ns); 
    js_register_cc_pipeline_UBOMorph(ns); 
    js_register_cc_pipeline_UBOUILocal(ns); 
    js_register_cc_pipeline_UBOGlobal(ns); 
    js_register_cc_pipeline_UBOCamera(ns); 
    js_register_cc_pipeline_UBOShadow(ns); 
    js_register_cc_pipeline_UBOCSM(ns); 
    js_register_cc_pipeline_DescriptorSetLayoutInfos(ns); 
    js_register_cc_pipeline_SHADOWMAP(ns); 
    js_register_cc_pipeline_ENVIRONMENT(ns); 
    js_register_cc_pipeline_SPOTSHADOWMAP(ns); 
    js_register_cc_pipeline_DIFFUSEMAP(ns); 
    js_register_cc_pipeline_JOINTTEXTURE(ns); 
    js_register_cc_pipeline_REALTIMEJOINTTEXTURE(ns); 
    js_register_cc_pipeline_POSITIONMORPH(ns); 
    js_register_cc_pipeline_NORMALMORPH(ns); 
    js_register_cc_pipeline_TANGENTMORPH(ns); 
    js_register_cc_pipeline_LIGHTMAPTEXTURE(ns); 
    js_register_cc_pipeline_SPRITETEXTURE(ns); 
    js_register_cc_pipeline_REFLECTIONTEXTURE(ns); 
    js_register_cc_pipeline_REFLECTIONSTORAGE(ns); 
    js_register_cc_pipeline_RenderPipelineInfo(ns); 
    js_register_cc_pipeline_RenderPipeline(ns); 
    js_register_cc_pipeline_RenderFlowInfo(ns); 
    js_register_cc_pipeline_RenderFlow(ns); 
    js_register_cc_pipeline_RenderStageInfo(ns); 
    js_register_cc_pipeline_RenderStage(ns); 
    js_register_cc_pipeline_ForwardPipeline(ns); 
    js_register_cc_pipeline_ForwardFlow(ns); 
    js_register_cc_pipeline_ForwardStage(ns); 
    js_register_cc_pipeline_ShadowFlow(ns); 
    js_register_cc_pipeline_ShadowStage(ns); 
    js_register_cc_pipeline_ShadowTransformInfo(ns); 
    js_register_cc_pipeline_CSMLayerInfo(ns); 
    js_register_cc_pipeline_CSMLayers(ns); 
    js_register_cc_pipeline_GlobalDSManager(ns); 
    js_register_cc_pipeline_InstancedItem(ns); 
    js_register_cc_pipeline_InstancedBuffer(ns); 
    js_register_cc_pipeline_DeferredPipeline(ns); 
    js_register_cc_pipeline_MainFlow(ns); 
    js_register_cc_pipeline_GbufferStage(ns); 
    js_register_cc_pipeline_RenderElem(ns); 
    js_register_cc_pipeline_LightingStage(ns); 
    js_register_cc_pipeline_BloomStage(ns); 
    js_register_cc_pipeline_PostProcessStage(ns); 
    js_register_cc_pipeline_PipelineSceneData(ns); 
    js_register_cc_pipeline_BatchedItem(ns); 
    js_register_cc_pipeline_BatchedBuffer(ns); 
#if CC_USE_GEOMETRY_RENDERER
    js_register_cc_pipeline_GeometryRenderer(ns); 
#endif // CC_USE_GEOMETRY_RENDERER
    
    /* Register global variables & global functions */
    
    
    
    return true;
}

// clang-format on
