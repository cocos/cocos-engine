// clang-format off

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

/****************************************************************************
 Copyright (c) 2022-2023 Xiamen Yaji Software Co., Ltd.

 http://www.cocos.com

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights to
 use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 of the Software, and to permit persons to whom the Software is furnished to do so,
 subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
****************************************************************************/

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-variable"
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-variable"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4101)
#endif


#define SWIG_STD_MOVE(OBJ) std::move(OBJ)


#include <stdio.h>


#include "bindings/jswrapper/SeApi.h"
#include "bindings/manual/jsb_conversions.h"
#include "bindings/manual/jsb_global.h"


#include "bindings/auto/jsb_pipeline_auto.h"
#include "bindings/auto/jsb_scene_auto.h"
#include "bindings/auto/jsb_gfx_auto.h"
#include "bindings/auto/jsb_assets_auto.h"
#include "bindings/auto/jsb_cocos_auto.h"
#include "renderer/pipeline/PipelineUBO.h"

using namespace cc;


#define cc_pipeline_RenderPipeline_globalDSManager_get(self_) self_->getGlobalDSManager()
  

#define cc_pipeline_RenderPipeline_descriptorSet_get(self_) self_->getDescriptorSet()
  

#define cc_pipeline_RenderPipeline_descriptorSetLayout_get(self_) self_->getDescriptorSetLayout()
  

#define cc_pipeline_RenderPipeline_constantMacros_get(self_) self_->getConstantMacros()
  

#define cc_pipeline_RenderPipeline_clusterEnabled_get(self_) self_->isClusterEnabled()
#define cc_pipeline_RenderPipeline_clusterEnabled_set(self_, val_) self_->setClusterEnabled(val_)
  

#define cc_pipeline_RenderPipeline_bloomEnabled_get(self_) self_->isBloomEnabled()
#define cc_pipeline_RenderPipeline_bloomEnabled_set(self_, val_) self_->setBloomEnabled(val_)
  

#define cc_pipeline_RenderPipeline_pipelineSceneData_get(self_) self_->getPipelineSceneData()
  

#define cc_pipeline_RenderPipeline_geometryRenderer_get(self_) self_->getGeometryRenderer()
  

#define cc_pipeline_RenderPipeline_profiler_get(self_) self_->getProfiler()
#define cc_pipeline_RenderPipeline_profiler_set(self_, val_) self_->setProfiler(val_)
  

#define cc_pipeline_RenderPipeline_shadingScale_get(self_) self_->getShadingScale()
#define cc_pipeline_RenderPipeline_shadingScale_set(self_, val_) self_->setShadingScale(val_)
  

#define cc_pipeline_RenderPipeline__tag_get(self_) self_->getTag()
#define cc_pipeline_RenderPipeline__tag_set(self_, val_) self_->setTag(val_)
  

#define cc_pipeline_RenderPipeline__flows_get(self_) self_->getFlows()
#define cc_pipeline_RenderPipeline__flows_set(self_, val_) self_->setFlows(val_)
  

#define cc_pipeline_PipelineSceneData_isHDR_get(self_) self_->isHDR()
#define cc_pipeline_PipelineSceneData_isHDR_set(self_, val_) self_->setHDR(val_)
  

#define cc_pipeline_PipelineSceneData_shadingScale_get(self_) self_->getShadingScale()
#define cc_pipeline_PipelineSceneData_shadingScale_set(self_, val_) self_->setShadingScale(val_)
  

#define cc_pipeline_PipelineSceneData_fog_get(self_) self_->getFog()
  

#define cc_pipeline_PipelineSceneData_ambient_get(self_) self_->getAmbient()
  

#define cc_pipeline_PipelineSceneData_skybox_get(self_) self_->getSkybox()
  

#define cc_pipeline_PipelineSceneData_shadows_get(self_) self_->getShadows()
  

#define cc_pipeline_PipelineSceneData_lightProbes_get(self_) self_->getLightProbes()
  

#define cc_pipeline_PipelineSceneData_validPunctualLights_get(self_) self_->getValidPunctualLights()
#define cc_pipeline_PipelineSceneData_validPunctualLights_set(self_, val_) self_->setValidPunctualLights(val_)
  

#define cc_pipeline_RenderStage__name_get(self_) self_->getName()
#define cc_pipeline_RenderStage__name_set(self_, val_) self_->setName(val_)
  

#define cc_pipeline_RenderStage__priority_get(self_) self_->getPriority()
#define cc_pipeline_RenderStage__priority_set(self_, val_) self_->setPriority(val_)
  

#define cc_pipeline_RenderStage__tag_get(self_) self_->getTag()
#define cc_pipeline_RenderStage__tag_set(self_, val_) self_->setTag(val_)
  

#define cc_pipeline_BloomStage_threshold_get(self_) self_->getThreshold()
#define cc_pipeline_BloomStage_threshold_set(self_, val_) self_->setThreshold(val_)
  

#define cc_pipeline_BloomStage_intensity_get(self_) self_->getIntensity()
#define cc_pipeline_BloomStage_intensity_set(self_, val_) self_->setIntensity(val_)
  

#define cc_pipeline_BloomStage_iterations_get(self_) self_->getIterations()
#define cc_pipeline_BloomStage_iterations_set(self_, val_) self_->setIterations(val_)
  

#define cc_pipeline_RenderFlow__name_get(self_) self_->getName()
#define cc_pipeline_RenderFlow__name_set(self_, val_) self_->setName(val_)
  

#define cc_pipeline_RenderFlow__priority_get(self_) self_->getPriority()
#define cc_pipeline_RenderFlow__priority_set(self_, val_) self_->setPriority(val_)
  

#define cc_pipeline_RenderFlow__tag_get(self_) self_->getTag()
#define cc_pipeline_RenderFlow__tag_set(self_, val_) self_->setTag(val_)
  

#define cc_pipeline_RenderFlow__stages_get(self_) self_->getStages()
#define cc_pipeline_RenderFlow__stages_set(self_, val_) self_->setStages(val_)
  


se::Class* __jsb_cc_pipeline_SkinningJointCapacity_class = nullptr;
se::Object* __jsb_cc_pipeline_SkinningJointCapacity_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_SkinningJointCapacity) 

static bool js_cc_pipeline_SkinningJointCapacity_jointUniformCapacity_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    uint32_t arg1 ;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc::pipeline::SkinningJointCapacity::jointUniformCapacity = arg1;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_SkinningJointCapacity_jointUniformCapacity_set) 

static bool js_cc_pipeline_SkinningJointCapacity_jointUniformCapacity_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    uint32_t result;
    
    result = cc::pipeline::SkinningJointCapacity::jointUniformCapacity;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_SkinningJointCapacity_jointUniformCapacity_get) 

static bool js_new_cc_pipeline_SkinningJointCapacity(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::SkinningJointCapacity *result;
    result = (cc::pipeline::SkinningJointCapacity *)new cc::pipeline::SkinningJointCapacity();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_SkinningJointCapacity, __jsb_cc_pipeline_SkinningJointCapacity_class, js_delete_cc_pipeline_SkinningJointCapacity)

static bool js_delete_cc_pipeline_SkinningJointCapacity(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_SkinningJointCapacity) 

bool js_register_cc_pipeline_SkinningJointCapacity(se::Object* obj) {
    auto* cls = se::Class::create("SkinningJointCapacity", obj, nullptr, _SE(js_new_cc_pipeline_SkinningJointCapacity)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("jointUniformCapacity", _SE(js_cc_pipeline_SkinningJointCapacity_jointUniformCapacity_get), _SE(js_cc_pipeline_SkinningJointCapacity_jointUniformCapacity_set)); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_SkinningJointCapacity));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::SkinningJointCapacity>(cls);
    
    __jsb_cc_pipeline_SkinningJointCapacity_proto = cls->getProto();
    __jsb_cc_pipeline_SkinningJointCapacity_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_RenderObject_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderObject_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderObject) 

static bool js_cc_pipeline_RenderObject_depth_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderObject *arg1 = (cc::pipeline::RenderObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depth, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderObject_depth_set) 

static bool js_cc_pipeline_RenderObject_depth_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderObject *arg1 = (cc::pipeline::RenderObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depth, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderObject_depth_get) 

static bool js_cc_pipeline_RenderObject_model_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderObject *arg1 = (cc::pipeline::RenderObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->model, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderObject_model_set) 

static bool js_cc_pipeline_RenderObject_model_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderObject *arg1 = (cc::pipeline::RenderObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderObject>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->model, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->model, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderObject_model_get) 

static bool js_new_cc_pipeline_RenderObject(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::RenderObject *result;
    result = (cc::pipeline::RenderObject *)new cc::pipeline::RenderObject();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_RenderObject, __jsb_cc_pipeline_RenderObject_class, js_delete_cc_pipeline_RenderObject)

static bool js_delete_cc_pipeline_RenderObject(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderObject) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::RenderObject * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::RenderObject*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("depth", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depth), ctx);
    }
    
    
    json->getProperty("model", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->model), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_RenderObject(se::Object* obj) {
    auto* cls = se::Class::create("RenderObject", obj, nullptr, _SE(js_new_cc_pipeline_RenderObject)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("depth", _SE(js_cc_pipeline_RenderObject_depth_get), _SE(js_cc_pipeline_RenderObject_depth_set)); 
    cls->defineProperty("model", _SE(js_cc_pipeline_RenderObject_model_get), _SE(js_cc_pipeline_RenderObject_model_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderObject));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderObject>(cls);
    
    __jsb_cc_pipeline_RenderObject_proto = cls->getProto();
    __jsb_cc_pipeline_RenderObject_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_RenderTargetInfo_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderTargetInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderTargetInfo) 

static bool js_cc_pipeline_RenderTargetInfo_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderTargetInfo *arg1 = (cc::pipeline::RenderTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTargetInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->width, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderTargetInfo_width_set) 

static bool js_cc_pipeline_RenderTargetInfo_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderTargetInfo *arg1 = (cc::pipeline::RenderTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTargetInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->width, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderTargetInfo_width_get) 

static bool js_cc_pipeline_RenderTargetInfo_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderTargetInfo *arg1 = (cc::pipeline::RenderTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTargetInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->height, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderTargetInfo_height_set) 

static bool js_cc_pipeline_RenderTargetInfo_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderTargetInfo *arg1 = (cc::pipeline::RenderTargetInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTargetInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->height, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderTargetInfo_height_get) 

static bool js_new_cc_pipeline_RenderTargetInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::RenderTargetInfo *result;
    result = (cc::pipeline::RenderTargetInfo *)new cc::pipeline::RenderTargetInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_RenderTargetInfo, __jsb_cc_pipeline_RenderTargetInfo_class, js_delete_cc_pipeline_RenderTargetInfo)

static bool js_delete_cc_pipeline_RenderTargetInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderTargetInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::RenderTargetInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::RenderTargetInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("width", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->width), ctx);
    }
    
    
    json->getProperty("height", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->height), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_RenderTargetInfo(se::Object* obj) {
    auto* cls = se::Class::create("RenderTargetInfo", obj, nullptr, _SE(js_new_cc_pipeline_RenderTargetInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("width", _SE(js_cc_pipeline_RenderTargetInfo_width_get), _SE(js_cc_pipeline_RenderTargetInfo_width_set)); 
    cls->defineProperty("height", _SE(js_cc_pipeline_RenderTargetInfo_height_get), _SE(js_cc_pipeline_RenderTargetInfo_height_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderTargetInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderTargetInfo>(cls);
    
    __jsb_cc_pipeline_RenderTargetInfo_proto = cls->getProto();
    __jsb_cc_pipeline_RenderTargetInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_RenderPass_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderPass_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderPass) 

static bool js_cc_pipeline_RenderPass_priority_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPass *arg1 = (cc::pipeline::RenderPass *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->priority, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPass_priority_set) 

static bool js_cc_pipeline_RenderPass_priority_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPass *arg1 = (cc::pipeline::RenderPass *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPass>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->priority, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPass_priority_get) 

static bool js_cc_pipeline_RenderPass_hash_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPass *arg1 = (cc::pipeline::RenderPass *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->hash, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPass_hash_set) 

static bool js_cc_pipeline_RenderPass_hash_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPass *arg1 = (cc::pipeline::RenderPass *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPass>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->hash, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPass_hash_get) 

static bool js_cc_pipeline_RenderPass_depth_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPass *arg1 = (cc::pipeline::RenderPass *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depth, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPass_depth_set) 

static bool js_cc_pipeline_RenderPass_depth_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPass *arg1 = (cc::pipeline::RenderPass *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPass>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depth, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPass_depth_get) 

static bool js_cc_pipeline_RenderPass_shaderID_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPass *arg1 = (cc::pipeline::RenderPass *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->shaderID, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPass_shaderID_set) 

static bool js_cc_pipeline_RenderPass_shaderID_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPass *arg1 = (cc::pipeline::RenderPass *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPass>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->shaderID, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPass_shaderID_get) 

static bool js_cc_pipeline_RenderPass_passIndex_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPass *arg1 = (cc::pipeline::RenderPass *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->passIndex, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPass_passIndex_set) 

static bool js_cc_pipeline_RenderPass_passIndex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPass *arg1 = (cc::pipeline::RenderPass *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPass>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->passIndex, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPass_passIndex_get) 

static bool js_cc_pipeline_RenderPass_subModel_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPass *arg1 = (cc::pipeline::RenderPass *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->subModel, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPass_subModel_set) 

static bool js_cc_pipeline_RenderPass_subModel_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPass *arg1 = (cc::pipeline::RenderPass *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPass>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->subModel, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->subModel, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPass_subModel_get) 

static bool js_new_cc_pipeline_RenderPass(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::RenderPass *result;
    result = (cc::pipeline::RenderPass *)new cc::pipeline::RenderPass();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_RenderPass, __jsb_cc_pipeline_RenderPass_class, js_delete_cc_pipeline_RenderPass)

static bool js_delete_cc_pipeline_RenderPass(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderPass) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::RenderPass * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::RenderPass*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("priority", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->priority), ctx);
    }
    
    
    json->getProperty("hash", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->hash), ctx);
    }
    
    
    json->getProperty("depth", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depth), ctx);
    }
    
    
    json->getProperty("shaderID", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->shaderID), ctx);
    }
    
    
    json->getProperty("passIndex", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->passIndex), ctx);
    }
    
    
    json->getProperty("subModel", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->subModel), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_RenderPass(se::Object* obj) {
    auto* cls = se::Class::create("RenderPass", obj, nullptr, _SE(js_new_cc_pipeline_RenderPass)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("priority", _SE(js_cc_pipeline_RenderPass_priority_get), _SE(js_cc_pipeline_RenderPass_priority_set)); 
    cls->defineProperty("hash", _SE(js_cc_pipeline_RenderPass_hash_get), _SE(js_cc_pipeline_RenderPass_hash_set)); 
    cls->defineProperty("depth", _SE(js_cc_pipeline_RenderPass_depth_get), _SE(js_cc_pipeline_RenderPass_depth_set)); 
    cls->defineProperty("shaderID", _SE(js_cc_pipeline_RenderPass_shaderID_get), _SE(js_cc_pipeline_RenderPass_shaderID_set)); 
    cls->defineProperty("passIndex", _SE(js_cc_pipeline_RenderPass_passIndex_get), _SE(js_cc_pipeline_RenderPass_passIndex_set)); 
    cls->defineProperty("subModel", _SE(js_cc_pipeline_RenderPass_subModel_get), _SE(js_cc_pipeline_RenderPass_subModel_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderPass));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderPass>(cls);
    
    __jsb_cc_pipeline_RenderPass_proto = cls->getProto();
    __jsb_cc_pipeline_RenderPass_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_RenderPassDesc_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderPassDesc_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderPassDesc) 

static bool js_cc_pipeline_RenderPassDesc_index_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPassDesc *arg1 = (cc::pipeline::RenderPassDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPassDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->index, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPassDesc_index_set) 

static bool js_cc_pipeline_RenderPassDesc_index_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPassDesc *arg1 = (cc::pipeline::RenderPassDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPassDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->index, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPassDesc_index_get) 

static bool js_cc_pipeline_RenderPassDesc_colorAttachments_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPassDesc *arg1 = (cc::pipeline::RenderPassDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPassDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->colorAttachments, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPassDesc_colorAttachments_set) 

static bool js_cc_pipeline_RenderPassDesc_colorAttachments_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPassDesc *arg1 = (cc::pipeline::RenderPassDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPassDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->colorAttachments, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->colorAttachments, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPassDesc_colorAttachments_get) 

static bool js_cc_pipeline_RenderPassDesc_depthStencilAttachment_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPassDesc *arg1 = (cc::pipeline::RenderPassDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPassDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthStencilAttachment, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPassDesc_depthStencilAttachment_set) 

static bool js_cc_pipeline_RenderPassDesc_depthStencilAttachment_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPassDesc *arg1 = (cc::pipeline::RenderPassDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPassDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthStencilAttachment, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthStencilAttachment, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPassDesc_depthStencilAttachment_get) 

static bool js_new_cc_pipeline_RenderPassDesc(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::RenderPassDesc *result;
    result = (cc::pipeline::RenderPassDesc *)new cc::pipeline::RenderPassDesc();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_RenderPassDesc, __jsb_cc_pipeline_RenderPassDesc_class, js_delete_cc_pipeline_RenderPassDesc)

static bool js_delete_cc_pipeline_RenderPassDesc(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderPassDesc) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::RenderPassDesc * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::RenderPassDesc*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("index", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->index), ctx);
    }
    
    
    json->getProperty("colorAttachments", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->colorAttachments), ctx);
    }
    
    
    json->getProperty("depthStencilAttachment", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthStencilAttachment), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_RenderPassDesc(se::Object* obj) {
    auto* cls = se::Class::create("RenderPassDesc", obj, nullptr, _SE(js_new_cc_pipeline_RenderPassDesc)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("index", _SE(js_cc_pipeline_RenderPassDesc_index_get), _SE(js_cc_pipeline_RenderPassDesc_index_set)); 
    cls->defineProperty("colorAttachments", _SE(js_cc_pipeline_RenderPassDesc_colorAttachments_get), _SE(js_cc_pipeline_RenderPassDesc_colorAttachments_set)); 
    cls->defineProperty("depthStencilAttachment", _SE(js_cc_pipeline_RenderPassDesc_depthStencilAttachment_get), _SE(js_cc_pipeline_RenderPassDesc_depthStencilAttachment_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderPassDesc));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderPassDesc>(cls);
    
    __jsb_cc_pipeline_RenderPassDesc_proto = cls->getProto();
    __jsb_cc_pipeline_RenderPassDesc_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_RenderTextureDesc_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderTextureDesc_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderTextureDesc) 

static bool js_cc_pipeline_RenderTextureDesc_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderTextureDesc *arg1 = (cc::pipeline::RenderTextureDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTextureDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderTextureDesc_name_set) 

static bool js_cc_pipeline_RenderTextureDesc_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderTextureDesc *arg1 = (cc::pipeline::RenderTextureDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTextureDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderTextureDesc_name_get) 

static bool js_cc_pipeline_RenderTextureDesc_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderTextureDesc *arg1 = (cc::pipeline::RenderTextureDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTextureDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->type, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderTextureDesc_type_set) 

static bool js_cc_pipeline_RenderTextureDesc_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderTextureDesc *arg1 = (cc::pipeline::RenderTextureDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTextureDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->type, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->type, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderTextureDesc_type_get) 

static bool js_cc_pipeline_RenderTextureDesc_usage_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderTextureDesc *arg1 = (cc::pipeline::RenderTextureDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTextureDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->usage, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderTextureDesc_usage_set) 

static bool js_cc_pipeline_RenderTextureDesc_usage_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderTextureDesc *arg1 = (cc::pipeline::RenderTextureDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTextureDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->usage, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->usage, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderTextureDesc_usage_get) 

static bool js_cc_pipeline_RenderTextureDesc_format_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderTextureDesc *arg1 = (cc::pipeline::RenderTextureDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTextureDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->format, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderTextureDesc_format_set) 

static bool js_cc_pipeline_RenderTextureDesc_format_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderTextureDesc *arg1 = (cc::pipeline::RenderTextureDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTextureDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->format, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->format, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderTextureDesc_format_get) 

static bool js_cc_pipeline_RenderTextureDesc_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderTextureDesc *arg1 = (cc::pipeline::RenderTextureDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTextureDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->width, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderTextureDesc_width_set) 

static bool js_cc_pipeline_RenderTextureDesc_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderTextureDesc *arg1 = (cc::pipeline::RenderTextureDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTextureDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->width, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderTextureDesc_width_get) 

static bool js_cc_pipeline_RenderTextureDesc_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderTextureDesc *arg1 = (cc::pipeline::RenderTextureDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTextureDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->height, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderTextureDesc_height_set) 

static bool js_cc_pipeline_RenderTextureDesc_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderTextureDesc *arg1 = (cc::pipeline::RenderTextureDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderTextureDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->height, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderTextureDesc_height_get) 

static bool js_new_cc_pipeline_RenderTextureDesc(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::RenderTextureDesc *result;
    result = (cc::pipeline::RenderTextureDesc *)new cc::pipeline::RenderTextureDesc();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_RenderTextureDesc, __jsb_cc_pipeline_RenderTextureDesc_class, js_delete_cc_pipeline_RenderTextureDesc)

static bool js_delete_cc_pipeline_RenderTextureDesc(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderTextureDesc) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::RenderTextureDesc * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::RenderTextureDesc*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("usage", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->usage), ctx);
    }
    
    
    json->getProperty("format", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->format), ctx);
    }
    
    
    json->getProperty("width", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->width), ctx);
    }
    
    
    json->getProperty("height", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->height), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_RenderTextureDesc(se::Object* obj) {
    auto* cls = se::Class::create("RenderTextureDesc", obj, nullptr, _SE(js_new_cc_pipeline_RenderTextureDesc)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("name", _SE(js_cc_pipeline_RenderTextureDesc_name_get), _SE(js_cc_pipeline_RenderTextureDesc_name_set)); 
    cls->defineProperty("type", _SE(js_cc_pipeline_RenderTextureDesc_type_get), _SE(js_cc_pipeline_RenderTextureDesc_type_set)); 
    cls->defineProperty("usage", _SE(js_cc_pipeline_RenderTextureDesc_usage_get), _SE(js_cc_pipeline_RenderTextureDesc_usage_set)); 
    cls->defineProperty("format", _SE(js_cc_pipeline_RenderTextureDesc_format_get), _SE(js_cc_pipeline_RenderTextureDesc_format_set)); 
    cls->defineProperty("width", _SE(js_cc_pipeline_RenderTextureDesc_width_get), _SE(js_cc_pipeline_RenderTextureDesc_width_set)); 
    cls->defineProperty("height", _SE(js_cc_pipeline_RenderTextureDesc_height_get), _SE(js_cc_pipeline_RenderTextureDesc_height_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderTextureDesc));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderTextureDesc>(cls);
    
    __jsb_cc_pipeline_RenderTextureDesc_proto = cls->getProto();
    __jsb_cc_pipeline_RenderTextureDesc_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_FrameBufferDesc_class = nullptr;
se::Object* __jsb_cc_pipeline_FrameBufferDesc_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_FrameBufferDesc) 

static bool js_cc_pipeline_FrameBufferDesc_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::FrameBufferDesc *arg1 = (cc::pipeline::FrameBufferDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::FrameBufferDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_FrameBufferDesc_name_set) 

static bool js_cc_pipeline_FrameBufferDesc_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::FrameBufferDesc *arg1 = (cc::pipeline::FrameBufferDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::FrameBufferDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_FrameBufferDesc_name_get) 

static bool js_cc_pipeline_FrameBufferDesc_renderPass_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::FrameBufferDesc *arg1 = (cc::pipeline::FrameBufferDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::FrameBufferDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->renderPass, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_FrameBufferDesc_renderPass_set) 

static bool js_cc_pipeline_FrameBufferDesc_renderPass_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::FrameBufferDesc *arg1 = (cc::pipeline::FrameBufferDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::FrameBufferDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->renderPass, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_FrameBufferDesc_renderPass_get) 

static bool js_cc_pipeline_FrameBufferDesc_colorTextures_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::FrameBufferDesc *arg1 = (cc::pipeline::FrameBufferDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::FrameBufferDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->colorTextures, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_FrameBufferDesc_colorTextures_set) 

static bool js_cc_pipeline_FrameBufferDesc_colorTextures_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::FrameBufferDesc *arg1 = (cc::pipeline::FrameBufferDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::FrameBufferDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->colorTextures, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->colorTextures, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_FrameBufferDesc_colorTextures_get) 

static bool js_cc_pipeline_FrameBufferDesc_depthStencilTexture_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::FrameBufferDesc *arg1 = (cc::pipeline::FrameBufferDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::FrameBufferDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->depthStencilTexture, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_FrameBufferDesc_depthStencilTexture_set) 

static bool js_cc_pipeline_FrameBufferDesc_depthStencilTexture_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::FrameBufferDesc *arg1 = (cc::pipeline::FrameBufferDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::FrameBufferDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->depthStencilTexture, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->depthStencilTexture, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_FrameBufferDesc_depthStencilTexture_get) 

static bool js_new_cc_pipeline_FrameBufferDesc(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::FrameBufferDesc *result;
    result = (cc::pipeline::FrameBufferDesc *)new cc::pipeline::FrameBufferDesc();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_FrameBufferDesc, __jsb_cc_pipeline_FrameBufferDesc_class, js_delete_cc_pipeline_FrameBufferDesc)

static bool js_delete_cc_pipeline_FrameBufferDesc(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_FrameBufferDesc) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::FrameBufferDesc * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::FrameBufferDesc*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("renderPass", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->renderPass), ctx);
    }
    
    
    json->getProperty("colorTextures", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->colorTextures), ctx);
    }
    
    
    json->getProperty("depthStencilTexture", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->depthStencilTexture), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_FrameBufferDesc(se::Object* obj) {
    auto* cls = se::Class::create("FrameBufferDesc", obj, nullptr, _SE(js_new_cc_pipeline_FrameBufferDesc)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("name", _SE(js_cc_pipeline_FrameBufferDesc_name_get), _SE(js_cc_pipeline_FrameBufferDesc_name_set)); 
    cls->defineProperty("renderPass", _SE(js_cc_pipeline_FrameBufferDesc_renderPass_get), _SE(js_cc_pipeline_FrameBufferDesc_renderPass_set)); 
    cls->defineProperty("colorTextures", _SE(js_cc_pipeline_FrameBufferDesc_colorTextures_get), _SE(js_cc_pipeline_FrameBufferDesc_colorTextures_set)); 
    cls->defineProperty("depthStencilTexture", _SE(js_cc_pipeline_FrameBufferDesc_depthStencilTexture_get), _SE(js_cc_pipeline_FrameBufferDesc_depthStencilTexture_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_FrameBufferDesc));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::FrameBufferDesc>(cls);
    
    __jsb_cc_pipeline_FrameBufferDesc_proto = cls->getProto();
    __jsb_cc_pipeline_FrameBufferDesc_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


static bool js_cc_pipeline_toNumber__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::RenderFlowType arg1 ;
    std::underlying_type< cc::pipeline::RenderFlowType >::type result;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = cc::pipeline::toNumber(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_pipeline_toNumber__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::RenderPassStage arg1 ;
    std::underlying_type< cc::pipeline::RenderPassStage >::type result;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = cc::pipeline::toNumber(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

se::Class* __jsb_cc_pipeline_InternalBindingDesc_class = nullptr;
se::Object* __jsb_cc_pipeline_InternalBindingDesc_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_InternalBindingDesc) 

static bool js_cc_pipeline_InternalBindingDesc_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InternalBindingDesc *arg1 = (cc::pipeline::InternalBindingDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->type, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InternalBindingDesc_type_set) 

static bool js_cc_pipeline_InternalBindingDesc_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InternalBindingDesc *arg1 = (cc::pipeline::InternalBindingDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->type, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->type, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InternalBindingDesc_type_get) 

static bool js_cc_pipeline_InternalBindingDesc_blockInfo_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InternalBindingDesc *arg1 = (cc::pipeline::InternalBindingDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blockInfo, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InternalBindingDesc_blockInfo_set) 

static bool js_cc_pipeline_InternalBindingDesc_blockInfo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InternalBindingDesc *arg1 = (cc::pipeline::InternalBindingDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blockInfo, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blockInfo, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InternalBindingDesc_blockInfo_get) 

static bool js_cc_pipeline_InternalBindingDesc_samplerInfo_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InternalBindingDesc *arg1 = (cc::pipeline::InternalBindingDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->samplerInfo, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InternalBindingDesc_samplerInfo_set) 

static bool js_cc_pipeline_InternalBindingDesc_samplerInfo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InternalBindingDesc *arg1 = (cc::pipeline::InternalBindingDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->samplerInfo, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->samplerInfo, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InternalBindingDesc_samplerInfo_get) 

static bool js_cc_pipeline_InternalBindingDesc_defaultValue_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InternalBindingDesc *arg1 = (cc::pipeline::InternalBindingDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->defaultValue, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InternalBindingDesc_defaultValue_set) 

static bool js_cc_pipeline_InternalBindingDesc_defaultValue_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InternalBindingDesc *arg1 = (cc::pipeline::InternalBindingDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->defaultValue, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->defaultValue, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InternalBindingDesc_defaultValue_get) 

static bool js_new_cc_pipeline_InternalBindingDesc(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::InternalBindingDesc *result;
    result = (cc::pipeline::InternalBindingDesc *)new cc::pipeline::InternalBindingDesc();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_InternalBindingDesc, __jsb_cc_pipeline_InternalBindingDesc_class, js_delete_cc_pipeline_InternalBindingDesc)

static bool js_delete_cc_pipeline_InternalBindingDesc(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_InternalBindingDesc) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::InternalBindingDesc * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::InternalBindingDesc*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("type", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->type), ctx);
    }
    
    
    json->getProperty("blockInfo", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blockInfo), ctx);
    }
    
    
    json->getProperty("samplerInfo", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->samplerInfo), ctx);
    }
    
    
    json->getProperty("defaultValue", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->defaultValue), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_InternalBindingDesc(se::Object* obj) {
    auto* cls = se::Class::create("InternalBindingDesc", obj, nullptr, _SE(js_new_cc_pipeline_InternalBindingDesc)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("type", _SE(js_cc_pipeline_InternalBindingDesc_type_get), _SE(js_cc_pipeline_InternalBindingDesc_type_set)); 
    cls->defineProperty("blockInfo", _SE(js_cc_pipeline_InternalBindingDesc_blockInfo_get), _SE(js_cc_pipeline_InternalBindingDesc_blockInfo_set)); 
    cls->defineProperty("samplerInfo", _SE(js_cc_pipeline_InternalBindingDesc_samplerInfo_get), _SE(js_cc_pipeline_InternalBindingDesc_samplerInfo_set)); 
    cls->defineProperty("defaultValue", _SE(js_cc_pipeline_InternalBindingDesc_defaultValue_get), _SE(js_cc_pipeline_InternalBindingDesc_defaultValue_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_InternalBindingDesc));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::InternalBindingDesc>(cls);
    
    __jsb_cc_pipeline_InternalBindingDesc_proto = cls->getProto();
    __jsb_cc_pipeline_InternalBindingDesc_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_InternalBindingInst_class = nullptr;
se::Object* __jsb_cc_pipeline_InternalBindingInst_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_InternalBindingInst) 

static bool js_cc_pipeline_InternalBindingInst_buffer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InternalBindingInst *arg1 = (cc::pipeline::InternalBindingInst *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingInst>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->buffer, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InternalBindingInst_buffer_set) 

static bool js_cc_pipeline_InternalBindingInst_buffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InternalBindingInst *arg1 = (cc::pipeline::InternalBindingInst *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingInst>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->buffer, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->buffer, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InternalBindingInst_buffer_get) 

static bool js_cc_pipeline_InternalBindingInst_sampler_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InternalBindingInst *arg1 = (cc::pipeline::InternalBindingInst *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingInst>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->sampler, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InternalBindingInst_sampler_set) 

static bool js_cc_pipeline_InternalBindingInst_sampler_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InternalBindingInst *arg1 = (cc::pipeline::InternalBindingInst *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingInst>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->sampler, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->sampler, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InternalBindingInst_sampler_get) 

static bool js_cc_pipeline_InternalBindingInst_texture_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InternalBindingInst *arg1 = (cc::pipeline::InternalBindingInst *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingInst>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->texture, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InternalBindingInst_texture_set) 

static bool js_cc_pipeline_InternalBindingInst_texture_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InternalBindingInst *arg1 = (cc::pipeline::InternalBindingInst *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InternalBindingInst>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->texture, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->texture, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InternalBindingInst_texture_get) 

static bool js_new_cc_pipeline_InternalBindingInst(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::InternalBindingInst *result;
    result = (cc::pipeline::InternalBindingInst *)new cc::pipeline::InternalBindingInst();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_InternalBindingInst, __jsb_cc_pipeline_InternalBindingInst_class, js_delete_cc_pipeline_InternalBindingInst)

static bool js_delete_cc_pipeline_InternalBindingInst(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_InternalBindingInst) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::InternalBindingInst * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::InternalBindingInst*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("buffer", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->buffer), ctx);
    }
    
    
    json->getProperty("sampler", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->sampler), ctx);
    }
    
    
    json->getProperty("texture", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->texture), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_InternalBindingInst(se::Object* obj) {
    auto* cls = se::Class::create("InternalBindingInst", obj, __jsb_cc_pipeline_InternalBindingDesc_proto, _SE(js_new_cc_pipeline_InternalBindingInst)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("buffer", _SE(js_cc_pipeline_InternalBindingInst_buffer_get), _SE(js_cc_pipeline_InternalBindingInst_buffer_set)); 
    cls->defineProperty("sampler", _SE(js_cc_pipeline_InternalBindingInst_sampler_get), _SE(js_cc_pipeline_InternalBindingInst_sampler_set)); 
    cls->defineProperty("texture", _SE(js_cc_pipeline_InternalBindingInst_texture_get), _SE(js_cc_pipeline_InternalBindingInst_texture_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_InternalBindingInst));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::InternalBindingInst>(cls);
    
    __jsb_cc_pipeline_InternalBindingInst_proto = cls->getProto();
    __jsb_cc_pipeline_InternalBindingInst_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_RenderQueueCreateInfo_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderQueueCreateInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderQueueCreateInfo) 

static bool js_cc_pipeline_RenderQueueCreateInfo_isTransparent_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderQueueCreateInfo *arg1 = (cc::pipeline::RenderQueueCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderQueueCreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->isTransparent);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderQueueCreateInfo_isTransparent_set) 

static bool js_cc_pipeline_RenderQueueCreateInfo_isTransparent_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderQueueCreateInfo *arg1 = (cc::pipeline::RenderQueueCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderQueueCreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->isTransparent, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderQueueCreateInfo_isTransparent_get) 

static bool js_cc_pipeline_RenderQueueCreateInfo_phases_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderQueueCreateInfo *arg1 = (cc::pipeline::RenderQueueCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderQueueCreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->phases, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderQueueCreateInfo_phases_set) 

static bool js_cc_pipeline_RenderQueueCreateInfo_phases_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderQueueCreateInfo *arg1 = (cc::pipeline::RenderQueueCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderQueueCreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->phases, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderQueueCreateInfo_phases_get) 

static bool js_cc_pipeline_RenderQueueCreateInfo_sortFunc_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderQueueCreateInfo *arg1 = (cc::pipeline::RenderQueueCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderQueueCreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->sortFunc, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderQueueCreateInfo_sortFunc_set) 

static bool js_cc_pipeline_RenderQueueCreateInfo_sortFunc_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderQueueCreateInfo *arg1 = (cc::pipeline::RenderQueueCreateInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderQueueCreateInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->sortFunc, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->sortFunc, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderQueueCreateInfo_sortFunc_get) 

static bool js_new_cc_pipeline_RenderQueueCreateInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::RenderQueueCreateInfo *result;
    result = (cc::pipeline::RenderQueueCreateInfo *)new cc::pipeline::RenderQueueCreateInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_RenderQueueCreateInfo, __jsb_cc_pipeline_RenderQueueCreateInfo_class, js_delete_cc_pipeline_RenderQueueCreateInfo)

static bool js_delete_cc_pipeline_RenderQueueCreateInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderQueueCreateInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::RenderQueueCreateInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::RenderQueueCreateInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("isTransparent", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isTransparent), ctx);
    }
    
    
    json->getProperty("phases", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->phases), ctx);
    }
    
    
    json->getProperty("sortFunc", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->sortFunc), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_RenderQueueCreateInfo(se::Object* obj) {
    auto* cls = se::Class::create("RenderQueueCreateInfo", obj, nullptr, _SE(js_new_cc_pipeline_RenderQueueCreateInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("isTransparent", _SE(js_cc_pipeline_RenderQueueCreateInfo_isTransparent_get), _SE(js_cc_pipeline_RenderQueueCreateInfo_isTransparent_set)); 
    cls->defineProperty("phases", _SE(js_cc_pipeline_RenderQueueCreateInfo_phases_get), _SE(js_cc_pipeline_RenderQueueCreateInfo_phases_set)); 
    cls->defineProperty("sortFunc", _SE(js_cc_pipeline_RenderQueueCreateInfo_sortFunc_get), _SE(js_cc_pipeline_RenderQueueCreateInfo_sortFunc_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderQueueCreateInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderQueueCreateInfo>(cls);
    
    __jsb_cc_pipeline_RenderQueueCreateInfo_proto = cls->getProto();
    __jsb_cc_pipeline_RenderQueueCreateInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


static bool js_cc_pipeline_toNumber__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::RenderPriority arg1 ;
    std::underlying_type< cc::pipeline::RenderPriority >::type result;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = cc::pipeline::toNumber(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_pipeline_toNumber__SWIG_3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::RenderQueueSortMode arg1 ;
    std::underlying_type< cc::pipeline::RenderQueueSortMode >::type result;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = cc::pipeline::toNumber(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

se::Class* __jsb_cc_pipeline_RenderQueueDesc_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderQueueDesc_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderQueueDesc) 

static bool js_new_cc_pipeline_RenderQueueDesc__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderQueueDesc *result;
    result = (cc::pipeline::RenderQueueDesc *)new cc::pipeline::RenderQueueDesc();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_pipeline_RenderQueueDesc__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    bool arg1 ;
    cc::pipeline::RenderQueueSortMode arg2 ;
    ccstd::vector< ccstd::string > *arg3 = 0 ;
    ccstd::vector< ccstd::string > temp3 ;
    cc::pipeline::RenderQueueDesc *result;
    
    ok &= sevalue_to_native(args[0], &arg1);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[2], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    result = (cc::pipeline::RenderQueueDesc *)new cc::pipeline::RenderQueueDesc(arg1,arg2,(ccstd::vector< ccstd::string > const &)*arg3);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_RenderQueueDesc(se::State& s) // NOLINT(readability-identifier-naming)
{
    size_t argc = s.args().size();
    bool ret = false;
    
    if(argc == 0) {
        ret = js_new_cc_pipeline_RenderQueueDesc__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 3) {
        ret = js_new_cc_pipeline_RenderQueueDesc__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    SE_REPORT_ERROR("Illegal arguments for construction of RenderQueueDesc");
    return false;
}
SE_BIND_CTOR(js_new_RenderQueueDesc, __jsb_cc_pipeline_RenderQueueDesc_class, js_delete_cc_pipeline_RenderQueueDesc)

static bool js_cc_pipeline_RenderQueueDesc_isTransparent_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderQueueDesc *arg1 = (cc::pipeline::RenderQueueDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderQueueDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->isTransparent);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderQueueDesc_isTransparent_set) 

static bool js_cc_pipeline_RenderQueueDesc_isTransparent_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderQueueDesc *arg1 = (cc::pipeline::RenderQueueDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderQueueDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->isTransparent, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderQueueDesc_isTransparent_get) 

static bool js_cc_pipeline_RenderQueueDesc_sortMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderQueueDesc *arg1 = (cc::pipeline::RenderQueueDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderQueueDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->sortMode, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderQueueDesc_sortMode_set) 

static bool js_cc_pipeline_RenderQueueDesc_sortMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderQueueDesc *arg1 = (cc::pipeline::RenderQueueDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderQueueDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->sortMode, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->sortMode, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderQueueDesc_sortMode_get) 

static bool js_cc_pipeline_RenderQueueDesc_stages_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderQueueDesc *arg1 = (cc::pipeline::RenderQueueDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderQueueDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stages, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderQueueDesc_stages_set) 

static bool js_cc_pipeline_RenderQueueDesc_stages_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderQueueDesc *arg1 = (cc::pipeline::RenderQueueDesc *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderQueueDesc>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stages, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stages, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderQueueDesc_stages_get) 

static bool js_delete_cc_pipeline_RenderQueueDesc(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderQueueDesc) 

bool js_register_cc_pipeline_RenderQueueDesc(se::Object* obj) {
    auto* cls = se::Class::create("RenderQueueDesc", obj, nullptr, _SE(js_new_RenderQueueDesc)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("isTransparent", _SE(js_cc_pipeline_RenderQueueDesc_isTransparent_get), _SE(js_cc_pipeline_RenderQueueDesc_isTransparent_set)); 
    cls->defineProperty("sortMode", _SE(js_cc_pipeline_RenderQueueDesc_sortMode_get), _SE(js_cc_pipeline_RenderQueueDesc_sortMode_set)); 
    cls->defineProperty("stages", _SE(js_cc_pipeline_RenderQueueDesc_stages_get), _SE(js_cc_pipeline_RenderQueueDesc_stages_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderQueueDesc));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderQueueDesc>(cls);
    
    __jsb_cc_pipeline_RenderQueueDesc_proto = cls->getProto();
    __jsb_cc_pipeline_RenderQueueDesc_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


static bool js_cc_pipeline_getPhaseID(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    ccstd::string *arg1 = 0 ;
    ccstd::string temp1 ;
    uint32_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = cc::pipeline::getPhaseID((ccstd::string const &)*arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_getPhaseID) 

static bool js_cc_pipeline_opaqueCompareFn(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPass *arg1 = 0 ;
    cc::pipeline::RenderPass *arg2 = 0 ;
    cc::pipeline::RenderPass temp1 ;
    cc::pipeline::RenderPass temp2 ;
    bool result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (bool)cc::pipeline::opaqueCompareFn((cc::pipeline::RenderPass const &)*arg1,(cc::pipeline::RenderPass const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_opaqueCompareFn) 

static bool js_cc_pipeline_transparentCompareFn(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPass *arg1 = 0 ;
    cc::pipeline::RenderPass *arg2 = 0 ;
    cc::pipeline::RenderPass temp1 ;
    cc::pipeline::RenderPass temp2 ;
    bool result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (bool)cc::pipeline::transparentCompareFn((cc::pipeline::RenderPass const &)*arg1,(cc::pipeline::RenderPass const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_transparentCompareFn) 

static bool js_cc_pipeline_convertPhase(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    ccstd::vector< ccstd::string > *arg1 = 0 ;
    ccstd::vector< ccstd::string > temp1 ;
    uint32_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = cc::pipeline::convertPhase((ccstd::vector< ccstd::string > const &)*arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_convertPhase) 

static bool js_cc_pipeline_toNumber__SWIG_4(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::PipelineGlobalBindings arg1 ;
    std::underlying_type< cc::pipeline::PipelineGlobalBindings >::type result;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = cc::pipeline::toNumber(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_pipeline_toNumber__SWIG_5(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::ModelLocalBindings arg1 ;
    std::underlying_type< cc::pipeline::ModelLocalBindings >::type result;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = cc::pipeline::toNumber(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_pipeline_toNumber__SWIG_6(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::SetIndex arg1 ;
    std::underlying_type< cc::pipeline::SetIndex >::type result;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = cc::pipeline::toNumber(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

se::Class* __jsb_cc_pipeline_UBOLocalBatched_class = nullptr;
se::Object* __jsb_cc_pipeline_UBOLocalBatched_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBOLocalBatched) 

static bool js_cc_pipeline_UBOLocalBatched_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::UBOLocalBatched::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOLocalBatched_DESCRIPTOR_get) 

static bool js_cc_pipeline_UBOLocalBatched_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock result;
    
    result = cc::pipeline::UBOLocalBatched::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOLocalBatched_LAYOUT_get) 

static bool js_cc_pipeline_UBOLocalBatched_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::UBOLocalBatched::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOLocalBatched_NAME_get) 

static bool js_new_cc_pipeline_UBOLocalBatched(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBOLocalBatched *result;
    result = (cc::pipeline::UBOLocalBatched *)new cc::pipeline::UBOLocalBatched();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBOLocalBatched, __jsb_cc_pipeline_UBOLocalBatched_class, js_delete_cc_pipeline_UBOLocalBatched)

static bool js_delete_cc_pipeline_UBOLocalBatched(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBOLocalBatched) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBOLocalBatched * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBOLocalBatched*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBOLocalBatched(se::Object* obj) {
    auto* cls = se::Class::create("UBOLocalBatched", obj, nullptr, _SE(js_new_cc_pipeline_UBOLocalBatched)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("BATCHING_COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("MAT_WORLDS_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("SIZE", nullptr, nullptr); 
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_UBOLocalBatched_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_UBOLocalBatched_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_UBOLocalBatched_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBOLocalBatched));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBOLocalBatched>(cls);
    
    __jsb_cc_pipeline_UBOLocalBatched_proto = cls->getProto();
    __jsb_cc_pipeline_UBOLocalBatched_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_UBOLocal_class = nullptr;
se::Object* __jsb_cc_pipeline_UBOLocal_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBOLocal) 

static bool js_cc_pipeline_UBOLocal_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::UBOLocal::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOLocal_DESCRIPTOR_get) 

static bool js_cc_pipeline_UBOLocal_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock result;
    
    result = cc::pipeline::UBOLocal::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOLocal_LAYOUT_get) 

static bool js_cc_pipeline_UBOLocal_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::UBOLocal::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOLocal_NAME_get) 

static bool js_new_cc_pipeline_UBOLocal(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBOLocal *result;
    result = (cc::pipeline::UBOLocal *)new cc::pipeline::UBOLocal();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBOLocal, __jsb_cc_pipeline_UBOLocal_class, js_delete_cc_pipeline_UBOLocal)

static bool js_delete_cc_pipeline_UBOLocal(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBOLocal) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBOLocal * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBOLocal*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBOLocal(se::Object* obj) {
    auto* cls = se::Class::create("UBOLocal", obj, nullptr, _SE(js_new_cc_pipeline_UBOLocal)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("MAT_WORLD_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("MAT_WORLD_IT_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("LIGHTINGMAP_UVPARAM", nullptr, nullptr); 
    cls->defineStaticProperty("LOCAL_SHADOW_BIAS", nullptr, nullptr); 
    cls->defineStaticProperty("COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("SIZE", nullptr, nullptr); 
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_UBOLocal_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_UBOLocal_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_UBOLocal_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBOLocal));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBOLocal>(cls);
    
    __jsb_cc_pipeline_UBOLocal_proto = cls->getProto();
    __jsb_cc_pipeline_UBOLocal_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_UBOWorldBound_class = nullptr;
se::Object* __jsb_cc_pipeline_UBOWorldBound_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBOWorldBound) 

static bool js_cc_pipeline_UBOWorldBound_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::UBOWorldBound::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOWorldBound_DESCRIPTOR_get) 

static bool js_cc_pipeline_UBOWorldBound_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock result;
    
    result = cc::pipeline::UBOWorldBound::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOWorldBound_LAYOUT_get) 

static bool js_cc_pipeline_UBOWorldBound_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::UBOWorldBound::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOWorldBound_NAME_get) 

static bool js_new_cc_pipeline_UBOWorldBound(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBOWorldBound *result;
    result = (cc::pipeline::UBOWorldBound *)new cc::pipeline::UBOWorldBound();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBOWorldBound, __jsb_cc_pipeline_UBOWorldBound_class, js_delete_cc_pipeline_UBOWorldBound)

static bool js_delete_cc_pipeline_UBOWorldBound(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBOWorldBound) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBOWorldBound * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBOWorldBound*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBOWorldBound(se::Object* obj) {
    auto* cls = se::Class::create("UBOWorldBound", obj, nullptr, _SE(js_new_cc_pipeline_UBOWorldBound)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("WORLD_BOUND_CENTER", nullptr, nullptr); 
    cls->defineStaticProperty("WORLD_BOUND_HALF_EXTENTS", nullptr, nullptr); 
    cls->defineStaticProperty("COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("SIZE", nullptr, nullptr); 
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_UBOWorldBound_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_UBOWorldBound_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_UBOWorldBound_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBOWorldBound));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBOWorldBound>(cls);
    
    __jsb_cc_pipeline_UBOWorldBound_proto = cls->getProto();
    __jsb_cc_pipeline_UBOWorldBound_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_UBOForwardLight_class = nullptr;
se::Object* __jsb_cc_pipeline_UBOForwardLight_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBOForwardLight) 

static bool js_cc_pipeline_UBOForwardLight_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::UBOForwardLight::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOForwardLight_DESCRIPTOR_get) 

static bool js_cc_pipeline_UBOForwardLight_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock result;
    
    result = cc::pipeline::UBOForwardLight::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOForwardLight_LAYOUT_get) 

static bool js_cc_pipeline_UBOForwardLight_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::UBOForwardLight::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOForwardLight_NAME_get) 

static bool js_new_cc_pipeline_UBOForwardLight(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBOForwardLight *result;
    result = (cc::pipeline::UBOForwardLight *)new cc::pipeline::UBOForwardLight();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBOForwardLight, __jsb_cc_pipeline_UBOForwardLight_class, js_delete_cc_pipeline_UBOForwardLight)

static bool js_delete_cc_pipeline_UBOForwardLight(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBOForwardLight) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBOForwardLight * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBOForwardLight*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBOForwardLight(se::Object* obj) {
    auto* cls = se::Class::create("UBOForwardLight", obj, nullptr, _SE(js_new_cc_pipeline_UBOForwardLight)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("LIGHTS_PER_PASS", nullptr, nullptr); 
    cls->defineStaticProperty("LIGHT_POS_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("LIGHT_COLOR_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("LIGHT_SIZE_RANGE_ANGLE_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("LIGHT_DIR_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("SIZE", nullptr, nullptr); 
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_UBOForwardLight_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_UBOForwardLight_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_UBOForwardLight_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBOForwardLight));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBOForwardLight>(cls);
    
    __jsb_cc_pipeline_UBOForwardLight_proto = cls->getProto();
    __jsb_cc_pipeline_UBOForwardLight_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_UBODeferredLight_class = nullptr;
se::Object* __jsb_cc_pipeline_UBODeferredLight_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBODeferredLight) 

static bool js_new_cc_pipeline_UBODeferredLight(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBODeferredLight *result;
    result = (cc::pipeline::UBODeferredLight *)new cc::pipeline::UBODeferredLight();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBODeferredLight, __jsb_cc_pipeline_UBODeferredLight_class, js_delete_cc_pipeline_UBODeferredLight)

static bool js_delete_cc_pipeline_UBODeferredLight(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBODeferredLight) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBODeferredLight * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBODeferredLight*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBODeferredLight(se::Object* obj) {
    auto* cls = se::Class::create("UBODeferredLight", obj, nullptr, _SE(js_new_cc_pipeline_UBODeferredLight)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("LIGHTS_PER_PASS", nullptr, nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBODeferredLight));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBODeferredLight>(cls);
    
    __jsb_cc_pipeline_UBODeferredLight_proto = cls->getProto();
    __jsb_cc_pipeline_UBODeferredLight_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_UBOSkinningTexture_class = nullptr;
se::Object* __jsb_cc_pipeline_UBOSkinningTexture_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBOSkinningTexture) 

static bool js_cc_pipeline_UBOSkinningTexture_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::UBOSkinningTexture::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOSkinningTexture_DESCRIPTOR_get) 

static bool js_cc_pipeline_UBOSkinningTexture_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock result;
    
    result = cc::pipeline::UBOSkinningTexture::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOSkinningTexture_LAYOUT_get) 

static bool js_cc_pipeline_UBOSkinningTexture_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::UBOSkinningTexture::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOSkinningTexture_NAME_get) 

static bool js_new_cc_pipeline_UBOSkinningTexture(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBOSkinningTexture *result;
    result = (cc::pipeline::UBOSkinningTexture *)new cc::pipeline::UBOSkinningTexture();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBOSkinningTexture, __jsb_cc_pipeline_UBOSkinningTexture_class, js_delete_cc_pipeline_UBOSkinningTexture)

static bool js_delete_cc_pipeline_UBOSkinningTexture(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBOSkinningTexture) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBOSkinningTexture * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBOSkinningTexture*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBOSkinningTexture(se::Object* obj) {
    auto* cls = se::Class::create("UBOSkinningTexture", obj, nullptr, _SE(js_new_cc_pipeline_UBOSkinningTexture)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("JOINTS_TEXTURE_INFO_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("SIZE", nullptr, nullptr); 
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_UBOSkinningTexture_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_UBOSkinningTexture_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_UBOSkinningTexture_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBOSkinningTexture));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBOSkinningTexture>(cls);
    
    __jsb_cc_pipeline_UBOSkinningTexture_proto = cls->getProto();
    __jsb_cc_pipeline_UBOSkinningTexture_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_UBOSkinningAnimation_class = nullptr;
se::Object* __jsb_cc_pipeline_UBOSkinningAnimation_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBOSkinningAnimation) 

static bool js_cc_pipeline_UBOSkinningAnimation_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::UBOSkinningAnimation::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOSkinningAnimation_DESCRIPTOR_get) 

static bool js_cc_pipeline_UBOSkinningAnimation_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock result;
    
    result = cc::pipeline::UBOSkinningAnimation::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOSkinningAnimation_LAYOUT_get) 

static bool js_cc_pipeline_UBOSkinningAnimation_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::UBOSkinningAnimation::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOSkinningAnimation_NAME_get) 

static bool js_new_cc_pipeline_UBOSkinningAnimation(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBOSkinningAnimation *result;
    result = (cc::pipeline::UBOSkinningAnimation *)new cc::pipeline::UBOSkinningAnimation();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBOSkinningAnimation, __jsb_cc_pipeline_UBOSkinningAnimation_class, js_delete_cc_pipeline_UBOSkinningAnimation)

static bool js_delete_cc_pipeline_UBOSkinningAnimation(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBOSkinningAnimation) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBOSkinningAnimation * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBOSkinningAnimation*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBOSkinningAnimation(se::Object* obj) {
    auto* cls = se::Class::create("UBOSkinningAnimation", obj, nullptr, _SE(js_new_cc_pipeline_UBOSkinningAnimation)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("JOINTS_ANIM_INFO_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("SIZE", nullptr, nullptr); 
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_UBOSkinningAnimation_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_UBOSkinningAnimation_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_UBOSkinningAnimation_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBOSkinningAnimation));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBOSkinningAnimation>(cls);
    
    __jsb_cc_pipeline_UBOSkinningAnimation_proto = cls->getProto();
    __jsb_cc_pipeline_UBOSkinningAnimation_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_UBOSkinning_class = nullptr;
se::Object* __jsb_cc_pipeline_UBOSkinning_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBOSkinning) 

static bool js_cc_pipeline_UBOSkinning_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    uint32_t arg1 ;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc::pipeline::UBOSkinning::count = arg1;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_UBOSkinning_count_set) 

static bool js_cc_pipeline_UBOSkinning_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    uint32_t result;
    
    result = cc::pipeline::UBOSkinning::count;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOSkinning_count_get) 

static bool js_cc_pipeline_UBOSkinning_size_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    uint32_t arg1 ;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc::pipeline::UBOSkinning::size = arg1;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_UBOSkinning_size_set) 

static bool js_cc_pipeline_UBOSkinning_size_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    uint32_t result;
    
    result = cc::pipeline::UBOSkinning::size;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOSkinning_size_get) 

static bool js_cc_pipeline_UBOSkinning_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::UBOSkinning::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOSkinning_DESCRIPTOR_get) 

static bool js_cc_pipeline_UBOSkinning_layout_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::UniformBlock arg1 ;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc::pipeline::UBOSkinning::layout = arg1;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_UBOSkinning_layout_set) 

static bool js_cc_pipeline_UBOSkinning_layout_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock result;
    
    result = cc::pipeline::UBOSkinning::layout;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOSkinning_layout_get) 

static bool js_cc_pipeline_UBOSkinning_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::UBOSkinning::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOSkinning_NAME_get) 

static bool js_cc_pipeline_UBOSkinning_initLayout_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    uint arg1 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc::pipeline::UBOSkinning::initLayout(SWIG_STD_MOVE(arg1));
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_UBOSkinning_initLayout_static) 

static bool js_new_cc_pipeline_UBOSkinning(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBOSkinning *result;
    result = (cc::pipeline::UBOSkinning *)new cc::pipeline::UBOSkinning();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBOSkinning, __jsb_cc_pipeline_UBOSkinning_class, js_delete_cc_pipeline_UBOSkinning)

static bool js_delete_cc_pipeline_UBOSkinning(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBOSkinning) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBOSkinning * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBOSkinning*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBOSkinning(se::Object* obj) {
    auto* cls = se::Class::create("UBOSkinning", obj, nullptr, _SE(js_new_cc_pipeline_UBOSkinning)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("count", _SE(js_cc_pipeline_UBOSkinning_count_get), _SE(js_cc_pipeline_UBOSkinning_count_set)); 
    cls->defineStaticProperty("size", _SE(js_cc_pipeline_UBOSkinning_size_get), _SE(js_cc_pipeline_UBOSkinning_size_set)); 
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_UBOSkinning_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("layout", _SE(js_cc_pipeline_UBOSkinning_layout_get), _SE(js_cc_pipeline_UBOSkinning_layout_set)); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_UBOSkinning_NAME_get), nullptr); 
    
    cls->defineStaticFunction("initLayout", _SE(js_cc_pipeline_UBOSkinning_initLayout_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBOSkinning));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBOSkinning>(cls);
    
    __jsb_cc_pipeline_UBOSkinning_proto = cls->getProto();
    __jsb_cc_pipeline_UBOSkinning_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_UBOMorph_class = nullptr;
se::Object* __jsb_cc_pipeline_UBOMorph_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBOMorph) 

static bool js_cc_pipeline_UBOMorph_COUNT_BASE_4_BYTES_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    uint32_t result;
    
    result = (uint32_t)cc::pipeline::UBOMorph::COUNT_BASE_4_BYTES;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOMorph_COUNT_BASE_4_BYTES_get) 

static bool js_cc_pipeline_UBOMorph_SIZE_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    uint32_t result;
    
    result = (uint32_t)cc::pipeline::UBOMorph::SIZE;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOMorph_SIZE_get) 

static bool js_cc_pipeline_UBOMorph_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::UBOMorph::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOMorph_DESCRIPTOR_get) 

static bool js_cc_pipeline_UBOMorph_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock result;
    
    result = cc::pipeline::UBOMorph::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOMorph_LAYOUT_get) 

static bool js_cc_pipeline_UBOMorph_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::UBOMorph::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOMorph_NAME_get) 

static bool js_new_cc_pipeline_UBOMorph(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBOMorph *result;
    result = (cc::pipeline::UBOMorph *)new cc::pipeline::UBOMorph();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBOMorph, __jsb_cc_pipeline_UBOMorph_class, js_delete_cc_pipeline_UBOMorph)

static bool js_delete_cc_pipeline_UBOMorph(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBOMorph) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBOMorph * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBOMorph*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBOMorph(se::Object* obj) {
    auto* cls = se::Class::create("UBOMorph", obj, nullptr, _SE(js_new_cc_pipeline_UBOMorph)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("MAX_MORPH_TARGET_COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("OFFSET_OF_WEIGHTS", nullptr, nullptr); 
    cls->defineStaticProperty("OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH", nullptr, nullptr); 
    cls->defineStaticProperty("OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT", nullptr, nullptr); 
    cls->defineStaticProperty("OFFSET_OF_VERTICES_COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("COUNT_BASE_4_BYTES", _SE(js_cc_pipeline_UBOMorph_COUNT_BASE_4_BYTES_get), nullptr); 
    cls->defineStaticProperty("SIZE", _SE(js_cc_pipeline_UBOMorph_SIZE_get), nullptr); 
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_UBOMorph_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_UBOMorph_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_UBOMorph_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBOMorph));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBOMorph>(cls);
    
    __jsb_cc_pipeline_UBOMorph_proto = cls->getProto();
    __jsb_cc_pipeline_UBOMorph_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_UBOUILocal_class = nullptr;
se::Object* __jsb_cc_pipeline_UBOUILocal_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBOUILocal) 

static bool js_cc_pipeline_UBOUILocal_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::UBOUILocal::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOUILocal_DESCRIPTOR_get) 

static bool js_cc_pipeline_UBOUILocal_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock result;
    
    result = cc::pipeline::UBOUILocal::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOUILocal_LAYOUT_get) 

static bool js_cc_pipeline_UBOUILocal_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::UBOUILocal::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOUILocal_NAME_get) 

static bool js_new_cc_pipeline_UBOUILocal(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBOUILocal *result;
    result = (cc::pipeline::UBOUILocal *)new cc::pipeline::UBOUILocal();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBOUILocal, __jsb_cc_pipeline_UBOUILocal_class, js_delete_cc_pipeline_UBOUILocal)

static bool js_delete_cc_pipeline_UBOUILocal(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBOUILocal) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBOUILocal * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBOUILocal*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBOUILocal(se::Object* obj) {
    auto* cls = se::Class::create("UBOUILocal", obj, nullptr, _SE(js_new_cc_pipeline_UBOUILocal)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_UBOUILocal_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_UBOUILocal_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_UBOUILocal_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBOUILocal));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBOUILocal>(cls);
    
    __jsb_cc_pipeline_UBOUILocal_proto = cls->getProto();
    __jsb_cc_pipeline_UBOUILocal_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_UBOSH_class = nullptr;
se::Object* __jsb_cc_pipeline_UBOSH_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBOSH) 

static bool js_cc_pipeline_UBOSH_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::UBOSH::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOSH_DESCRIPTOR_get) 

static bool js_cc_pipeline_UBOSH_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock result;
    
    result = cc::pipeline::UBOSH::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOSH_LAYOUT_get) 

static bool js_cc_pipeline_UBOSH_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::UBOSH::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOSH_NAME_get) 

static bool js_new_cc_pipeline_UBOSH(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBOSH *result;
    result = (cc::pipeline::UBOSH *)new cc::pipeline::UBOSH();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBOSH, __jsb_cc_pipeline_UBOSH_class, js_delete_cc_pipeline_UBOSH)

static bool js_delete_cc_pipeline_UBOSH(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBOSH) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBOSH * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBOSH*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBOSH(se::Object* obj) {
    auto* cls = se::Class::create("UBOSH", obj, nullptr, _SE(js_new_cc_pipeline_UBOSH)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("SH_LINEAR_CONST_R_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("SH_LINEAR_CONST_G_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("SH_LINEAR_CONST_B_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("SH_QUADRATIC_R_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("SH_QUADRATIC_G_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("SH_QUADRATIC_B_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("SH_QUADRATIC_A_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("SIZE", nullptr, nullptr); 
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_UBOSH_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_UBOSH_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_UBOSH_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBOSH));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBOSH>(cls);
    
    __jsb_cc_pipeline_UBOSH_proto = cls->getProto();
    __jsb_cc_pipeline_UBOSH_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


static bool js_cc_pipeline_toNumber__SWIG_7(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::ForwardStagePriority arg1 ;
    std::underlying_type< cc::pipeline::ForwardStagePriority >::type result;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = cc::pipeline::toNumber(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_pipeline_toNumber__SWIG_8(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::ForwardFlowPriority arg1 ;
    std::underlying_type< cc::pipeline::ForwardFlowPriority >::type result;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = cc::pipeline::toNumber(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_pipeline_toNumber__SWIG_9(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::RenderFlowTag arg1 ;
    std::underlying_type< cc::pipeline::RenderFlowTag >::type result;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = cc::pipeline::toNumber(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_pipeline_toNumber__SWIG_10(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::DeferredStagePriority arg1 ;
    std::underlying_type< cc::pipeline::DeferredStagePriority >::type result;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = cc::pipeline::toNumber(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_pipeline_toNumber__SWIG_11(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::DeferredFlowPriority arg1 ;
    std::underlying_type< cc::pipeline::DeferredFlowPriority >::type result;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = cc::pipeline::toNumber(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

se::Class* __jsb_cc_pipeline_UBOGlobal_class = nullptr;
se::Object* __jsb_cc_pipeline_UBOGlobal_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBOGlobal) 

static bool js_cc_pipeline_UBOGlobal_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::UBOGlobal::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOGlobal_DESCRIPTOR_get) 

static bool js_cc_pipeline_UBOGlobal_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock result;
    
    result = cc::pipeline::UBOGlobal::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOGlobal_LAYOUT_get) 

static bool js_cc_pipeline_UBOGlobal_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::UBOGlobal::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOGlobal_NAME_get) 

static bool js_new_cc_pipeline_UBOGlobal(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBOGlobal *result;
    result = (cc::pipeline::UBOGlobal *)new cc::pipeline::UBOGlobal();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBOGlobal, __jsb_cc_pipeline_UBOGlobal_class, js_delete_cc_pipeline_UBOGlobal)

static bool js_delete_cc_pipeline_UBOGlobal(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBOGlobal) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBOGlobal * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBOGlobal*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBOGlobal(se::Object* obj) {
    auto* cls = se::Class::create("UBOGlobal", obj, nullptr, _SE(js_new_cc_pipeline_UBOGlobal)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("TIME_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("SCREEN_SIZE_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("NATIVE_SIZE_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("DEBUG_VIEW_MODE_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("DEBUG_VIEW_COMPOSITE_PACK_1_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("DEBUG_VIEW_COMPOSITE_PACK_2_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("DEBUG_VIEW_COMPOSITE_PACK_3_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("SIZE", nullptr, nullptr); 
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_UBOGlobal_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_UBOGlobal_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_UBOGlobal_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBOGlobal));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBOGlobal>(cls);
    
    __jsb_cc_pipeline_UBOGlobal_proto = cls->getProto();
    __jsb_cc_pipeline_UBOGlobal_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_UBOCamera_class = nullptr;
se::Object* __jsb_cc_pipeline_UBOCamera_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBOCamera) 

static bool js_cc_pipeline_UBOCamera_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::UBOCamera::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOCamera_DESCRIPTOR_get) 

static bool js_cc_pipeline_UBOCamera_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock result;
    
    result = cc::pipeline::UBOCamera::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOCamera_LAYOUT_get) 

static bool js_cc_pipeline_UBOCamera_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::UBOCamera::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOCamera_NAME_get) 

static bool js_new_cc_pipeline_UBOCamera(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBOCamera *result;
    result = (cc::pipeline::UBOCamera *)new cc::pipeline::UBOCamera();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBOCamera, __jsb_cc_pipeline_UBOCamera_class, js_delete_cc_pipeline_UBOCamera)

static bool js_delete_cc_pipeline_UBOCamera(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBOCamera) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBOCamera * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBOCamera*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBOCamera(se::Object* obj) {
    auto* cls = se::Class::create("UBOCamera", obj, nullptr, _SE(js_new_cc_pipeline_UBOCamera)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("MAT_VIEW_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("MAT_VIEW_INV_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("MAT_PROJ_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("MAT_PROJ_INV_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("MAT_VIEW_PROJ_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("MAT_VIEW_PROJ_INV_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("CAMERA_POS_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("SURFACE_TRANSFORM_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("SCREEN_SCALE_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("EXPOSURE_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("MAIN_LIT_DIR_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("MAIN_LIT_COLOR_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("AMBIENT_SKY_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("AMBIENT_GROUND_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("GLOBAL_FOG_COLOR_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("GLOBAL_FOG_BASE_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("GLOBAL_FOG_ADD_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("GLOBAL_NEAR_FAR_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("GLOBAL_VIEW_PORT_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("SIZE", nullptr, nullptr); 
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_UBOCamera_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_UBOCamera_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_UBOCamera_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBOCamera));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBOCamera>(cls);
    
    __jsb_cc_pipeline_UBOCamera_proto = cls->getProto();
    __jsb_cc_pipeline_UBOCamera_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_UBOShadow_class = nullptr;
se::Object* __jsb_cc_pipeline_UBOShadow_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBOShadow) 

static bool js_cc_pipeline_UBOShadow_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::UBOShadow::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOShadow_DESCRIPTOR_get) 

static bool js_cc_pipeline_UBOShadow_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock result;
    
    result = cc::pipeline::UBOShadow::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOShadow_LAYOUT_get) 

static bool js_cc_pipeline_UBOShadow_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::UBOShadow::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOShadow_NAME_get) 

static bool js_new_cc_pipeline_UBOShadow(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBOShadow *result;
    result = (cc::pipeline::UBOShadow *)new cc::pipeline::UBOShadow();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBOShadow, __jsb_cc_pipeline_UBOShadow_class, js_delete_cc_pipeline_UBOShadow)

static bool js_delete_cc_pipeline_UBOShadow(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBOShadow) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBOShadow * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBOShadow*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBOShadow(se::Object* obj) {
    auto* cls = se::Class::create("UBOShadow", obj, nullptr, _SE(js_new_cc_pipeline_UBOShadow)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("MAT_LIGHT_VIEW_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("MAT_LIGHT_VIEW_PROJ_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("SHADOW_INV_PROJ_DEPTH_INFO_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("SHADOW_PROJ_DEPTH_INFO_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("SHADOW_PROJ_INFO_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("SHADOW_COLOR_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("PLANAR_NORMAL_DISTANCE_INFO_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("SIZE", nullptr, nullptr); 
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_UBOShadow_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_UBOShadow_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_UBOShadow_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBOShadow));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBOShadow>(cls);
    
    __jsb_cc_pipeline_UBOShadow_proto = cls->getProto();
    __jsb_cc_pipeline_UBOShadow_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_UBOCSM_class = nullptr;
se::Object* __jsb_cc_pipeline_UBOCSM_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_UBOCSM) 

static bool js_cc_pipeline_UBOCSM_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::UBOCSM::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOCSM_DESCRIPTOR_get) 

static bool js_cc_pipeline_UBOCSM_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformBlock result;
    
    result = cc::pipeline::UBOCSM::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOCSM_LAYOUT_get) 

static bool js_cc_pipeline_UBOCSM_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::UBOCSM::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_UBOCSM_NAME_get) 

static bool js_new_cc_pipeline_UBOCSM(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::UBOCSM *result;
    result = (cc::pipeline::UBOCSM *)new cc::pipeline::UBOCSM();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_UBOCSM, __jsb_cc_pipeline_UBOCSM_class, js_delete_cc_pipeline_UBOCSM)

static bool js_delete_cc_pipeline_UBOCSM(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_UBOCSM) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::UBOCSM * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::UBOCSM*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_UBOCSM(se::Object* obj) {
    auto* cls = se::Class::create("UBOCSM", obj, nullptr, _SE(js_new_cc_pipeline_UBOCSM)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("CSM_LEVEL_COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("CSM_VIEW_DIR_0_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("CSM_VIEW_DIR_1_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("CSM_VIEW_DIR_2_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("CSM_ATLAS_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("MAT_CSM_VIEW_PROJ_LEVELS_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("CSM_PROJ_DEPTH_INFO_LEVELS_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("CSM_PROJ_INFO_LEVELS_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("CSM_SPLITS_INFO_OFFSET", nullptr, nullptr); 
    cls->defineStaticProperty("COUNT", nullptr, nullptr); 
    cls->defineStaticProperty("SIZE", nullptr, nullptr); 
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_UBOCSM_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_UBOCSM_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_UBOCSM_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_UBOCSM));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::UBOCSM>(cls);
    
    __jsb_cc_pipeline_UBOCSM_proto = cls->getProto();
    __jsb_cc_pipeline_UBOCSM_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_DescriptorSetLayoutInfos_class = nullptr;
se::Object* __jsb_cc_pipeline_DescriptorSetLayoutInfos_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_DescriptorSetLayoutInfos) 

static bool js_cc_pipeline_DescriptorSetLayoutInfos_bindings_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::DescriptorSetLayoutInfos *arg1 = (cc::pipeline::DescriptorSetLayoutInfos *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::DescriptorSetLayoutInfos>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->bindings, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_DescriptorSetLayoutInfos_bindings_set) 

static bool js_cc_pipeline_DescriptorSetLayoutInfos_bindings_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::DescriptorSetLayoutInfos *arg1 = (cc::pipeline::DescriptorSetLayoutInfos *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::DescriptorSetLayoutInfos>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->bindings, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->bindings, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_DescriptorSetLayoutInfos_bindings_get) 

static bool js_cc_pipeline_DescriptorSetLayoutInfos_blocks_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::DescriptorSetLayoutInfos *arg1 = (cc::pipeline::DescriptorSetLayoutInfos *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::DescriptorSetLayoutInfos>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->blocks, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_DescriptorSetLayoutInfos_blocks_set) 

static bool js_cc_pipeline_DescriptorSetLayoutInfos_blocks_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::DescriptorSetLayoutInfos *arg1 = (cc::pipeline::DescriptorSetLayoutInfos *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::DescriptorSetLayoutInfos>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->blocks, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->blocks, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_DescriptorSetLayoutInfos_blocks_get) 

static bool js_cc_pipeline_DescriptorSetLayoutInfos_samplers_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::DescriptorSetLayoutInfos *arg1 = (cc::pipeline::DescriptorSetLayoutInfos *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::DescriptorSetLayoutInfos>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->samplers, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_DescriptorSetLayoutInfos_samplers_set) 

static bool js_cc_pipeline_DescriptorSetLayoutInfos_samplers_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::DescriptorSetLayoutInfos *arg1 = (cc::pipeline::DescriptorSetLayoutInfos *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::DescriptorSetLayoutInfos>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->samplers, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->samplers, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_DescriptorSetLayoutInfos_samplers_get) 

static bool js_cc_pipeline_DescriptorSetLayoutInfos_storeImages_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::DescriptorSetLayoutInfos *arg1 = (cc::pipeline::DescriptorSetLayoutInfos *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::DescriptorSetLayoutInfos>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->storeImages, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_DescriptorSetLayoutInfos_storeImages_set) 

static bool js_cc_pipeline_DescriptorSetLayoutInfos_storeImages_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::DescriptorSetLayoutInfos *arg1 = (cc::pipeline::DescriptorSetLayoutInfos *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::DescriptorSetLayoutInfos>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->storeImages, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->storeImages, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_DescriptorSetLayoutInfos_storeImages_get) 

static bool js_new_cc_pipeline_DescriptorSetLayoutInfos(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::DescriptorSetLayoutInfos *result;
    result = (cc::pipeline::DescriptorSetLayoutInfos *)new cc::pipeline::DescriptorSetLayoutInfos();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_DescriptorSetLayoutInfos, __jsb_cc_pipeline_DescriptorSetLayoutInfos_class, js_delete_cc_pipeline_DescriptorSetLayoutInfos)

static bool js_delete_cc_pipeline_DescriptorSetLayoutInfos(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_DescriptorSetLayoutInfos) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::DescriptorSetLayoutInfos * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::DescriptorSetLayoutInfos*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("bindings", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->bindings), ctx);
    }
    
    
    json->getProperty("blocks", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->blocks), ctx);
    }
    
    
    json->getProperty("samplers", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->samplers), ctx);
    }
    
    
    json->getProperty("storeImages", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->storeImages), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_DescriptorSetLayoutInfos(se::Object* obj) {
    auto* cls = se::Class::create("DescriptorSetLayoutInfos", obj, nullptr, _SE(js_new_cc_pipeline_DescriptorSetLayoutInfos)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("bindings", _SE(js_cc_pipeline_DescriptorSetLayoutInfos_bindings_get), _SE(js_cc_pipeline_DescriptorSetLayoutInfos_bindings_set)); 
    cls->defineProperty("blocks", _SE(js_cc_pipeline_DescriptorSetLayoutInfos_blocks_get), _SE(js_cc_pipeline_DescriptorSetLayoutInfos_blocks_set)); 
    cls->defineProperty("samplers", _SE(js_cc_pipeline_DescriptorSetLayoutInfos_samplers_get), _SE(js_cc_pipeline_DescriptorSetLayoutInfos_samplers_set)); 
    cls->defineProperty("storeImages", _SE(js_cc_pipeline_DescriptorSetLayoutInfos_storeImages_get), _SE(js_cc_pipeline_DescriptorSetLayoutInfos_storeImages_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_DescriptorSetLayoutInfos));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::DescriptorSetLayoutInfos>(cls);
    
    __jsb_cc_pipeline_DescriptorSetLayoutInfos_proto = cls->getProto();
    __jsb_cc_pipeline_DescriptorSetLayoutInfos_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


static bool js_cc_pipeline_toNumber__SWIG_12(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::LayerList arg1 ;
    std::underlying_type< cc::pipeline::LayerList >::type result;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = cc::pipeline::toNumber(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_pipeline_toNumber(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_cc_pipeline_toNumber__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_pipeline_toNumber__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_pipeline_toNumber__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_pipeline_toNumber__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_pipeline_toNumber__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_pipeline_toNumber__SWIG_5(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_pipeline_toNumber__SWIG_6(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_pipeline_toNumber__SWIG_7(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_pipeline_toNumber__SWIG_8(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_pipeline_toNumber__SWIG_9(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_pipeline_toNumber__SWIG_10(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_pipeline_toNumber__SWIG_11(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_pipeline_toNumber__SWIG_12(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_toNumber) 

static bool js_cc_pipeline_nextPow2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    uint32_t arg1 ;
    uint32_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = cc::pipeline::nextPow2(SWIG_STD_MOVE(arg1));
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_nextPow2) 

static bool js_cc_pipeline_supportsR16HalfFloatTexture(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (bool)cc::pipeline::supportsR16HalfFloatTexture((cc::gfx::Device const *)arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_supportsR16HalfFloatTexture) 

static bool js_cc_pipeline_supportsR32FloatTexture(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (bool)cc::pipeline::supportsR32FloatTexture((cc::gfx::Device const *)arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_supportsR32FloatTexture) 

se::Class* __jsb_cc_pipeline_SHADOWMAP_class = nullptr;
se::Object* __jsb_cc_pipeline_SHADOWMAP_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_SHADOWMAP) 

static bool js_cc_pipeline_SHADOWMAP_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::SHADOWMAP::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_SHADOWMAP_DESCRIPTOR_get) 

static bool js_cc_pipeline_SHADOWMAP_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture result;
    
    result = cc::pipeline::SHADOWMAP::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_SHADOWMAP_LAYOUT_get) 

static bool js_cc_pipeline_SHADOWMAP_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::SHADOWMAP::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_SHADOWMAP_NAME_get) 

static bool js_new_cc_pipeline_SHADOWMAP(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::SHADOWMAP *result;
    result = (cc::pipeline::SHADOWMAP *)new cc::pipeline::SHADOWMAP();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_SHADOWMAP, __jsb_cc_pipeline_SHADOWMAP_class, js_delete_cc_pipeline_SHADOWMAP)

static bool js_delete_cc_pipeline_SHADOWMAP(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_SHADOWMAP) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::SHADOWMAP * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::SHADOWMAP*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_SHADOWMAP(se::Object* obj) {
    auto* cls = se::Class::create("SHADOWMAP", obj, nullptr, _SE(js_new_cc_pipeline_SHADOWMAP)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_SHADOWMAP_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_SHADOWMAP_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_SHADOWMAP_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_SHADOWMAP));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::SHADOWMAP>(cls);
    
    __jsb_cc_pipeline_SHADOWMAP_proto = cls->getProto();
    __jsb_cc_pipeline_SHADOWMAP_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_ENVIRONMENT_class = nullptr;
se::Object* __jsb_cc_pipeline_ENVIRONMENT_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_ENVIRONMENT) 

static bool js_cc_pipeline_ENVIRONMENT_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::ENVIRONMENT::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_ENVIRONMENT_DESCRIPTOR_get) 

static bool js_cc_pipeline_ENVIRONMENT_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture result;
    
    result = cc::pipeline::ENVIRONMENT::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_ENVIRONMENT_LAYOUT_get) 

static bool js_cc_pipeline_ENVIRONMENT_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::ENVIRONMENT::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_ENVIRONMENT_NAME_get) 

static bool js_new_cc_pipeline_ENVIRONMENT(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::ENVIRONMENT *result;
    result = (cc::pipeline::ENVIRONMENT *)new cc::pipeline::ENVIRONMENT();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_ENVIRONMENT, __jsb_cc_pipeline_ENVIRONMENT_class, js_delete_cc_pipeline_ENVIRONMENT)

static bool js_delete_cc_pipeline_ENVIRONMENT(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_ENVIRONMENT) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::ENVIRONMENT * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::ENVIRONMENT*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_ENVIRONMENT(se::Object* obj) {
    auto* cls = se::Class::create("ENVIRONMENT", obj, nullptr, _SE(js_new_cc_pipeline_ENVIRONMENT)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_ENVIRONMENT_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_ENVIRONMENT_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_ENVIRONMENT_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_ENVIRONMENT));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::ENVIRONMENT>(cls);
    
    __jsb_cc_pipeline_ENVIRONMENT_proto = cls->getProto();
    __jsb_cc_pipeline_ENVIRONMENT_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_SPOTSHADOWMAP_class = nullptr;
se::Object* __jsb_cc_pipeline_SPOTSHADOWMAP_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_SPOTSHADOWMAP) 

static bool js_cc_pipeline_SPOTSHADOWMAP_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::SPOTSHADOWMAP::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_SPOTSHADOWMAP_DESCRIPTOR_get) 

static bool js_cc_pipeline_SPOTSHADOWMAP_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture result;
    
    result = cc::pipeline::SPOTSHADOWMAP::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_SPOTSHADOWMAP_LAYOUT_get) 

static bool js_cc_pipeline_SPOTSHADOWMAP_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::SPOTSHADOWMAP::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_SPOTSHADOWMAP_NAME_get) 

static bool js_new_cc_pipeline_SPOTSHADOWMAP(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::SPOTSHADOWMAP *result;
    result = (cc::pipeline::SPOTSHADOWMAP *)new cc::pipeline::SPOTSHADOWMAP();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_SPOTSHADOWMAP, __jsb_cc_pipeline_SPOTSHADOWMAP_class, js_delete_cc_pipeline_SPOTSHADOWMAP)

static bool js_delete_cc_pipeline_SPOTSHADOWMAP(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_SPOTSHADOWMAP) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::SPOTSHADOWMAP * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::SPOTSHADOWMAP*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_SPOTSHADOWMAP(se::Object* obj) {
    auto* cls = se::Class::create("SPOTSHADOWMAP", obj, nullptr, _SE(js_new_cc_pipeline_SPOTSHADOWMAP)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_SPOTSHADOWMAP_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_SPOTSHADOWMAP_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_SPOTSHADOWMAP_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_SPOTSHADOWMAP));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::SPOTSHADOWMAP>(cls);
    
    __jsb_cc_pipeline_SPOTSHADOWMAP_proto = cls->getProto();
    __jsb_cc_pipeline_SPOTSHADOWMAP_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_DIFFUSEMAP_class = nullptr;
se::Object* __jsb_cc_pipeline_DIFFUSEMAP_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_DIFFUSEMAP) 

static bool js_cc_pipeline_DIFFUSEMAP_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::DIFFUSEMAP::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_DIFFUSEMAP_DESCRIPTOR_get) 

static bool js_cc_pipeline_DIFFUSEMAP_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture result;
    
    result = cc::pipeline::DIFFUSEMAP::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_DIFFUSEMAP_LAYOUT_get) 

static bool js_cc_pipeline_DIFFUSEMAP_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::DIFFUSEMAP::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_DIFFUSEMAP_NAME_get) 

static bool js_new_cc_pipeline_DIFFUSEMAP(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::DIFFUSEMAP *result;
    result = (cc::pipeline::DIFFUSEMAP *)new cc::pipeline::DIFFUSEMAP();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_DIFFUSEMAP, __jsb_cc_pipeline_DIFFUSEMAP_class, js_delete_cc_pipeline_DIFFUSEMAP)

static bool js_delete_cc_pipeline_DIFFUSEMAP(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_DIFFUSEMAP) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::DIFFUSEMAP * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::DIFFUSEMAP*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_DIFFUSEMAP(se::Object* obj) {
    auto* cls = se::Class::create("DIFFUSEMAP", obj, nullptr, _SE(js_new_cc_pipeline_DIFFUSEMAP)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_DIFFUSEMAP_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_DIFFUSEMAP_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_DIFFUSEMAP_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_DIFFUSEMAP));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::DIFFUSEMAP>(cls);
    
    __jsb_cc_pipeline_DIFFUSEMAP_proto = cls->getProto();
    __jsb_cc_pipeline_DIFFUSEMAP_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_JOINTTEXTURE_class = nullptr;
se::Object* __jsb_cc_pipeline_JOINTTEXTURE_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_JOINTTEXTURE) 

static bool js_cc_pipeline_JOINTTEXTURE_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::JOINTTEXTURE::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_JOINTTEXTURE_DESCRIPTOR_get) 

static bool js_cc_pipeline_JOINTTEXTURE_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture result;
    
    result = cc::pipeline::JOINTTEXTURE::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_JOINTTEXTURE_LAYOUT_get) 

static bool js_cc_pipeline_JOINTTEXTURE_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::JOINTTEXTURE::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_JOINTTEXTURE_NAME_get) 

static bool js_new_cc_pipeline_JOINTTEXTURE(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::JOINTTEXTURE *result;
    result = (cc::pipeline::JOINTTEXTURE *)new cc::pipeline::JOINTTEXTURE();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_JOINTTEXTURE, __jsb_cc_pipeline_JOINTTEXTURE_class, js_delete_cc_pipeline_JOINTTEXTURE)

static bool js_delete_cc_pipeline_JOINTTEXTURE(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_JOINTTEXTURE) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::JOINTTEXTURE * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::JOINTTEXTURE*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_JOINTTEXTURE(se::Object* obj) {
    auto* cls = se::Class::create("JOINTTEXTURE", obj, nullptr, _SE(js_new_cc_pipeline_JOINTTEXTURE)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_JOINTTEXTURE_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_JOINTTEXTURE_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_JOINTTEXTURE_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_JOINTTEXTURE));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::JOINTTEXTURE>(cls);
    
    __jsb_cc_pipeline_JOINTTEXTURE_proto = cls->getProto();
    __jsb_cc_pipeline_JOINTTEXTURE_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_REALTIMEJOINTTEXTURE_class = nullptr;
se::Object* __jsb_cc_pipeline_REALTIMEJOINTTEXTURE_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_REALTIMEJOINTTEXTURE) 

static bool js_cc_pipeline_REALTIMEJOINTTEXTURE_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::REALTIMEJOINTTEXTURE::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_REALTIMEJOINTTEXTURE_DESCRIPTOR_get) 

static bool js_cc_pipeline_REALTIMEJOINTTEXTURE_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture result;
    
    result = cc::pipeline::REALTIMEJOINTTEXTURE::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_REALTIMEJOINTTEXTURE_LAYOUT_get) 

static bool js_cc_pipeline_REALTIMEJOINTTEXTURE_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::REALTIMEJOINTTEXTURE::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_REALTIMEJOINTTEXTURE_NAME_get) 

static bool js_new_cc_pipeline_REALTIMEJOINTTEXTURE(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::REALTIMEJOINTTEXTURE *result;
    result = (cc::pipeline::REALTIMEJOINTTEXTURE *)new cc::pipeline::REALTIMEJOINTTEXTURE();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_REALTIMEJOINTTEXTURE, __jsb_cc_pipeline_REALTIMEJOINTTEXTURE_class, js_delete_cc_pipeline_REALTIMEJOINTTEXTURE)

static bool js_delete_cc_pipeline_REALTIMEJOINTTEXTURE(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_REALTIMEJOINTTEXTURE) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::REALTIMEJOINTTEXTURE * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::REALTIMEJOINTTEXTURE*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_REALTIMEJOINTTEXTURE(se::Object* obj) {
    auto* cls = se::Class::create("REALTIMEJOINTTEXTURE", obj, nullptr, _SE(js_new_cc_pipeline_REALTIMEJOINTTEXTURE)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_REALTIMEJOINTTEXTURE_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_REALTIMEJOINTTEXTURE_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_REALTIMEJOINTTEXTURE_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_REALTIMEJOINTTEXTURE));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::REALTIMEJOINTTEXTURE>(cls);
    
    __jsb_cc_pipeline_REALTIMEJOINTTEXTURE_proto = cls->getProto();
    __jsb_cc_pipeline_REALTIMEJOINTTEXTURE_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_POSITIONMORPH_class = nullptr;
se::Object* __jsb_cc_pipeline_POSITIONMORPH_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_POSITIONMORPH) 

static bool js_cc_pipeline_POSITIONMORPH_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::POSITIONMORPH::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_POSITIONMORPH_DESCRIPTOR_get) 

static bool js_cc_pipeline_POSITIONMORPH_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture result;
    
    result = cc::pipeline::POSITIONMORPH::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_POSITIONMORPH_LAYOUT_get) 

static bool js_cc_pipeline_POSITIONMORPH_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::POSITIONMORPH::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_POSITIONMORPH_NAME_get) 

static bool js_new_cc_pipeline_POSITIONMORPH(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::POSITIONMORPH *result;
    result = (cc::pipeline::POSITIONMORPH *)new cc::pipeline::POSITIONMORPH();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_POSITIONMORPH, __jsb_cc_pipeline_POSITIONMORPH_class, js_delete_cc_pipeline_POSITIONMORPH)

static bool js_delete_cc_pipeline_POSITIONMORPH(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_POSITIONMORPH) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::POSITIONMORPH * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::POSITIONMORPH*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_POSITIONMORPH(se::Object* obj) {
    auto* cls = se::Class::create("POSITIONMORPH", obj, nullptr, _SE(js_new_cc_pipeline_POSITIONMORPH)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_POSITIONMORPH_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_POSITIONMORPH_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_POSITIONMORPH_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_POSITIONMORPH));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::POSITIONMORPH>(cls);
    
    __jsb_cc_pipeline_POSITIONMORPH_proto = cls->getProto();
    __jsb_cc_pipeline_POSITIONMORPH_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_NORMALMORPH_class = nullptr;
se::Object* __jsb_cc_pipeline_NORMALMORPH_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_NORMALMORPH) 

static bool js_cc_pipeline_NORMALMORPH_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::NORMALMORPH::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_NORMALMORPH_DESCRIPTOR_get) 

static bool js_cc_pipeline_NORMALMORPH_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture result;
    
    result = cc::pipeline::NORMALMORPH::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_NORMALMORPH_LAYOUT_get) 

static bool js_cc_pipeline_NORMALMORPH_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::NORMALMORPH::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_NORMALMORPH_NAME_get) 

static bool js_new_cc_pipeline_NORMALMORPH(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::NORMALMORPH *result;
    result = (cc::pipeline::NORMALMORPH *)new cc::pipeline::NORMALMORPH();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_NORMALMORPH, __jsb_cc_pipeline_NORMALMORPH_class, js_delete_cc_pipeline_NORMALMORPH)

static bool js_delete_cc_pipeline_NORMALMORPH(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_NORMALMORPH) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::NORMALMORPH * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::NORMALMORPH*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_NORMALMORPH(se::Object* obj) {
    auto* cls = se::Class::create("NORMALMORPH", obj, nullptr, _SE(js_new_cc_pipeline_NORMALMORPH)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_NORMALMORPH_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_NORMALMORPH_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_NORMALMORPH_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_NORMALMORPH));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::NORMALMORPH>(cls);
    
    __jsb_cc_pipeline_NORMALMORPH_proto = cls->getProto();
    __jsb_cc_pipeline_NORMALMORPH_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_TANGENTMORPH_class = nullptr;
se::Object* __jsb_cc_pipeline_TANGENTMORPH_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_TANGENTMORPH) 

static bool js_cc_pipeline_TANGENTMORPH_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::TANGENTMORPH::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_TANGENTMORPH_DESCRIPTOR_get) 

static bool js_cc_pipeline_TANGENTMORPH_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture result;
    
    result = cc::pipeline::TANGENTMORPH::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_TANGENTMORPH_LAYOUT_get) 

static bool js_cc_pipeline_TANGENTMORPH_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::TANGENTMORPH::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_TANGENTMORPH_NAME_get) 

static bool js_new_cc_pipeline_TANGENTMORPH(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::TANGENTMORPH *result;
    result = (cc::pipeline::TANGENTMORPH *)new cc::pipeline::TANGENTMORPH();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_TANGENTMORPH, __jsb_cc_pipeline_TANGENTMORPH_class, js_delete_cc_pipeline_TANGENTMORPH)

static bool js_delete_cc_pipeline_TANGENTMORPH(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_TANGENTMORPH) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::TANGENTMORPH * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::TANGENTMORPH*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_TANGENTMORPH(se::Object* obj) {
    auto* cls = se::Class::create("TANGENTMORPH", obj, nullptr, _SE(js_new_cc_pipeline_TANGENTMORPH)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_TANGENTMORPH_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_TANGENTMORPH_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_TANGENTMORPH_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_TANGENTMORPH));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::TANGENTMORPH>(cls);
    
    __jsb_cc_pipeline_TANGENTMORPH_proto = cls->getProto();
    __jsb_cc_pipeline_TANGENTMORPH_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_LIGHTMAPTEXTURE_class = nullptr;
se::Object* __jsb_cc_pipeline_LIGHTMAPTEXTURE_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_LIGHTMAPTEXTURE) 

static bool js_cc_pipeline_LIGHTMAPTEXTURE_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::LIGHTMAPTEXTURE::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_LIGHTMAPTEXTURE_DESCRIPTOR_get) 

static bool js_cc_pipeline_LIGHTMAPTEXTURE_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture result;
    
    result = cc::pipeline::LIGHTMAPTEXTURE::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_LIGHTMAPTEXTURE_LAYOUT_get) 

static bool js_cc_pipeline_LIGHTMAPTEXTURE_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::LIGHTMAPTEXTURE::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_LIGHTMAPTEXTURE_NAME_get) 

static bool js_new_cc_pipeline_LIGHTMAPTEXTURE(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::LIGHTMAPTEXTURE *result;
    result = (cc::pipeline::LIGHTMAPTEXTURE *)new cc::pipeline::LIGHTMAPTEXTURE();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_LIGHTMAPTEXTURE, __jsb_cc_pipeline_LIGHTMAPTEXTURE_class, js_delete_cc_pipeline_LIGHTMAPTEXTURE)

static bool js_delete_cc_pipeline_LIGHTMAPTEXTURE(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_LIGHTMAPTEXTURE) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::LIGHTMAPTEXTURE * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::LIGHTMAPTEXTURE*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_LIGHTMAPTEXTURE(se::Object* obj) {
    auto* cls = se::Class::create("LIGHTMAPTEXTURE", obj, nullptr, _SE(js_new_cc_pipeline_LIGHTMAPTEXTURE)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_LIGHTMAPTEXTURE_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_LIGHTMAPTEXTURE_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_LIGHTMAPTEXTURE_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_LIGHTMAPTEXTURE));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::LIGHTMAPTEXTURE>(cls);
    
    __jsb_cc_pipeline_LIGHTMAPTEXTURE_proto = cls->getProto();
    __jsb_cc_pipeline_LIGHTMAPTEXTURE_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_SPRITETEXTURE_class = nullptr;
se::Object* __jsb_cc_pipeline_SPRITETEXTURE_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_SPRITETEXTURE) 

static bool js_cc_pipeline_SPRITETEXTURE_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::SPRITETEXTURE::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_SPRITETEXTURE_DESCRIPTOR_get) 

static bool js_cc_pipeline_SPRITETEXTURE_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture result;
    
    result = cc::pipeline::SPRITETEXTURE::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_SPRITETEXTURE_LAYOUT_get) 

static bool js_cc_pipeline_SPRITETEXTURE_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::SPRITETEXTURE::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_SPRITETEXTURE_NAME_get) 

static bool js_new_cc_pipeline_SPRITETEXTURE(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::SPRITETEXTURE *result;
    result = (cc::pipeline::SPRITETEXTURE *)new cc::pipeline::SPRITETEXTURE();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_SPRITETEXTURE, __jsb_cc_pipeline_SPRITETEXTURE_class, js_delete_cc_pipeline_SPRITETEXTURE)

static bool js_delete_cc_pipeline_SPRITETEXTURE(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_SPRITETEXTURE) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::SPRITETEXTURE * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::SPRITETEXTURE*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_SPRITETEXTURE(se::Object* obj) {
    auto* cls = se::Class::create("SPRITETEXTURE", obj, nullptr, _SE(js_new_cc_pipeline_SPRITETEXTURE)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_SPRITETEXTURE_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_SPRITETEXTURE_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_SPRITETEXTURE_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_SPRITETEXTURE));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::SPRITETEXTURE>(cls);
    
    __jsb_cc_pipeline_SPRITETEXTURE_proto = cls->getProto();
    __jsb_cc_pipeline_SPRITETEXTURE_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_REFLECTIONTEXTURE_class = nullptr;
se::Object* __jsb_cc_pipeline_REFLECTIONTEXTURE_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_REFLECTIONTEXTURE) 

static bool js_cc_pipeline_REFLECTIONTEXTURE_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::REFLECTIONTEXTURE::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_REFLECTIONTEXTURE_DESCRIPTOR_get) 

static bool js_cc_pipeline_REFLECTIONTEXTURE_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture result;
    
    result = cc::pipeline::REFLECTIONTEXTURE::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_REFLECTIONTEXTURE_LAYOUT_get) 

static bool js_cc_pipeline_REFLECTIONTEXTURE_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::REFLECTIONTEXTURE::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_REFLECTIONTEXTURE_NAME_get) 

static bool js_new_cc_pipeline_REFLECTIONTEXTURE(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::REFLECTIONTEXTURE *result;
    result = (cc::pipeline::REFLECTIONTEXTURE *)new cc::pipeline::REFLECTIONTEXTURE();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_REFLECTIONTEXTURE, __jsb_cc_pipeline_REFLECTIONTEXTURE_class, js_delete_cc_pipeline_REFLECTIONTEXTURE)

static bool js_delete_cc_pipeline_REFLECTIONTEXTURE(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_REFLECTIONTEXTURE) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::REFLECTIONTEXTURE * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::REFLECTIONTEXTURE*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_REFLECTIONTEXTURE(se::Object* obj) {
    auto* cls = se::Class::create("REFLECTIONTEXTURE", obj, nullptr, _SE(js_new_cc_pipeline_REFLECTIONTEXTURE)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_REFLECTIONTEXTURE_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_REFLECTIONTEXTURE_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_REFLECTIONTEXTURE_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_REFLECTIONTEXTURE));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::REFLECTIONTEXTURE>(cls);
    
    __jsb_cc_pipeline_REFLECTIONTEXTURE_proto = cls->getProto();
    __jsb_cc_pipeline_REFLECTIONTEXTURE_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_REFLECTIONSTORAGE_class = nullptr;
se::Object* __jsb_cc_pipeline_REFLECTIONSTORAGE_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_REFLECTIONSTORAGE) 

static bool js_cc_pipeline_REFLECTIONSTORAGE_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::REFLECTIONSTORAGE::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_REFLECTIONSTORAGE_DESCRIPTOR_get) 

static bool js_cc_pipeline_REFLECTIONSTORAGE_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformStorageImage result;
    
    result = cc::pipeline::REFLECTIONSTORAGE::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_REFLECTIONSTORAGE_LAYOUT_get) 

static bool js_cc_pipeline_REFLECTIONSTORAGE_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::REFLECTIONSTORAGE::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_REFLECTIONSTORAGE_NAME_get) 

static bool js_new_cc_pipeline_REFLECTIONSTORAGE(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::REFLECTIONSTORAGE *result;
    result = (cc::pipeline::REFLECTIONSTORAGE *)new cc::pipeline::REFLECTIONSTORAGE();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_REFLECTIONSTORAGE, __jsb_cc_pipeline_REFLECTIONSTORAGE_class, js_delete_cc_pipeline_REFLECTIONSTORAGE)

static bool js_delete_cc_pipeline_REFLECTIONSTORAGE(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_REFLECTIONSTORAGE) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::REFLECTIONSTORAGE * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::REFLECTIONSTORAGE*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_REFLECTIONSTORAGE(se::Object* obj) {
    auto* cls = se::Class::create("REFLECTIONSTORAGE", obj, nullptr, _SE(js_new_cc_pipeline_REFLECTIONSTORAGE)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_REFLECTIONSTORAGE_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_REFLECTIONSTORAGE_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_REFLECTIONSTORAGE_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_REFLECTIONSTORAGE));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::REFLECTIONSTORAGE>(cls);
    
    __jsb_cc_pipeline_REFLECTIONSTORAGE_proto = cls->getProto();
    __jsb_cc_pipeline_REFLECTIONSTORAGE_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_REFLECTIONPROBECUBEMAP_class = nullptr;
se::Object* __jsb_cc_pipeline_REFLECTIONPROBECUBEMAP_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_REFLECTIONPROBECUBEMAP) 

static bool js_cc_pipeline_REFLECTIONPROBECUBEMAP_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::REFLECTIONPROBECUBEMAP::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_REFLECTIONPROBECUBEMAP_DESCRIPTOR_get) 

static bool js_cc_pipeline_REFLECTIONPROBECUBEMAP_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture result;
    
    result = cc::pipeline::REFLECTIONPROBECUBEMAP::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_REFLECTIONPROBECUBEMAP_LAYOUT_get) 

static bool js_cc_pipeline_REFLECTIONPROBECUBEMAP_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::REFLECTIONPROBECUBEMAP::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_REFLECTIONPROBECUBEMAP_NAME_get) 

static bool js_new_cc_pipeline_REFLECTIONPROBECUBEMAP(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::REFLECTIONPROBECUBEMAP *result;
    result = (cc::pipeline::REFLECTIONPROBECUBEMAP *)new cc::pipeline::REFLECTIONPROBECUBEMAP();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_REFLECTIONPROBECUBEMAP, __jsb_cc_pipeline_REFLECTIONPROBECUBEMAP_class, js_delete_cc_pipeline_REFLECTIONPROBECUBEMAP)

static bool js_delete_cc_pipeline_REFLECTIONPROBECUBEMAP(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_REFLECTIONPROBECUBEMAP) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::REFLECTIONPROBECUBEMAP * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::REFLECTIONPROBECUBEMAP*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_REFLECTIONPROBECUBEMAP(se::Object* obj) {
    auto* cls = se::Class::create("REFLECTIONPROBECUBEMAP", obj, nullptr, _SE(js_new_cc_pipeline_REFLECTIONPROBECUBEMAP)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_REFLECTIONPROBECUBEMAP_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_REFLECTIONPROBECUBEMAP_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_REFLECTIONPROBECUBEMAP_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_REFLECTIONPROBECUBEMAP));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::REFLECTIONPROBECUBEMAP>(cls);
    
    __jsb_cc_pipeline_REFLECTIONPROBECUBEMAP_proto = cls->getProto();
    __jsb_cc_pipeline_REFLECTIONPROBECUBEMAP_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_REFLECTIONPROBEPLANARMAP_class = nullptr;
se::Object* __jsb_cc_pipeline_REFLECTIONPROBEPLANARMAP_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_REFLECTIONPROBEPLANARMAP) 

static bool js_cc_pipeline_REFLECTIONPROBEPLANARMAP_DESCRIPTOR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::DescriptorSetLayoutBinding result;
    
    result = cc::pipeline::REFLECTIONPROBEPLANARMAP::DESCRIPTOR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_REFLECTIONPROBEPLANARMAP_DESCRIPTOR_get) 

static bool js_cc_pipeline_REFLECTIONPROBEPLANARMAP_LAYOUT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::gfx::UniformSamplerTexture result;
    
    result = cc::pipeline::REFLECTIONPROBEPLANARMAP::LAYOUT;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_REFLECTIONPROBEPLANARMAP_LAYOUT_get) 

static bool js_cc_pipeline_REFLECTIONPROBEPLANARMAP_NAME_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    ccstd::string result;
    
    result = (ccstd::string)cc::pipeline::REFLECTIONPROBEPLANARMAP::NAME;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_REFLECTIONPROBEPLANARMAP_NAME_get) 

static bool js_new_cc_pipeline_REFLECTIONPROBEPLANARMAP(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::REFLECTIONPROBEPLANARMAP *result;
    result = (cc::pipeline::REFLECTIONPROBEPLANARMAP *)new cc::pipeline::REFLECTIONPROBEPLANARMAP();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_REFLECTIONPROBEPLANARMAP, __jsb_cc_pipeline_REFLECTIONPROBEPLANARMAP_class, js_delete_cc_pipeline_REFLECTIONPROBEPLANARMAP)

static bool js_delete_cc_pipeline_REFLECTIONPROBEPLANARMAP(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_REFLECTIONPROBEPLANARMAP) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::REFLECTIONPROBEPLANARMAP * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::REFLECTIONPROBEPLANARMAP*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    return ok;
}


bool js_register_cc_pipeline_REFLECTIONPROBEPLANARMAP(se::Object* obj) {
    auto* cls = se::Class::create("REFLECTIONPROBEPLANARMAP", obj, nullptr, _SE(js_new_cc_pipeline_REFLECTIONPROBEPLANARMAP)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    cls->defineStaticProperty("BINDING", nullptr, nullptr); 
    cls->defineStaticProperty("DESCRIPTOR", _SE(js_cc_pipeline_REFLECTIONPROBEPLANARMAP_DESCRIPTOR_get), nullptr); 
    cls->defineStaticProperty("LAYOUT", _SE(js_cc_pipeline_REFLECTIONPROBEPLANARMAP_LAYOUT_get), nullptr); 
    cls->defineStaticProperty("NAME", _SE(js_cc_pipeline_REFLECTIONPROBEPLANARMAP_NAME_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_REFLECTIONPROBEPLANARMAP));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::REFLECTIONPROBEPLANARMAP>(cls);
    
    __jsb_cc_pipeline_REFLECTIONPROBEPLANARMAP_proto = cls->getProto();
    __jsb_cc_pipeline_REFLECTIONPROBEPLANARMAP_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


static bool js_cc_pipeline_localDescriptorSetLayoutResizeMaxJoints(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    uint32_t arg1 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc::pipeline::localDescriptorSetLayoutResizeMaxJoints(SWIG_STD_MOVE(arg1));
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_localDescriptorSetLayoutResizeMaxJoints) 

se::Class* __jsb_cc_pipeline_RenderPipelineInfo_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderPipelineInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderPipelineInfo) 

static bool js_cc_pipeline_RenderPipelineInfo_tag_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipelineInfo *arg1 = (cc::pipeline::RenderPipelineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipelineInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->tag, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPipelineInfo_tag_set) 

static bool js_cc_pipeline_RenderPipelineInfo_tag_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPipelineInfo *arg1 = (cc::pipeline::RenderPipelineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipelineInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->tag, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPipelineInfo_tag_get) 

static bool js_cc_pipeline_RenderPipelineInfo_flows_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipelineInfo *arg1 = (cc::pipeline::RenderPipelineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipelineInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->flows, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPipelineInfo_flows_set) 

static bool js_cc_pipeline_RenderPipelineInfo_flows_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPipelineInfo *arg1 = (cc::pipeline::RenderPipelineInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipelineInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->flows, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->flows, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPipelineInfo_flows_get) 

static bool js_new_cc_pipeline_RenderPipelineInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::RenderPipelineInfo *result;
    result = (cc::pipeline::RenderPipelineInfo *)new cc::pipeline::RenderPipelineInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_RenderPipelineInfo, __jsb_cc_pipeline_RenderPipelineInfo_class, js_delete_cc_pipeline_RenderPipelineInfo)

static bool js_delete_cc_pipeline_RenderPipelineInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderPipelineInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::RenderPipelineInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::RenderPipelineInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("tag", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->tag), ctx);
    }
    
    
    json->getProperty("flows", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->flows), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_RenderPipelineInfo(se::Object* obj) {
    auto* cls = se::Class::create("RenderPipelineInfo", obj, nullptr, _SE(js_new_cc_pipeline_RenderPipelineInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("tag", _SE(js_cc_pipeline_RenderPipelineInfo_tag_get), _SE(js_cc_pipeline_RenderPipelineInfo_tag_set)); 
    cls->defineProperty("flows", _SE(js_cc_pipeline_RenderPipelineInfo_flows_get), _SE(js_cc_pipeline_RenderPipelineInfo_flows_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderPipelineInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderPipelineInfo>(cls);
    
    __jsb_cc_pipeline_RenderPipelineInfo_proto = cls->getProto();
    __jsb_cc_pipeline_RenderPipelineInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_RenderPipeline_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderPipeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderPipeline) 

static bool js_cc_pipeline_RenderPipeline_getInstance_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::pipeline::RenderPipeline *)cc::pipeline::RenderPipeline::getInstance();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getInstance_static) 

static bool js_cc_pipeline_RenderPipeline_getRenderArea_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::gfx::Rect result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = cc::pipeline::RenderPipeline::getRenderArea(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getRenderArea_static) 

static bool js_new_cc_pipeline_RenderPipeline(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::RenderPipeline *result;
    result = (cc::pipeline::RenderPipeline *)new cc::pipeline::RenderPipeline();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_RenderPipeline, __jsb_cc_pipeline_RenderPipeline_class, js_delete_cc_pipeline_RenderPipeline)

static bool js_delete_cc_pipeline_RenderPipeline(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderPipeline) 

static bool js_cc_pipeline_RenderPipeline_activate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::gfx::Swapchain *arg2 = (cc::gfx::Swapchain *) NULL ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (bool)(arg1)->activate(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_activate) 

static bool js_cc_pipeline_RenderPipeline_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->destroy();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_destroy) 

static bool js_cc_pipeline_RenderPipeline_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::pipeline::RenderPipelineInfo *arg2 = 0 ;
    cc::pipeline::RenderPipelineInfo temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (bool)(arg1)->initialize((cc::pipeline::RenderPipelineInfo const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_initialize) 

static bool js_cc_pipeline_RenderPipeline_render(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    ccstd::vector< cc::scene::Camera * > *arg2 = 0 ;
    ccstd::vector< cc::scene::Camera * > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->render((ccstd::vector< cc::scene::Camera * > const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_render) 

static bool js_cc_pipeline_RenderPipeline_onGlobalPipelineStateChanged(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    (arg1)->onGlobalPipelineStateChanged();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_onGlobalPipelineStateChanged) 

static bool js_cc_pipeline_RenderPipeline_getGlobalBindings(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    ccstd::unordered_map< ccstd::string,cc::pipeline::InternalBindingInst > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::unordered_map< ccstd::string,cc::pipeline::InternalBindingInst > *) &((cc::pipeline::RenderPipeline const *)arg1)->getGlobalBindings();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getGlobalBindings) 

static bool js_cc_pipeline_RenderPipeline_getMacros(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::MacroRecord *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    result = (cc::MacroRecord *) &((cc::pipeline::RenderPipeline const *)arg1)->getMacros();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getMacros) 

static bool js_cc_pipeline_RenderPipeline_setValue__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    ccstd::string *arg2 = 0 ;
    int32_t arg3 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setValue((ccstd::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_pipeline_RenderPipeline_setValue__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    ccstd::string *arg2 = 0 ;
    bool arg3 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setValue((ccstd::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_pipeline_RenderPipeline_setValue__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string *arg3 = 0 ;
    ccstd::string temp2 ;
    ccstd::string temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setValue((ccstd::string const &)*arg2,(ccstd::string const &)*arg3);
    
    
    return true;
}

static bool js_cc_pipeline_RenderPipeline_setValue(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_cc_pipeline_RenderPipeline_setValue__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_pipeline_RenderPipeline_setValue__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_pipeline_RenderPipeline_setValue__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_setValue) 

static bool js_cc_pipeline_RenderPipeline_getCommandBuffers(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::gfx::CommandBufferList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::CommandBufferList *) &((cc::pipeline::RenderPipeline const *)arg1)->getCommandBuffers();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getCommandBuffers) 

static bool js_cc_pipeline_RenderPipeline_getQueryPools(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::gfx::QueryPoolList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::QueryPoolList *) &((cc::pipeline::RenderPipeline const *)arg1)->getQueryPools();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getQueryPools) 

static bool js_cc_pipeline_RenderPipeline_getPipelineUBO(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::pipeline::PipelineUBO *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    result = (cc::pipeline::PipelineUBO *)((cc::pipeline::RenderPipeline const *)arg1)->getPipelineUBO();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getPipelineUBO) 

static bool js_cc_pipeline_RenderPipeline_getDevice(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::gfx::Device *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Device *)((cc::pipeline::RenderPipeline const *)arg1)->getDevice();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getDevice) 

static bool js_cc_pipeline_RenderPipeline_getRenderstageByName(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    cc::pipeline::RenderStage *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::pipeline::RenderStage *)((cc::pipeline::RenderPipeline const *)arg1)->getRenderstageByName((ccstd::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getRenderstageByName) 

static bool js_cc_pipeline_RenderPipeline_isOccluded(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    cc::scene::SubModel *arg3 = (cc::scene::SubModel *) NULL ;
    bool result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (bool)(arg1)->isOccluded((cc::scene::Camera const *)arg2,(cc::scene::SubModel const *)arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_isOccluded) 

static bool js_cc_pipeline_RenderPipeline_isOcclusionQueryEnabled(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    result = (bool)((cc::pipeline::RenderPipeline const *)arg1)->isOcclusionQueryEnabled();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_isOcclusionQueryEnabled) 

static bool js_cc_pipeline_RenderPipeline_setOcclusionQueryEnabled(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setOcclusionQueryEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_setOcclusionQueryEnabled) 

static bool js_cc_pipeline_RenderPipeline_isEnvmapEnabled(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    result = (bool)((cc::pipeline::RenderPipeline const *)arg1)->isEnvmapEnabled();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_isEnvmapEnabled) 

static bool js_cc_pipeline_RenderPipeline_getViewport(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    cc::gfx::Viewport result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (arg1)->getViewport(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getViewport) 

static bool js_cc_pipeline_RenderPipeline_getScissor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    cc::gfx::Rect result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (arg1)->getScissor(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getScissor) 

static bool js_cc_pipeline_RenderPipeline_genQuadVertexData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::Vec4 *arg2 = 0 ;
    float *arg3 ;
    cc::Vec4 temp2 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->genQuadVertexData((cc::Vec4 const &)*arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_genQuadVertexData) 

static bool js_cc_pipeline_RenderPipeline_getWidth(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    result = ((cc::pipeline::RenderPipeline const *)arg1)->getWidth();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getWidth) 

static bool js_cc_pipeline_RenderPipeline_getHeight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    result = ((cc::pipeline::RenderPipeline const *)arg1)->getHeight();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getHeight) 

static bool js_cc_pipeline_RenderPipeline_getClearcolor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    cc::gfx::Color result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = ((cc::pipeline::RenderPipeline const *)arg1)->getClearcolor(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getClearcolor) 

static bool js_cc_pipeline_RenderPipeline_getIAByRenderArea(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::gfx::Rect *arg2 = 0 ;
    cc::gfx::Rect temp2 ;
    cc::gfx::InputAssembler *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::InputAssembler *)(arg1)->getIAByRenderArea((cc::gfx::Rect const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_getIAByRenderArea) 

static bool js_cc_pipeline_RenderPipeline_updateQuadVertexData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::Vec4 *arg2 = 0 ;
    cc::gfx::Buffer *arg3 = (cc::gfx::Buffer *) NULL ;
    cc::Vec4 temp2 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->updateQuadVertexData((cc::Vec4 const &)*arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_updateQuadVertexData) 

static bool js_cc_pipeline_RenderPipeline_ensureEnoughSize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    ccstd::vector< cc::scene::Camera * > *arg2 = 0 ;
    ccstd::vector< cc::scene::Camera * > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->ensureEnoughSize((ccstd::vector< cc::scene::Camera * > const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_ensureEnoughSize) 

static bool js_cc_pipeline_RenderPipeline_createQuadInputAssembler(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::gfx::Buffer *arg2 = (cc::gfx::Buffer *) NULL ;
    cc::gfx::Buffer **arg3 = (cc::gfx::Buffer **) NULL ;
    cc::gfx::InputAssembler **arg4 = (cc::gfx::InputAssembler **) NULL ;
    bool result;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (bool)(arg1)->createQuadInputAssembler(arg2,arg3,arg4);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_createQuadInputAssembler) 

static bool js_cc_pipeline_RenderPipeline_resetRenderQueue(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->resetRenderQueue(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_resetRenderQueue) 

static bool js_cc_pipeline_RenderPipeline_isRenderQueueReset(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    result = (bool)((cc::pipeline::RenderPipeline const *)arg1)->isRenderQueueReset();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderPipeline_isRenderQueueReset) 

static bool js_cc_pipeline_RenderPipeline_globalDSManager_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::pipeline::GlobalDSManager *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    result = (cc::pipeline::GlobalDSManager *)cc_pipeline_RenderPipeline_globalDSManager_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPipeline_globalDSManager_get) 

static bool js_cc_pipeline_RenderPipeline_descriptorSet_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::gfx::DescriptorSet *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::DescriptorSet *)cc_pipeline_RenderPipeline_descriptorSet_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPipeline_descriptorSet_get) 

static bool js_cc_pipeline_RenderPipeline_descriptorSetLayout_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::gfx::DescriptorSetLayout *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::DescriptorSetLayout *)cc_pipeline_RenderPipeline_descriptorSetLayout_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPipeline_descriptorSetLayout_get) 

static bool js_cc_pipeline_RenderPipeline_constantMacros_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    ccstd::string *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::string *) &cc_pipeline_RenderPipeline_constantMacros_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPipeline_constantMacros_get) 

static bool js_cc_pipeline_RenderPipeline_clusterEnabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_pipeline_RenderPipeline_clusterEnabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPipeline_clusterEnabled_set) 

static bool js_cc_pipeline_RenderPipeline_clusterEnabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_pipeline_RenderPipeline_clusterEnabled_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPipeline_clusterEnabled_get) 

static bool js_cc_pipeline_RenderPipeline_bloomEnabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_pipeline_RenderPipeline_bloomEnabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPipeline_bloomEnabled_set) 

static bool js_cc_pipeline_RenderPipeline_bloomEnabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_pipeline_RenderPipeline_bloomEnabled_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPipeline_bloomEnabled_get) 

static bool js_cc_pipeline_RenderPipeline_pipelineSceneData_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::pipeline::PipelineSceneData *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    result = (cc::pipeline::PipelineSceneData *)cc_pipeline_RenderPipeline_pipelineSceneData_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPipeline_pipelineSceneData_get) 

static bool js_cc_pipeline_RenderPipeline_geometryRenderer_get(se::State& s)
{
#if CC_USE_GEOMETRY_RENDERER
    
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::pipeline::GeometryRenderer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    result = (cc::pipeline::GeometryRenderer *)cc_pipeline_RenderPipeline_geometryRenderer_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
#endif // CC_USE_GEOMETRY_RENDERER
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPipeline_geometryRenderer_get) 

static bool js_cc_pipeline_RenderPipeline_profiler_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::scene::Model *arg2 = (cc::scene::Model *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_pipeline_RenderPipeline_profiler_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPipeline_profiler_set) 

static bool js_cc_pipeline_RenderPipeline_profiler_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::scene::Model *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::Model *)cc_pipeline_RenderPipeline_profiler_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPipeline_profiler_get) 

static bool js_cc_pipeline_RenderPipeline_shadingScale_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_pipeline_RenderPipeline_shadingScale_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPipeline_shadingScale_set) 

static bool js_cc_pipeline_RenderPipeline_shadingScale_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_pipeline_RenderPipeline_shadingScale_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPipeline_shadingScale_get) 

static bool js_cc_pipeline_RenderPipeline__tag_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_pipeline_RenderPipeline__tag_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPipeline__tag_set) 

static bool js_cc_pipeline_RenderPipeline__tag_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    result = cc_pipeline_RenderPipeline__tag_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPipeline__tag_get) 

static bool js_cc_pipeline_RenderPipeline__flows_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::pipeline::RenderFlowList arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_pipeline_RenderPipeline__flows_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderPipeline__flows_set) 

static bool js_cc_pipeline_RenderPipeline__flows_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderPipeline *arg1 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::pipeline::RenderFlowList result;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderPipeline>(s);
    if (nullptr == arg1) return true;
    result = cc_pipeline_RenderPipeline__flows_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderPipeline__flows_get) 

bool js_register_cc_pipeline_RenderPipeline(se::Object* obj) {
    auto* cls = se::Class::create("RenderPipeline", obj, __jsb_cc_Asset_proto, _SE(js_new_cc_pipeline_RenderPipeline)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("globalDSManager", _SE(js_cc_pipeline_RenderPipeline_globalDSManager_get), nullptr); 
    cls->defineProperty("descriptorSet", _SE(js_cc_pipeline_RenderPipeline_descriptorSet_get), nullptr); 
    cls->defineProperty("descriptorSetLayout", _SE(js_cc_pipeline_RenderPipeline_descriptorSetLayout_get), nullptr); 
    cls->defineProperty("constantMacros", _SE(js_cc_pipeline_RenderPipeline_constantMacros_get), nullptr); 
    cls->defineProperty("clusterEnabled", _SE(js_cc_pipeline_RenderPipeline_clusterEnabled_get), _SE(js_cc_pipeline_RenderPipeline_clusterEnabled_set)); 
    cls->defineProperty("bloomEnabled", _SE(js_cc_pipeline_RenderPipeline_bloomEnabled_get), _SE(js_cc_pipeline_RenderPipeline_bloomEnabled_set)); 
    cls->defineProperty("pipelineSceneData", _SE(js_cc_pipeline_RenderPipeline_pipelineSceneData_get), nullptr); 
    cls->defineProperty("geometryRenderer", _SE(js_cc_pipeline_RenderPipeline_geometryRenderer_get), nullptr); 
    cls->defineProperty("profiler", _SE(js_cc_pipeline_RenderPipeline_profiler_get), _SE(js_cc_pipeline_RenderPipeline_profiler_set)); 
    cls->defineProperty("shadingScale", _SE(js_cc_pipeline_RenderPipeline_shadingScale_get), _SE(js_cc_pipeline_RenderPipeline_shadingScale_set)); 
    cls->defineProperty("_tag", _SE(js_cc_pipeline_RenderPipeline__tag_get), _SE(js_cc_pipeline_RenderPipeline__tag_set)); 
    cls->defineProperty("_flows", _SE(js_cc_pipeline_RenderPipeline__flows_get), _SE(js_cc_pipeline_RenderPipeline__flows_set)); 
    
    cls->defineFunction("activate", _SE(js_cc_pipeline_RenderPipeline_activate)); 
    cls->defineFunction("destroy", _SE(js_cc_pipeline_RenderPipeline_destroy)); 
    cls->defineFunction("initialize", _SE(js_cc_pipeline_RenderPipeline_initialize)); 
    cls->defineFunction("render", _SE(js_cc_pipeline_RenderPipeline_render)); 
    cls->defineFunction("onGlobalPipelineStateChanged", _SE(js_cc_pipeline_RenderPipeline_onGlobalPipelineStateChanged)); 
    cls->defineFunction("getGlobalBindings", _SE(js_cc_pipeline_RenderPipeline_getGlobalBindings)); 
    cls->defineFunction("getMacros", _SE(js_cc_pipeline_RenderPipeline_getMacros)); 
    cls->defineFunction("setValue", _SE(js_cc_pipeline_RenderPipeline_setValue)); 
    cls->defineFunction("getCommandBuffers", _SE(js_cc_pipeline_RenderPipeline_getCommandBuffers)); 
    cls->defineFunction("getQueryPools", _SE(js_cc_pipeline_RenderPipeline_getQueryPools)); 
    cls->defineFunction("getPipelineUBO", _SE(js_cc_pipeline_RenderPipeline_getPipelineUBO)); 
    cls->defineFunction("getDevice", _SE(js_cc_pipeline_RenderPipeline_getDevice)); 
    cls->defineFunction("getRenderstageByName", _SE(js_cc_pipeline_RenderPipeline_getRenderstageByName)); 
    cls->defineFunction("isOccluded", _SE(js_cc_pipeline_RenderPipeline_isOccluded)); 
    cls->defineFunction("isOcclusionQueryEnabled", _SE(js_cc_pipeline_RenderPipeline_isOcclusionQueryEnabled)); 
    cls->defineFunction("setOcclusionQueryEnabled", _SE(js_cc_pipeline_RenderPipeline_setOcclusionQueryEnabled)); 
    cls->defineFunction("isEnvmapEnabled", _SE(js_cc_pipeline_RenderPipeline_isEnvmapEnabled)); 
    cls->defineFunction("getViewport", _SE(js_cc_pipeline_RenderPipeline_getViewport)); 
    cls->defineFunction("getScissor", _SE(js_cc_pipeline_RenderPipeline_getScissor)); 
    cls->defineFunction("genQuadVertexData", _SE(js_cc_pipeline_RenderPipeline_genQuadVertexData)); 
    cls->defineFunction("getWidth", _SE(js_cc_pipeline_RenderPipeline_getWidth)); 
    cls->defineFunction("getHeight", _SE(js_cc_pipeline_RenderPipeline_getHeight)); 
    cls->defineFunction("getClearcolor", _SE(js_cc_pipeline_RenderPipeline_getClearcolor)); 
    cls->defineFunction("getIAByRenderArea", _SE(js_cc_pipeline_RenderPipeline_getIAByRenderArea)); 
    cls->defineFunction("updateQuadVertexData", _SE(js_cc_pipeline_RenderPipeline_updateQuadVertexData)); 
    cls->defineFunction("ensureEnoughSize", _SE(js_cc_pipeline_RenderPipeline_ensureEnoughSize)); 
    cls->defineFunction("createQuadInputAssembler", _SE(js_cc_pipeline_RenderPipeline_createQuadInputAssembler)); 
    cls->defineFunction("resetRenderQueue", _SE(js_cc_pipeline_RenderPipeline_resetRenderQueue)); 
    cls->defineFunction("isRenderQueueReset", _SE(js_cc_pipeline_RenderPipeline_isRenderQueueReset)); 
    
    
    cls->defineStaticFunction("getInstance", _SE(js_cc_pipeline_RenderPipeline_getInstance_static)); 
    cls->defineStaticFunction("getRenderArea", _SE(js_cc_pipeline_RenderPipeline_getRenderArea_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderPipeline));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderPipeline>(cls);
    
    __jsb_cc_pipeline_RenderPipeline_proto = cls->getProto();
    __jsb_cc_pipeline_RenderPipeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_RenderFlowInfo_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderFlowInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderFlowInfo) 

static bool js_cc_pipeline_RenderFlowInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlowInfo *arg1 = (cc::pipeline::RenderFlowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlowInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderFlowInfo_name_set) 

static bool js_cc_pipeline_RenderFlowInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderFlowInfo *arg1 = (cc::pipeline::RenderFlowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlowInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderFlowInfo_name_get) 

static bool js_cc_pipeline_RenderFlowInfo_priority_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlowInfo *arg1 = (cc::pipeline::RenderFlowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlowInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->priority, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderFlowInfo_priority_set) 

static bool js_cc_pipeline_RenderFlowInfo_priority_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderFlowInfo *arg1 = (cc::pipeline::RenderFlowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlowInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->priority, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderFlowInfo_priority_get) 

static bool js_cc_pipeline_RenderFlowInfo_tag_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlowInfo *arg1 = (cc::pipeline::RenderFlowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlowInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->tag, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderFlowInfo_tag_set) 

static bool js_cc_pipeline_RenderFlowInfo_tag_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderFlowInfo *arg1 = (cc::pipeline::RenderFlowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlowInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->tag, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderFlowInfo_tag_get) 

static bool js_cc_pipeline_RenderFlowInfo_stages_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlowInfo *arg1 = (cc::pipeline::RenderFlowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlowInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stages, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderFlowInfo_stages_set) 

static bool js_cc_pipeline_RenderFlowInfo_stages_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderFlowInfo *arg1 = (cc::pipeline::RenderFlowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlowInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stages, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->stages, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderFlowInfo_stages_get) 

static bool js_new_cc_pipeline_RenderFlowInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::RenderFlowInfo *result;
    result = (cc::pipeline::RenderFlowInfo *)new cc::pipeline::RenderFlowInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_RenderFlowInfo, __jsb_cc_pipeline_RenderFlowInfo_class, js_delete_cc_pipeline_RenderFlowInfo)

static bool js_delete_cc_pipeline_RenderFlowInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderFlowInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::RenderFlowInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::RenderFlowInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("priority", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->priority), ctx);
    }
    
    
    json->getProperty("tag", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->tag), ctx);
    }
    
    
    json->getProperty("stages", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stages), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_RenderFlowInfo(se::Object* obj) {
    auto* cls = se::Class::create("RenderFlowInfo", obj, nullptr, _SE(js_new_cc_pipeline_RenderFlowInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("name", _SE(js_cc_pipeline_RenderFlowInfo_name_get), _SE(js_cc_pipeline_RenderFlowInfo_name_set)); 
    cls->defineProperty("priority", _SE(js_cc_pipeline_RenderFlowInfo_priority_get), _SE(js_cc_pipeline_RenderFlowInfo_priority_set)); 
    cls->defineProperty("tag", _SE(js_cc_pipeline_RenderFlowInfo_tag_get), _SE(js_cc_pipeline_RenderFlowInfo_tag_set)); 
    cls->defineProperty("stages", _SE(js_cc_pipeline_RenderFlowInfo_stages_get), _SE(js_cc_pipeline_RenderFlowInfo_stages_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderFlowInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderFlowInfo>(cls);
    
    __jsb_cc_pipeline_RenderFlowInfo_proto = cls->getProto();
    __jsb_cc_pipeline_RenderFlowInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_RenderFlow_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderFlow_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderFlow) 

static bool js_new_cc_pipeline_RenderFlow(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::RenderFlow *result;
    result = (cc::pipeline::RenderFlow *)new cc::pipeline::RenderFlow();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_RenderFlow, __jsb_cc_pipeline_RenderFlow_class, js_delete_cc_pipeline_RenderFlow)

static bool js_delete_cc_pipeline_RenderFlow(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderFlow) 

static bool js_cc_pipeline_RenderFlow_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlow *arg1 = (cc::pipeline::RenderFlow *) NULL ;
    cc::pipeline::RenderFlowInfo *arg2 = 0 ;
    cc::pipeline::RenderFlowInfo temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlow>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (bool)(arg1)->initialize((cc::pipeline::RenderFlowInfo const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderFlow_initialize) 

static bool js_cc_pipeline_RenderFlow_activate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlow *arg1 = (cc::pipeline::RenderFlow *) NULL ;
    cc::pipeline::RenderPipeline *arg2 = (cc::pipeline::RenderPipeline *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlow>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->activate(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderFlow_activate) 

static bool js_cc_pipeline_RenderFlow_render(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlow *arg1 = (cc::pipeline::RenderFlow *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlow>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->render(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderFlow_render) 

static bool js_cc_pipeline_RenderFlow_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlow *arg1 = (cc::pipeline::RenderFlow *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlow>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderFlow_destroy) 

static bool js_cc_pipeline_RenderFlow_getRenderstageByName(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlow *arg1 = (cc::pipeline::RenderFlow *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    cc::pipeline::RenderStage *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlow>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::pipeline::RenderStage *)((cc::pipeline::RenderFlow const *)arg1)->getRenderstageByName((ccstd::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderFlow_getRenderstageByName) 

static bool js_cc_pipeline_RenderFlow__name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlow *arg1 = (cc::pipeline::RenderFlow *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlow>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_pipeline_RenderFlow__name_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderFlow__name_set) 

static bool js_cc_pipeline_RenderFlow__name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderFlow *arg1 = (cc::pipeline::RenderFlow *) NULL ;
    ccstd::string *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlow>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::string *) &cc_pipeline_RenderFlow__name_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderFlow__name_get) 

static bool js_cc_pipeline_RenderFlow__priority_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlow *arg1 = (cc::pipeline::RenderFlow *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlow>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_pipeline_RenderFlow__priority_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderFlow__priority_set) 

static bool js_cc_pipeline_RenderFlow__priority_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderFlow *arg1 = (cc::pipeline::RenderFlow *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlow>(s);
    if (nullptr == arg1) return true;
    result = cc_pipeline_RenderFlow__priority_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderFlow__priority_get) 

static bool js_cc_pipeline_RenderFlow__tag_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlow *arg1 = (cc::pipeline::RenderFlow *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlow>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_pipeline_RenderFlow__tag_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderFlow__tag_set) 

static bool js_cc_pipeline_RenderFlow__tag_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderFlow *arg1 = (cc::pipeline::RenderFlow *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlow>(s);
    if (nullptr == arg1) return true;
    result = cc_pipeline_RenderFlow__tag_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderFlow__tag_get) 

static bool js_cc_pipeline_RenderFlow__stages_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlow *arg1 = (cc::pipeline::RenderFlow *) NULL ;
    cc::pipeline::RenderStageList arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlow>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_pipeline_RenderFlow__stages_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderFlow__stages_set) 

static bool js_cc_pipeline_RenderFlow__stages_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderFlow *arg1 = (cc::pipeline::RenderFlow *) NULL ;
    cc::pipeline::RenderStageList result;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderFlow>(s);
    if (nullptr == arg1) return true;
    result = cc_pipeline_RenderFlow__stages_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderFlow__stages_get) 

bool js_register_cc_pipeline_RenderFlow(se::Object* obj) {
    auto* cls = se::Class::create("RenderFlow", obj, nullptr, _SE(js_new_cc_pipeline_RenderFlow)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("_name", _SE(js_cc_pipeline_RenderFlow__name_get), _SE(js_cc_pipeline_RenderFlow__name_set)); 
    cls->defineProperty("_priority", _SE(js_cc_pipeline_RenderFlow__priority_get), _SE(js_cc_pipeline_RenderFlow__priority_set)); 
    cls->defineProperty("_tag", _SE(js_cc_pipeline_RenderFlow__tag_get), _SE(js_cc_pipeline_RenderFlow__tag_set)); 
    cls->defineProperty("_stages", _SE(js_cc_pipeline_RenderFlow__stages_get), _SE(js_cc_pipeline_RenderFlow__stages_set)); 
    
    cls->defineFunction("initialize", _SE(js_cc_pipeline_RenderFlow_initialize)); 
    cls->defineFunction("activate", _SE(js_cc_pipeline_RenderFlow_activate)); 
    cls->defineFunction("render", _SE(js_cc_pipeline_RenderFlow_render)); 
    cls->defineFunction("destroy", _SE(js_cc_pipeline_RenderFlow_destroy)); 
    cls->defineFunction("getRenderstageByName", _SE(js_cc_pipeline_RenderFlow_getRenderstageByName)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderFlow));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderFlow>(cls);
    
    __jsb_cc_pipeline_RenderFlow_proto = cls->getProto();
    __jsb_cc_pipeline_RenderFlow_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_RenderStageInfo_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderStageInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderStageInfo) 

static bool js_cc_pipeline_RenderStageInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStageInfo *arg1 = (cc::pipeline::RenderStageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStageInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderStageInfo_name_set) 

static bool js_cc_pipeline_RenderStageInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderStageInfo *arg1 = (cc::pipeline::RenderStageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStageInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderStageInfo_name_get) 

static bool js_cc_pipeline_RenderStageInfo_priority_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStageInfo *arg1 = (cc::pipeline::RenderStageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStageInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->priority, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderStageInfo_priority_set) 

static bool js_cc_pipeline_RenderStageInfo_priority_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderStageInfo *arg1 = (cc::pipeline::RenderStageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStageInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->priority, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderStageInfo_priority_get) 

static bool js_cc_pipeline_RenderStageInfo_tag_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStageInfo *arg1 = (cc::pipeline::RenderStageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStageInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->tag, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderStageInfo_tag_set) 

static bool js_cc_pipeline_RenderStageInfo_tag_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderStageInfo *arg1 = (cc::pipeline::RenderStageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStageInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->tag, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderStageInfo_tag_get) 

static bool js_cc_pipeline_RenderStageInfo_renderQueues_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStageInfo *arg1 = (cc::pipeline::RenderStageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStageInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->renderQueues, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderStageInfo_renderQueues_set) 

static bool js_cc_pipeline_RenderStageInfo_renderQueues_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderStageInfo *arg1 = (cc::pipeline::RenderStageInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStageInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->renderQueues, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->renderQueues, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderStageInfo_renderQueues_get) 

static bool js_new_cc_pipeline_RenderStageInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::RenderStageInfo *result;
    result = (cc::pipeline::RenderStageInfo *)new cc::pipeline::RenderStageInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_RenderStageInfo, __jsb_cc_pipeline_RenderStageInfo_class, js_delete_cc_pipeline_RenderStageInfo)

static bool js_delete_cc_pipeline_RenderStageInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderStageInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::RenderStageInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::RenderStageInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("priority", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->priority), ctx);
    }
    
    
    json->getProperty("tag", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->tag), ctx);
    }
    
    
    json->getProperty("renderQueues", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->renderQueues), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_RenderStageInfo(se::Object* obj) {
    auto* cls = se::Class::create("RenderStageInfo", obj, nullptr, _SE(js_new_cc_pipeline_RenderStageInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("name", _SE(js_cc_pipeline_RenderStageInfo_name_get), _SE(js_cc_pipeline_RenderStageInfo_name_set)); 
    cls->defineProperty("priority", _SE(js_cc_pipeline_RenderStageInfo_priority_get), _SE(js_cc_pipeline_RenderStageInfo_priority_set)); 
    cls->defineProperty("tag", _SE(js_cc_pipeline_RenderStageInfo_tag_get), _SE(js_cc_pipeline_RenderStageInfo_tag_set)); 
    cls->defineProperty("renderQueues", _SE(js_cc_pipeline_RenderStageInfo_renderQueues_get), _SE(js_cc_pipeline_RenderStageInfo_renderQueues_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderStageInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderStageInfo>(cls);
    
    __jsb_cc_pipeline_RenderStageInfo_proto = cls->getProto();
    __jsb_cc_pipeline_RenderStageInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_RenderStage_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderStage_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderStage) 

static bool js_new_cc_pipeline_RenderStage(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::RenderStage *result;
    result = (cc::pipeline::RenderStage *)new cc::pipeline::RenderStage();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_RenderStage, __jsb_cc_pipeline_RenderStage_class, js_delete_cc_pipeline_RenderStage)

static bool js_delete_cc_pipeline_RenderStage(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderStage) 

static bool js_cc_pipeline_RenderStage_activate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStage *arg1 = (cc::pipeline::RenderStage *) NULL ;
    cc::pipeline::RenderPipeline *arg2 = (cc::pipeline::RenderPipeline *) NULL ;
    cc::pipeline::RenderFlow *arg3 = (cc::pipeline::RenderFlow *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->activate(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderStage_activate) 

static bool js_cc_pipeline_RenderStage_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStage *arg1 = (cc::pipeline::RenderStage *) NULL ;
    cc::pipeline::RenderStageInfo *arg2 = 0 ;
    cc::pipeline::RenderStageInfo temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (bool)(arg1)->initialize((cc::pipeline::RenderStageInfo const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderStage_initialize) 

static bool js_cc_pipeline_RenderStage_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStage *arg1 = (cc::pipeline::RenderStage *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStage>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderStage_destroy) 

static bool js_cc_pipeline_RenderStage_render(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStage *arg1 = (cc::pipeline::RenderStage *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->render(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderStage_render) 

static bool js_cc_pipeline_RenderStage_getFlow(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStage *arg1 = (cc::pipeline::RenderStage *) NULL ;
    cc::pipeline::RenderFlow *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStage>(s);
    if (nullptr == arg1) return true;
    result = (cc::pipeline::RenderFlow *)((cc::pipeline::RenderStage const *)arg1)->getFlow();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_RenderStage_getFlow) 

static bool js_cc_pipeline_RenderStage__name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStage *arg1 = (cc::pipeline::RenderStage *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_pipeline_RenderStage__name_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderStage__name_set) 

static bool js_cc_pipeline_RenderStage__name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderStage *arg1 = (cc::pipeline::RenderStage *) NULL ;
    ccstd::string *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStage>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::string *) &cc_pipeline_RenderStage__name_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderStage__name_get) 

static bool js_cc_pipeline_RenderStage__priority_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStage *arg1 = (cc::pipeline::RenderStage *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_pipeline_RenderStage__priority_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderStage__priority_set) 

static bool js_cc_pipeline_RenderStage__priority_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderStage *arg1 = (cc::pipeline::RenderStage *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStage>(s);
    if (nullptr == arg1) return true;
    result = cc_pipeline_RenderStage__priority_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderStage__priority_get) 

static bool js_cc_pipeline_RenderStage__tag_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStage *arg1 = (cc::pipeline::RenderStage *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_pipeline_RenderStage__tag_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderStage__tag_set) 

static bool js_cc_pipeline_RenderStage__tag_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderStage *arg1 = (cc::pipeline::RenderStage *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderStage>(s);
    if (nullptr == arg1) return true;
    result = cc_pipeline_RenderStage__tag_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderStage__tag_get) 

bool js_register_cc_pipeline_RenderStage(se::Object* obj) {
    auto* cls = se::Class::create("RenderStage", obj, nullptr, _SE(js_new_cc_pipeline_RenderStage)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("_name", _SE(js_cc_pipeline_RenderStage__name_get), _SE(js_cc_pipeline_RenderStage__name_set)); 
    cls->defineProperty("_priority", _SE(js_cc_pipeline_RenderStage__priority_get), _SE(js_cc_pipeline_RenderStage__priority_set)); 
    cls->defineProperty("_tag", _SE(js_cc_pipeline_RenderStage__tag_get), _SE(js_cc_pipeline_RenderStage__tag_set)); 
    
    cls->defineFunction("activate", _SE(js_cc_pipeline_RenderStage_activate)); 
    cls->defineFunction("initialize", _SE(js_cc_pipeline_RenderStage_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_pipeline_RenderStage_destroy)); 
    cls->defineFunction("render", _SE(js_cc_pipeline_RenderStage_render)); 
    cls->defineFunction("getFlow", _SE(js_cc_pipeline_RenderStage_getFlow)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderStage));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderStage>(cls);
    
    __jsb_cc_pipeline_RenderStage_proto = cls->getProto();
    __jsb_cc_pipeline_RenderStage_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_ForwardPipeline_class = nullptr;
se::Object* __jsb_cc_pipeline_ForwardPipeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_ForwardPipeline) 

static bool js_new_cc_pipeline_ForwardPipeline(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::ForwardPipeline *result;
    result = (cc::pipeline::ForwardPipeline *)new cc::pipeline::ForwardPipeline();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_ForwardPipeline, __jsb_cc_pipeline_ForwardPipeline_class, js_delete_cc_pipeline_ForwardPipeline)

static bool js_delete_cc_pipeline_ForwardPipeline(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_ForwardPipeline) 

static bool js_cc_pipeline_ForwardPipeline_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ForwardPipeline *arg1 = (cc::pipeline::ForwardPipeline *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ForwardPipeline>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->destroy();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ForwardPipeline_destroy) 

static bool js_cc_pipeline_ForwardPipeline_getValidLights(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ForwardPipeline *arg1 = (cc::pipeline::ForwardPipeline *) NULL ;
    cc::pipeline::LightList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ForwardPipeline>(s);
    if (nullptr == arg1) return true;
    result = (cc::pipeline::LightList *) &((cc::pipeline::ForwardPipeline const *)arg1)->getValidLights();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ForwardPipeline_getValidLights) 

static bool js_cc_pipeline_ForwardPipeline_getLightBuffers(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ForwardPipeline *arg1 = (cc::pipeline::ForwardPipeline *) NULL ;
    cc::gfx::BufferList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ForwardPipeline>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::BufferList *) &((cc::pipeline::ForwardPipeline const *)arg1)->getLightBuffers();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ForwardPipeline_getLightBuffers) 

static bool js_cc_pipeline_ForwardPipeline_getLightIndexOffsets(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ForwardPipeline *arg1 = (cc::pipeline::ForwardPipeline *) NULL ;
    cc::pipeline::UintList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ForwardPipeline>(s);
    if (nullptr == arg1) return true;
    result = (cc::pipeline::UintList *) &((cc::pipeline::ForwardPipeline const *)arg1)->getLightIndexOffsets();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ForwardPipeline_getLightIndexOffsets) 

static bool js_cc_pipeline_ForwardPipeline_getLightIndices(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ForwardPipeline *arg1 = (cc::pipeline::ForwardPipeline *) NULL ;
    cc::pipeline::UintList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ForwardPipeline>(s);
    if (nullptr == arg1) return true;
    result = (cc::pipeline::UintList *) &((cc::pipeline::ForwardPipeline const *)arg1)->getLightIndices();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ForwardPipeline_getLightIndices) 

bool js_register_cc_pipeline_ForwardPipeline(se::Object* obj) {
    auto* cls = se::Class::create("ForwardPipeline", obj, __jsb_cc_pipeline_RenderPipeline_proto, _SE(js_new_cc_pipeline_ForwardPipeline)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("destroy", _SE(js_cc_pipeline_ForwardPipeline_destroy)); 
    cls->defineFunction("getValidLights", _SE(js_cc_pipeline_ForwardPipeline_getValidLights)); 
    cls->defineFunction("getLightBuffers", _SE(js_cc_pipeline_ForwardPipeline_getLightBuffers)); 
    cls->defineFunction("getLightIndexOffsets", _SE(js_cc_pipeline_ForwardPipeline_getLightIndexOffsets)); 
    cls->defineFunction("getLightIndices", _SE(js_cc_pipeline_ForwardPipeline_getLightIndices)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_ForwardPipeline));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::ForwardPipeline>(cls);
    
    __jsb_cc_pipeline_ForwardPipeline_proto = cls->getProto();
    __jsb_cc_pipeline_ForwardPipeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_ForwardFlow_class = nullptr;
se::Object* __jsb_cc_pipeline_ForwardFlow_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_ForwardFlow) 

static bool js_cc_pipeline_ForwardFlow_getInitializeInfo_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlowInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::pipeline::RenderFlowInfo *) &cc::pipeline::ForwardFlow::getInitializeInfo();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ForwardFlow_getInitializeInfo_static) 

static bool js_new_cc_pipeline_ForwardFlow(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::ForwardFlow *result;
    result = (cc::pipeline::ForwardFlow *)new cc::pipeline::ForwardFlow();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_ForwardFlow, __jsb_cc_pipeline_ForwardFlow_class, js_delete_cc_pipeline_ForwardFlow)

static bool js_delete_cc_pipeline_ForwardFlow(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_ForwardFlow) 

bool js_register_cc_pipeline_ForwardFlow(se::Object* obj) {
    auto* cls = se::Class::create("ForwardFlow", obj, __jsb_cc_pipeline_RenderFlow_proto, _SE(js_new_cc_pipeline_ForwardFlow)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    
    cls->defineStaticFunction("getInitializeInfo", _SE(js_cc_pipeline_ForwardFlow_getInitializeInfo_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_ForwardFlow));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::ForwardFlow>(cls);
    
    __jsb_cc_pipeline_ForwardFlow_proto = cls->getProto();
    __jsb_cc_pipeline_ForwardFlow_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_ForwardStage_class = nullptr;
se::Object* __jsb_cc_pipeline_ForwardStage_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_ForwardStage) 

static bool js_cc_pipeline_ForwardStage_getInitializeInfo_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStageInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::pipeline::RenderStageInfo *) &cc::pipeline::ForwardStage::getInitializeInfo();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ForwardStage_getInitializeInfo_static) 

static bool js_new_cc_pipeline_ForwardStage(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::ForwardStage *result;
    result = (cc::pipeline::ForwardStage *)new cc::pipeline::ForwardStage();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_ForwardStage, __jsb_cc_pipeline_ForwardStage_class, js_delete_cc_pipeline_ForwardStage)

static bool js_delete_cc_pipeline_ForwardStage(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_ForwardStage) 

bool js_register_cc_pipeline_ForwardStage(se::Object* obj) {
    auto* cls = se::Class::create("ForwardStage", obj, __jsb_cc_pipeline_RenderStage_proto, _SE(js_new_cc_pipeline_ForwardStage)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    
    cls->defineStaticFunction("getInitializeInfo", _SE(js_cc_pipeline_ForwardStage_getInitializeInfo_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_ForwardStage));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::ForwardStage>(cls);
    
    __jsb_cc_pipeline_ForwardStage_proto = cls->getProto();
    __jsb_cc_pipeline_ForwardStage_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_ShadowFlow_class = nullptr;
se::Object* __jsb_cc_pipeline_ShadowFlow_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_ShadowFlow) 

static bool js_new_cc_pipeline_ShadowFlow(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::ShadowFlow *result;
    result = (cc::pipeline::ShadowFlow *)new cc::pipeline::ShadowFlow();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_ShadowFlow, __jsb_cc_pipeline_ShadowFlow_class, js_delete_cc_pipeline_ShadowFlow)

static bool js_delete_cc_pipeline_ShadowFlow(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_ShadowFlow) 

static bool js_cc_pipeline_ShadowFlow_getInitializeInfo_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlowInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::pipeline::RenderFlowInfo *) &cc::pipeline::ShadowFlow::getInitializeInfo();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowFlow_getInitializeInfo_static) 

bool js_register_cc_pipeline_ShadowFlow(se::Object* obj) {
    auto* cls = se::Class::create("ShadowFlow", obj, __jsb_cc_pipeline_RenderFlow_proto, _SE(js_new_cc_pipeline_ShadowFlow)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    
    cls->defineStaticFunction("getInitializeInfo", _SE(js_cc_pipeline_ShadowFlow_getInitializeInfo_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_ShadowFlow));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::ShadowFlow>(cls);
    
    __jsb_cc_pipeline_ShadowFlow_proto = cls->getProto();
    __jsb_cc_pipeline_ShadowFlow_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_ShadowStage_class = nullptr;
se::Object* __jsb_cc_pipeline_ShadowStage_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_ShadowStage) 

static bool js_new_cc_pipeline_ShadowStage(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::ShadowStage *result;
    result = (cc::pipeline::ShadowStage *)new cc::pipeline::ShadowStage();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_ShadowStage, __jsb_cc_pipeline_ShadowStage_class, js_delete_cc_pipeline_ShadowStage)

static bool js_delete_cc_pipeline_ShadowStage(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_ShadowStage) 

static bool js_cc_pipeline_ShadowStage_getInitializeInfo_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStageInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::pipeline::RenderStageInfo *) &cc::pipeline::ShadowStage::getInitializeInfo();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowStage_getInitializeInfo_static) 

static bool js_cc_pipeline_ShadowStage_setFramebuffer(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowStage *arg1 = (cc::pipeline::ShadowStage *) NULL ;
    cc::gfx::Framebuffer *arg2 = (cc::gfx::Framebuffer *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowStage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setFramebuffer(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowStage_setFramebuffer) 

static bool js_cc_pipeline_ShadowStage_setUsage__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::ShadowStage *arg1 = (cc::pipeline::ShadowStage *) NULL ;
    cc::gfx::DescriptorSet *arg2 = (cc::gfx::DescriptorSet *) NULL ;
    cc::scene::Light *arg3 = (cc::scene::Light *) NULL ;
    cc::gfx::Framebuffer *arg4 = (cc::gfx::Framebuffer *) NULL ;
    uint32_t arg5 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowStage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setUsage(arg2,(cc::scene::Light const *)arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_ShadowStage_setUsage__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::ShadowStage *arg1 = (cc::pipeline::ShadowStage *) NULL ;
    cc::gfx::DescriptorSet *arg2 = (cc::gfx::DescriptorSet *) NULL ;
    cc::scene::Light *arg3 = (cc::scene::Light *) NULL ;
    cc::gfx::Framebuffer *arg4 = (cc::gfx::Framebuffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowStage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setUsage(arg2,(cc::scene::Light const *)arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_ShadowStage_setUsage(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 4) {
        ok = js_cc_pipeline_ShadowStage_setUsage__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 3) {
        ok = js_cc_pipeline_ShadowStage_setUsage__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowStage_setUsage) 

static bool js_cc_pipeline_ShadowStage_clearFramebuffer(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowStage *arg1 = (cc::pipeline::ShadowStage *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowStage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->clearFramebuffer((cc::scene::Camera const *)arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowStage_clearFramebuffer) 

bool js_register_cc_pipeline_ShadowStage(se::Object* obj) {
    auto* cls = se::Class::create("ShadowStage", obj, __jsb_cc_pipeline_RenderStage_proto, _SE(js_new_cc_pipeline_ShadowStage)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("setFramebuffer", _SE(js_cc_pipeline_ShadowStage_setFramebuffer)); 
    cls->defineFunction("setUsage", _SE(js_cc_pipeline_ShadowStage_setUsage)); 
    cls->defineFunction("clearFramebuffer", _SE(js_cc_pipeline_ShadowStage_clearFramebuffer)); 
    
    
    cls->defineStaticFunction("getInitializeInfo", _SE(js_cc_pipeline_ShadowStage_getInitializeInfo_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_ShadowStage));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::ShadowStage>(cls);
    
    __jsb_cc_pipeline_ShadowStage_proto = cls->getProto();
    __jsb_cc_pipeline_ShadowStage_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_ShadowTransformInfo_class = nullptr;
se::Object* __jsb_cc_pipeline_ShadowTransformInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_ShadowTransformInfo) 

static bool js_new_cc_pipeline_ShadowTransformInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    uint32_t arg1 ;
    cc::pipeline::ShadowTransformInfo *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (cc::pipeline::ShadowTransformInfo *)new cc::pipeline::ShadowTransformInfo(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_ShadowTransformInfo, __jsb_cc_pipeline_ShadowTransformInfo_class, js_delete_cc_pipeline_ShadowTransformInfo)

static bool js_delete_cc_pipeline_ShadowTransformInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_ShadowTransformInfo) 

static bool js_cc_pipeline_ShadowTransformInfo_getLevel(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    if (nullptr == arg1) return true;
    result = ((cc::pipeline::ShadowTransformInfo const *)arg1)->getLevel();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_getLevel) 

static bool js_cc_pipeline_ShadowTransformInfo_getShadowObjects(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    cc::pipeline::RenderObjectList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::pipeline::RenderObjectList *) &(arg1)->getShadowObjects();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_getShadowObjects) 

static bool js_cc_pipeline_ShadowTransformInfo_setShadowObjects(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    cc::pipeline::RenderObjectList *arg2 = 0 ;
    cc::pipeline::RenderObjectList temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setShadowObjects((cc::pipeline::RenderObjectList &&)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_setShadowObjects) 

static bool js_cc_pipeline_ShadowTransformInfo_addShadowObject(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    cc::pipeline::RenderObject *arg2 = 0 ;
    cc::pipeline::RenderObject temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->addShadowObject((cc::pipeline::RenderObject &&)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_addShadowObject) 

static bool js_cc_pipeline_ShadowTransformInfo_clearShadowObjects(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    if (nullptr == arg1) return true;
    (arg1)->clearShadowObjects();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_clearShadowObjects) 

static bool js_cc_pipeline_ShadowTransformInfo_getShadowCameraFar(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    if (nullptr == arg1) return true;
    result = (float)((cc::pipeline::ShadowTransformInfo const *)arg1)->getShadowCameraFar();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_getShadowCameraFar) 

static bool js_cc_pipeline_ShadowTransformInfo_setShadowCameraFar(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setShadowCameraFar(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_setShadowCameraFar) 

static bool js_cc_pipeline_ShadowTransformInfo_getMatShadowView(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    cc::Mat4 *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::Mat4 *) &((cc::pipeline::ShadowTransformInfo const *)arg1)->getMatShadowView();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_getMatShadowView) 

static bool js_cc_pipeline_ShadowTransformInfo_setMatShadowView(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    cc::Mat4 *arg2 = 0 ;
    cc::Mat4 temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setMatShadowView((cc::Mat4 const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_setMatShadowView) 

static bool js_cc_pipeline_ShadowTransformInfo_getMatShadowProj(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    cc::Mat4 *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::Mat4 *) &((cc::pipeline::ShadowTransformInfo const *)arg1)->getMatShadowProj();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_getMatShadowProj) 

static bool js_cc_pipeline_ShadowTransformInfo_setMatShadowProj(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    cc::Mat4 *arg2 = 0 ;
    cc::Mat4 temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setMatShadowProj((cc::Mat4 const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_setMatShadowProj) 

static bool js_cc_pipeline_ShadowTransformInfo_getMatShadowViewProj(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    cc::Mat4 *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::Mat4 *) &((cc::pipeline::ShadowTransformInfo const *)arg1)->getMatShadowViewProj();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_getMatShadowViewProj) 

static bool js_cc_pipeline_ShadowTransformInfo_setMatShadowViewProj(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    cc::Mat4 *arg2 = 0 ;
    cc::Mat4 temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setMatShadowViewProj((cc::Mat4 const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_setMatShadowViewProj) 

static bool js_cc_pipeline_ShadowTransformInfo_getValidFrustum(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    geometry::Frustum *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    if (nullptr == arg1) return true;
    result = (geometry::Frustum *) &((cc::pipeline::ShadowTransformInfo const *)arg1)->getValidFrustum();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_getValidFrustum) 

static bool js_cc_pipeline_ShadowTransformInfo_getSplitFrustum(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    geometry::Frustum *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    if (nullptr == arg1) return true;
    result = (geometry::Frustum *) &((cc::pipeline::ShadowTransformInfo const *)arg1)->getSplitFrustum();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_getSplitFrustum) 

static bool js_cc_pipeline_ShadowTransformInfo_getLightViewFrustum(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    geometry::Frustum *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    if (nullptr == arg1) return true;
    result = (geometry::Frustum *) &((cc::pipeline::ShadowTransformInfo const *)arg1)->getLightViewFrustum();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_getLightViewFrustum) 

static bool js_cc_pipeline_ShadowTransformInfo_getCastLightViewBoundingBox(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    geometry::AABB *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    if (nullptr == arg1) return true;
    result = (geometry::AABB *) &((cc::pipeline::ShadowTransformInfo const *)arg1)->getCastLightViewBoundingBox();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_getCastLightViewBoundingBox) 

static bool js_cc_pipeline_ShadowTransformInfo_createMatrix(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    geometry::Frustum *arg2 = 0 ;
    cc::scene::DirectionalLight *arg3 = (cc::scene::DirectionalLight *) NULL ;
    float arg4 ;
    bool arg5 ;
    geometry::Frustum temp2 ;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->createMatrix((geometry::Frustum const &)*arg2,(cc::scene::DirectionalLight const *)arg3,arg4,arg5);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_createMatrix) 

static bool js_cc_pipeline_ShadowTransformInfo_copyToValidFrustum(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    geometry::Frustum *arg2 = 0 ;
    geometry::Frustum temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->copyToValidFrustum((geometry::Frustum const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_copyToValidFrustum) 

static bool js_cc_pipeline_ShadowTransformInfo_calculateValidFrustumOrtho(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    cc::Mat4 *arg6 = 0 ;
    cc::Mat4 temp6 ;
    
    if(argc != 5) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &temp6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg6 = &temp6;
    
    (arg1)->calculateValidFrustumOrtho(arg2,arg3,arg4,arg5,(cc::Mat4 const &)*arg6);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_calculateValidFrustumOrtho) 

static bool js_cc_pipeline_ShadowTransformInfo_calculateSplitFrustum(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ShadowTransformInfo *arg1 = (cc::pipeline::ShadowTransformInfo *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    cc::Mat4 *arg6 = 0 ;
    cc::Mat4 temp6 ;
    
    if(argc != 5) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ShadowTransformInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &temp6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg6 = &temp6;
    
    (arg1)->calculateSplitFrustum(arg2,arg3,arg4,arg5,(cc::Mat4 const &)*arg6);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ShadowTransformInfo_calculateSplitFrustum) 

bool js_register_cc_pipeline_ShadowTransformInfo(se::Object* obj) {
    auto* cls = se::Class::create("ShadowTransformInfo", obj, nullptr, _SE(js_new_cc_pipeline_ShadowTransformInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getLevel", _SE(js_cc_pipeline_ShadowTransformInfo_getLevel)); 
    cls->defineFunction("getShadowObjects", _SE(js_cc_pipeline_ShadowTransformInfo_getShadowObjects)); 
    cls->defineFunction("setShadowObjects", _SE(js_cc_pipeline_ShadowTransformInfo_setShadowObjects)); 
    cls->defineFunction("addShadowObject", _SE(js_cc_pipeline_ShadowTransformInfo_addShadowObject)); 
    cls->defineFunction("clearShadowObjects", _SE(js_cc_pipeline_ShadowTransformInfo_clearShadowObjects)); 
    cls->defineFunction("getShadowCameraFar", _SE(js_cc_pipeline_ShadowTransformInfo_getShadowCameraFar)); 
    cls->defineFunction("setShadowCameraFar", _SE(js_cc_pipeline_ShadowTransformInfo_setShadowCameraFar)); 
    cls->defineFunction("getMatShadowView", _SE(js_cc_pipeline_ShadowTransformInfo_getMatShadowView)); 
    cls->defineFunction("setMatShadowView", _SE(js_cc_pipeline_ShadowTransformInfo_setMatShadowView)); 
    cls->defineFunction("getMatShadowProj", _SE(js_cc_pipeline_ShadowTransformInfo_getMatShadowProj)); 
    cls->defineFunction("setMatShadowProj", _SE(js_cc_pipeline_ShadowTransformInfo_setMatShadowProj)); 
    cls->defineFunction("getMatShadowViewProj", _SE(js_cc_pipeline_ShadowTransformInfo_getMatShadowViewProj)); 
    cls->defineFunction("setMatShadowViewProj", _SE(js_cc_pipeline_ShadowTransformInfo_setMatShadowViewProj)); 
    cls->defineFunction("getValidFrustum", _SE(js_cc_pipeline_ShadowTransformInfo_getValidFrustum)); 
    cls->defineFunction("getSplitFrustum", _SE(js_cc_pipeline_ShadowTransformInfo_getSplitFrustum)); 
    cls->defineFunction("getLightViewFrustum", _SE(js_cc_pipeline_ShadowTransformInfo_getLightViewFrustum)); 
    cls->defineFunction("getCastLightViewBoundingBox", _SE(js_cc_pipeline_ShadowTransformInfo_getCastLightViewBoundingBox)); 
    cls->defineFunction("createMatrix", _SE(js_cc_pipeline_ShadowTransformInfo_createMatrix)); 
    cls->defineFunction("copyToValidFrustum", _SE(js_cc_pipeline_ShadowTransformInfo_copyToValidFrustum)); 
    cls->defineFunction("calculateValidFrustumOrtho", _SE(js_cc_pipeline_ShadowTransformInfo_calculateValidFrustumOrtho)); 
    cls->defineFunction("calculateSplitFrustum", _SE(js_cc_pipeline_ShadowTransformInfo_calculateSplitFrustum)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_ShadowTransformInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::ShadowTransformInfo>(cls);
    
    __jsb_cc_pipeline_ShadowTransformInfo_proto = cls->getProto();
    __jsb_cc_pipeline_ShadowTransformInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_CSMLayerInfo_class = nullptr;
se::Object* __jsb_cc_pipeline_CSMLayerInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_CSMLayerInfo) 

static bool js_new_cc_pipeline_CSMLayerInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    uint32_t arg1 ;
    cc::pipeline::CSMLayerInfo *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (cc::pipeline::CSMLayerInfo *)new cc::pipeline::CSMLayerInfo(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_CSMLayerInfo, __jsb_cc_pipeline_CSMLayerInfo_class, js_delete_cc_pipeline_CSMLayerInfo)

static bool js_delete_cc_pipeline_CSMLayerInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_CSMLayerInfo) 

static bool js_cc_pipeline_CSMLayerInfo_getSplitCameraNear(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::CSMLayerInfo *arg1 = (cc::pipeline::CSMLayerInfo *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::CSMLayerInfo>(s);
    if (nullptr == arg1) return true;
    result = (float)((cc::pipeline::CSMLayerInfo const *)arg1)->getSplitCameraNear();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_CSMLayerInfo_getSplitCameraNear) 

static bool js_cc_pipeline_CSMLayerInfo_setSplitCameraNear(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::CSMLayerInfo *arg1 = (cc::pipeline::CSMLayerInfo *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::CSMLayerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setSplitCameraNear(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_CSMLayerInfo_setSplitCameraNear) 

static bool js_cc_pipeline_CSMLayerInfo_getSplitCameraFar(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::CSMLayerInfo *arg1 = (cc::pipeline::CSMLayerInfo *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::CSMLayerInfo>(s);
    if (nullptr == arg1) return true;
    result = (float)((cc::pipeline::CSMLayerInfo const *)arg1)->getSplitCameraFar();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_CSMLayerInfo_getSplitCameraFar) 

static bool js_cc_pipeline_CSMLayerInfo_setSplitCameraFar(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::CSMLayerInfo *arg1 = (cc::pipeline::CSMLayerInfo *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::CSMLayerInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setSplitCameraFar(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_CSMLayerInfo_setSplitCameraFar) 

static bool js_cc_pipeline_CSMLayerInfo_getCSMAtlas(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::CSMLayerInfo *arg1 = (cc::pipeline::CSMLayerInfo *) NULL ;
    cc::Vec4 *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::CSMLayerInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::Vec4 *) &((cc::pipeline::CSMLayerInfo const *)arg1)->getCSMAtlas();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_CSMLayerInfo_getCSMAtlas) 

bool js_register_cc_pipeline_CSMLayerInfo(se::Object* obj) {
    auto* cls = se::Class::create("CSMLayerInfo", obj, __jsb_cc_pipeline_ShadowTransformInfo_proto, _SE(js_new_cc_pipeline_CSMLayerInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getSplitCameraNear", _SE(js_cc_pipeline_CSMLayerInfo_getSplitCameraNear)); 
    cls->defineFunction("setSplitCameraNear", _SE(js_cc_pipeline_CSMLayerInfo_setSplitCameraNear)); 
    cls->defineFunction("getSplitCameraFar", _SE(js_cc_pipeline_CSMLayerInfo_getSplitCameraFar)); 
    cls->defineFunction("setSplitCameraFar", _SE(js_cc_pipeline_CSMLayerInfo_setSplitCameraFar)); 
    cls->defineFunction("getCSMAtlas", _SE(js_cc_pipeline_CSMLayerInfo_getCSMAtlas)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_CSMLayerInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::CSMLayerInfo>(cls);
    
    __jsb_cc_pipeline_CSMLayerInfo_proto = cls->getProto();
    __jsb_cc_pipeline_CSMLayerInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_CSMLayers_class = nullptr;
se::Object* __jsb_cc_pipeline_CSMLayers_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_CSMLayers) 

static bool js_new_cc_pipeline_CSMLayers(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::CSMLayers *result;
    result = (cc::pipeline::CSMLayers *)new cc::pipeline::CSMLayers();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_CSMLayers, __jsb_cc_pipeline_CSMLayers_class, js_delete_cc_pipeline_CSMLayers)

static bool js_delete_cc_pipeline_CSMLayers(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_CSMLayers) 

bool js_register_cc_pipeline_CSMLayers(se::Object* obj) {
    auto* cls = se::Class::create("CSMLayers", obj, nullptr, _SE(js_new_cc_pipeline_CSMLayers)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_CSMLayers));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::CSMLayers>(cls);
    
    __jsb_cc_pipeline_CSMLayers_proto = cls->getProto();
    __jsb_cc_pipeline_CSMLayers_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_GlobalDSManager_class = nullptr;
se::Object* __jsb_cc_pipeline_GlobalDSManager_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_GlobalDSManager) 

static bool js_new_cc_pipeline_GlobalDSManager(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::GlobalDSManager *result;
    result = (cc::pipeline::GlobalDSManager *)new cc::pipeline::GlobalDSManager();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_GlobalDSManager, __jsb_cc_pipeline_GlobalDSManager_class, js_delete_cc_pipeline_GlobalDSManager)

static bool js_delete_cc_pipeline_GlobalDSManager(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_GlobalDSManager) 

static bool js_cc_pipeline_GlobalDSManager_getLinearSampler(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::GlobalDSManager *arg1 = (cc::pipeline::GlobalDSManager *) NULL ;
    cc::gfx::Sampler *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::GlobalDSManager>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Sampler *)((cc::pipeline::GlobalDSManager const *)arg1)->getLinearSampler();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GlobalDSManager_getLinearSampler) 

static bool js_cc_pipeline_GlobalDSManager_getPointSampler(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::GlobalDSManager *arg1 = (cc::pipeline::GlobalDSManager *) NULL ;
    cc::gfx::Sampler *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::GlobalDSManager>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Sampler *)((cc::pipeline::GlobalDSManager const *)arg1)->getPointSampler();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GlobalDSManager_getPointSampler) 

static bool js_cc_pipeline_GlobalDSManager_getDescriptorSetLayout(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::GlobalDSManager *arg1 = (cc::pipeline::GlobalDSManager *) NULL ;
    cc::gfx::DescriptorSetLayout *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::GlobalDSManager>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::DescriptorSetLayout *)((cc::pipeline::GlobalDSManager const *)arg1)->getDescriptorSetLayout();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GlobalDSManager_getDescriptorSetLayout) 

static bool js_cc_pipeline_GlobalDSManager_getGlobalDescriptorSet(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::GlobalDSManager *arg1 = (cc::pipeline::GlobalDSManager *) NULL ;
    cc::gfx::DescriptorSet *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::GlobalDSManager>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::DescriptorSet *)((cc::pipeline::GlobalDSManager const *)arg1)->getGlobalDescriptorSet();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GlobalDSManager_getGlobalDescriptorSet) 

static bool js_cc_pipeline_GlobalDSManager_activate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::GlobalDSManager *arg1 = (cc::pipeline::GlobalDSManager *) NULL ;
    cc::gfx::Device *arg2 = (cc::gfx::Device *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::GlobalDSManager>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->activate(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GlobalDSManager_activate) 

static bool js_cc_pipeline_GlobalDSManager_bindBuffer(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::GlobalDSManager *arg1 = (cc::pipeline::GlobalDSManager *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Buffer *arg3 = (cc::gfx::Buffer *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::GlobalDSManager>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->bindBuffer(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GlobalDSManager_bindBuffer) 

static bool js_cc_pipeline_GlobalDSManager_bindTexture(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::GlobalDSManager *arg1 = (cc::pipeline::GlobalDSManager *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Texture *arg3 = (cc::gfx::Texture *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::GlobalDSManager>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->bindTexture(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GlobalDSManager_bindTexture) 

static bool js_cc_pipeline_GlobalDSManager_bindSampler(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::GlobalDSManager *arg1 = (cc::pipeline::GlobalDSManager *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Sampler *arg3 = (cc::gfx::Sampler *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::GlobalDSManager>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->bindSampler(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GlobalDSManager_bindSampler) 

static bool js_cc_pipeline_GlobalDSManager_update(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::GlobalDSManager *arg1 = (cc::pipeline::GlobalDSManager *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::GlobalDSManager>(s);
    if (nullptr == arg1) return true;
    (arg1)->update();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GlobalDSManager_update) 

static bool js_cc_pipeline_GlobalDSManager_getOrCreateDescriptorSet(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::GlobalDSManager *arg1 = (cc::pipeline::GlobalDSManager *) NULL ;
    cc::scene::Light *arg2 = (cc::scene::Light *) NULL ;
    cc::gfx::DescriptorSet *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::GlobalDSManager>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::gfx::DescriptorSet *)(arg1)->getOrCreateDescriptorSet((cc::scene::Light const *)arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GlobalDSManager_getOrCreateDescriptorSet) 

static bool js_cc_pipeline_GlobalDSManager_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::GlobalDSManager *arg1 = (cc::pipeline::GlobalDSManager *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::GlobalDSManager>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GlobalDSManager_destroy) 

static bool js_cc_pipeline_GlobalDSManager_setDescriptorSetLayout_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    cc::pipeline::GlobalDSManager::setDescriptorSetLayout();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GlobalDSManager_setDescriptorSetLayout_static) 

bool js_register_cc_pipeline_GlobalDSManager(se::Object* obj) {
    auto* cls = se::Class::create("GlobalDSManager", obj, nullptr, _SE(js_new_cc_pipeline_GlobalDSManager)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("getLinearSampler", _SE(js_cc_pipeline_GlobalDSManager_getLinearSampler)); 
    cls->defineFunction("getPointSampler", _SE(js_cc_pipeline_GlobalDSManager_getPointSampler)); 
    cls->defineFunction("getDescriptorSetLayout", _SE(js_cc_pipeline_GlobalDSManager_getDescriptorSetLayout)); 
    cls->defineFunction("getGlobalDescriptorSet", _SE(js_cc_pipeline_GlobalDSManager_getGlobalDescriptorSet)); 
    cls->defineFunction("activate", _SE(js_cc_pipeline_GlobalDSManager_activate)); 
    cls->defineFunction("bindBuffer", _SE(js_cc_pipeline_GlobalDSManager_bindBuffer)); 
    cls->defineFunction("bindTexture", _SE(js_cc_pipeline_GlobalDSManager_bindTexture)); 
    cls->defineFunction("bindSampler", _SE(js_cc_pipeline_GlobalDSManager_bindSampler)); 
    cls->defineFunction("update", _SE(js_cc_pipeline_GlobalDSManager_update)); 
    cls->defineFunction("getOrCreateDescriptorSet", _SE(js_cc_pipeline_GlobalDSManager_getOrCreateDescriptorSet)); 
    cls->defineFunction("destroy", _SE(js_cc_pipeline_GlobalDSManager_destroy)); 
    
    
    cls->defineStaticFunction("setDescriptorSetLayout", _SE(js_cc_pipeline_GlobalDSManager_setDescriptorSetLayout_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_GlobalDSManager));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::GlobalDSManager>(cls);
    
    __jsb_cc_pipeline_GlobalDSManager_proto = cls->getProto();
    __jsb_cc_pipeline_GlobalDSManager_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_InstancedItem_class = nullptr;
se::Object* __jsb_cc_pipeline_InstancedItem_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_InstancedItem) 

static bool js_cc_pipeline_InstancedItem_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InstancedItem_count_set) 

static bool js_cc_pipeline_InstancedItem_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InstancedItem_count_get) 

static bool js_cc_pipeline_InstancedItem_capacity_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->capacity, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InstancedItem_capacity_set) 

static bool js_cc_pipeline_InstancedItem_capacity_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->capacity, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InstancedItem_capacity_get) 

static bool js_cc_pipeline_InstancedItem_vb_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->vb, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InstancedItem_vb_set) 

static bool js_cc_pipeline_InstancedItem_vb_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->vb, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->vb, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InstancedItem_vb_get) 

static bool js_cc_pipeline_InstancedItem_data_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->data, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InstancedItem_data_set) 

static bool js_cc_pipeline_InstancedItem_data_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->data, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->data, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InstancedItem_data_get) 

static bool js_cc_pipeline_InstancedItem_ia_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->ia, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InstancedItem_ia_set) 

static bool js_cc_pipeline_InstancedItem_ia_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->ia, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->ia, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InstancedItem_ia_get) 

static bool js_cc_pipeline_InstancedItem_stride_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->stride, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InstancedItem_stride_set) 

static bool js_cc_pipeline_InstancedItem_stride_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->stride, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InstancedItem_stride_get) 

static bool js_cc_pipeline_InstancedItem_shader_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->shader, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InstancedItem_shader_set) 

static bool js_cc_pipeline_InstancedItem_shader_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->shader, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->shader, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InstancedItem_shader_get) 

static bool js_cc_pipeline_InstancedItem_descriptorSet_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->descriptorSet, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InstancedItem_descriptorSet_set) 

static bool js_cc_pipeline_InstancedItem_descriptorSet_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->descriptorSet, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->descriptorSet, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InstancedItem_descriptorSet_get) 

static bool js_cc_pipeline_InstancedItem_lightingMap_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->lightingMap, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InstancedItem_lightingMap_set) 

static bool js_cc_pipeline_InstancedItem_lightingMap_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->lightingMap, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->lightingMap, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InstancedItem_lightingMap_get) 

static bool js_cc_pipeline_InstancedItem_reflectionProbeCubemap_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->reflectionProbeCubemap, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InstancedItem_reflectionProbeCubemap_set) 

static bool js_cc_pipeline_InstancedItem_reflectionProbeCubemap_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->reflectionProbeCubemap, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->reflectionProbeCubemap, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InstancedItem_reflectionProbeCubemap_get) 

static bool js_cc_pipeline_InstancedItem_reflectionProbePlanarMap_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->reflectionProbePlanarMap, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InstancedItem_reflectionProbePlanarMap_set) 

static bool js_cc_pipeline_InstancedItem_reflectionProbePlanarMap_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->reflectionProbePlanarMap, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->reflectionProbePlanarMap, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InstancedItem_reflectionProbePlanarMap_get) 

static bool js_cc_pipeline_InstancedItem_reflectionProbeType_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->reflectionProbeType, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_InstancedItem_reflectionProbeType_set) 

static bool js_cc_pipeline_InstancedItem_reflectionProbeType_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::InstancedItem *arg1 = (cc::pipeline::InstancedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->reflectionProbeType, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_InstancedItem_reflectionProbeType_get) 

static bool js_new_cc_pipeline_InstancedItem(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::InstancedItem *result;
    result = (cc::pipeline::InstancedItem *)new cc::pipeline::InstancedItem();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_InstancedItem, __jsb_cc_pipeline_InstancedItem_class, js_delete_cc_pipeline_InstancedItem)

static bool js_delete_cc_pipeline_InstancedItem(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_InstancedItem) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::InstancedItem * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::InstancedItem*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("capacity", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->capacity), ctx);
    }
    
    
    json->getProperty("vb", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->vb), ctx);
    }
    
    
    json->getProperty("data", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->data), ctx);
    }
    
    
    json->getProperty("ia", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->ia), ctx);
    }
    
    
    json->getProperty("stride", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->stride), ctx);
    }
    
    
    json->getProperty("shader", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->shader), ctx);
    }
    
    
    json->getProperty("descriptorSet", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->descriptorSet), ctx);
    }
    
    
    json->getProperty("lightingMap", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->lightingMap), ctx);
    }
    
    
    json->getProperty("reflectionProbeCubemap", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->reflectionProbeCubemap), ctx);
    }
    
    
    json->getProperty("reflectionProbePlanarMap", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->reflectionProbePlanarMap), ctx);
    }
    
    
    json->getProperty("reflectionProbeType", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->reflectionProbeType), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_InstancedItem(se::Object* obj) {
    auto* cls = se::Class::create("InstancedItem", obj, nullptr, _SE(js_new_cc_pipeline_InstancedItem)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("count", _SE(js_cc_pipeline_InstancedItem_count_get), _SE(js_cc_pipeline_InstancedItem_count_set)); 
    cls->defineProperty("capacity", _SE(js_cc_pipeline_InstancedItem_capacity_get), _SE(js_cc_pipeline_InstancedItem_capacity_set)); 
    cls->defineProperty("vb", _SE(js_cc_pipeline_InstancedItem_vb_get), _SE(js_cc_pipeline_InstancedItem_vb_set)); 
    cls->defineProperty("data", _SE(js_cc_pipeline_InstancedItem_data_get), _SE(js_cc_pipeline_InstancedItem_data_set)); 
    cls->defineProperty("ia", _SE(js_cc_pipeline_InstancedItem_ia_get), _SE(js_cc_pipeline_InstancedItem_ia_set)); 
    cls->defineProperty("stride", _SE(js_cc_pipeline_InstancedItem_stride_get), _SE(js_cc_pipeline_InstancedItem_stride_set)); 
    cls->defineProperty("shader", _SE(js_cc_pipeline_InstancedItem_shader_get), _SE(js_cc_pipeline_InstancedItem_shader_set)); 
    cls->defineProperty("descriptorSet", _SE(js_cc_pipeline_InstancedItem_descriptorSet_get), _SE(js_cc_pipeline_InstancedItem_descriptorSet_set)); 
    cls->defineProperty("lightingMap", _SE(js_cc_pipeline_InstancedItem_lightingMap_get), _SE(js_cc_pipeline_InstancedItem_lightingMap_set)); 
    cls->defineProperty("reflectionProbeCubemap", _SE(js_cc_pipeline_InstancedItem_reflectionProbeCubemap_get), _SE(js_cc_pipeline_InstancedItem_reflectionProbeCubemap_set)); 
    cls->defineProperty("reflectionProbePlanarMap", _SE(js_cc_pipeline_InstancedItem_reflectionProbePlanarMap_get), _SE(js_cc_pipeline_InstancedItem_reflectionProbePlanarMap_set)); 
    cls->defineProperty("reflectionProbeType", _SE(js_cc_pipeline_InstancedItem_reflectionProbeType_get), _SE(js_cc_pipeline_InstancedItem_reflectionProbeType_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_InstancedItem));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::InstancedItem>(cls);
    
    __jsb_cc_pipeline_InstancedItem_proto = cls->getProto();
    __jsb_cc_pipeline_InstancedItem_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_InstancedBuffer_class = nullptr;
se::Object* __jsb_cc_pipeline_InstancedBuffer_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_InstancedBuffer) 

static bool js_new_cc_pipeline_InstancedBuffer(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::pipeline::InstancedBuffer *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::pipeline::InstancedBuffer *)new cc::pipeline::InstancedBuffer((cc::scene::Pass const *)arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_InstancedBuffer, __jsb_cc_pipeline_InstancedBuffer_class, js_delete_cc_pipeline_InstancedBuffer)

static bool js_delete_cc_pipeline_InstancedBuffer(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_InstancedBuffer) 

static bool js_cc_pipeline_InstancedBuffer_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedBuffer *arg1 = (cc::pipeline::InstancedBuffer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedBuffer>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_InstancedBuffer_destroy) 

static bool js_cc_pipeline_InstancedBuffer_merge__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::InstancedBuffer *arg1 = (cc::pipeline::InstancedBuffer *) NULL ;
    cc::scene::SubModel *arg2 = (cc::scene::SubModel *) NULL ;
    uint32_t arg3 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->merge(arg2,arg3);
    
    
    return true;
}

static bool js_cc_pipeline_InstancedBuffer_merge__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::InstancedBuffer *arg1 = (cc::pipeline::InstancedBuffer *) NULL ;
    cc::scene::SubModel *arg2 = (cc::scene::SubModel *) NULL ;
    uint32_t arg3 ;
    cc::gfx::Shader *arg4 = (cc::gfx::Shader *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->merge(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_InstancedBuffer_merge(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_cc_pipeline_InstancedBuffer_merge__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 3) {
        ok = js_cc_pipeline_InstancedBuffer_merge__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_InstancedBuffer_merge) 

static bool js_cc_pipeline_InstancedBuffer_uploadBuffers(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedBuffer *arg1 = (cc::pipeline::InstancedBuffer *) NULL ;
    cc::gfx::CommandBuffer *arg2 = (cc::gfx::CommandBuffer *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    ((cc::pipeline::InstancedBuffer const *)arg1)->uploadBuffers(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_InstancedBuffer_uploadBuffers) 

static bool js_cc_pipeline_InstancedBuffer_clear(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedBuffer *arg1 = (cc::pipeline::InstancedBuffer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedBuffer>(s);
    if (nullptr == arg1) return true;
    (arg1)->clear();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_InstancedBuffer_clear) 

static bool js_cc_pipeline_InstancedBuffer_setDynamicOffset(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedBuffer *arg1 = (cc::pipeline::InstancedBuffer *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setDynamicOffset(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_InstancedBuffer_setDynamicOffset) 

static bool js_cc_pipeline_InstancedBuffer_getInstances(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedBuffer *arg1 = (cc::pipeline::InstancedBuffer *) NULL ;
    cc::pipeline::InstancedItemList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedBuffer>(s);
    if (nullptr == arg1) return true;
    result = (cc::pipeline::InstancedItemList *) &((cc::pipeline::InstancedBuffer const *)arg1)->getInstances();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_InstancedBuffer_getInstances) 

static bool js_cc_pipeline_InstancedBuffer_getPass(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedBuffer *arg1 = (cc::pipeline::InstancedBuffer *) NULL ;
    cc::scene::Pass *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedBuffer>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::Pass *)((cc::pipeline::InstancedBuffer const *)arg1)->getPass();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_InstancedBuffer_getPass) 

static bool js_cc_pipeline_InstancedBuffer_hasPendingModels(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedBuffer *arg1 = (cc::pipeline::InstancedBuffer *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedBuffer>(s);
    if (nullptr == arg1) return true;
    result = (bool)((cc::pipeline::InstancedBuffer const *)arg1)->hasPendingModels();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_InstancedBuffer_hasPendingModels) 

static bool js_cc_pipeline_InstancedBuffer_dynamicOffsets(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::InstancedBuffer *arg1 = (cc::pipeline::InstancedBuffer *) NULL ;
    cc::pipeline::DynamicOffsetList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::InstancedBuffer>(s);
    if (nullptr == arg1) return true;
    result = (cc::pipeline::DynamicOffsetList *) &((cc::pipeline::InstancedBuffer const *)arg1)->dynamicOffsets();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_InstancedBuffer_dynamicOffsets) 

bool js_register_cc_pipeline_InstancedBuffer(se::Object* obj) {
    auto* cls = se::Class::create("InstancedBuffer", obj, nullptr, _SE(js_new_cc_pipeline_InstancedBuffer)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("destroy", _SE(js_cc_pipeline_InstancedBuffer_destroy)); 
    cls->defineFunction("merge", _SE(js_cc_pipeline_InstancedBuffer_merge)); 
    cls->defineFunction("uploadBuffers", _SE(js_cc_pipeline_InstancedBuffer_uploadBuffers)); 
    cls->defineFunction("clear", _SE(js_cc_pipeline_InstancedBuffer_clear)); 
    cls->defineFunction("setDynamicOffset", _SE(js_cc_pipeline_InstancedBuffer_setDynamicOffset)); 
    cls->defineFunction("getInstances", _SE(js_cc_pipeline_InstancedBuffer_getInstances)); 
    cls->defineFunction("getPass", _SE(js_cc_pipeline_InstancedBuffer_getPass)); 
    cls->defineFunction("hasPendingModels", _SE(js_cc_pipeline_InstancedBuffer_hasPendingModels)); 
    cls->defineFunction("dynamicOffsets", _SE(js_cc_pipeline_InstancedBuffer_dynamicOffsets)); 
    
    cls->defineStaticProperty("INITIAL_CAPACITY", nullptr, nullptr); 
    cls->defineStaticProperty("MAX_CAPACITY", nullptr, nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_InstancedBuffer));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::InstancedBuffer>(cls);
    
    __jsb_cc_pipeline_InstancedBuffer_proto = cls->getProto();
    __jsb_cc_pipeline_InstancedBuffer_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_DeferredPipeline_class = nullptr;
se::Object* __jsb_cc_pipeline_DeferredPipeline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_DeferredPipeline) 

static bool js_new_cc_pipeline_DeferredPipeline(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::DeferredPipeline *result;
    result = (cc::pipeline::DeferredPipeline *)new cc::pipeline::DeferredPipeline();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_DeferredPipeline, __jsb_cc_pipeline_DeferredPipeline_class, js_delete_cc_pipeline_DeferredPipeline)

static bool js_delete_cc_pipeline_DeferredPipeline(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_DeferredPipeline) 

static bool js_cc_pipeline_DeferredPipeline_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::DeferredPipeline *arg1 = (cc::pipeline::DeferredPipeline *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::DeferredPipeline>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->destroy();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_DeferredPipeline_destroy) 

static bool js_cc_pipeline_DeferredPipeline_getLightsUBO(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::DeferredPipeline *arg1 = (cc::pipeline::DeferredPipeline *) NULL ;
    cc::gfx::Buffer *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::DeferredPipeline>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Buffer *)((cc::pipeline::DeferredPipeline const *)arg1)->getLightsUBO();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_DeferredPipeline_getLightsUBO) 

static bool js_cc_pipeline_DeferredPipeline_getValidLights(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::DeferredPipeline *arg1 = (cc::pipeline::DeferredPipeline *) NULL ;
    cc::pipeline::LightList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::DeferredPipeline>(s);
    if (nullptr == arg1) return true;
    result = (cc::pipeline::LightList *) &((cc::pipeline::DeferredPipeline const *)arg1)->getValidLights();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_DeferredPipeline_getValidLights) 

static bool js_cc_pipeline_DeferredPipeline_getLightBuffers(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::DeferredPipeline *arg1 = (cc::pipeline::DeferredPipeline *) NULL ;
    cc::gfx::BufferList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::DeferredPipeline>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::BufferList *) &((cc::pipeline::DeferredPipeline const *)arg1)->getLightBuffers();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_DeferredPipeline_getLightBuffers) 

static bool js_cc_pipeline_DeferredPipeline_getLightIndexOffsets(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::DeferredPipeline *arg1 = (cc::pipeline::DeferredPipeline *) NULL ;
    cc::pipeline::UintList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::DeferredPipeline>(s);
    if (nullptr == arg1) return true;
    result = (cc::pipeline::UintList *) &((cc::pipeline::DeferredPipeline const *)arg1)->getLightIndexOffsets();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_DeferredPipeline_getLightIndexOffsets) 

static bool js_cc_pipeline_DeferredPipeline_getLightIndices(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::DeferredPipeline *arg1 = (cc::pipeline::DeferredPipeline *) NULL ;
    cc::pipeline::UintList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::DeferredPipeline>(s);
    if (nullptr == arg1) return true;
    result = (cc::pipeline::UintList *) &((cc::pipeline::DeferredPipeline const *)arg1)->getLightIndices();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_DeferredPipeline_getLightIndices) 

bool js_register_cc_pipeline_DeferredPipeline(se::Object* obj) {
    auto* cls = se::Class::create("DeferredPipeline", obj, __jsb_cc_pipeline_RenderPipeline_proto, _SE(js_new_cc_pipeline_DeferredPipeline)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("destroy", _SE(js_cc_pipeline_DeferredPipeline_destroy)); 
    cls->defineFunction("getLightsUBO", _SE(js_cc_pipeline_DeferredPipeline_getLightsUBO)); 
    cls->defineFunction("getValidLights", _SE(js_cc_pipeline_DeferredPipeline_getValidLights)); 
    cls->defineFunction("getLightBuffers", _SE(js_cc_pipeline_DeferredPipeline_getLightBuffers)); 
    cls->defineFunction("getLightIndexOffsets", _SE(js_cc_pipeline_DeferredPipeline_getLightIndexOffsets)); 
    cls->defineFunction("getLightIndices", _SE(js_cc_pipeline_DeferredPipeline_getLightIndices)); 
    
    cls->defineStaticProperty("GBUFFER_COUNT", nullptr, nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_DeferredPipeline));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::DeferredPipeline>(cls);
    
    __jsb_cc_pipeline_DeferredPipeline_proto = cls->getProto();
    __jsb_cc_pipeline_DeferredPipeline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_MainFlow_class = nullptr;
se::Object* __jsb_cc_pipeline_MainFlow_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_MainFlow) 

static bool js_cc_pipeline_MainFlow_getInitializeInfo_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlowInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::pipeline::RenderFlowInfo *) &cc::pipeline::MainFlow::getInitializeInfo();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_MainFlow_getInitializeInfo_static) 

static bool js_new_cc_pipeline_MainFlow(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::MainFlow *result;
    result = (cc::pipeline::MainFlow *)new cc::pipeline::MainFlow();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_MainFlow, __jsb_cc_pipeline_MainFlow_class, js_delete_cc_pipeline_MainFlow)

static bool js_delete_cc_pipeline_MainFlow(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_MainFlow) 

bool js_register_cc_pipeline_MainFlow(se::Object* obj) {
    auto* cls = se::Class::create("MainFlow", obj, __jsb_cc_pipeline_RenderFlow_proto, _SE(js_new_cc_pipeline_MainFlow)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    
    cls->defineStaticFunction("getInitializeInfo", _SE(js_cc_pipeline_MainFlow_getInitializeInfo_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_MainFlow));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::MainFlow>(cls);
    
    __jsb_cc_pipeline_MainFlow_proto = cls->getProto();
    __jsb_cc_pipeline_MainFlow_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_GbufferStage_class = nullptr;
se::Object* __jsb_cc_pipeline_GbufferStage_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_GbufferStage) 

static bool js_cc_pipeline_GbufferStage_getInitializeInfo_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStageInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::pipeline::RenderStageInfo *) &cc::pipeline::GbufferStage::getInitializeInfo();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GbufferStage_getInitializeInfo_static) 

static bool js_new_cc_pipeline_GbufferStage(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::GbufferStage *result;
    result = (cc::pipeline::GbufferStage *)new cc::pipeline::GbufferStage();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_GbufferStage, __jsb_cc_pipeline_GbufferStage_class, js_delete_cc_pipeline_GbufferStage)

static bool js_delete_cc_pipeline_GbufferStage(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_GbufferStage) 

bool js_register_cc_pipeline_GbufferStage(se::Object* obj) {
    auto* cls = se::Class::create("GbufferStage", obj, __jsb_cc_pipeline_RenderStage_proto, _SE(js_new_cc_pipeline_GbufferStage)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    
    cls->defineStaticFunction("getInitializeInfo", _SE(js_cc_pipeline_GbufferStage_getInitializeInfo_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_GbufferStage));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::GbufferStage>(cls);
    
    __jsb_cc_pipeline_GbufferStage_proto = cls->getProto();
    __jsb_cc_pipeline_GbufferStage_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_RenderElem_class = nullptr;
se::Object* __jsb_cc_pipeline_RenderElem_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_RenderElem) 

static bool js_cc_pipeline_RenderElem_renderObject_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderElem *arg1 = (cc::pipeline::RenderElem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderElem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->renderObject, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderElem_renderObject_set) 

static bool js_cc_pipeline_RenderElem_renderObject_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderElem *arg1 = (cc::pipeline::RenderElem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderElem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->renderObject, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->renderObject, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderElem_renderObject_get) 

static bool js_cc_pipeline_RenderElem_set_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderElem *arg1 = (cc::pipeline::RenderElem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderElem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->set, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderElem_set_set) 

static bool js_cc_pipeline_RenderElem_set_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderElem *arg1 = (cc::pipeline::RenderElem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderElem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->set, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->set, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderElem_set_get) 

static bool js_cc_pipeline_RenderElem_modelIndex_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderElem *arg1 = (cc::pipeline::RenderElem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderElem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->modelIndex, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderElem_modelIndex_set) 

static bool js_cc_pipeline_RenderElem_modelIndex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderElem *arg1 = (cc::pipeline::RenderElem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderElem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->modelIndex, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderElem_modelIndex_get) 

static bool js_cc_pipeline_RenderElem_passIndex_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderElem *arg1 = (cc::pipeline::RenderElem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderElem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->passIndex, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_RenderElem_passIndex_set) 

static bool js_cc_pipeline_RenderElem_passIndex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::RenderElem *arg1 = (cc::pipeline::RenderElem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::RenderElem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->passIndex, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_RenderElem_passIndex_get) 

static bool js_new_cc_pipeline_RenderElem(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::RenderElem *result;
    result = (cc::pipeline::RenderElem *)new cc::pipeline::RenderElem();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_RenderElem, __jsb_cc_pipeline_RenderElem_class, js_delete_cc_pipeline_RenderElem)

static bool js_delete_cc_pipeline_RenderElem(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_RenderElem) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::RenderElem * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::RenderElem*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("renderObject", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->renderObject), ctx);
    }
    
    
    json->getProperty("set", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->set), ctx);
    }
    
    
    json->getProperty("modelIndex", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->modelIndex), ctx);
    }
    
    
    json->getProperty("passIndex", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->passIndex), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_RenderElem(se::Object* obj) {
    auto* cls = se::Class::create("RenderElem", obj, nullptr, _SE(js_new_cc_pipeline_RenderElem)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("renderObject", _SE(js_cc_pipeline_RenderElem_renderObject_get), _SE(js_cc_pipeline_RenderElem_renderObject_set)); 
    cls->defineProperty("set", _SE(js_cc_pipeline_RenderElem_set_get), _SE(js_cc_pipeline_RenderElem_set_set)); 
    cls->defineProperty("modelIndex", _SE(js_cc_pipeline_RenderElem_modelIndex_get), _SE(js_cc_pipeline_RenderElem_modelIndex_set)); 
    cls->defineProperty("passIndex", _SE(js_cc_pipeline_RenderElem_passIndex_get), _SE(js_cc_pipeline_RenderElem_passIndex_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_RenderElem));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::RenderElem>(cls);
    
    __jsb_cc_pipeline_RenderElem_proto = cls->getProto();
    __jsb_cc_pipeline_RenderElem_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_LightingStage_class = nullptr;
se::Object* __jsb_cc_pipeline_LightingStage_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_LightingStage) 

static bool js_cc_pipeline_LightingStage_getInitializeInfo_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStageInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::pipeline::RenderStageInfo *) &cc::pipeline::LightingStage::getInitializeInfo();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_LightingStage_getInitializeInfo_static) 

static bool js_new_cc_pipeline_LightingStage(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::LightingStage *result;
    result = (cc::pipeline::LightingStage *)new cc::pipeline::LightingStage();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_LightingStage, __jsb_cc_pipeline_LightingStage_class, js_delete_cc_pipeline_LightingStage)

static bool js_delete_cc_pipeline_LightingStage(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_LightingStage) 

bool js_register_cc_pipeline_LightingStage(se::Object* obj) {
    auto* cls = se::Class::create("LightingStage", obj, __jsb_cc_pipeline_RenderStage_proto, _SE(js_new_cc_pipeline_LightingStage)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    
    cls->defineStaticFunction("getInitializeInfo", _SE(js_cc_pipeline_LightingStage_getInitializeInfo_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_LightingStage));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::LightingStage>(cls);
    
    __jsb_cc_pipeline_LightingStage_proto = cls->getProto();
    __jsb_cc_pipeline_LightingStage_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_BloomStage_class = nullptr;
se::Object* __jsb_cc_pipeline_BloomStage_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_BloomStage) 

static bool js_new_cc_pipeline_BloomStage(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::BloomStage *result;
    result = (cc::pipeline::BloomStage *)new cc::pipeline::BloomStage();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_BloomStage, __jsb_cc_pipeline_BloomStage_class, js_delete_cc_pipeline_BloomStage)

static bool js_delete_cc_pipeline_BloomStage(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_BloomStage) 

static bool js_cc_pipeline_BloomStage_getInitializeInfo_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStageInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::pipeline::RenderStageInfo *) &cc::pipeline::BloomStage::getInitializeInfo();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_BloomStage_getInitializeInfo_static) 

static bool js_cc_pipeline_BloomStage_getPrefilterUBO(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BloomStage *arg1 = (cc::pipeline::BloomStage *) NULL ;
    cc::gfx::Buffer *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::BloomStage>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Buffer *)(arg1)->getPrefilterUBO();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_BloomStage_getPrefilterUBO) 

static bool js_cc_pipeline_BloomStage_getDownsampleUBO(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BloomStage *arg1 = (cc::pipeline::BloomStage *) NULL ;
    cc::pipeline::BloomStage::SampleUBOArray *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::BloomStage>(s);
    if (nullptr == arg1) return true;
    result = (cc::pipeline::BloomStage::SampleUBOArray *) &(arg1)->getDownsampleUBO();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_BloomStage_getDownsampleUBO) 

static bool js_cc_pipeline_BloomStage_getUpsampleUBO(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BloomStage *arg1 = (cc::pipeline::BloomStage *) NULL ;
    cc::pipeline::BloomStage::SampleUBOArray *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::BloomStage>(s);
    if (nullptr == arg1) return true;
    result = (cc::pipeline::BloomStage::SampleUBOArray *) &(arg1)->getUpsampleUBO();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_BloomStage_getUpsampleUBO) 

static bool js_cc_pipeline_BloomStage_getCombineUBO(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BloomStage *arg1 = (cc::pipeline::BloomStage *) NULL ;
    cc::gfx::Buffer *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::BloomStage>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Buffer *)(arg1)->getCombineUBO();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_BloomStage_getCombineUBO) 

static bool js_cc_pipeline_BloomStage_getSampler(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BloomStage *arg1 = (cc::pipeline::BloomStage *) NULL ;
    cc::gfx::Sampler *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::BloomStage>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Sampler *)((cc::pipeline::BloomStage const *)arg1)->getSampler();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_BloomStage_getSampler) 

static bool js_cc_pipeline_BloomStage_threshold_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BloomStage *arg1 = (cc::pipeline::BloomStage *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BloomStage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_pipeline_BloomStage_threshold_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BloomStage_threshold_set) 

static bool js_cc_pipeline_BloomStage_threshold_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BloomStage *arg1 = (cc::pipeline::BloomStage *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BloomStage>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_pipeline_BloomStage_threshold_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BloomStage_threshold_get) 

static bool js_cc_pipeline_BloomStage_intensity_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BloomStage *arg1 = (cc::pipeline::BloomStage *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BloomStage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_pipeline_BloomStage_intensity_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BloomStage_intensity_set) 

static bool js_cc_pipeline_BloomStage_intensity_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BloomStage *arg1 = (cc::pipeline::BloomStage *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BloomStage>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_pipeline_BloomStage_intensity_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BloomStage_intensity_get) 

static bool js_cc_pipeline_BloomStage_iterations_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BloomStage *arg1 = (cc::pipeline::BloomStage *) NULL ;
    int arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BloomStage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_pipeline_BloomStage_iterations_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BloomStage_iterations_set) 

static bool js_cc_pipeline_BloomStage_iterations_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BloomStage *arg1 = (cc::pipeline::BloomStage *) NULL ;
    int result;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BloomStage>(s);
    if (nullptr == arg1) return true;
    result = (int)cc_pipeline_BloomStage_iterations_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BloomStage_iterations_get) 

bool js_register_cc_pipeline_BloomStage(se::Object* obj) {
    auto* cls = se::Class::create("BloomStage", obj, __jsb_cc_pipeline_RenderStage_proto, _SE(js_new_cc_pipeline_BloomStage)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("threshold", _SE(js_cc_pipeline_BloomStage_threshold_get), _SE(js_cc_pipeline_BloomStage_threshold_set)); 
    cls->defineProperty("intensity", _SE(js_cc_pipeline_BloomStage_intensity_get), _SE(js_cc_pipeline_BloomStage_intensity_set)); 
    cls->defineProperty("iterations", _SE(js_cc_pipeline_BloomStage_iterations_get), _SE(js_cc_pipeline_BloomStage_iterations_set)); 
    
    cls->defineFunction("getPrefilterUBO", _SE(js_cc_pipeline_BloomStage_getPrefilterUBO)); 
    cls->defineFunction("getDownsampleUBO", _SE(js_cc_pipeline_BloomStage_getDownsampleUBO)); 
    cls->defineFunction("getUpsampleUBO", _SE(js_cc_pipeline_BloomStage_getUpsampleUBO)); 
    cls->defineFunction("getCombineUBO", _SE(js_cc_pipeline_BloomStage_getCombineUBO)); 
    cls->defineFunction("getSampler", _SE(js_cc_pipeline_BloomStage_getSampler)); 
    
    
    cls->defineStaticFunction("getInitializeInfo", _SE(js_cc_pipeline_BloomStage_getInitializeInfo_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_BloomStage));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::BloomStage>(cls);
    
    __jsb_cc_pipeline_BloomStage_proto = cls->getProto();
    __jsb_cc_pipeline_BloomStage_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_PostProcessStage_class = nullptr;
se::Object* __jsb_cc_pipeline_PostProcessStage_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_PostProcessStage) 

static bool js_new_cc_pipeline_PostProcessStage(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::PostProcessStage *result;
    result = (cc::pipeline::PostProcessStage *)new cc::pipeline::PostProcessStage();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_PostProcessStage, __jsb_cc_pipeline_PostProcessStage_class, js_delete_cc_pipeline_PostProcessStage)

static bool js_delete_cc_pipeline_PostProcessStage(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_PostProcessStage) 

static bool js_cc_pipeline_PostProcessStage_getInitializeInfo_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStageInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::pipeline::RenderStageInfo *) &cc::pipeline::PostProcessStage::getInitializeInfo();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PostProcessStage_getInitializeInfo_static) 

bool js_register_cc_pipeline_PostProcessStage(se::Object* obj) {
    auto* cls = se::Class::create("PostProcessStage", obj, __jsb_cc_pipeline_RenderStage_proto, _SE(js_new_cc_pipeline_PostProcessStage)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    
    cls->defineStaticFunction("getInitializeInfo", _SE(js_cc_pipeline_PostProcessStage_getInitializeInfo_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_PostProcessStage));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::PostProcessStage>(cls);
    
    __jsb_cc_pipeline_PostProcessStage_proto = cls->getProto();
    __jsb_cc_pipeline_PostProcessStage_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_PipelineSceneData_class = nullptr;
se::Object* __jsb_cc_pipeline_PipelineSceneData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_PipelineSceneData) 

static bool js_new_cc_pipeline_PipelineSceneData(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::PipelineSceneData *result;
    result = (cc::pipeline::PipelineSceneData *)new cc::pipeline::PipelineSceneData();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_PipelineSceneData, __jsb_cc_pipeline_PipelineSceneData_class, js_delete_cc_pipeline_PipelineSceneData)

static bool js_delete_cc_pipeline_PipelineSceneData(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_PipelineSceneData) 

static bool js_cc_pipeline_PipelineSceneData_activate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::gfx::Device *arg2 = (cc::gfx::Device *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->activate(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_activate) 

static bool js_cc_pipeline_PipelineSceneData_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_destroy) 

static bool js_cc_pipeline_PipelineSceneData_updatePipelineSceneData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    (arg1)->updatePipelineSceneData();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_updatePipelineSceneData) 

static bool js_cc_pipeline_PipelineSceneData_setShadowFramebuffer(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::scene::Light *arg2 = (cc::scene::Light *) NULL ;
    cc::gfx::Framebuffer *arg3 = (cc::gfx::Framebuffer *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setShadowFramebuffer((cc::scene::Light const *)arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_setShadowFramebuffer) 

static bool js_cc_pipeline_PipelineSceneData_getOctree(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::scene::Octree *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::Octree *)((cc::pipeline::PipelineSceneData const *)arg1)->getOctree();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_getOctree) 

static bool js_cc_pipeline_PipelineSceneData_getOcclusionQueryInputAssembler(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::gfx::InputAssembler *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::InputAssembler *)((cc::pipeline::PipelineSceneData const *)arg1)->getOcclusionQueryInputAssembler();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_getOcclusionQueryInputAssembler) 

static bool js_cc_pipeline_PipelineSceneData_getOcclusionQueryPass(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::scene::Pass *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::Pass *)((cc::pipeline::PipelineSceneData const *)arg1)->getOcclusionQueryPass();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_getOcclusionQueryPass) 

static bool js_cc_pipeline_PipelineSceneData_getOcclusionQueryShader(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::gfx::Shader *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Shader *)((cc::pipeline::PipelineSceneData const *)arg1)->getOcclusionQueryShader();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_getOcclusionQueryShader) 

static bool js_cc_pipeline_PipelineSceneData_getGeometryRendererMaterials(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::Material > > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::IntrusivePtr< cc::Material > > *) &((cc::pipeline::PipelineSceneData const *)arg1)->getGeometryRendererMaterials();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_getGeometryRendererMaterials) 

static bool js_cc_pipeline_PipelineSceneData_getGeometryRendererPasses(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    ccstd::vector< cc::scene::Pass * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::scene::Pass * > *) &((cc::pipeline::PipelineSceneData const *)arg1)->getGeometryRendererPasses();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_getGeometryRendererPasses) 

static bool js_cc_pipeline_PipelineSceneData_getGeometryRendererShaders(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    ccstd::vector< cc::gfx::Shader * > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::gfx::Shader * > *) &((cc::pipeline::PipelineSceneData const *)arg1)->getGeometryRendererShaders();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_getGeometryRendererShaders) 

static bool js_cc_pipeline_PipelineSceneData_getDebugRendererPass(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::scene::Pass *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::Pass *)((cc::pipeline::PipelineSceneData const *)arg1)->getDebugRendererPass();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_getDebugRendererPass) 

static bool js_cc_pipeline_PipelineSceneData_getDebugRendererShader(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::gfx::Shader *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Shader *)((cc::pipeline::PipelineSceneData const *)arg1)->getDebugRendererShader();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_getDebugRendererShader) 

static bool js_cc_pipeline_PipelineSceneData_addRenderObject(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::pipeline::RenderObject *arg2 = 0 ;
    cc::pipeline::RenderObject temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->addRenderObject((cc::pipeline::RenderObject &&)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_addRenderObject) 

static bool js_cc_pipeline_PipelineSceneData_clearRenderObjects(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    (arg1)->clearRenderObjects();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_clearRenderObjects) 

static bool js_cc_pipeline_PipelineSceneData_addValidPunctualLight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::scene::Light *arg2 = (cc::scene::Light *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addValidPunctualLight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_addValidPunctualLight) 

static bool js_cc_pipeline_PipelineSceneData_clearValidPunctualLights(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    (arg1)->clearValidPunctualLights();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_PipelineSceneData_clearValidPunctualLights) 

static bool js_cc_pipeline_PipelineSceneData_isHDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_pipeline_PipelineSceneData_isHDR_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_PipelineSceneData_isHDR_set) 

static bool js_cc_pipeline_PipelineSceneData_isHDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_pipeline_PipelineSceneData_isHDR_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_PipelineSceneData_isHDR_get) 

static bool js_cc_pipeline_PipelineSceneData_shadingScale_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_pipeline_PipelineSceneData_shadingScale_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_PipelineSceneData_shadingScale_set) 

static bool js_cc_pipeline_PipelineSceneData_shadingScale_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_pipeline_PipelineSceneData_shadingScale_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_PipelineSceneData_shadingScale_get) 

static bool js_cc_pipeline_PipelineSceneData_fog_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::scene::Fog *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::Fog *)cc_pipeline_PipelineSceneData_fog_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_PipelineSceneData_fog_get) 

static bool js_cc_pipeline_PipelineSceneData_ambient_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::scene::Ambient *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::Ambient *)cc_pipeline_PipelineSceneData_ambient_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_PipelineSceneData_ambient_get) 

static bool js_cc_pipeline_PipelineSceneData_skybox_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::scene::Skybox *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::Skybox *)cc_pipeline_PipelineSceneData_skybox_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_PipelineSceneData_skybox_get) 

static bool js_cc_pipeline_PipelineSceneData_shadows_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::scene::Shadows *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::Shadows *)cc_pipeline_PipelineSceneData_shadows_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_PipelineSceneData_shadows_get) 

static bool js_cc_pipeline_PipelineSceneData_lightProbes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    cc::gi::LightProbes *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    result = (cc::gi::LightProbes *)cc_pipeline_PipelineSceneData_lightProbes_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_PipelineSceneData_lightProbes_get) 

static bool js_cc_pipeline_PipelineSceneData_validPunctualLights_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    ccstd::vector< cc::scene::Light const * > arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_pipeline_PipelineSceneData_validPunctualLights_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_PipelineSceneData_validPunctualLights_set) 

static bool js_cc_pipeline_PipelineSceneData_validPunctualLights_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::PipelineSceneData *arg1 = (cc::pipeline::PipelineSceneData *) NULL ;
    ccstd::vector< cc::scene::Light const * > result;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::PipelineSceneData>(s);
    if (nullptr == arg1) return true;
    result = cc_pipeline_PipelineSceneData_validPunctualLights_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_PipelineSceneData_validPunctualLights_get) 

bool js_register_cc_pipeline_PipelineSceneData(se::Object* obj) {
    auto* cls = se::Class::create("PipelineSceneData", obj, nullptr, _SE(js_new_cc_pipeline_PipelineSceneData)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("isHDR", _SE(js_cc_pipeline_PipelineSceneData_isHDR_get), _SE(js_cc_pipeline_PipelineSceneData_isHDR_set)); 
    cls->defineProperty("shadingScale", _SE(js_cc_pipeline_PipelineSceneData_shadingScale_get), _SE(js_cc_pipeline_PipelineSceneData_shadingScale_set)); 
    cls->defineProperty("fog", _SE(js_cc_pipeline_PipelineSceneData_fog_get), nullptr); 
    cls->defineProperty("ambient", _SE(js_cc_pipeline_PipelineSceneData_ambient_get), nullptr); 
    cls->defineProperty("skybox", _SE(js_cc_pipeline_PipelineSceneData_skybox_get), nullptr); 
    cls->defineProperty("shadows", _SE(js_cc_pipeline_PipelineSceneData_shadows_get), nullptr); 
    cls->defineProperty("lightProbes", _SE(js_cc_pipeline_PipelineSceneData_lightProbes_get), nullptr); 
    cls->defineProperty("validPunctualLights", _SE(js_cc_pipeline_PipelineSceneData_validPunctualLights_get), _SE(js_cc_pipeline_PipelineSceneData_validPunctualLights_set)); 
    
    cls->defineFunction("activate", _SE(js_cc_pipeline_PipelineSceneData_activate)); 
    cls->defineFunction("destroy", _SE(js_cc_pipeline_PipelineSceneData_destroy)); 
    cls->defineFunction("updatePipelineSceneData", _SE(js_cc_pipeline_PipelineSceneData_updatePipelineSceneData)); 
    cls->defineFunction("setShadowFramebuffer", _SE(js_cc_pipeline_PipelineSceneData_setShadowFramebuffer)); 
    cls->defineFunction("getOctree", _SE(js_cc_pipeline_PipelineSceneData_getOctree)); 
    cls->defineFunction("getOcclusionQueryInputAssembler", _SE(js_cc_pipeline_PipelineSceneData_getOcclusionQueryInputAssembler)); 
    cls->defineFunction("getOcclusionQueryPass", _SE(js_cc_pipeline_PipelineSceneData_getOcclusionQueryPass)); 
    cls->defineFunction("getOcclusionQueryShader", _SE(js_cc_pipeline_PipelineSceneData_getOcclusionQueryShader)); 
    cls->defineFunction("getGeometryRendererMaterials", _SE(js_cc_pipeline_PipelineSceneData_getGeometryRendererMaterials)); 
    cls->defineFunction("getGeometryRendererPasses", _SE(js_cc_pipeline_PipelineSceneData_getGeometryRendererPasses)); 
    cls->defineFunction("getGeometryRendererShaders", _SE(js_cc_pipeline_PipelineSceneData_getGeometryRendererShaders)); 
    cls->defineFunction("getDebugRendererPass", _SE(js_cc_pipeline_PipelineSceneData_getDebugRendererPass)); 
    cls->defineFunction("getDebugRendererShader", _SE(js_cc_pipeline_PipelineSceneData_getDebugRendererShader)); 
    cls->defineFunction("addRenderObject", _SE(js_cc_pipeline_PipelineSceneData_addRenderObject)); 
    cls->defineFunction("clearRenderObjects", _SE(js_cc_pipeline_PipelineSceneData_clearRenderObjects)); 
    cls->defineFunction("addValidPunctualLight", _SE(js_cc_pipeline_PipelineSceneData_addValidPunctualLight)); 
    cls->defineFunction("clearValidPunctualLights", _SE(js_cc_pipeline_PipelineSceneData_clearValidPunctualLights)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_PipelineSceneData));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::PipelineSceneData>(cls);
    
    __jsb_cc_pipeline_PipelineSceneData_proto = cls->getProto();
    __jsb_cc_pipeline_PipelineSceneData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_BatchedItem_class = nullptr;
se::Object* __jsb_cc_pipeline_BatchedItem_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_BatchedItem) 

static bool js_cc_pipeline_BatchedItem_vbs_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->vbs, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BatchedItem_vbs_set) 

static bool js_cc_pipeline_BatchedItem_vbs_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->vbs, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->vbs, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BatchedItem_vbs_get) 

static bool js_cc_pipeline_BatchedItem_vbDatas_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->vbDatas, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BatchedItem_vbDatas_set) 

static bool js_cc_pipeline_BatchedItem_vbDatas_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->vbDatas, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->vbDatas, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BatchedItem_vbDatas_get) 

static bool js_cc_pipeline_BatchedItem_indexBuffer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->indexBuffer, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BatchedItem_indexBuffer_set) 

static bool js_cc_pipeline_BatchedItem_indexBuffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->indexBuffer, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->indexBuffer, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BatchedItem_indexBuffer_get) 

static bool js_cc_pipeline_BatchedItem_indexData_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->indexData, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BatchedItem_indexData_set) 

static bool js_cc_pipeline_BatchedItem_indexData_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->indexData, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->indexData, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BatchedItem_indexData_get) 

static bool js_cc_pipeline_BatchedItem_vbCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->vbCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BatchedItem_vbCount_set) 

static bool js_cc_pipeline_BatchedItem_vbCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->vbCount, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BatchedItem_vbCount_get) 

static bool js_cc_pipeline_BatchedItem_mergeCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->mergeCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BatchedItem_mergeCount_set) 

static bool js_cc_pipeline_BatchedItem_mergeCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->mergeCount, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BatchedItem_mergeCount_get) 

static bool js_cc_pipeline_BatchedItem_ia_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->ia, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BatchedItem_ia_set) 

static bool js_cc_pipeline_BatchedItem_ia_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->ia, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->ia, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BatchedItem_ia_get) 

static bool js_cc_pipeline_BatchedItem_ubo_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->ubo, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BatchedItem_ubo_set) 

static bool js_cc_pipeline_BatchedItem_ubo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->ubo, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->ubo, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BatchedItem_ubo_get) 

static bool js_cc_pipeline_BatchedItem_uboData_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->uboData, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BatchedItem_uboData_set) 

static bool js_cc_pipeline_BatchedItem_uboData_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->uboData, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->uboData, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BatchedItem_uboData_get) 

static bool js_cc_pipeline_BatchedItem_descriptorSet_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->descriptorSet, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BatchedItem_descriptorSet_set) 

static bool js_cc_pipeline_BatchedItem_descriptorSet_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->descriptorSet, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->descriptorSet, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BatchedItem_descriptorSet_get) 

static bool js_cc_pipeline_BatchedItem_pass_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->pass, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BatchedItem_pass_set) 

static bool js_cc_pipeline_BatchedItem_pass_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->pass, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->pass, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BatchedItem_pass_get) 

static bool js_cc_pipeline_BatchedItem_shader_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->shader, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_pipeline_BatchedItem_shader_set) 

static bool js_cc_pipeline_BatchedItem_shader_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::pipeline::BatchedItem *arg1 = (cc::pipeline::BatchedItem *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedItem>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->shader, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->shader, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_pipeline_BatchedItem_shader_get) 

static bool js_new_cc_pipeline_BatchedItem(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::BatchedItem *result;
    result = (cc::pipeline::BatchedItem *)new cc::pipeline::BatchedItem();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_BatchedItem, __jsb_cc_pipeline_BatchedItem_class, js_delete_cc_pipeline_BatchedItem)

static bool js_delete_cc_pipeline_BatchedItem(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_BatchedItem) 

template<>
bool sevalue_to_native(const se::Value &from, cc::pipeline::BatchedItem * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::pipeline::BatchedItem*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("vbs", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->vbs), ctx);
    }
    
    
    json->getProperty("vbDatas", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->vbDatas), ctx);
    }
    
    
    json->getProperty("indexBuffer", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->indexBuffer), ctx);
    }
    
    
    json->getProperty("indexData", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->indexData), ctx);
    }
    
    
    json->getProperty("vbCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->vbCount), ctx);
    }
    
    
    json->getProperty("mergeCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->mergeCount), ctx);
    }
    
    
    json->getProperty("ia", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->ia), ctx);
    }
    
    
    json->getProperty("ubo", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->ubo), ctx);
    }
    
    
    json->getProperty("uboData", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->uboData), ctx);
    }
    
    
    json->getProperty("descriptorSet", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->descriptorSet), ctx);
    }
    
    
    json->getProperty("pass", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->pass), ctx);
    }
    
    
    json->getProperty("shader", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->shader), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_pipeline_BatchedItem(se::Object* obj) {
    auto* cls = se::Class::create("BatchedItem", obj, nullptr, _SE(js_new_cc_pipeline_BatchedItem)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("vbs", _SE(js_cc_pipeline_BatchedItem_vbs_get), _SE(js_cc_pipeline_BatchedItem_vbs_set)); 
    cls->defineProperty("vbDatas", _SE(js_cc_pipeline_BatchedItem_vbDatas_get), _SE(js_cc_pipeline_BatchedItem_vbDatas_set)); 
    cls->defineProperty("indexBuffer", _SE(js_cc_pipeline_BatchedItem_indexBuffer_get), _SE(js_cc_pipeline_BatchedItem_indexBuffer_set)); 
    cls->defineProperty("indexData", _SE(js_cc_pipeline_BatchedItem_indexData_get), _SE(js_cc_pipeline_BatchedItem_indexData_set)); 
    cls->defineProperty("vbCount", _SE(js_cc_pipeline_BatchedItem_vbCount_get), _SE(js_cc_pipeline_BatchedItem_vbCount_set)); 
    cls->defineProperty("mergeCount", _SE(js_cc_pipeline_BatchedItem_mergeCount_get), _SE(js_cc_pipeline_BatchedItem_mergeCount_set)); 
    cls->defineProperty("ia", _SE(js_cc_pipeline_BatchedItem_ia_get), _SE(js_cc_pipeline_BatchedItem_ia_set)); 
    cls->defineProperty("ubo", _SE(js_cc_pipeline_BatchedItem_ubo_get), _SE(js_cc_pipeline_BatchedItem_ubo_set)); 
    cls->defineProperty("uboData", _SE(js_cc_pipeline_BatchedItem_uboData_get), _SE(js_cc_pipeline_BatchedItem_uboData_set)); 
    cls->defineProperty("descriptorSet", _SE(js_cc_pipeline_BatchedItem_descriptorSet_get), _SE(js_cc_pipeline_BatchedItem_descriptorSet_set)); 
    cls->defineProperty("pass", _SE(js_cc_pipeline_BatchedItem_pass_get), _SE(js_cc_pipeline_BatchedItem_pass_set)); 
    cls->defineProperty("shader", _SE(js_cc_pipeline_BatchedItem_shader_get), _SE(js_cc_pipeline_BatchedItem_shader_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_BatchedItem));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::BatchedItem>(cls);
    
    __jsb_cc_pipeline_BatchedItem_proto = cls->getProto();
    __jsb_cc_pipeline_BatchedItem_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_BatchedBuffer_class = nullptr;
se::Object* __jsb_cc_pipeline_BatchedBuffer_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_BatchedBuffer) 

static bool js_new_cc_pipeline_BatchedBuffer(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::pipeline::BatchedBuffer *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::pipeline::BatchedBuffer *)new cc::pipeline::BatchedBuffer((cc::scene::Pass const *)arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_BatchedBuffer, __jsb_cc_pipeline_BatchedBuffer_class, js_delete_cc_pipeline_BatchedBuffer)

static bool js_delete_cc_pipeline_BatchedBuffer(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_BatchedBuffer) 

static bool js_cc_pipeline_BatchedBuffer_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedBuffer *arg1 = (cc::pipeline::BatchedBuffer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedBuffer>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_BatchedBuffer_destroy) 

static bool js_cc_pipeline_BatchedBuffer_merge(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedBuffer *arg1 = (cc::pipeline::BatchedBuffer *) NULL ;
    cc::scene::SubModel *arg2 = (cc::scene::SubModel *) NULL ;
    uint32_t arg3 ;
    cc::scene::Model *arg4 = (cc::scene::Model *) NULL ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->merge((cc::scene::SubModel const *)arg2,arg3,(cc::scene::Model const *)arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_BatchedBuffer_merge) 

static bool js_cc_pipeline_BatchedBuffer_clear(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedBuffer *arg1 = (cc::pipeline::BatchedBuffer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedBuffer>(s);
    if (nullptr == arg1) return true;
    (arg1)->clear();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_BatchedBuffer_clear) 

static bool js_cc_pipeline_BatchedBuffer_setDynamicOffset(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedBuffer *arg1 = (cc::pipeline::BatchedBuffer *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setDynamicOffset(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_BatchedBuffer_setDynamicOffset) 

static bool js_cc_pipeline_BatchedBuffer_getBatches(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedBuffer *arg1 = (cc::pipeline::BatchedBuffer *) NULL ;
    cc::pipeline::BatchedItemList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedBuffer>(s);
    if (nullptr == arg1) return true;
    result = (cc::pipeline::BatchedItemList *) &((cc::pipeline::BatchedBuffer const *)arg1)->getBatches();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_BatchedBuffer_getBatches) 

static bool js_cc_pipeline_BatchedBuffer_getPass(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedBuffer *arg1 = (cc::pipeline::BatchedBuffer *) NULL ;
    cc::scene::Pass *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedBuffer>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::Pass *)((cc::pipeline::BatchedBuffer const *)arg1)->getPass();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_BatchedBuffer_getPass) 

static bool js_cc_pipeline_BatchedBuffer_getDynamicOffset(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::BatchedBuffer *arg1 = (cc::pipeline::BatchedBuffer *) NULL ;
    cc::pipeline::DynamicOffsetList *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::BatchedBuffer>(s);
    if (nullptr == arg1) return true;
    result = (cc::pipeline::DynamicOffsetList *) &((cc::pipeline::BatchedBuffer const *)arg1)->getDynamicOffset();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_BatchedBuffer_getDynamicOffset) 

bool js_register_cc_pipeline_BatchedBuffer(se::Object* obj) {
    auto* cls = se::Class::create("BatchedBuffer", obj, nullptr, _SE(js_new_cc_pipeline_BatchedBuffer)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("destroy", _SE(js_cc_pipeline_BatchedBuffer_destroy)); 
    cls->defineFunction("merge", _SE(js_cc_pipeline_BatchedBuffer_merge)); 
    cls->defineFunction("clear", _SE(js_cc_pipeline_BatchedBuffer_clear)); 
    cls->defineFunction("setDynamicOffset", _SE(js_cc_pipeline_BatchedBuffer_setDynamicOffset)); 
    cls->defineFunction("getBatches", _SE(js_cc_pipeline_BatchedBuffer_getBatches)); 
    cls->defineFunction("getPass", _SE(js_cc_pipeline_BatchedBuffer_getPass)); 
    cls->defineFunction("getDynamicOffset", _SE(js_cc_pipeline_BatchedBuffer_getDynamicOffset)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_BatchedBuffer));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::BatchedBuffer>(cls);
    
    __jsb_cc_pipeline_BatchedBuffer_proto = cls->getProto();
    __jsb_cc_pipeline_BatchedBuffer_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

#if CC_USE_GEOMETRY_RENDERER

se::Class* __jsb_cc_pipeline_GeometryRenderer_class = nullptr;
se::Object* __jsb_cc_pipeline_GeometryRenderer_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_GeometryRenderer) 

static bool js_new_cc_pipeline_GeometryRenderer(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::GeometryRenderer *result;
    result = (cc::pipeline::GeometryRenderer *)new cc::pipeline::GeometryRenderer();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_GeometryRenderer, __jsb_cc_pipeline_GeometryRenderer_class, js_delete_cc_pipeline_GeometryRenderer)

static bool js_delete_cc_pipeline_GeometryRenderer(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_GeometryRenderer) 

static bool js_cc_pipeline_GeometryRenderer_empty(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    result = (bool)((cc::pipeline::GeometryRenderer const *)arg1)->empty();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_empty) 

static bool js_cc_pipeline_GeometryRenderer_update(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    (arg1)->update();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_update) 

static bool js_cc_pipeline_GeometryRenderer_addDashedLine__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::gfx::Color arg4 ;
    bool arg5 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addDashedLine((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addDashedLine__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::gfx::Color arg4 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->addDashedLine((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addDashedLine(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addDashedLine__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 3) {
        ok = js_cc_pipeline_GeometryRenderer_addDashedLine__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addDashedLine) 

static bool js_cc_pipeline_GeometryRenderer_addLine__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::gfx::Color arg4 ;
    bool arg5 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addLine((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addLine__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::gfx::Color arg4 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->addLine((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addLine(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addLine__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 3) {
        ok = js_cc_pipeline_GeometryRenderer_addLine__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addLine) 

static bool js_cc_pipeline_GeometryRenderer_addTriangle__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::gfx::Color arg5 ;
    bool arg6 ;
    bool arg7 ;
    bool arg8 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addTriangle((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4,arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addTriangle__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::gfx::Color arg5 ;
    bool arg6 ;
    bool arg7 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addTriangle((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addTriangle__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::gfx::Color arg5 ;
    bool arg6 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addTriangle((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addTriangle__SWIG_3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::gfx::Color arg5 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->addTriangle((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addTriangle(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addTriangle__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addTriangle__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addTriangle__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addTriangle__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addTriangle) 

static bool js_cc_pipeline_GeometryRenderer_addQuad__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::Vec3 *arg5 = 0 ;
    cc::gfx::Color arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    cc::Vec3 temp5 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg5 = &temp5;
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addQuad((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4,(cc::Vec3 const &)*arg5,arg6,arg7,arg8,arg9);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addQuad__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::Vec3 *arg5 = 0 ;
    cc::gfx::Color arg6 ;
    bool arg7 ;
    bool arg8 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    cc::Vec3 temp5 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg5 = &temp5;
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addQuad((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4,(cc::Vec3 const &)*arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addQuad__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::Vec3 *arg5 = 0 ;
    cc::gfx::Color arg6 ;
    bool arg7 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    cc::Vec3 temp5 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg5 = &temp5;
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addQuad((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4,(cc::Vec3 const &)*arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addQuad__SWIG_3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::Vec3 *arg5 = 0 ;
    cc::gfx::Color arg6 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    cc::Vec3 temp5 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg5 = &temp5;
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->addQuad((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4,(cc::Vec3 const &)*arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addQuad(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 8) {
        ok = js_cc_pipeline_GeometryRenderer_addQuad__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addQuad__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addQuad__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addQuad__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addQuad) 

static bool js_cc_pipeline_GeometryRenderer_addBoundingBox__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::geometry::AABB *arg2 = 0 ;
    cc::gfx::Color arg3 ;
    bool arg4 ;
    bool arg5 ;
    bool arg6 ;
    bool arg7 ;
    cc::Mat4 *arg8 = 0 ;
    cc::geometry::AABB temp2 ;
    cc::Mat4 temp8 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &temp8, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg8 = &temp8;
    
    (arg1)->addBoundingBox((cc::geometry::AABB const &)*arg2,arg3,arg4,arg5,arg6,arg7,(cc::Mat4 const &)*arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addBoundingBox__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::geometry::AABB *arg2 = 0 ;
    cc::gfx::Color arg3 ;
    bool arg4 ;
    bool arg5 ;
    bool arg6 ;
    bool arg7 ;
    cc::geometry::AABB temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addBoundingBox((cc::geometry::AABB const &)*arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addBoundingBox__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::geometry::AABB *arg2 = 0 ;
    cc::gfx::Color arg3 ;
    bool arg4 ;
    bool arg5 ;
    bool arg6 ;
    cc::geometry::AABB temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addBoundingBox((cc::geometry::AABB const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addBoundingBox__SWIG_3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::geometry::AABB *arg2 = 0 ;
    cc::gfx::Color arg3 ;
    bool arg4 ;
    bool arg5 ;
    cc::geometry::AABB temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addBoundingBox((cc::geometry::AABB const &)*arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addBoundingBox__SWIG_4(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::geometry::AABB *arg2 = 0 ;
    cc::gfx::Color arg3 ;
    bool arg4 ;
    cc::geometry::AABB temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addBoundingBox((cc::geometry::AABB const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addBoundingBox__SWIG_5(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::geometry::AABB *arg2 = 0 ;
    cc::gfx::Color arg3 ;
    cc::geometry::AABB temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->addBoundingBox((cc::geometry::AABB const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addBoundingBox(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addBoundingBox__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addBoundingBox__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addBoundingBox__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addBoundingBox__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 3) {
        ok = js_cc_pipeline_GeometryRenderer_addBoundingBox__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_pipeline_GeometryRenderer_addBoundingBox__SWIG_5(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addBoundingBox) 

static bool js_cc_pipeline_GeometryRenderer_addCross__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    bool arg5 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addCross((cc::Vec3 const &)*arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCross__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->addCross((cc::Vec3 const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCross(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addCross__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 3) {
        ok = js_cc_pipeline_GeometryRenderer_addCross__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addCross) 

static bool js_cc_pipeline_GeometryRenderer_addFrustum__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::geometry::Frustum *arg2 = 0 ;
    cc::gfx::Color arg3 ;
    bool arg4 ;
    cc::geometry::Frustum temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addFrustum((cc::geometry::Frustum const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addFrustum__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::geometry::Frustum *arg2 = 0 ;
    cc::gfx::Color arg3 ;
    cc::geometry::Frustum temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->addFrustum((cc::geometry::Frustum const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addFrustum(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_pipeline_GeometryRenderer_addFrustum__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_pipeline_GeometryRenderer_addFrustum__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addFrustum) 

static bool js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    bool arg11 ;
    cc::Mat4 *arg12 = 0 ;
    cc::Vec3 temp2 ;
    cc::Mat4 temp12 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[9], &arg11);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[10], &temp12, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg12 = &temp12;
    
    (arg1)->addCapsule((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,(cc::Mat4 const &)*arg12);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    bool arg11 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[9], &arg11);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addCapsule((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addCapsule((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addCapsule((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_4(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addCapsule((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_5(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    uint32_t arg7 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->addCapsule((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_6(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->addCapsule((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_7(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->addCapsule((cc::Vec3 const &)*arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCapsule(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 11) {
        ok = js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 10) {
        ok = js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 9) {
        ok = js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 8) {
        ok = js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_5(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_6(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addCapsule__SWIG_7(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addCapsule) 

static bool js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    cc::Mat4 *arg11 = 0 ;
    cc::Vec3 temp2 ;
    cc::Mat4 temp11 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[9], &temp11, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg11 = &temp11;
    
    (arg1)->addCylinder((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,(cc::Mat4 const &)*arg11);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addCylinder((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addCylinder((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    bool arg8 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addCylinder((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_4(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addCylinder((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_5(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->addCylinder((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_6(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->addCylinder((cc::Vec3 const &)*arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCylinder(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 10) {
        ok = js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 9) {
        ok = js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 8) {
        ok = js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_5(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addCylinder__SWIG_6(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addCylinder) 

static bool js_cc_pipeline_GeometryRenderer_addCone__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    cc::Mat4 *arg11 = 0 ;
    cc::Vec3 temp2 ;
    cc::Mat4 temp11 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[9], &temp11, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg11 = &temp11;
    
    (arg1)->addCone((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,(cc::Mat4 const &)*arg11);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCone__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addCone((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCone__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addCone((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCone__SWIG_3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    bool arg8 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addCone((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCone__SWIG_4(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addCone((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCone__SWIG_5(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->addCone((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCone__SWIG_6(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->addCone((cc::Vec3 const &)*arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCone(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 10) {
        ok = js_cc_pipeline_GeometryRenderer_addCone__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 9) {
        ok = js_cc_pipeline_GeometryRenderer_addCone__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 8) {
        ok = js_cc_pipeline_GeometryRenderer_addCone__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addCone__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addCone__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addCone__SWIG_5(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addCone__SWIG_6(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addCone) 

static bool js_cc_pipeline_GeometryRenderer_addCircle__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    bool arg6 ;
    bool arg7 ;
    cc::Mat4 *arg8 = 0 ;
    cc::Vec3 temp2 ;
    cc::Mat4 temp8 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &temp8, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg8 = &temp8;
    
    (arg1)->addCircle((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,(cc::Mat4 const &)*arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCircle__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    bool arg6 ;
    bool arg7 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addCircle((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCircle__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    bool arg6 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addCircle((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCircle__SWIG_3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->addCircle((cc::Vec3 const &)*arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCircle__SWIG_4(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->addCircle((cc::Vec3 const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addCircle(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addCircle__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addCircle__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addCircle__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addCircle__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 3) {
        ok = js_cc_pipeline_GeometryRenderer_addCircle__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addCircle) 

static bool js_cc_pipeline_GeometryRenderer_addArc__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    float arg5 ;
    float arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Mat4 *arg10 = 0 ;
    cc::Vec3 temp2 ;
    cc::Mat4 temp10 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[8], &temp10, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg10 = &temp10;
    
    (arg1)->addArc((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,(cc::Mat4 const &)*arg10);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addArc__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    float arg5 ;
    float arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addArc((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addArc__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    float arg5 ;
    float arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addArc((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addArc__SWIG_3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    float arg5 ;
    float arg6 ;
    uint32_t arg7 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->addArc((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addArc__SWIG_4(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    float arg5 ;
    float arg6 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addArc((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addArc(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 9) {
        ok = js_cc_pipeline_GeometryRenderer_addArc__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 8) {
        ok = js_cc_pipeline_GeometryRenderer_addArc__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addArc__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addArc__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addArc__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addArc) 

static bool js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    bool arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Mat4 *arg10 = 0 ;
    cc::Vec3 temp2 ;
    cc::Mat4 temp10 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[8], &temp10, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg10 = &temp10;
    
    (arg1)->addPolygon((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,(cc::Mat4 const &)*arg10);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    bool arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addPolygon((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    bool arg6 ;
    bool arg7 ;
    bool arg8 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addPolygon((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    bool arg6 ;
    bool arg7 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addPolygon((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_4(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    bool arg6 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addPolygon((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_5(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->addPolygon((cc::Vec3 const &)*arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_6(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->addPolygon((cc::Vec3 const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addPolygon(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 9) {
        ok = js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 8) {
        ok = js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_5(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 3) {
        ok = js_cc_pipeline_GeometryRenderer_addPolygon__SWIG_6(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addPolygon) 

static bool js_cc_pipeline_GeometryRenderer_addDisc__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    bool arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Mat4 *arg10 = 0 ;
    cc::Vec3 temp2 ;
    cc::Mat4 temp10 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[8], &temp10, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg10 = &temp10;
    
    (arg1)->addDisc((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,(cc::Mat4 const &)*arg10);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addDisc__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    bool arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addDisc((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addDisc__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    bool arg6 ;
    bool arg7 ;
    bool arg8 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addDisc((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addDisc__SWIG_3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    bool arg6 ;
    bool arg7 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addDisc((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addDisc__SWIG_4(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    bool arg6 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addDisc((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addDisc__SWIG_5(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->addDisc((cc::Vec3 const &)*arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addDisc__SWIG_6(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->addDisc((cc::Vec3 const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addDisc(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 9) {
        ok = js_cc_pipeline_GeometryRenderer_addDisc__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 8) {
        ok = js_cc_pipeline_GeometryRenderer_addDisc__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addDisc__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addDisc__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addDisc__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addDisc__SWIG_5(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 3) {
        ok = js_cc_pipeline_GeometryRenderer_addDisc__SWIG_6(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addDisc) 

static bool js_cc_pipeline_GeometryRenderer_addSector__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    float arg5 ;
    float arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    bool arg11 ;
    cc::Mat4 *arg12 = 0 ;
    cc::Vec3 temp2 ;
    cc::Mat4 temp12 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[9], &arg11);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[10], &temp12, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg12 = &temp12;
    
    (arg1)->addSector((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,(cc::Mat4 const &)*arg12);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSector__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    float arg5 ;
    float arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    bool arg11 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[9], &arg11);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addSector((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSector__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    float arg5 ;
    float arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addSector((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSector__SWIG_3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    float arg5 ;
    float arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addSector((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSector__SWIG_4(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    float arg5 ;
    float arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addSector((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSector__SWIG_5(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    float arg5 ;
    float arg6 ;
    uint32_t arg7 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->addSector((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSector__SWIG_6(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    float arg5 ;
    float arg6 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addSector((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSector(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 11) {
        ok = js_cc_pipeline_GeometryRenderer_addSector__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 10) {
        ok = js_cc_pipeline_GeometryRenderer_addSector__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 9) {
        ok = js_cc_pipeline_GeometryRenderer_addSector__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 8) {
        ok = js_cc_pipeline_GeometryRenderer_addSector__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addSector__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addSector__SWIG_5(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addSector__SWIG_6(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addSector) 

static bool js_cc_pipeline_GeometryRenderer_addSphere__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    cc::Mat4 *arg11 = 0 ;
    cc::Vec3 temp2 ;
    cc::Mat4 temp11 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[9], &temp11, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg11 = &temp11;
    
    (arg1)->addSphere((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,(cc::Mat4 const &)*arg11);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSphere__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addSphere((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSphere__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addSphere((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSphere__SWIG_3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    bool arg8 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addSphere((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSphere__SWIG_4(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addSphere((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSphere__SWIG_5(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    uint32_t arg6 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->addSphere((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSphere__SWIG_6(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    uint32_t arg5 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->addSphere((cc::Vec3 const &)*arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSphere__SWIG_7(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->addSphere((cc::Vec3 const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSphere(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 10) {
        ok = js_cc_pipeline_GeometryRenderer_addSphere__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 9) {
        ok = js_cc_pipeline_GeometryRenderer_addSphere__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 8) {
        ok = js_cc_pipeline_GeometryRenderer_addSphere__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addSphere__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addSphere__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addSphere__SWIG_5(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addSphere__SWIG_6(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 3) {
        ok = js_cc_pipeline_GeometryRenderer_addSphere__SWIG_7(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addSphere) 

static bool js_cc_pipeline_GeometryRenderer_addTorus__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    bool arg11 ;
    cc::Mat4 *arg12 = 0 ;
    cc::Vec3 temp2 ;
    cc::Mat4 temp12 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[9], &arg11);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[10], &temp12, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg12 = &temp12;
    
    (arg1)->addTorus((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,(cc::Mat4 const &)*arg12);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addTorus__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    bool arg11 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[9], &arg11);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addTorus((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addTorus__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    bool arg10 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[8], &arg10);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addTorus((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addTorus__SWIG_3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addTorus((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addTorus__SWIG_4(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addTorus((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addTorus__SWIG_5(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    uint32_t arg7 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->addTorus((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addTorus__SWIG_6(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    uint32_t arg6 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->addTorus((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addTorus__SWIG_7(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::gfx::Color arg5 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->addTorus((cc::Vec3 const &)*arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addTorus(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 11) {
        ok = js_cc_pipeline_GeometryRenderer_addTorus__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 10) {
        ok = js_cc_pipeline_GeometryRenderer_addTorus__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 9) {
        ok = js_cc_pipeline_GeometryRenderer_addTorus__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 8) {
        ok = js_cc_pipeline_GeometryRenderer_addTorus__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addTorus__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addTorus__SWIG_5(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addTorus__SWIG_6(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addTorus__SWIG_7(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addTorus) 

static bool js_cc_pipeline_GeometryRenderer_addOctahedron__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    bool arg5 ;
    bool arg6 ;
    bool arg7 ;
    bool arg8 ;
    cc::Mat4 *arg9 = 0 ;
    cc::Vec3 temp2 ;
    cc::Mat4 temp9 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &temp9, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg9 = &temp9;
    
    (arg1)->addOctahedron((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8,(cc::Mat4 const &)*arg9);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addOctahedron__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    bool arg5 ;
    bool arg6 ;
    bool arg7 ;
    bool arg8 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addOctahedron((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addOctahedron__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    bool arg5 ;
    bool arg6 ;
    bool arg7 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addOctahedron((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addOctahedron__SWIG_3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    bool arg5 ;
    bool arg6 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addOctahedron((cc::Vec3 const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addOctahedron__SWIG_4(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    bool arg5 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addOctahedron((cc::Vec3 const &)*arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addOctahedron__SWIG_5(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::gfx::Color arg4 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->addOctahedron((cc::Vec3 const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addOctahedron(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 8) {
        ok = js_cc_pipeline_GeometryRenderer_addOctahedron__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addOctahedron__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addOctahedron__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addOctahedron__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addOctahedron__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 3) {
        ok = js_cc_pipeline_GeometryRenderer_addOctahedron__SWIG_5(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addOctahedron) 

static bool js_cc_pipeline_GeometryRenderer_addBezier__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::Vec3 *arg5 = 0 ;
    cc::gfx::Color arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Mat4 *arg10 = 0 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    cc::Vec3 temp5 ;
    cc::Mat4 temp10 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg5 = &temp5;
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[8], &temp10, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg10 = &temp10;
    
    (arg1)->addBezier((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4,(cc::Vec3 const &)*arg5,arg6,arg7,arg8,arg9,(cc::Mat4 const &)*arg10);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addBezier__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::Vec3 *arg5 = 0 ;
    cc::gfx::Color arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    bool arg9 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    cc::Vec3 temp5 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg5 = &temp5;
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg9);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addBezier((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4,(cc::Vec3 const &)*arg5,arg6,arg7,arg8,arg9);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addBezier__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::Vec3 *arg5 = 0 ;
    cc::gfx::Color arg6 ;
    uint32_t arg7 ;
    bool arg8 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    cc::Vec3 temp5 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg5 = &temp5;
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[6], &arg8);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addBezier((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4,(cc::Vec3 const &)*arg5,arg6,arg7,arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addBezier__SWIG_3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::Vec3 *arg5 = 0 ;
    cc::gfx::Color arg6 ;
    uint32_t arg7 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    cc::Vec3 temp5 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg5 = &temp5;
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->addBezier((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4,(cc::Vec3 const &)*arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addBezier__SWIG_4(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::Vec3 *arg5 = 0 ;
    cc::gfx::Color arg6 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    cc::Vec3 temp5 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg5 = &temp5;
    
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->addBezier((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4,(cc::Vec3 const &)*arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addBezier(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 9) {
        ok = js_cc_pipeline_GeometryRenderer_addBezier__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 8) {
        ok = js_cc_pipeline_GeometryRenderer_addBezier__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addBezier__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addBezier__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addBezier__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addBezier) 

static bool js_cc_pipeline_GeometryRenderer_addSpline__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::geometry::Spline *arg2 = 0 ;
    cc::gfx::Color arg3 ;
    uint32_t arg4 ;
    float arg5 ;
    uint32_t arg6 ;
    bool arg7 ;
    cc::geometry::Spline temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addSpline((cc::geometry::Spline const &)*arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSpline__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::geometry::Spline *arg2 = 0 ;
    cc::gfx::Color arg3 ;
    uint32_t arg4 ;
    float arg5 ;
    uint32_t arg6 ;
    cc::geometry::Spline temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->addSpline((cc::geometry::Spline const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSpline__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::geometry::Spline *arg2 = 0 ;
    cc::gfx::Color arg3 ;
    uint32_t arg4 ;
    float arg5 ;
    cc::geometry::Spline temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addSpline((cc::geometry::Spline const &)*arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSpline__SWIG_3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::geometry::Spline *arg2 = 0 ;
    cc::gfx::Color arg3 ;
    uint32_t arg4 ;
    cc::geometry::Spline temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->addSpline((cc::geometry::Spline const &)*arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSpline__SWIG_4(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::geometry::Spline *arg2 = 0 ;
    cc::gfx::Color arg3 ;
    cc::geometry::Spline temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->addSpline((cc::geometry::Spline const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addSpline(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addSpline__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addSpline__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addSpline__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 3) {
        ok = js_cc_pipeline_GeometryRenderer_addSpline__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_pipeline_GeometryRenderer_addSpline__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addSpline) 

static bool js_cc_pipeline_GeometryRenderer_addMesh__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    ccstd::vector< cc::Vec3 > *arg3 = 0 ;
    cc::gfx::Color arg4 ;
    bool arg5 ;
    bool arg6 ;
    cc::Mat4 *arg7 = 0 ;
    cc::Vec3 temp2 ;
    ccstd::vector< cc::Vec3 > temp3 ;
    cc::Mat4 temp7 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &temp7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg7 = &temp7;
    
    (arg1)->addMesh((cc::Vec3 const &)*arg2,(ccstd::vector< cc::Vec3 > const &)*arg3,arg4,arg5,arg6,(cc::Mat4 const &)*arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addMesh__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    ccstd::vector< cc::Vec3 > *arg3 = 0 ;
    cc::gfx::Color arg4 ;
    bool arg5 ;
    bool arg6 ;
    cc::Vec3 temp2 ;
    ccstd::vector< cc::Vec3 > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addMesh((cc::Vec3 const &)*arg2,(ccstd::vector< cc::Vec3 > const &)*arg3,arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addMesh__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    ccstd::vector< cc::Vec3 > *arg3 = 0 ;
    cc::gfx::Color arg4 ;
    bool arg5 ;
    cc::Vec3 temp2 ;
    ccstd::vector< cc::Vec3 > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addMesh((cc::Vec3 const &)*arg2,(ccstd::vector< cc::Vec3 > const &)*arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addMesh__SWIG_3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    ccstd::vector< cc::Vec3 > *arg3 = 0 ;
    cc::gfx::Color arg4 ;
    cc::Vec3 temp2 ;
    ccstd::vector< cc::Vec3 > temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->addMesh((cc::Vec3 const &)*arg2,(ccstd::vector< cc::Vec3 > const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addMesh(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addMesh__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addMesh__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addMesh__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 3) {
        ok = js_cc_pipeline_GeometryRenderer_addMesh__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addMesh) 

static bool js_cc_pipeline_GeometryRenderer_addIndexedMesh__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    ccstd::vector< cc::Vec3 > *arg3 = 0 ;
    ccstd::vector< uint32_t > *arg4 = 0 ;
    cc::gfx::Color arg5 ;
    bool arg6 ;
    bool arg7 ;
    cc::Mat4 *arg8 = 0 ;
    cc::Vec3 temp2 ;
    ccstd::vector< cc::Vec3 > temp3 ;
    ccstd::vector< uint32_t > temp4 ;
    cc::Mat4 temp8 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &temp8, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg8 = &temp8;
    
    (arg1)->addIndexedMesh((cc::Vec3 const &)*arg2,(ccstd::vector< cc::Vec3 > const &)*arg3,(ccstd::vector< uint32_t > const &)*arg4,arg5,arg6,arg7,(cc::Mat4 const &)*arg8);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addIndexedMesh__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    ccstd::vector< cc::Vec3 > *arg3 = 0 ;
    ccstd::vector< uint32_t > *arg4 = 0 ;
    cc::gfx::Color arg5 ;
    bool arg6 ;
    bool arg7 ;
    cc::Vec3 temp2 ;
    ccstd::vector< cc::Vec3 > temp3 ;
    ccstd::vector< uint32_t > temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addIndexedMesh((cc::Vec3 const &)*arg2,(ccstd::vector< cc::Vec3 > const &)*arg3,(ccstd::vector< uint32_t > const &)*arg4,arg5,arg6,arg7);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addIndexedMesh__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    ccstd::vector< cc::Vec3 > *arg3 = 0 ;
    ccstd::vector< uint32_t > *arg4 = 0 ;
    cc::gfx::Color arg5 ;
    bool arg6 ;
    cc::Vec3 temp2 ;
    ccstd::vector< cc::Vec3 > temp3 ;
    ccstd::vector< uint32_t > temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addIndexedMesh((cc::Vec3 const &)*arg2,(ccstd::vector< cc::Vec3 > const &)*arg3,(ccstd::vector< uint32_t > const &)*arg4,arg5,arg6);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addIndexedMesh__SWIG_3(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::pipeline::GeometryRenderer *arg1 = (cc::pipeline::GeometryRenderer *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    ccstd::vector< cc::Vec3 > *arg3 = 0 ;
    ccstd::vector< uint32_t > *arg4 = 0 ;
    cc::gfx::Color arg5 ;
    cc::Vec3 temp2 ;
    ccstd::vector< cc::Vec3 > temp3 ;
    ccstd::vector< uint32_t > temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::pipeline::GeometryRenderer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->addIndexedMesh((cc::Vec3 const &)*arg2,(ccstd::vector< cc::Vec3 > const &)*arg3,(ccstd::vector< uint32_t > const &)*arg4,arg5);
    
    
    return true;
}

static bool js_cc_pipeline_GeometryRenderer_addIndexedMesh(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 7) {
        ok = js_cc_pipeline_GeometryRenderer_addIndexedMesh__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 6) {
        ok = js_cc_pipeline_GeometryRenderer_addIndexedMesh__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 5) {
        ok = js_cc_pipeline_GeometryRenderer_addIndexedMesh__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 4) {
        ok = js_cc_pipeline_GeometryRenderer_addIndexedMesh__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_pipeline_GeometryRenderer_addIndexedMesh) 

bool js_register_cc_pipeline_GeometryRenderer(se::Object* obj) {
    auto* cls = se::Class::create("GeometryRenderer", obj, nullptr, _SE(js_new_cc_pipeline_GeometryRenderer)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("empty", _SE(js_cc_pipeline_GeometryRenderer_empty)); 
    cls->defineFunction("update", _SE(js_cc_pipeline_GeometryRenderer_update)); 
    cls->defineFunction("addDashedLine", _SE(js_cc_pipeline_GeometryRenderer_addDashedLine)); 
    cls->defineFunction("addLine", _SE(js_cc_pipeline_GeometryRenderer_addLine)); 
    cls->defineFunction("addTriangle", _SE(js_cc_pipeline_GeometryRenderer_addTriangle)); 
    cls->defineFunction("addQuad", _SE(js_cc_pipeline_GeometryRenderer_addQuad)); 
    cls->defineFunction("addBoundingBox", _SE(js_cc_pipeline_GeometryRenderer_addBoundingBox)); 
    cls->defineFunction("addCross", _SE(js_cc_pipeline_GeometryRenderer_addCross)); 
    cls->defineFunction("addFrustum", _SE(js_cc_pipeline_GeometryRenderer_addFrustum)); 
    cls->defineFunction("addCapsule", _SE(js_cc_pipeline_GeometryRenderer_addCapsule)); 
    cls->defineFunction("addCylinder", _SE(js_cc_pipeline_GeometryRenderer_addCylinder)); 
    cls->defineFunction("addCone", _SE(js_cc_pipeline_GeometryRenderer_addCone)); 
    cls->defineFunction("addCircle", _SE(js_cc_pipeline_GeometryRenderer_addCircle)); 
    cls->defineFunction("addArc", _SE(js_cc_pipeline_GeometryRenderer_addArc)); 
    cls->defineFunction("addPolygon", _SE(js_cc_pipeline_GeometryRenderer_addPolygon)); 
    cls->defineFunction("addDisc", _SE(js_cc_pipeline_GeometryRenderer_addDisc)); 
    cls->defineFunction("addSector", _SE(js_cc_pipeline_GeometryRenderer_addSector)); 
    cls->defineFunction("addSphere", _SE(js_cc_pipeline_GeometryRenderer_addSphere)); 
    cls->defineFunction("addTorus", _SE(js_cc_pipeline_GeometryRenderer_addTorus)); 
    cls->defineFunction("addOctahedron", _SE(js_cc_pipeline_GeometryRenderer_addOctahedron)); 
    cls->defineFunction("addBezier", _SE(js_cc_pipeline_GeometryRenderer_addBezier)); 
    cls->defineFunction("addSpline", _SE(js_cc_pipeline_GeometryRenderer_addSpline)); 
    cls->defineFunction("addMesh", _SE(js_cc_pipeline_GeometryRenderer_addMesh)); 
    cls->defineFunction("addIndexedMesh", _SE(js_cc_pipeline_GeometryRenderer_addIndexedMesh)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_GeometryRenderer));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::GeometryRenderer>(cls);
    
    __jsb_cc_pipeline_GeometryRenderer_proto = cls->getProto();
    __jsb_cc_pipeline_GeometryRenderer_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

#endif // CC_USE_GEOMETRY_RENDERER

se::Class* __jsb_cc_pipeline_ReflectionProbeFlow_class = nullptr;
se::Object* __jsb_cc_pipeline_ReflectionProbeFlow_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_ReflectionProbeFlow) 

static bool js_new_cc_pipeline_ReflectionProbeFlow(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::ReflectionProbeFlow *result;
    result = (cc::pipeline::ReflectionProbeFlow *)new cc::pipeline::ReflectionProbeFlow();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_ReflectionProbeFlow, __jsb_cc_pipeline_ReflectionProbeFlow_class, js_delete_cc_pipeline_ReflectionProbeFlow)

static bool js_delete_cc_pipeline_ReflectionProbeFlow(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_ReflectionProbeFlow) 

static bool js_cc_pipeline_ReflectionProbeFlow_getInitializeInfo_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderFlowInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::pipeline::RenderFlowInfo *) &cc::pipeline::ReflectionProbeFlow::getInitializeInfo();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ReflectionProbeFlow_getInitializeInfo_static) 

bool js_register_cc_pipeline_ReflectionProbeFlow(se::Object* obj) {
    auto* cls = se::Class::create("ReflectionProbeFlow", obj, __jsb_cc_pipeline_RenderFlow_proto, _SE(js_new_cc_pipeline_ReflectionProbeFlow)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    
    cls->defineStaticFunction("getInitializeInfo", _SE(js_cc_pipeline_ReflectionProbeFlow_getInitializeInfo_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_ReflectionProbeFlow));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::ReflectionProbeFlow>(cls);
    
    __jsb_cc_pipeline_ReflectionProbeFlow_proto = cls->getProto();
    __jsb_cc_pipeline_ReflectionProbeFlow_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_pipeline_ReflectionProbeStage_class = nullptr;
se::Object* __jsb_cc_pipeline_ReflectionProbeStage_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_pipeline_ReflectionProbeStage) 

static bool js_new_cc_pipeline_ReflectionProbeStage(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::pipeline::ReflectionProbeStage *result;
    result = (cc::pipeline::ReflectionProbeStage *)new cc::pipeline::ReflectionProbeStage();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_pipeline_ReflectionProbeStage, __jsb_cc_pipeline_ReflectionProbeStage_class, js_delete_cc_pipeline_ReflectionProbeStage)

static bool js_delete_cc_pipeline_ReflectionProbeStage(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_pipeline_ReflectionProbeStage) 

static bool js_cc_pipeline_ReflectionProbeStage_getInitializeInfo_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::RenderStageInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::pipeline::RenderStageInfo *) &cc::pipeline::ReflectionProbeStage::getInitializeInfo();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ReflectionProbeStage_getInitializeInfo_static) 

static bool js_cc_pipeline_ReflectionProbeStage_setFramebuffer(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ReflectionProbeStage *arg1 = (cc::pipeline::ReflectionProbeStage *) NULL ;
    cc::gfx::Framebuffer *arg2 = (cc::gfx::Framebuffer *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ReflectionProbeStage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setFramebuffer(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ReflectionProbeStage_setFramebuffer) 

static bool js_cc_pipeline_ReflectionProbeStage_setUsage(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::pipeline::ReflectionProbeStage *arg1 = (cc::pipeline::ReflectionProbeStage *) NULL ;
    cc::gfx::Framebuffer *arg2 = (cc::gfx::Framebuffer *) NULL ;
    cc::scene::ReflectionProbe *arg3 = (cc::scene::ReflectionProbe *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::pipeline::ReflectionProbeStage>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setUsage(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_pipeline_ReflectionProbeStage_setUsage) 

bool js_register_cc_pipeline_ReflectionProbeStage(se::Object* obj) {
    auto* cls = se::Class::create("ReflectionProbeStage", obj, __jsb_cc_pipeline_RenderStage_proto, _SE(js_new_cc_pipeline_ReflectionProbeStage)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("setFramebuffer", _SE(js_cc_pipeline_ReflectionProbeStage_setFramebuffer)); 
    cls->defineFunction("setUsage", _SE(js_cc_pipeline_ReflectionProbeStage_setUsage)); 
    
    
    cls->defineStaticFunction("getInitializeInfo", _SE(js_cc_pipeline_ReflectionProbeStage_getInitializeInfo_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_pipeline_ReflectionProbeStage));
    
    
    cls->install();
    JSBClassType::registerClass<cc::pipeline::ReflectionProbeStage>(cls);
    
    __jsb_cc_pipeline_ReflectionProbeStage_proto = cls->getProto();
    __jsb_cc_pipeline_ReflectionProbeStage_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}




bool register_all_pipeline(se::Object* obj) {
    // Get the ns
    se::Value nsVal;
    if (!obj->getProperty("nr", &nsVal, true))
    {
        se::HandleObject jsobj(se::Object::createPlainObject());
        nsVal.setObject(jsobj);
        obj->setProperty("nr", nsVal);
    }
    se::Object* ns = nsVal.toObject();
    /* Register classes */
    js_register_cc_pipeline_SkinningJointCapacity(ns); 
    js_register_cc_pipeline_RenderObject(ns); 
    js_register_cc_pipeline_RenderTargetInfo(ns); 
    js_register_cc_pipeline_RenderPass(ns); 
    js_register_cc_pipeline_RenderPassDesc(ns); 
    js_register_cc_pipeline_RenderTextureDesc(ns); 
    js_register_cc_pipeline_FrameBufferDesc(ns); 
    js_register_cc_pipeline_InternalBindingDesc(ns); 
    js_register_cc_pipeline_InternalBindingInst(ns); 
    js_register_cc_pipeline_RenderQueueCreateInfo(ns); 
    js_register_cc_pipeline_RenderQueueDesc(ns); 
    js_register_cc_pipeline_UBOLocalBatched(ns); 
    js_register_cc_pipeline_UBOLocal(ns); 
    js_register_cc_pipeline_UBOWorldBound(ns); 
    js_register_cc_pipeline_UBOForwardLight(ns); 
    js_register_cc_pipeline_UBODeferredLight(ns); 
    js_register_cc_pipeline_UBOSkinningTexture(ns); 
    js_register_cc_pipeline_UBOSkinningAnimation(ns); 
    js_register_cc_pipeline_UBOSkinning(ns); 
    js_register_cc_pipeline_UBOMorph(ns); 
    js_register_cc_pipeline_UBOUILocal(ns); 
    js_register_cc_pipeline_UBOSH(ns); 
    js_register_cc_pipeline_UBOGlobal(ns); 
    js_register_cc_pipeline_UBOCamera(ns); 
    js_register_cc_pipeline_UBOShadow(ns); 
    js_register_cc_pipeline_UBOCSM(ns); 
    js_register_cc_pipeline_DescriptorSetLayoutInfos(ns); 
    js_register_cc_pipeline_SHADOWMAP(ns); 
    js_register_cc_pipeline_ENVIRONMENT(ns); 
    js_register_cc_pipeline_SPOTSHADOWMAP(ns); 
    js_register_cc_pipeline_DIFFUSEMAP(ns); 
    js_register_cc_pipeline_JOINTTEXTURE(ns); 
    js_register_cc_pipeline_REALTIMEJOINTTEXTURE(ns); 
    js_register_cc_pipeline_POSITIONMORPH(ns); 
    js_register_cc_pipeline_NORMALMORPH(ns); 
    js_register_cc_pipeline_TANGENTMORPH(ns); 
    js_register_cc_pipeline_LIGHTMAPTEXTURE(ns); 
    js_register_cc_pipeline_SPRITETEXTURE(ns); 
    js_register_cc_pipeline_REFLECTIONTEXTURE(ns); 
    js_register_cc_pipeline_REFLECTIONSTORAGE(ns); 
    js_register_cc_pipeline_REFLECTIONPROBECUBEMAP(ns); 
    js_register_cc_pipeline_REFLECTIONPROBEPLANARMAP(ns); 
    js_register_cc_pipeline_RenderPipelineInfo(ns); 
    js_register_cc_pipeline_RenderPipeline(ns); 
    js_register_cc_pipeline_RenderFlowInfo(ns); 
    js_register_cc_pipeline_RenderFlow(ns); 
    js_register_cc_pipeline_RenderStageInfo(ns); 
    js_register_cc_pipeline_RenderStage(ns); 
    js_register_cc_pipeline_ForwardPipeline(ns); 
    js_register_cc_pipeline_ForwardFlow(ns); 
    js_register_cc_pipeline_ForwardStage(ns); 
    js_register_cc_pipeline_ShadowFlow(ns); 
    js_register_cc_pipeline_ShadowStage(ns); 
    js_register_cc_pipeline_ShadowTransformInfo(ns); 
    js_register_cc_pipeline_CSMLayerInfo(ns); 
    js_register_cc_pipeline_CSMLayers(ns); 
    js_register_cc_pipeline_GlobalDSManager(ns); 
    js_register_cc_pipeline_InstancedItem(ns); 
    js_register_cc_pipeline_InstancedBuffer(ns); 
    js_register_cc_pipeline_DeferredPipeline(ns); 
    js_register_cc_pipeline_MainFlow(ns); 
    js_register_cc_pipeline_GbufferStage(ns); 
    js_register_cc_pipeline_RenderElem(ns); 
    js_register_cc_pipeline_LightingStage(ns); 
    js_register_cc_pipeline_BloomStage(ns); 
    js_register_cc_pipeline_PostProcessStage(ns); 
    js_register_cc_pipeline_PipelineSceneData(ns); 
    js_register_cc_pipeline_BatchedItem(ns); 
    js_register_cc_pipeline_BatchedBuffer(ns); 
#if CC_USE_GEOMETRY_RENDERER
    js_register_cc_pipeline_GeometryRenderer(ns); 
#endif // CC_USE_GEOMETRY_RENDERER
    js_register_cc_pipeline_ReflectionProbeFlow(ns); 
    js_register_cc_pipeline_ReflectionProbeStage(ns); 
    
    /* Register global variables & global functions */
    
    
    
    return true;
}


#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif
// clang-format on
