// clang-format off

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

/****************************************************************************
 Copyright (c) 2022-2023 Xiamen Yaji Software Co., Ltd.

 http://www.cocos.com

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights to
 use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 of the Software, and to permit persons to whom the Software is furnished to do so,
 subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
****************************************************************************/

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-variable"
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-variable"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4101)
#endif


#define SWIG_STD_MOVE(OBJ) std::move(OBJ)


#include <stdio.h>


#include "bindings/jswrapper/SeApi.h"
#include "bindings/manual/jsb_conversions.h"
#include "bindings/manual/jsb_global.h"


#include "bindings/auto/jsb_scene_auto.h"
#include "bindings/auto/jsb_gfx_auto.h"
#include "bindings/auto/jsb_pipeline_auto.h"
#include "bindings/auto/jsb_geometry_auto.h"
#include "bindings/auto/jsb_assets_auto.h"
#include "bindings/auto/jsb_render_auto.h"
#include "bindings/auto/jsb_cocos_auto.h"
#include "bindings/auto/jsb_2d_auto.h"

using namespace cc;


#define cc_Root_device_get(self_) self_->getDevice()
#define cc_Root_device_set(self_, val_) self_->setDevice(val_)
  

#define cc_Root__device_get(self_) self_->getDevice()
#define cc_Root__device_set(self_, val_) self_->setDevice(val_)
  

#define cc_Root_mainWindow_get(self_) self_->getMainWindow()
  

#define cc_Root_curWindow_get(self_) self_->getCurWindow()
#define cc_Root_curWindow_set(self_, val_) self_->setCurWindow(val_)
  

#define cc_Root_tempWindow_get(self_) self_->getTempWindow()
#define cc_Root_tempWindow_set(self_, val_) self_->setTempWindow(val_)
  

#define cc_Root_windows_get(self_) self_->getWindows()
  

#define cc_Root_scenes_get(self_) self_->getScenes()
  

#define cc_Root_cumulativeTime_get(self_) self_->getCumulativeTime()
  

#define cc_Root_frameTime_get(self_) self_->getFrameTime()
  

#define cc_Root_frameCount_get(self_) self_->getFrameCount()
  

#define cc_Root_fps_get(self_) self_->getFps()
  

#define cc_Root_fixedFPS_get(self_) self_->getFixedFPS()
#define cc_Root_fixedFPS_set(self_, val_) self_->setFixedFPS(val_)
  

#define cc_Root_useDeferredPipeline_get(self_) self_->isUsingDeferredPipeline()
  

#define cc_Root_usesCustomPipeline_get(self_) self_->usesCustomPipeline()
  

#define cc_Root_pipeline_get(self_) self_->getPipeline()
  

#define cc_Root_customPipeline_get(self_) self_->getCustomPipeline()
  

#define cc_Root_cameraList_get(self_) self_->getCameraList()
  

#define cc_scene_RenderWindow_width_get(self_) self_->getWidth()
  

#define cc_scene_RenderWindow_height_get(self_) self_->getHeight()
  

#define cc_scene_RenderWindow_framebuffer_get(self_) self_->getFramebuffer()
  

#define cc_scene_RenderWindow_cameras_get(self_) self_->getCameras()
  

#define cc_scene_RenderWindow_swapchain_get(self_) self_->getSwapchain()
  

#define cc_scene_Pass_root_get(self_) self_->getRoot()
  

#define cc_scene_Pass_device_get(self_) self_->getDevice()
  

#define cc_scene_Pass_shaderInfo_get(self_) self_->getShaderInfo()
  

#define cc_scene_Pass_localSetLayout_get(self_) self_->getLocalSetLayout()
  

#define cc_scene_Pass_program_get(self_) self_->getProgram()
  

#define cc_scene_Pass_properties_get(self_) self_->getProperties()
  

#define cc_scene_Pass_defines_get(self_) self_->getDefines()
  

#define cc_scene_Pass_passIndex_get(self_) self_->getPassIndex()
  

#define cc_scene_Pass_propertyIndex_get(self_) self_->getPropertyIndex()
  

#define cc_scene_Pass_dynamics_get(self_) self_->getDynamics()
  

#define cc_scene_Pass_rootBufferDirty_get(self_) self_->isRootBufferDirty()
  

#define cc_scene_Pass__rootBufferDirty_get(self_) self_->isRootBufferDirty()
#define cc_scene_Pass__rootBufferDirty_set(self_, val_) self_->_setRootBufferDirty(val_)
  

#define cc_scene_Pass_priority_get(self_) self_->getPriority()
  

#define cc_scene_Pass_primitive_get(self_) self_->getPrimitive()
  

#define cc_scene_Pass_stage_get(self_) self_->getStage()
  

#define cc_scene_Pass_phase_get(self_) self_->getPhase()
  

#define cc_scene_Pass_rasterizerState_get(self_) self_->getRasterizerState()
  

#define cc_scene_Pass_depthStencilState_get(self_) self_->getDepthStencilState()
  

#define cc_scene_Pass_blendState_get(self_) self_->getBlendState()
  

#define cc_scene_Pass_dynamicStates_get(self_) self_->getDynamicStates()
  

#define cc_scene_Pass_batchingScheme_get(self_) self_->getBatchingScheme()
  

#define cc_scene_Pass_descriptorSet_get(self_) self_->getDescriptorSet()
  

#define cc_scene_Pass_hash_get(self_) self_->getHash()
  

#define cc_scene_Pass_pipelineLayout_get(self_) self_->getPipelineLayout()
  

#define cc_PassInstance_parent_get(self_) self_->getParent()
  

#define cc_Node_uuid_get(self_) self_->getUuid()
  

#define cc_Node_angle_get(self_) self_->getAngle()
#define cc_Node_angle_set(self_, val_) self_->setAngle(val_)
  

#define cc_Node_matrix_set(self_, val_) self_->setMatrix(val_)
  

#define cc_Node_hasChangedFlags_get(self_) self_->getChangedFlags()
#define cc_Node_hasChangedFlags_set(self_, val_) self_->setChangedFlags(val_)
  

#define cc_Node__persistNode_get(self_) self_->isPersistNode()
#define cc_Node__persistNode_set(self_, val_) self_->setPersistNode(val_)
  

#define cc_Node_mobility_get(self_) self_->getMobility()
#define cc_Node_mobility_set(self_, val_) self_->setMobility(val_)
  

#define cc_scene_Ambient_skyColor_get(self_) self_->getSkyColor()
#define cc_scene_Ambient_skyColor_set(self_, val_) self_->setSkyColor(val_)
  

#define cc_scene_Ambient_skyIllum_get(self_) self_->getSkyIllum()
#define cc_scene_Ambient_skyIllum_set(self_, val_) self_->setSkyIllum(val_)
  

#define cc_scene_Ambient_groundAlbedo_get(self_) self_->getGroundAlbedo()
#define cc_scene_Ambient_groundAlbedo_set(self_, val_) self_->setGroundAlbedo(val_)
  

#define cc_scene_Ambient_enabled_get(self_) self_->isEnabled()
#define cc_scene_Ambient_enabled_set(self_, val_) self_->setEnabled(val_)
  

#define cc_scene_Ambient_mipmapCount_get(self_) self_->getMipmapCount()
#define cc_scene_Ambient_mipmapCount_set(self_, val_) self_->setMipmapCount(val_)
  

#define cc_scene_Light_baked_get(self_) self_->isBaked()
#define cc_scene_Light_baked_set(self_, val_) self_->setBaked(val_)
  

#define cc_scene_Light_color_get(self_) self_->getColor()
#define cc_scene_Light_color_set(self_, val_) self_->setColor(val_)
  

#define cc_scene_Light_useColorTemperature_get(self_) self_->isUseColorTemperature()
#define cc_scene_Light_useColorTemperature_set(self_, val_) self_->setUseColorTemperature(val_)
  

#define cc_scene_Light_colorTemperature_get(self_) self_->getColorTemperature()
#define cc_scene_Light_colorTemperature_set(self_, val_) self_->setColorTemperature(val_)
  

#define cc_scene_Light_node_get(self_) self_->getNode()
#define cc_scene_Light_node_set(self_, val_) self_->setNode(val_)
  

#define cc_scene_Light_type_get(self_) self_->getType()
#define cc_scene_Light_type_set(self_, val_) self_->setType(val_)
  

#define cc_scene_Light_name_get(self_) self_->getName()
#define cc_scene_Light_name_set(self_, val_) self_->setName(val_)
  

#define cc_scene_Light_scene_get(self_) self_->getScene()
  

#define cc_scene_Light_visibility_get(self_) self_->getVisibility()
#define cc_scene_Light_visibility_set(self_, val_) self_->setVisibility(val_)
  

#define cc_scene_LODData_screenUsagePercentage_get(self_) self_->getScreenUsagePercentage()
#define cc_scene_LODData_screenUsagePercentage_set(self_, val_) self_->setScreenUsagePercentage(val_)
  

#define cc_scene_LODData_models_get(self_) self_->getModels()
  

#define cc_scene_LODGroup_lodCount_get(self_) self_->getLodCount()
  

#define cc_scene_LODGroup_enabled_get(self_) self_->isEnabled()
#define cc_scene_LODGroup_enabled_set(self_, val_) self_->setEnabled(val_)
  

#define cc_scene_LODGroup_localBoundaryCenter_get(self_) self_->getLocalBoundaryCenter()
#define cc_scene_LODGroup_localBoundaryCenter_set(self_, val_) self_->setLocalBoundaryCenter(val_)
  

#define cc_scene_LODGroup_objectSize_get(self_) self_->getObjectSize()
#define cc_scene_LODGroup_objectSize_set(self_, val_) self_->setObjectSize(val_)
  

#define cc_scene_LODGroup_node_get(self_) self_->getNode()
#define cc_scene_LODGroup_node_set(self_, val_) self_->setNode(val_)
  

#define cc_scene_LODGroup_lodDataArray_get(self_) self_->getLodDataArray()
  

#define cc_scene_LODGroup_scene_get(self_) self_->getScene()
  

#define cc_scene_DirectionalLight_direction_get(self_) self_->getDirection()
#define cc_scene_DirectionalLight_direction_set(self_, val_) self_->setDirection(val_)
  

#define cc_scene_DirectionalLight_illuminance_get(self_) self_->getIlluminance()
#define cc_scene_DirectionalLight_illuminance_set(self_, val_) self_->setIlluminance(val_)
  

#define cc_scene_DirectionalLight_illuminanceHDR_get(self_) self_->getIlluminanceHDR()
#define cc_scene_DirectionalLight_illuminanceHDR_set(self_, val_) self_->setIlluminanceHDR(val_)
  

#define cc_scene_DirectionalLight_illuminanceLDR_get(self_) self_->getIlluminanceLDR()
#define cc_scene_DirectionalLight_illuminanceLDR_set(self_, val_) self_->setIlluminanceLDR(val_)
  

#define cc_scene_DirectionalLight_shadowEnabled_get(self_) self_->isShadowEnabled()
#define cc_scene_DirectionalLight_shadowEnabled_set(self_, val_) self_->setShadowEnabled(val_)
  

#define cc_scene_DirectionalLight_shadowPcf_get(self_) self_->getShadowPcf()
#define cc_scene_DirectionalLight_shadowPcf_set(self_, val_) self_->setShadowPcf(val_)
  

#define cc_scene_DirectionalLight_shadowBias_get(self_) self_->getShadowBias()
#define cc_scene_DirectionalLight_shadowBias_set(self_, val_) self_->setShadowBias(val_)
  

#define cc_scene_DirectionalLight_shadowNormalBias_get(self_) self_->getShadowNormalBias()
#define cc_scene_DirectionalLight_shadowNormalBias_set(self_, val_) self_->setShadowNormalBias(val_)
  

#define cc_scene_DirectionalLight_shadowSaturation_get(self_) self_->getShadowSaturation()
#define cc_scene_DirectionalLight_shadowSaturation_set(self_, val_) self_->setShadowSaturation(val_)
  

#define cc_scene_DirectionalLight_shadowDistance_get(self_) self_->getShadowDistance()
#define cc_scene_DirectionalLight_shadowDistance_set(self_, val_) self_->setShadowDistance(val_)
  

#define cc_scene_DirectionalLight_shadowInvisibleOcclusionRange_get(self_) self_->getShadowInvisibleOcclusionRange()
#define cc_scene_DirectionalLight_shadowInvisibleOcclusionRange_set(self_, val_) self_->setShadowInvisibleOcclusionRange(val_)
  

#define cc_scene_DirectionalLight_shadowFixedArea_get(self_) self_->isShadowFixedArea()
#define cc_scene_DirectionalLight_shadowFixedArea_set(self_, val_) self_->setShadowFixedArea(val_)
  

#define cc_scene_DirectionalLight_shadowNear_get(self_) self_->getShadowNear()
#define cc_scene_DirectionalLight_shadowNear_set(self_, val_) self_->setShadowNear(val_)
  

#define cc_scene_DirectionalLight_shadowFar_get(self_) self_->getShadowFar()
#define cc_scene_DirectionalLight_shadowFar_set(self_, val_) self_->setShadowFar(val_)
  

#define cc_scene_DirectionalLight_shadowOrthoSize_get(self_) self_->getShadowOrthoSize()
#define cc_scene_DirectionalLight_shadowOrthoSize_set(self_, val_) self_->setShadowOrthoSize(val_)
  

#define cc_scene_DirectionalLight_csmLevel_get(self_) self_->getCSMLevel()
#define cc_scene_DirectionalLight_csmLevel_set(self_, val_) self_->setCSMLevel(val_)
  

#define cc_scene_DirectionalLight_csmNeedUpdate_get(self_) self_->isCSMNeedUpdate()
#define cc_scene_DirectionalLight_csmNeedUpdate_set(self_, val_) self_->setCSMNeedUpdate(val_)
  

#define cc_scene_DirectionalLight_csmLayerLambda_get(self_) self_->getCSMLayerLambda()
#define cc_scene_DirectionalLight_csmLayerLambda_set(self_, val_) self_->setCSMLayerLambda(val_)
  

#define cc_scene_DirectionalLight_csmOptimizationMode_get(self_) self_->getCSMOptimizationMode()
#define cc_scene_DirectionalLight_csmOptimizationMode_set(self_, val_) self_->setCSMOptimizationMode(val_)
  

#define cc_scene_DirectionalLight_csmLayersTransition_get(self_) self_->getCSMLayersTransition()
#define cc_scene_DirectionalLight_csmLayersTransition_set(self_, val_) self_->setCSMLayersTransition(val_)
  

#define cc_scene_DirectionalLight_csmTransitionRange_get(self_) self_->getCSMTransitionRange()
#define cc_scene_DirectionalLight_csmTransitionRange_set(self_, val_) self_->setCSMTransitionRange(val_)
  

#define cc_scene_SpotLight_position_get(self_) self_->getPosition()
  

#define cc_scene_SpotLight_range_get(self_) self_->getRange()
#define cc_scene_SpotLight_range_set(self_, val_) self_->setRange(val_)
  

#define cc_scene_SpotLight_luminance_get(self_) self_->getLuminance()
#define cc_scene_SpotLight_luminance_set(self_, val_) self_->setLuminance(val_)
  

#define cc_scene_SpotLight_luminanceHDR_get(self_) self_->getLuminanceHDR()
#define cc_scene_SpotLight_luminanceHDR_set(self_, val_) self_->setLuminanceHDR(val_)
  

#define cc_scene_SpotLight_luminanceLDR_get(self_) self_->getLuminanceLDR()
#define cc_scene_SpotLight_luminanceLDR_set(self_, val_) self_->setLuminanceLDR(val_)
  

#define cc_scene_SpotLight_direction_get(self_) self_->getDirection()
  

#define cc_scene_SpotLight_spotAngle_get(self_) self_->getSpotAngle()
#define cc_scene_SpotLight_spotAngle_set(self_, val_) self_->setSpotAngle(val_)
  

#define cc_scene_SpotLight_angle_get(self_) self_->getAngle()
  

#define cc_scene_SpotLight_aabb_get(self_) self_->getAABB()
  

#define cc_scene_SpotLight_frustum_get(self_) self_->getFrustum()
#define cc_scene_SpotLight_frustum_set(self_, val_) self_->setFrustum(val_)
  

#define cc_scene_SpotLight_shadowEnabled_get(self_) self_->isShadowEnabled()
#define cc_scene_SpotLight_shadowEnabled_set(self_, val_) self_->setShadowEnabled(val_)
  

#define cc_scene_SpotLight_shadowPcf_get(self_) self_->getShadowPcf()
#define cc_scene_SpotLight_shadowPcf_set(self_, val_) self_->setShadowPcf(val_)
  

#define cc_scene_SpotLight_shadowBias_get(self_) self_->getShadowBias()
#define cc_scene_SpotLight_shadowBias_set(self_, val_) self_->setShadowBias(val_)
  

#define cc_scene_SpotLight_shadowNormalBias_get(self_) self_->getShadowNormalBias()
#define cc_scene_SpotLight_shadowNormalBias_set(self_, val_) self_->setShadowNormalBias(val_)
  

#define cc_scene_SpotLight_size_get(self_) self_->getSize()
#define cc_scene_SpotLight_size_set(self_, val_) self_->setSize(val_)
  

#define cc_scene_SphereLight_position_get(self_) self_->getPosition()
#define cc_scene_SphereLight_position_set(self_, val_) self_->setPosition(val_)
  

#define cc_scene_SphereLight_size_get(self_) self_->getSize()
#define cc_scene_SphereLight_size_set(self_, val_) self_->setSize(val_)
  

#define cc_scene_SphereLight_range_get(self_) self_->getRange()
#define cc_scene_SphereLight_range_set(self_, val_) self_->setRange(val_)
  

#define cc_scene_SphereLight_luminance_get(self_) self_->getLuminance()
#define cc_scene_SphereLight_luminance_set(self_, val_) self_->setLuminance(val_)
  

#define cc_scene_SphereLight_luminanceHDR_get(self_) self_->getLuminanceHDR()
#define cc_scene_SphereLight_luminanceHDR_set(self_, val_) self_->setLuminanceHDR(val_)
  

#define cc_scene_SphereLight_luminanceLDR_get(self_) self_->getLuminanceLDR()
#define cc_scene_SphereLight_luminanceLDR_set(self_, val_) self_->setLuminanceLDR(val_)
  

#define cc_scene_SphereLight_aabb_get(self_) self_->getAABB()
  

#define cc_scene_Camera_iso_get(self_) self_->getIso()
#define cc_scene_Camera_iso_set(self_, val_) self_->setIso(val_)
  

#define cc_scene_Camera_isoValue_get(self_) self_->getIsoValue()
  

#define cc_scene_Camera_ec_get(self_) self_->getEc()
#define cc_scene_Camera_ec_set(self_, val_) self_->setEc(val_)
  

#define cc_scene_Camera_exposure_get(self_) self_->getExposure()
  

#define cc_scene_Camera_shutter_get(self_) self_->getShutter()
#define cc_scene_Camera_shutter_set(self_, val_) self_->setShutter(val_)
  

#define cc_scene_Camera_shutterValue_get(self_) self_->getShutterValue()
  

#define cc_scene_Camera_apertureValue_get(self_) self_->getApertureValue()
  

#define cc_scene_Camera_width_get(self_) self_->getWidth()
  

#define cc_scene_Camera_height_get(self_) self_->getHeight()
  

#define cc_scene_Camera_aspect_get(self_) self_->getAspect()
  

#define cc_scene_Camera_scene_get(self_) self_->getScene()
  

#define cc_scene_Camera_name_get(self_) self_->getName()
  

#define cc_scene_Camera_window_get(self_) self_->getWindow()
#define cc_scene_Camera_window_set(self_, val_) self_->setWindow(val_)
  

#define cc_scene_Camera_forward_get(self_) self_->getForward()
#define cc_scene_Camera_forward_set(self_, val_) self_->setForward(val_)
  

#define cc_scene_Camera_aperture_get(self_) self_->getAperture()
#define cc_scene_Camera_aperture_set(self_, val_) self_->setAperture(val_)
  

#define cc_scene_Camera_position_get(self_) self_->getPosition()
#define cc_scene_Camera_position_set(self_, val_) self_->setPosition(val_)
  

#define cc_scene_Camera_projectionType_get(self_) self_->getProjectionType()
#define cc_scene_Camera_projectionType_set(self_, val_) self_->setProjectionType(val_)
  

#define cc_scene_Camera_fovAxis_get(self_) self_->getFovAxis()
#define cc_scene_Camera_fovAxis_set(self_, val_) self_->setFovAxis(val_)
  

#define cc_scene_Camera_fov_get(self_) self_->getFov()
#define cc_scene_Camera_fov_set(self_, val_) self_->setFov(val_)
  

#define cc_scene_Camera_nearClip_get(self_) self_->getNearClip()
#define cc_scene_Camera_nearClip_set(self_, val_) self_->setNearClip(val_)
  

#define cc_scene_Camera_farClip_get(self_) self_->getFarClip()
#define cc_scene_Camera_farClip_set(self_, val_) self_->setFarClip(val_)
  

#define cc_scene_Camera_viewport_get(self_) self_->getViewport()
#define cc_scene_Camera_viewport_set(self_, val_) self_->setViewport(val_)
  

#define cc_scene_Camera_orthoHeight_get(self_) self_->getOrthoHeight()
#define cc_scene_Camera_orthoHeight_set(self_, val_) self_->setOrthoHeight(val_)
  

#define cc_scene_Camera_clearColor_get(self_) self_->getClearColor()
#define cc_scene_Camera_clearColor_set(self_, val_) self_->setClearColor(val_)
  

#define cc_scene_Camera_clearDepth_get(self_) self_->getClearDepth()
#define cc_scene_Camera_clearDepth_set(self_, val_) self_->setClearDepth(val_)
  

#define cc_scene_Camera_clearFlag_get(self_) self_->getClearFlag()
#define cc_scene_Camera_clearFlag_set(self_, val_) self_->setClearFlag(val_)
  

#define cc_scene_Camera_clearStencil_get(self_) self_->getClearStencil()
#define cc_scene_Camera_clearStencil_set(self_, val_) self_->setClearStencil(val_)
  

#define cc_scene_Camera_enabled_get(self_) self_->isEnabled()
#define cc_scene_Camera_enabled_set(self_, val_) self_->setEnabled(val_)
  

#define cc_scene_Camera_exposure_get(self_) self_->getExposure()
  

#define cc_scene_Camera_frustum_get(self_) self_->getFrustum()
#define cc_scene_Camera_frustum_set(self_, val_) self_->setFrustum(val_)
  

#define cc_scene_Camera_isWindowSize_get(self_) self_->isWindowSize()
#define cc_scene_Camera_isWindowSize_set(self_, val_) self_->setWindowSize(val_)
  

#define cc_scene_Camera_priority_get(self_) self_->getPriority()
#define cc_scene_Camera_priority_set(self_, val_) self_->setPriority(val_)
  

#define cc_scene_Camera_screenScale_get(self_) self_->getScreenScale()
#define cc_scene_Camera_screenScale_set(self_, val_) self_->setScreenScale(val_)
  

#define cc_scene_Camera_visibility_get(self_) self_->getVisibility()
#define cc_scene_Camera_visibility_set(self_, val_) self_->setVisibility(val_)
  

#define cc_scene_Camera_node_get(self_) self_->getNode()
#define cc_scene_Camera_node_set(self_, val_) self_->setNode(val_)
  

#define cc_scene_Camera_surfaceTransform_get(self_) self_->getSurfaceTransform()
  

#define cc_scene_Camera_geometryRenderer_get(self_) self_->getGeometryRenderer()
  

#define cc_scene_Camera_systemWindowId_get(self_) self_->getSystemWindowId()
  

#define cc_scene_Camera_cameraUsage_get(self_) self_->getCameraUsage()
#define cc_scene_Camera_cameraUsage_set(self_, val_) self_->setCameraUsage(val_)
  

#define cc_scene_RenderScene_name_get(self_) self_->getName()
  

#define cc_scene_RenderScene_cameras_get(self_) self_->getCameras()
  

#define cc_scene_RenderScene_sphereLights_get(self_) self_->getSphereLights()
  

#define cc_scene_RenderScene_spotLights_get(self_) self_->getSpotLights()
  

#define cc_scene_RenderScene_models_get(self_) self_->getModels()
  

#define cc_scene_RenderScene_lodGroups_get(self_) self_->getLODGroups()
  

#define cc_scene_Skybox_model_get(self_) self_->getModel()
  

#define cc_scene_Skybox_enabled_get(self_) self_->isEnabled()
#define cc_scene_Skybox_enabled_set(self_, val_) self_->setEnabled(val_)
  

#define cc_scene_Skybox_useHDR_get(self_) self_->isUseHDR()
#define cc_scene_Skybox_useHDR_set(self_, val_) self_->setUseHDR(val_)
  

#define cc_scene_Skybox_useIBL_get(self_) self_->isUseIBL()
#define cc_scene_Skybox_useIBL_set(self_, val_) self_->setUseIBL(val_)
  

#define cc_scene_Skybox_useDiffuseMap_get(self_) self_->isUseDiffuseMap()
#define cc_scene_Skybox_useDiffuseMap_set(self_, val_) self_->setUseDiffuseMap(val_)
  

#define cc_scene_Skybox_isRGBE_get(self_) self_->isRGBE()
  

#define cc_scene_Skybox_envmap_get(self_) self_->getEnvmap()
#define cc_scene_Skybox_envmap_set(self_, val_) self_->setEnvmap(val_)
  

#define cc_scene_Skybox_diffuseMap_get(self_) self_->getDiffuseMap()
#define cc_scene_Skybox_diffuseMap_set(self_, val_) self_->setDiffuseMap(val_)
  

#define cc_scene_Fog_enabled_get(self_) self_->isEnabled()
#define cc_scene_Fog_enabled_set(self_, val_) self_->setEnabled(val_)
  

#define cc_scene_Fog_accurate_get(self_) self_->isAccurate()
#define cc_scene_Fog_accurate_set(self_, val_) self_->setAccurate(val_)
  

#define cc_scene_Fog_fogColor_get(self_) self_->getFogColor()
#define cc_scene_Fog_fogColor_set(self_, val_) self_->setFogColor(val_)
  

#define cc_scene_Fog_type_get(self_) self_->getType()
#define cc_scene_Fog_type_set(self_, val_) self_->setType(val_)
  

#define cc_scene_Fog_fogDensity_get(self_) self_->getFogDensity()
#define cc_scene_Fog_fogDensity_set(self_, val_) self_->setFogDensity(val_)
  

#define cc_scene_Fog_fogStart_get(self_) self_->getFogStart()
#define cc_scene_Fog_fogStart_set(self_, val_) self_->setFogStart(val_)
  

#define cc_scene_Fog_fogEnd_get(self_) self_->getFogEnd()
#define cc_scene_Fog_fogEnd_set(self_, val_) self_->setFogEnd(val_)
  

#define cc_scene_Fog_fogAtten_get(self_) self_->getFogAtten()
#define cc_scene_Fog_fogAtten_set(self_, val_) self_->setFogAtten(val_)
  

#define cc_scene_Fog_fogTop_get(self_) self_->getFogTop()
#define cc_scene_Fog_fogTop_set(self_, val_) self_->setFogTop(val_)
  

#define cc_scene_Fog_fogRange_get(self_) self_->getFogRange()
#define cc_scene_Fog_fogRange_set(self_, val_) self_->setFogRange(val_)
  

#define cc_scene_Fog_colorArray_get(self_) self_->getColorArray()
  

#define cc_scene_Model_scene_get(self_) self_->getScene()
#define cc_scene_Model_scene_set(self_, val_) self_->setScene(val_)
  

#define cc_scene_Model__subModels_get(self_) self_->getSubModels()
  

#define cc_scene_Model_subModels_get(self_) self_->getSubModels()
  

#define cc_scene_Model_inited_get(self_) self_->isInited()
  

#define cc_scene_Model__localDataUpdated_get(self_) self_->isLocalDataUpdated()
#define cc_scene_Model__localDataUpdated_set(self_, val_) self_->setLocalDataUpdated(val_)
  

#define cc_scene_Model__worldBounds_get(self_) self_->getWorldBounds()
#define cc_scene_Model__worldBounds_set(self_, val_) self_->setWorldBounds(val_)
  

#define cc_scene_Model_worldBounds_get(self_) self_->getWorldBounds()
#define cc_scene_Model_worldBounds_set(self_, val_) self_->setWorldBounds(val_)
  

#define cc_scene_Model__modelBounds_get(self_) self_->getModelBounds()
#define cc_scene_Model__modelBounds_set(self_, val_) self_->setModelBounds(val_)
  

#define cc_scene_Model_modelBounds_get(self_) self_->getModelBounds()
#define cc_scene_Model_modelBounds_set(self_, val_) self_->setModelBounds(val_)
  

#define cc_scene_Model_worldBoundBuffer_get(self_) self_->getWorldBoundBuffer()
#define cc_scene_Model_worldBoundBuffer_set(self_, val_) self_->setWorldBoundBuffer(val_)
  

#define cc_scene_Model_localBuffer_get(self_) self_->getLocalBuffer()
#define cc_scene_Model_localBuffer_set(self_, val_) self_->setLocalBuffer(val_)
  

#define cc_scene_Model_updateStamp_get(self_) self_->getUpdateStamp()
  

#define cc_scene_Model_receiveShadow_get(self_) self_->isReceiveShadow()
#define cc_scene_Model_receiveShadow_set(self_, val_) self_->setReceiveShadow(val_)
  

#define cc_scene_Model_castShadow_get(self_) self_->isCastShadow()
#define cc_scene_Model_castShadow_set(self_, val_) self_->setCastShadow(val_)
  

#define cc_scene_Model_shadowBias_get(self_) self_->getShadowBias()
#define cc_scene_Model_shadowBias_set(self_, val_) self_->setShadowBias(val_)
  

#define cc_scene_Model_shadowNormalBias_get(self_) self_->getShadowNormalBias()
#define cc_scene_Model_shadowNormalBias_set(self_, val_) self_->setShadowNormalBias(val_)
  

#define cc_scene_Model_node_get(self_) self_->getNode()
#define cc_scene_Model_node_set(self_, val_) self_->setNode(val_)
  

#define cc_scene_Model_transform_get(self_) self_->getTransform()
#define cc_scene_Model_transform_set(self_, val_) self_->setTransform(val_)
  

#define cc_scene_Model_visFlags_get(self_) self_->getVisFlags()
#define cc_scene_Model_visFlags_set(self_, val_) self_->setVisFlags(val_)
  

#define cc_scene_Model_enabled_get(self_) self_->isEnabled()
#define cc_scene_Model_enabled_set(self_, val_) self_->setEnabled(val_)
  

#define cc_scene_Model_type_get(self_) self_->getType()
#define cc_scene_Model_type_set(self_, val_) self_->setType(val_)
  

#define cc_scene_Model_isDynamicBatching_get(self_) self_->isDynamicBatching()
#define cc_scene_Model_isDynamicBatching_set(self_, val_) self_->setDynamicBatching(val_)
  

#define cc_scene_Model_priority_get(self_) self_->getPriority()
#define cc_scene_Model_priority_set(self_, val_) self_->setPriority(val_)
  

#define cc_scene_Model_tetrahedronIndex_get(self_) self_->getTetrahedronIndex()
#define cc_scene_Model_tetrahedronIndex_set(self_, val_) self_->setTetrahedronIndex(val_)
  

#define cc_scene_Model_useLightProbe_get(self_) self_->getUseLightProbe()
#define cc_scene_Model_useLightProbe_set(self_, val_) self_->setUseLightProbe(val_)
  

#define cc_scene_Model_bakeToReflectionProbe_get(self_) self_->getBakeToReflectionProbe()
#define cc_scene_Model_bakeToReflectionProbe_set(self_, val_) self_->setBakeToReflectionProbe(val_)
  

#define cc_scene_Model_reflectionProbeType_get(self_) self_->getReflectionProbeType()
#define cc_scene_Model_reflectionProbeType_set(self_, val_) self_->setReflectionProbeType(val_)
  

#define cc_scene_SubModel_passes_get(self_) self_->getPasses()
#define cc_scene_SubModel_passes_set(self_, val_) self_->setPasses(val_)
  

#define cc_scene_SubModel_shaders_get(self_) self_->getShaders()
#define cc_scene_SubModel_shaders_set(self_, val_) self_->setShaders(val_)
  

#define cc_scene_SubModel_subMesh_get(self_) self_->getSubMesh()
#define cc_scene_SubModel_subMesh_set(self_, val_) self_->setSubMesh(val_)
  

#define cc_scene_SubModel_priority_get(self_) self_->getPriority()
#define cc_scene_SubModel_priority_set(self_, val_) self_->setPriority(val_)
  

#define cc_scene_SubModel_inputAssembler_get(self_) self_->getInputAssembler()
#define cc_scene_SubModel_inputAssembler_set(self_, val_) self_->setInputAssembler(val_)
  

#define cc_scene_SubModel_descriptorSet_get(self_) self_->getDescriptorSet()
#define cc_scene_SubModel_descriptorSet_set(self_, val_) self_->setDescriptorSet(val_)
  

#define cc_scene_SubModel_patches_get(self_) self_->getPatches()
  

#define cc_scene_SubModel_planarInstanceShader_get(self_) self_->getPlanarInstanceShader()
#define cc_scene_SubModel_planarInstanceShader_set(self_, val_) self_->setPlanarInstanceShader(val_)
  

#define cc_scene_SubModel_planarShader_get(self_) self_->getPlanarShader()
#define cc_scene_SubModel_planarShader_set(self_, val_) self_->setPlanarShader(val_)
  

#define cc_scene_ShadowsInfo_enabled_get(self_) self_->isEnabled()
#define cc_scene_ShadowsInfo_enabled_set(self_, val_) self_->setEnabled(val_)
  

#define cc_scene_ShadowsInfo_type_get(self_) self_->getType()
#define cc_scene_ShadowsInfo_type_set(self_, val_) self_->setType(val_)
  

#define cc_scene_ShadowsInfo_shadowColor_get(self_) self_->getShadowColor()
#define cc_scene_ShadowsInfo_shadowColor_set(self_, val_) self_->setShadowColor(val_)
  

#define cc_scene_ShadowsInfo_planeDirection_get(self_) self_->getPlaneDirection()
#define cc_scene_ShadowsInfo_planeDirection_set(self_, val_) self_->setPlaneDirection(val_)
  

#define cc_scene_ShadowsInfo_planeHeight_get(self_) self_->getPlaneHeight()
#define cc_scene_ShadowsInfo_planeHeight_set(self_, val_) self_->setPlaneHeight(val_)
  

#define cc_scene_ShadowsInfo_maxReceived_get(self_) self_->getMaxReceived()
#define cc_scene_ShadowsInfo_maxReceived_set(self_, val_) self_->setMaxReceived(val_)
  

#define cc_scene_ShadowsInfo_shadowMapSize_get(self_) self_->getShadowMapSize()
#define cc_scene_ShadowsInfo_shadowMapSize_set(self_, val_) self_->setShadowMapSize(val_)
  

#define cc_scene_Shadows_enabled_get(self_) self_->isEnabled()
#define cc_scene_Shadows_enabled_set(self_, val_) self_->setEnabled(val_)
  

#define cc_scene_Shadows_type_get(self_) self_->getType()
#define cc_scene_Shadows_type_set(self_, val_) self_->setType(val_)
  

#define cc_scene_Shadows_normal_get(self_) self_->getNormal()
#define cc_scene_Shadows_normal_set(self_, val_) self_->setNormal(val_)
  

#define cc_scene_Shadows_distance_get(self_) self_->getDistance()
#define cc_scene_Shadows_distance_set(self_, val_) self_->setDistance(val_)
  

#define cc_scene_Shadows_shadowColor_get(self_) self_->getShadowColor()
#define cc_scene_Shadows_shadowColor_set(self_, val_) self_->setShadowColor(val_)
  

#define cc_scene_Shadows_maxReceived_get(self_) self_->getMaxReceived()
#define cc_scene_Shadows_maxReceived_set(self_, val_) self_->setMaxReceived(val_)
  

#define cc_scene_Shadows_size_get(self_) self_->getSize()
#define cc_scene_Shadows_size_set(self_, val_) self_->setSize(val_)
  

#define cc_scene_Shadows_shadowMapDirty_get(self_) self_->isShadowMapDirty()
#define cc_scene_Shadows_shadowMapDirty_set(self_, val_) self_->setShadowMapDirty(val_)
  

#define cc_scene_Shadows_matLight_get(self_) self_->getMatLight()
  

#define cc_scene_Shadows_material_get(self_) self_->getMaterial()
  

#define cc_scene_Shadows_instancingMaterial_get(self_) self_->getInstancingMaterial()
  

#define cc_scene_AmbientInfo_skyColor_set(self_, val_) self_->setSkyColor(val_)
  

#define cc_scene_AmbientInfo_skyIllum_get(self_) self_->getSkyIllum()
#define cc_scene_AmbientInfo_skyIllum_set(self_, val_) self_->setSkyIllum(val_)
  

#define cc_scene_AmbientInfo_groundAlbedo_set(self_, val_) self_->setGroundAlbedo(val_)
  

#define cc_scene_AmbientInfo__skyColor_get(self_) self_->getSkyColorHDR()
#define cc_scene_AmbientInfo__skyColor_set(self_, val_) self_->setSkyColorHDR(val_)
  

#define cc_scene_AmbientInfo__skyIllum_get(self_) self_->getSkyIllumHDR()
#define cc_scene_AmbientInfo__skyIllum_set(self_, val_) self_->setSkyIllumHDR(val_)
  

#define cc_scene_AmbientInfo__groundAlbedo_get(self_) self_->getGroundAlbedoHDR()
#define cc_scene_AmbientInfo__groundAlbedo_set(self_, val_) self_->setGroundAlbedoHDR(val_)
  

#define cc_scene_AmbientInfo_skyColorLDR_get(self_) self_->getSkyColorLDR()
  

#define cc_scene_AmbientInfo_groundAlbedoLDR_get(self_) self_->getGroundAlbedoLDR()
  

#define cc_scene_AmbientInfo_skyIllumLDR_get(self_) self_->getSkyIllumLDR()
  

#define cc_scene_AmbientInfo_skyLightingColor_get(self_) self_->getSkyLightingColor()
#define cc_scene_AmbientInfo_skyLightingColor_set(self_, val_) self_->setSkyLightingColor(val_)
  

#define cc_scene_AmbientInfo_groundLightingColor_get(self_) self_->getGroundLightingColor()
#define cc_scene_AmbientInfo_groundLightingColor_set(self_, val_) self_->setGroundLightingColor(val_)
  

#define cc_scene_FogInfo_type_get(self_) self_->getType()
#define cc_scene_FogInfo_type_set(self_, val_) self_->setType(val_)
  

#define cc_scene_FogInfo_fogColor_get(self_) self_->getFogColor()
#define cc_scene_FogInfo_fogColor_set(self_, val_) self_->setFogColor(val_)
  

#define cc_scene_FogInfo_enabled_get(self_) self_->isEnabled()
#define cc_scene_FogInfo_enabled_set(self_, val_) self_->setEnabled(val_)
  

#define cc_scene_FogInfo_accurate_get(self_) self_->isAccurate()
#define cc_scene_FogInfo_accurate_set(self_, val_) self_->setAccurate(val_)
  

#define cc_scene_FogInfo_fogDensity_get(self_) self_->getFogDensity()
#define cc_scene_FogInfo_fogDensity_set(self_, val_) self_->setFogDensity(val_)
  

#define cc_scene_FogInfo_fogStart_get(self_) self_->getFogStart()
#define cc_scene_FogInfo_fogStart_set(self_, val_) self_->setFogStart(val_)
  

#define cc_scene_FogInfo_fogEnd_get(self_) self_->getFogEnd()
#define cc_scene_FogInfo_fogEnd_set(self_, val_) self_->setFogEnd(val_)
  

#define cc_scene_FogInfo_fogAtten_get(self_) self_->getFogAtten()
#define cc_scene_FogInfo_fogAtten_set(self_, val_) self_->setFogAtten(val_)
  

#define cc_scene_FogInfo_fogTop_get(self_) self_->getFogTop()
#define cc_scene_FogInfo_fogTop_set(self_, val_) self_->setFogTop(val_)
  

#define cc_scene_FogInfo_fogRange_get(self_) self_->getFogRange()
#define cc_scene_FogInfo_fogRange_set(self_, val_) self_->setFogRange(val_)
  

#define cc_scene_SkyboxInfo__envmap_get(self_) self_->getEnvmapForJS()
#define cc_scene_SkyboxInfo__envmap_set(self_, val_) self_->setEnvmapForJS(val_)
  

#define cc_scene_SkyboxInfo_applyDiffuseMap_get(self_) self_->isApplyDiffuseMap()
#define cc_scene_SkyboxInfo_applyDiffuseMap_set(self_, val_) self_->setApplyDiffuseMap(val_)
  

#define cc_scene_SkyboxInfo_enabled_get(self_) self_->isEnabled()
#define cc_scene_SkyboxInfo_enabled_set(self_, val_) self_->setEnabled(val_)
  

#define cc_scene_SkyboxInfo_useIBL_get(self_) self_->isUseIBL()
#define cc_scene_SkyboxInfo_useIBL_set(self_, val_) self_->setUseIBL(val_)
  

#define cc_scene_SkyboxInfo_useHDR_get(self_) self_->isUseHDR()
#define cc_scene_SkyboxInfo_useHDR_set(self_, val_) self_->setUseHDR(val_)
  

#define cc_scene_SkyboxInfo_envmap_get(self_) self_->getEnvmap()
#define cc_scene_SkyboxInfo_envmap_set(self_, val_) self_->setEnvmap(val_)
  

#define cc_scene_SkyboxInfo_diffuseMap_get(self_) self_->getDiffuseMap()
#define cc_scene_SkyboxInfo_diffuseMap_set(self_, val_) self_->setDiffuseMap(val_)
  

#define cc_scene_SkyboxInfo_reflectionMap_get(self_) self_->getReflectionMap()
#define cc_scene_SkyboxInfo_reflectionMap_set(self_, val_) self_->setReflectionMap(val_)
  

#define cc_scene_SkyboxInfo_skyboxMaterial_get(self_) self_->getSkyboxMaterial()
#define cc_scene_SkyboxInfo_skyboxMaterial_set(self_, val_) self_->setSkyboxMaterial(val_)
  

#define cc_scene_SkyboxInfo_rotationAngle_get(self_) self_->getRotationAngle()
#define cc_scene_SkyboxInfo_rotationAngle_set(self_, val_) self_->setRotationAngle(val_)
  

#define cc_scene_SkyboxInfo_envLightingType_get(self_) self_->getEnvLightingType()
#define cc_scene_SkyboxInfo_envLightingType_set(self_, val_) self_->setEnvLightingType(val_)
  

#define cc_scene_OctreeInfo_enabled_get(self_) self_->isEnabled()
#define cc_scene_OctreeInfo_enabled_set(self_, val_) self_->setEnabled(val_)
  

#define cc_scene_OctreeInfo_minPos_get(self_) self_->getMinPos()
#define cc_scene_OctreeInfo_minPos_set(self_, val_) self_->setMinPos(val_)
  

#define cc_scene_OctreeInfo_maxPos_get(self_) self_->getMaxPos()
#define cc_scene_OctreeInfo_maxPos_set(self_, val_) self_->setMaxPos(val_)
  

#define cc_scene_OctreeInfo_depth_get(self_) self_->getDepth()
#define cc_scene_OctreeInfo_depth_set(self_, val_) self_->setDepth(val_)
  

#define cc_Scene_autoReleaseAssets_get(self_) self_->isAutoReleaseAssets()
#define cc_Scene_autoReleaseAssets_set(self_, val_) self_->setAutoReleaseAssets(val_)
  

#define cc_scene_ReflectionProbe_probeType_get(self_) self_->getProbeType()
#define cc_scene_ReflectionProbe_probeType_set(self_, val_) self_->setProbeType(val_)
  

#define cc_scene_ReflectionProbe_resolution_get(self_) self_->getResolution()
#define cc_scene_ReflectionProbe_resolution_set(self_, val_) self_->setResolution(val_)
  

#define cc_scene_ReflectionProbe_clearFlag_get(self_) self_->getClearFlag()
#define cc_scene_ReflectionProbe_clearFlag_set(self_, val_) self_->setClearFlag(val_)
  

#define cc_scene_ReflectionProbe_backgroundColor_get(self_) self_->getBackgroundColor()
#define cc_scene_ReflectionProbe_backgroundColor_set(self_, val_) self_->setBackgroundColor(val_)
  

#define cc_scene_ReflectionProbe_visibility_get(self_) self_->getVisibility()
#define cc_scene_ReflectionProbe_visibility_set(self_, val_) self_->setVisibility(val_)
  

#define cc_scene_ReflectionProbe_size_get(self_) self_->getBoudingSize()
#define cc_scene_ReflectionProbe_size_set(self_, val_) self_->setBoudingSize(val_)
  

#define cc_scene_ReflectionProbe_boundingBox_get(self_) self_->getBoundingBox()
  

#define cc_scene_ReflectionProbe_previewSphere_get(self_) self_->getPreviewSphere()
#define cc_scene_ReflectionProbe_previewSphere_set(self_, val_) self_->setPreviewSphere(val_)
  

#define cc_scene_ReflectionProbe_previewPlane_get(self_) self_->getPreviewPlane()
#define cc_scene_ReflectionProbe_previewPlane_set(self_, val_) self_->setPreviewPlane(val_)
  

#define cc_scene_ReflectionProbe_bakedCubeTextures_get(self_) self_->getBakedCubeTextures()
  

#define cc_scene_ReflectionProbe_cubemap_get(self_) self_->getCubeMap()
#define cc_scene_ReflectionProbe_cubemap_set(self_, val_) self_->setCubeMap(val_)
  

#define cc_scene_ReflectionProbe_node_get(self_) self_->getNode()
  

#define cc_scene_ReflectionProbe_realtimePlanarTexture_get(self_) self_->getRealtimePlanarTexture()
  

#define cc_SceneGlobals_bakedWithStationaryMainLight_get(self_) self_->getBakedWithStationaryMainLight()
#define cc_SceneGlobals_bakedWithStationaryMainLight_set(self_, val_) self_->setBakedWithStationaryMainLight(val_)
  


static bool js_cc_hasFlag__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::TransformBit arg1 ;
    cc::TransformBit arg2 ;
    bool result;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = (bool)cc::hasFlag(arg1,arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}

static bool js_cc_hasAnyFlags__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::TransformBit arg1 ;
    cc::TransformBit arg2 ;
    bool result;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = (bool)cc::hasAnyFlags(arg1,arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}

static bool js_cc_hasAllFlags__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::TransformBit arg1 ;
    cc::TransformBit arg2 ;
    bool result;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = (bool)cc::hasAllFlags(arg1,arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}

static bool js_cc_addFlags__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::TransformBit *arg1 = 0 ;
    cc::TransformBit arg2 ;
    cc::TransformBit temp1 ;
    cc::TransformBit result;
    
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = (cc::TransformBit)cc::addFlags(*arg1,arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_removeFlags__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::TransformBit *arg1 = 0 ;
    cc::TransformBit arg2 ;
    cc::TransformBit temp1 ;
    cc::TransformBit result;
    
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = (cc::TransformBit)cc::removeFlags(*arg1,arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_toNumber__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::TransformBit arg1 ;
    std::underlying_type< cc::TransformBit >::type result;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = cc::toNumber(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

se::Class* __jsb_cc_Layers_class = nullptr;
se::Object* __jsb_cc_Layers_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Layers) 

static bool js_cc_Layers_makeMaskInclude_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    ccstd::vector< uint32_t > *arg1 = 0 ;
    ccstd::vector< uint32_t > temp1 ;
    uint32_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = cc::Layers::makeMaskInclude((ccstd::vector< uint32_t > const &)*arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Layers_makeMaskInclude_static) 

static bool js_cc_Layers_makeMaskExclude_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    ccstd::vector< uint32_t > *arg1 = 0 ;
    ccstd::vector< uint32_t > temp1 ;
    uint32_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = cc::Layers::makeMaskExclude((ccstd::vector< uint32_t > const &)*arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Layers_makeMaskExclude_static) 

bool js_register_cc_Layers(se::Object* obj) {
    auto* cls = se::Class::create("Layers", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    
    cls->defineStaticFunction("makeMaskInclude", _SE(js_cc_Layers_makeMaskInclude_static)); 
    cls->defineStaticFunction("makeMaskExclude", _SE(js_cc_Layers_makeMaskExclude_static)); 
    
    
    cls->install();
    JSBClassType::registerClass<cc::Layers>(cls);
    
    __jsb_cc_Layers_proto = cls->getProto();
    __jsb_cc_Layers_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


static bool js_cc_hasFlag__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Layers::LayerList arg1 ;
    cc::Layers::LayerList arg2 ;
    bool result;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = (bool)cc::hasFlag(arg1,arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}

static bool js_cc_hasFlag(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_cc_hasFlag__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_hasFlag__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_hasFlag) 

static bool js_cc_hasAnyFlags__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Layers::LayerList arg1 ;
    cc::Layers::LayerList arg2 ;
    bool result;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = (bool)cc::hasAnyFlags(arg1,arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}

static bool js_cc_hasAnyFlags(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_cc_hasAnyFlags__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_hasAnyFlags__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_hasAnyFlags) 

static bool js_cc_hasAllFlags__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Layers::LayerList arg1 ;
    cc::Layers::LayerList arg2 ;
    bool result;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = (bool)cc::hasAllFlags(arg1,arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}

static bool js_cc_hasAllFlags(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_cc_hasAllFlags__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_hasAllFlags__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_hasAllFlags) 

static bool js_cc_addFlags__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Layers::LayerList *arg1 = 0 ;
    cc::Layers::LayerList arg2 ;
    cc::Layers::LayerList temp1 ;
    cc::Layers::LayerList result;
    
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = (cc::Layers::LayerList)cc::addFlags(*arg1,arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_addFlags(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_cc_addFlags__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_addFlags__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_addFlags) 

static bool js_cc_removeFlags__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Layers::LayerList *arg1 = 0 ;
    cc::Layers::LayerList arg2 ;
    cc::Layers::LayerList temp1 ;
    cc::Layers::LayerList result;
    
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = (cc::Layers::LayerList)cc::removeFlags(*arg1,arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_removeFlags(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_cc_removeFlags__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_removeFlags__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_removeFlags) 

static bool js_cc_toNumber__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Layers::LayerList arg1 ;
    std::underlying_type< cc::Layers::LayerList >::type result;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = cc::toNumber(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_toNumber(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_cc_toNumber__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_toNumber__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_toNumber) 

se::Class* __jsb_cc_Node_class = nullptr;
se::Object* __jsb_cc_Node_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Node) 

se::Class* __jsb_cc_Node_UserData_class = nullptr;
se::Object* __jsb_cc_Node_UserData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Node_UserData) 

static bool js_delete_cc_Node_UserData(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Node_UserData) 

bool js_register_cc_Node_UserData(se::Object* obj) {
    auto* cls = se::Class::create({"Node", "UserData"}, obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Node_UserData));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Node::UserData>(cls);
    
    __jsb_cc_Node_UserData_proto = cls->getProto();
    __jsb_cc_Node_UserData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


static bool js_cc_Node_TRANSFORM_ON_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    uint32_t result;
    
    result = (uint32_t)cc::Node::TRANSFORM_ON;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Node_TRANSFORM_ON_get) 

static bool js_cc_Node_instantiate_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    bool arg2 ;
    cc::Node *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::Node *)cc::Node::instantiate(arg1,arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_instantiate_static) 

static bool js_cc_Node_setScene_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc::Node::setScene(arg1);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setScene_static) 

static bool js_cc_Node_resetHasChangedFlags_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    cc::Node::resetChangedFlags();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_resetHasChangedFlags_static) 

static bool js_cc_Node_clearNodeArray_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    cc::Node::clearNodeArray();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_clearNodeArray_static) 

static bool js_new_cc_Node__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::Node *result;
    result = (cc::Node *)new cc::Node();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_Node__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    ccstd::string *arg1 = 0 ;
    ccstd::string temp1 ;
    cc::Node *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = (cc::Node *)new cc::Node((ccstd::string const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_Node(se::State& s) // NOLINT(readability-identifier-naming)
{
    size_t argc = s.args().size();
    bool ret = false;
    
    if(argc == 0) {
        ret = js_new_cc_Node__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 1) {
        ret = js_new_cc_Node__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    SE_REPORT_ERROR("Illegal arguments for construction of Node");
    return false;
}
SE_BIND_CTOR(js_new_Node, __jsb_cc_Node_class, js_delete_cc_Node)

static bool js_delete_cc_Node(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Node) 

static bool js_cc_Node_onPostActivated(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->onPostActivated(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_onPostActivated) 

static bool js_cc_Node_setParent__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    bool arg3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setParent(arg2,arg3);
    
    
    return true;
}

static bool js_cc_Node_setParent__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setParent(arg2);
    
    
    return true;
}

static bool js_cc_Node_setParent(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_cc_Node_setParent__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_Node_setParent__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Node_setParent) 

static bool js_cc_Node_getScene(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Scene *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    result = (cc::Scene *)((cc::Node const *)arg1)->getScene();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_getScene) 

static bool js_cc_Node_walk__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Node::WalkCallback *arg2 = 0 ;
    cc::Node::WalkCallback temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->walk((cc::Node::WalkCallback const &)*arg2);
    
    
    return true;
}

static bool js_cc_Node_walk__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Node::WalkCallback *arg2 = 0 ;
    cc::Node::WalkCallback *arg3 = 0 ;
    cc::Node::WalkCallback temp2 ;
    cc::Node::WalkCallback temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->walk((cc::Node::WalkCallback const &)*arg2,(cc::Node::WalkCallback const &)*arg3);
    
    
    return true;
}

static bool js_cc_Node_walk(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_cc_Node_walk__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_Node_walk__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Node_walk) 

static bool js_cc_Node_destroyAllChildren(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroyAllChildren();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_destroyAllChildren) 

static bool js_cc_Node__updateSiblingIndex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    (arg1)->updateSiblingIndex();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node__updateSiblingIndex) 

static bool js_cc_Node_addChild(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addChild(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_addChild) 

static bool js_cc_Node_removeChild(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    ((cc::Node const *)arg1)->removeChild(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_removeChild) 

static bool js_cc_Node_removeFromParent(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    (arg1)->removeFromParent();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_removeFromParent) 

static bool js_cc_Node_removeAllChildren(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    (arg1)->removeAllChildren();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_removeAllChildren) 

static bool js_cc_Node_isChildOf(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (bool)((cc::Node const *)arg1)->isChildOf(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_isChildOf) 

static bool js_cc_Node_setActive(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setActive(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setActive) 

static bool js_cc_Node_setSiblingIndex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    index_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setSiblingIndex(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setSiblingIndex) 

static bool js_cc_Node_isActive(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    result = (bool)((cc::Node const *)arg1)->isActive();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_isActive) 

static bool js_cc_Node_getParent(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Node *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    result = (cc::Node *)((cc::Node const *)arg1)->getParent();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_getParent) 

static bool js_cc_Node_getChildByUuid(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    cc::Node *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::Node *)((cc::Node const *)arg1)->getChildByUuid((ccstd::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_getChildByUuid) 

static bool js_cc_Node_getChildByName(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    cc::Node *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::Node *)((cc::Node const *)arg1)->getChildByName((ccstd::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_getChildByName) 

static bool js_cc_Node_getChildByPath(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    cc::Node *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::Node *)((cc::Node const *)arg1)->getChildByPath((ccstd::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_getChildByPath) 

static bool js_cc_Node_getSiblingIndex(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    index_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    result = ((cc::Node const *)arg1)->getSiblingIndex();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_getSiblingIndex) 

static bool js_cc_Node_insertChild(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    index_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->insertChild(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_insertChild) 

static bool js_cc_Node_invalidateChildren(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::TransformBit arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->invalidateChildren(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_invalidateChildren) 

static bool js_cc_Node_translate__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::NodeSpace arg3 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->translate((cc::Vec3 const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_Node_translate__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->translate((cc::Vec3 const &)*arg2);
    
    
    return true;
}

static bool js_cc_Node_translate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_cc_Node_translate__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_Node_translate__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Node_translate) 

static bool js_cc_Node_lookAt__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->lookAt((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3);
    
    
    return true;
}

static bool js_cc_Node_lookAt__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->lookAt((cc::Vec3 const &)*arg2);
    
    
    return true;
}

static bool js_cc_Node_lookAt(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_cc_Node_lookAt__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_Node_lookAt__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Node_lookAt) 

static bool js_cc_Node_pauseSystemEvents(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->pauseSystemEvents(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_pauseSystemEvents) 

static bool js_cc_Node_resumeSystemEvents(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->resumeSystemEvents(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_resumeSystemEvents) 

static bool js_cc_Node_getPathInHierarchy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    ccstd::string result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    result = ((cc::Node const *)arg1)->getPathInHierarchy();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_getPathInHierarchy) 

static bool js_cc_Node_setPositionInternal__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    float arg3 ;
    bool arg4 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPositionInternal(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_Node_setPositionInternal__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    bool arg5 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPositionInternal(arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_Node_setPositionInternal(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_Node_setPositionInternal__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 4) {
        ok = js_cc_Node_setPositionInternal__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Node_setPositionInternal) 

static bool js_cc_Node_setPositionForJS(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPositionForJS(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setPositionForJS) 

static bool js_cc_Node_setRotationInternal(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    bool arg6 ;
    
    if(argc != 5) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRotationInternal(arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setRotationInternal) 

static bool js_cc_Node_setRotationForJS(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRotationForJS(arg2,arg3,arg4,arg5);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setRotationForJS) 

static bool js_cc_Node_setEulerAngles(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setEulerAngles((cc::Vec3 const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setEulerAngles) 

static bool js_cc_Node_setRotationFromEulerForJS(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRotationFromEulerForJS(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setRotationFromEulerForJS) 

static bool js_cc_Node_setScaleInternal__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    float arg3 ;
    bool arg4 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setScaleInternal(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_Node_setScaleInternal__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    bool arg5 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setScaleInternal(arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_Node_setScaleInternal(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_Node_setScaleInternal__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 4) {
        ok = js_cc_Node_setScaleInternal__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Node_setScaleInternal) 

static bool js_cc_Node_setScaleForJS(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setScaleForJS(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setScaleForJS) 

static bool js_cc_Node_inverseTransformPoint(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    cc::Vec3 result;
    cc::Vec3 *temp ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (arg1)->inverseTransformPoint((cc::Vec3 const &)*arg2);
    
    temp = ccnew cc::Vec3(result);
    ok &= nativevalue_to_se(temp, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_inverseTransformPoint) 

static bool js_cc_Node_setWorldPosition__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setWorldPosition((cc::Vec3 const &)*arg2);
    
    
    return true;
}

static bool js_cc_Node_setWorldPosition__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setWorldPosition(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_Node_setWorldPosition(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_cc_Node_setWorldPosition__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 3) {
        ok = js_cc_Node_setWorldPosition__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Node_setWorldPosition) 

static bool js_cc_Node_setWorldRotation__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Quaternion *arg2 = 0 ;
    cc::Quaternion temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setWorldRotation((cc::Quaternion const &)*arg2);
    
    
    return true;
}

static bool js_cc_Node_setWorldRotation__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setWorldRotation(arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_Node_setWorldRotation(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_cc_Node_setWorldRotation__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 4) {
        ok = js_cc_Node_setWorldRotation__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Node_setWorldRotation) 

static bool js_cc_Node_setWorldScale__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setWorldScale((cc::Vec3 const &)*arg2);
    
    
    return true;
}

static bool js_cc_Node_setWorldScale__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setWorldScale(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_Node_setWorldScale(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_cc_Node_setWorldScale__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 3) {
        ok = js_cc_Node_setWorldScale__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Node_setWorldScale) 

static bool js_cc_Node_setWorldRotationFromEuler(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setWorldRotationFromEuler(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setWorldRotationFromEuler) 

static bool js_cc_Node_updateWorldTransform(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    (arg1)->updateWorldTransform();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_updateWorldTransform) 

static bool js_cc_Node_setForward(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setForward((cc::Vec3 const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setForward) 

static bool js_cc_Node_isStatic(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    result = (bool)((cc::Node const *)arg1)->isStatic();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_isStatic) 

static bool js_cc_Node_setStatic(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setStatic(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setStatic) 

static bool js_cc_Node_setDirtyFlag(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setDirtyFlag(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setDirtyFlag) 

static bool js_cc_Node_getDirtyFlag(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    result = ((cc::Node const *)arg1)->getDirtyFlag();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_getDirtyFlag) 

static bool js_cc_Node_setLayer(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setLayer(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setLayer) 

static bool js_cc_Node_getLayer(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    result = ((cc::Node const *)arg1)->getLayer();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_getLayer) 

static bool js_cc_Node__setChildren(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::Node > > *arg2 = 0 ;
    ccstd::vector< cc::IntrusivePtr< cc::Node > > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->_setChildren((ccstd::vector< cc::IntrusivePtr< cc::Node > > &&)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node__setChildren) 

static bool js_cc_Node__getSharedArrayBufferObject(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    se::Object *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    result = (se::Object *)((cc::Node const *)arg1)->_getSharedArrayBufferObject();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node__getSharedArrayBufferObject) 

static bool js_cc_Node__onPreDestroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->onPreDestroy();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node__onPreDestroy) 

static bool js_cc_Node__onPreDestroyBase(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->onPreDestroyBase();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node__onPreDestroyBase) 

static bool js_cc_Node_onSiblingIndexChanged_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->onSiblingIndexChanged, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Node_onSiblingIndexChanged_set) 

static bool js_cc_Node_onSiblingIndexChanged_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Node *arg1 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->onSiblingIndexChanged, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->onSiblingIndexChanged, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Node_onSiblingIndexChanged_get) 

static bool js_cc_Node__id_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_id, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Node__id_set) 

static bool js_cc_Node__id_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Node *arg1 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_id, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_id, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Node__id_get) 

static bool js_cc_Node__parentInternal_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_parent, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Node__parentInternal_set) 

static bool js_cc_Node__parentInternal_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Node *arg1 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_parent, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_parent, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Node__parentInternal_get) 

static bool js_cc_Node__mobility_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_mobility, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Node__mobility_set) 

static bool js_cc_Node__mobility_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Node *arg1 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_mobility, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_mobility, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Node__mobility_get) 

static bool js_cc_Node_uuid_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Node *arg1 = (cc::Node *) NULL ;
    ccstd::string *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::string *) &cc_Node_uuid_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Node_uuid_get) 

static bool js_cc_Node_angle_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_Node_angle_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Node_angle_set) 

static bool js_cc_Node_angle_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Node *arg1 = (cc::Node *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_Node_angle_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Node_angle_get) 

static bool js_cc_Node_matrix_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Mat4 *arg2 = 0 ;
    cc::Mat4 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_Node_matrix_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Node_matrix_set) 

static bool js_cc_Node_hasChangedFlags_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_Node_hasChangedFlags_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Node_hasChangedFlags_set) 

static bool js_cc_Node_hasChangedFlags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Node *arg1 = (cc::Node *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    result = cc_Node_hasChangedFlags_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Node_hasChangedFlags_get) 

static bool js_cc_Node__persistNode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_Node__persistNode_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Node__persistNode_set) 

static bool js_cc_Node__persistNode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Node *arg1 = (cc::Node *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_Node__persistNode_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Node__persistNode_get) 

static bool js_cc_Node_mobility_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::MobilityMode arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_Node_mobility_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Node_mobility_set) 

static bool js_cc_Node_mobility_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::MobilityMode result;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    if (nullptr == arg1) return true;
    result = (cc::MobilityMode)cc_Node_mobility_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Node_mobility_get) 

bool js_register_cc_Node(se::Object* obj) {
    auto* cls = se::Class::create("Node", obj, __jsb_cc_CCObject_proto, _SE(js_new_Node)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("onSiblingIndexChanged", _SE(js_cc_Node_onSiblingIndexChanged_get), _SE(js_cc_Node_onSiblingIndexChanged_set)); 
    cls->defineProperty("_id", _SE(js_cc_Node__id_get), _SE(js_cc_Node__id_set)); 
    cls->defineProperty("_parentInternal", _SE(js_cc_Node__parentInternal_get), _SE(js_cc_Node__parentInternal_set)); 
    cls->defineProperty("_mobility", _SE(js_cc_Node__mobility_get), _SE(js_cc_Node__mobility_set)); 
    cls->defineProperty("uuid", _SE(js_cc_Node_uuid_get), nullptr); 
    cls->defineProperty("angle", _SE(js_cc_Node_angle_get), _SE(js_cc_Node_angle_set)); 
    cls->defineProperty("matrix", nullptr, _SE(js_cc_Node_matrix_set)); 
    cls->defineProperty("hasChangedFlags", _SE(js_cc_Node_hasChangedFlags_get), _SE(js_cc_Node_hasChangedFlags_set)); 
    cls->defineProperty("_persistNode", _SE(js_cc_Node__persistNode_get), _SE(js_cc_Node__persistNode_set)); 
    cls->defineProperty("mobility", _SE(js_cc_Node_mobility_get), _SE(js_cc_Node_mobility_set)); 
    
    cls->defineFunction("onPostActivated", _SE(js_cc_Node_onPostActivated)); 
    cls->defineFunction("setParent", _SE(js_cc_Node_setParent)); 
    cls->defineFunction("getScene", _SE(js_cc_Node_getScene)); 
    cls->defineFunction("walk", _SE(js_cc_Node_walk)); 
    cls->defineFunction("destroyAllChildren", _SE(js_cc_Node_destroyAllChildren)); 
    cls->defineFunction("_updateSiblingIndex", _SE(js_cc_Node__updateSiblingIndex)); 
    cls->defineFunction("addChild", _SE(js_cc_Node_addChild)); 
    cls->defineFunction("removeChild", _SE(js_cc_Node_removeChild)); 
    cls->defineFunction("removeFromParent", _SE(js_cc_Node_removeFromParent)); 
    cls->defineFunction("removeAllChildren", _SE(js_cc_Node_removeAllChildren)); 
    cls->defineFunction("isChildOf", _SE(js_cc_Node_isChildOf)); 
    cls->defineFunction("setActive", _SE(js_cc_Node_setActive)); 
    cls->defineFunction("setSiblingIndex", _SE(js_cc_Node_setSiblingIndex)); 
    cls->defineFunction("isActive", _SE(js_cc_Node_isActive)); 
    cls->defineFunction("getParent", _SE(js_cc_Node_getParent)); 
    cls->defineFunction("getChildByUuid", _SE(js_cc_Node_getChildByUuid)); 
    cls->defineFunction("getChildByName", _SE(js_cc_Node_getChildByName)); 
    cls->defineFunction("getChildByPath", _SE(js_cc_Node_getChildByPath)); 
    cls->defineFunction("getSiblingIndex", _SE(js_cc_Node_getSiblingIndex)); 
    cls->defineFunction("insertChild", _SE(js_cc_Node_insertChild)); 
    cls->defineFunction("invalidateChildren", _SE(js_cc_Node_invalidateChildren)); 
    cls->defineFunction("translate", _SE(js_cc_Node_translate)); 
    cls->defineFunction("lookAt", _SE(js_cc_Node_lookAt)); 
    cls->defineFunction("pauseSystemEvents", _SE(js_cc_Node_pauseSystemEvents)); 
    cls->defineFunction("resumeSystemEvents", _SE(js_cc_Node_resumeSystemEvents)); 
    cls->defineFunction("getPathInHierarchy", _SE(js_cc_Node_getPathInHierarchy)); 
    cls->defineFunction("setPositionInternal", _SE(js_cc_Node_setPositionInternal)); 
    cls->defineFunction("setPositionForJS", _SE(js_cc_Node_setPositionForJS)); 
    cls->defineFunction("setRotationInternal", _SE(js_cc_Node_setRotationInternal)); 
    cls->defineFunction("setRotationForJS", _SE(js_cc_Node_setRotationForJS)); 
    cls->defineFunction("setEulerAngles", _SE(js_cc_Node_setEulerAngles)); 
    cls->defineFunction("setRotationFromEulerForJS", _SE(js_cc_Node_setRotationFromEulerForJS)); 
    cls->defineFunction("setScaleInternal", _SE(js_cc_Node_setScaleInternal)); 
    cls->defineFunction("setScaleForJS", _SE(js_cc_Node_setScaleForJS)); 
    cls->defineFunction("inverseTransformPoint", _SE(js_cc_Node_inverseTransformPoint)); 
    cls->defineFunction("setWorldPosition", _SE(js_cc_Node_setWorldPosition)); 
    cls->defineFunction("setWorldRotation", _SE(js_cc_Node_setWorldRotation)); 
    cls->defineFunction("setWorldScale", _SE(js_cc_Node_setWorldScale)); 
    cls->defineFunction("setWorldRotationFromEuler", _SE(js_cc_Node_setWorldRotationFromEuler)); 
    cls->defineFunction("updateWorldTransform", _SE(js_cc_Node_updateWorldTransform)); 
    cls->defineFunction("setForward", _SE(js_cc_Node_setForward)); 
    cls->defineFunction("isStatic", _SE(js_cc_Node_isStatic)); 
    cls->defineFunction("setStatic", _SE(js_cc_Node_setStatic)); 
    cls->defineFunction("setDirtyFlag", _SE(js_cc_Node_setDirtyFlag)); 
    cls->defineFunction("getDirtyFlag", _SE(js_cc_Node_getDirtyFlag)); 
    cls->defineFunction("setLayer", _SE(js_cc_Node_setLayer)); 
    cls->defineFunction("getLayer", _SE(js_cc_Node_getLayer)); 
    cls->defineFunction("_setChildren", _SE(js_cc_Node__setChildren)); 
    cls->defineFunction("_getSharedArrayBufferObject", _SE(js_cc_Node__getSharedArrayBufferObject)); 
    cls->defineFunction("_onPreDestroy", _SE(js_cc_Node__onPreDestroy)); 
    cls->defineFunction("_onPreDestroyBase", _SE(js_cc_Node__onPreDestroyBase)); 
    
    cls->defineStaticProperty("TRANSFORM_ON", _SE(js_cc_Node_TRANSFORM_ON_get), nullptr); 
    
    cls->defineStaticFunction("instantiate", _SE(js_cc_Node_instantiate_static)); 
    cls->defineStaticFunction("setScene", _SE(js_cc_Node_setScene_static)); 
    cls->defineStaticFunction("resetHasChangedFlags", _SE(js_cc_Node_resetHasChangedFlags_static)); 
    cls->defineStaticFunction("clearNodeArray", _SE(js_cc_Node_clearNodeArray_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Node));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Node>(cls);
    
    __jsb_cc_Node_proto = cls->getProto();
    __jsb_cc_Node_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Scene_class = nullptr;
se::Object* __jsb_cc_Scene_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Scene) 

static bool js_new_cc_Scene__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    ccstd::string *arg1 = 0 ;
    ccstd::string temp1 ;
    cc::Scene *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = (cc::Scene *)new cc::Scene((ccstd::string const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_Scene__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::Scene *result;
    result = (cc::Scene *)new cc::Scene();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_Scene(se::State& s) // NOLINT(readability-identifier-naming)
{
    size_t argc = s.args().size();
    bool ret = false;
    
    if(argc == 1) {
        ret = js_new_cc_Scene__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 0) {
        ret = js_new_cc_Scene__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    SE_REPORT_ERROR("Illegal arguments for construction of Scene");
    return false;
}
SE_BIND_CTOR(js_new_Scene, __jsb_cc_Scene_class, js_delete_cc_Scene)

static bool js_delete_cc_Scene(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Scene) 

static bool js_cc_Scene_getRenderScene(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Scene *arg1 = (cc::Scene *) NULL ;
    cc::scene::RenderScene *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Scene>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::RenderScene *)((cc::Scene const *)arg1)->getRenderScene();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Scene_getRenderScene) 

static bool js_cc_Scene_getSceneGlobals(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Scene *arg1 = (cc::Scene *) NULL ;
    cc::SceneGlobals *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Scene>(s);
    if (nullptr == arg1) return true;
    result = (cc::SceneGlobals *)((cc::Scene const *)arg1)->getSceneGlobals();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Scene_getSceneGlobals) 

static bool js_cc_Scene_setSceneGlobals(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Scene *arg1 = (cc::Scene *) NULL ;
    cc::SceneGlobals *arg2 = (cc::SceneGlobals *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Scene>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setSceneGlobals(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Scene_setSceneGlobals) 

static bool js_cc_Scene__load(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Scene *arg1 = (cc::Scene *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Scene>(s);
    if (nullptr == arg1) return true;
    (arg1)->load();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Scene__load) 

static bool js_cc_Scene__activate__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Scene *arg1 = (cc::Scene *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Scene>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->activate(arg2);
    
    
    return true;
}

static bool js_cc_Scene__activate__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Scene *arg1 = (cc::Scene *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Scene>(s);
    if (nullptr == arg1) return true;
    (arg1)->activate();
    
    
    return true;
}

static bool js_cc_Scene__activate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_cc_Scene__activate__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 0) {
        ok = js_cc_Scene__activate__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Scene__activate) 

static bool js_cc_Scene_onBatchCreated(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Scene *arg1 = (cc::Scene *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Scene>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->onBatchCreated(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Scene_onBatchCreated) 

static bool js_cc_Scene_autoReleaseAssets_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Scene *arg1 = (cc::Scene *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Scene>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_Scene_autoReleaseAssets_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Scene_autoReleaseAssets_set) 

static bool js_cc_Scene_autoReleaseAssets_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Scene *arg1 = (cc::Scene *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::Scene>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_Scene_autoReleaseAssets_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Scene_autoReleaseAssets_get) 

bool js_register_cc_Scene(se::Object* obj) {
    auto* cls = se::Class::create("Scene", obj, __jsb_cc_Node_proto, _SE(js_new_Scene)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("autoReleaseAssets", _SE(js_cc_Scene_autoReleaseAssets_get), _SE(js_cc_Scene_autoReleaseAssets_set)); 
    
    cls->defineFunction("getRenderScene", _SE(js_cc_Scene_getRenderScene)); 
    cls->defineFunction("getSceneGlobals", _SE(js_cc_Scene_getSceneGlobals)); 
    cls->defineFunction("setSceneGlobals", _SE(js_cc_Scene_setSceneGlobals)); 
    cls->defineFunction("_load", _SE(js_cc_Scene__load)); 
    cls->defineFunction("_activate", _SE(js_cc_Scene__activate)); 
    cls->defineFunction("onBatchCreated", _SE(js_cc_Scene_onBatchCreated)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Scene));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Scene>(cls);
    
    __jsb_cc_Scene_proto = cls->getProto();
    __jsb_cc_Scene_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_SceneGlobals_class = nullptr;
se::Object* __jsb_cc_SceneGlobals_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_SceneGlobals) 

static bool js_new_cc_SceneGlobals(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::SceneGlobals *result;
    result = (cc::SceneGlobals *)new cc::SceneGlobals();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_SceneGlobals, __jsb_cc_SceneGlobals_class, js_delete_cc_SceneGlobals)

static bool js_delete_cc_SceneGlobals(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_SceneGlobals) 

static bool js_cc_SceneGlobals_activate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;
    cc::Scene *arg2 = (cc::Scene *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->activate(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneGlobals_activate) 

static bool js_cc_SceneGlobals_getAmbientInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;
    cc::scene::AmbientInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::AmbientInfo *)((cc::SceneGlobals const *)arg1)->getAmbientInfo();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneGlobals_getAmbientInfo) 

static bool js_cc_SceneGlobals_getShadowsInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;
    cc::scene::ShadowsInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::ShadowsInfo *)((cc::SceneGlobals const *)arg1)->getShadowsInfo();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneGlobals_getShadowsInfo) 

static bool js_cc_SceneGlobals_getSkyboxInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;
    cc::scene::SkyboxInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::SkyboxInfo *)((cc::SceneGlobals const *)arg1)->getSkyboxInfo();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneGlobals_getSkyboxInfo) 

static bool js_cc_SceneGlobals_getFogInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;
    cc::scene::FogInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::FogInfo *)((cc::SceneGlobals const *)arg1)->getFogInfo();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneGlobals_getFogInfo) 

static bool js_cc_SceneGlobals_getOctreeInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;
    cc::scene::OctreeInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::OctreeInfo *)((cc::SceneGlobals const *)arg1)->getOctreeInfo();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneGlobals_getOctreeInfo) 

static bool js_cc_SceneGlobals_getLightProbeInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;
    cc::gi::LightProbeInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);
    if (nullptr == arg1) return true;
    result = (cc::gi::LightProbeInfo *)((cc::SceneGlobals const *)arg1)->getLightProbeInfo();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneGlobals_getLightProbeInfo) 

static bool js_cc_SceneGlobals_setAmbientInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;
    cc::scene::AmbientInfo *arg2 = (cc::scene::AmbientInfo *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setAmbientInfo(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneGlobals_setAmbientInfo) 

static bool js_cc_SceneGlobals_setShadowsInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;
    cc::scene::ShadowsInfo *arg2 = (cc::scene::ShadowsInfo *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setShadowsInfo(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneGlobals_setShadowsInfo) 

static bool js_cc_SceneGlobals_setSkyboxInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;
    cc::scene::SkyboxInfo *arg2 = (cc::scene::SkyboxInfo *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setSkyboxInfo(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneGlobals_setSkyboxInfo) 

static bool js_cc_SceneGlobals_setFogInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;
    cc::scene::FogInfo *arg2 = (cc::scene::FogInfo *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setFogInfo(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneGlobals_setFogInfo) 

static bool js_cc_SceneGlobals_setOctreeInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;
    cc::scene::OctreeInfo *arg2 = (cc::scene::OctreeInfo *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setOctreeInfo(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneGlobals_setOctreeInfo) 

static bool js_cc_SceneGlobals_setLightProbeInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;
    cc::gi::LightProbeInfo *arg2 = (cc::gi::LightProbeInfo *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setLightProbeInfo(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneGlobals_setLightProbeInfo) 

static bool js_cc_SceneGlobals_bakedWithStationaryMainLight_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_SceneGlobals_bakedWithStationaryMainLight_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_SceneGlobals_bakedWithStationaryMainLight_set) 

static bool js_cc_SceneGlobals_bakedWithStationaryMainLight_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_SceneGlobals_bakedWithStationaryMainLight_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_SceneGlobals_bakedWithStationaryMainLight_get) 

bool js_register_cc_SceneGlobals(se::Object* obj) {
    auto* cls = se::Class::create("SceneGlobals", obj, nullptr, _SE(js_new_cc_SceneGlobals)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("bakedWithStationaryMainLight", _SE(js_cc_SceneGlobals_bakedWithStationaryMainLight_get), _SE(js_cc_SceneGlobals_bakedWithStationaryMainLight_set)); 
    
    cls->defineFunction("activate", _SE(js_cc_SceneGlobals_activate)); 
    cls->defineFunction("getAmbientInfo", _SE(js_cc_SceneGlobals_getAmbientInfo)); 
    cls->defineFunction("getShadowsInfo", _SE(js_cc_SceneGlobals_getShadowsInfo)); 
    cls->defineFunction("getSkyboxInfo", _SE(js_cc_SceneGlobals_getSkyboxInfo)); 
    cls->defineFunction("getFogInfo", _SE(js_cc_SceneGlobals_getFogInfo)); 
    cls->defineFunction("getOctreeInfo", _SE(js_cc_SceneGlobals_getOctreeInfo)); 
    cls->defineFunction("getLightProbeInfo", _SE(js_cc_SceneGlobals_getLightProbeInfo)); 
    cls->defineFunction("setAmbientInfo", _SE(js_cc_SceneGlobals_setAmbientInfo)); 
    cls->defineFunction("setShadowsInfo", _SE(js_cc_SceneGlobals_setShadowsInfo)); 
    cls->defineFunction("setSkyboxInfo", _SE(js_cc_SceneGlobals_setSkyboxInfo)); 
    cls->defineFunction("setFogInfo", _SE(js_cc_SceneGlobals_setFogInfo)); 
    cls->defineFunction("setOctreeInfo", _SE(js_cc_SceneGlobals_setOctreeInfo)); 
    cls->defineFunction("setLightProbeInfo", _SE(js_cc_SceneGlobals_setLightProbeInfo)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_SceneGlobals));
    
    
    cls->install();
    JSBClassType::registerClass<cc::SceneGlobals>(cls);
    
    __jsb_cc_SceneGlobals_proto = cls->getProto();
    __jsb_cc_SceneGlobals_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_DebugViewConfig_class = nullptr;
se::Object* __jsb_cc_DebugViewConfig_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_DebugViewConfig) 

static bool js_cc_DebugViewConfig_singleMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DebugViewConfig *arg1 = (cc::DebugViewConfig *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugViewConfig>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->singleMode, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DebugViewConfig_singleMode_set) 

static bool js_cc_DebugViewConfig_singleMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DebugViewConfig *arg1 = (cc::DebugViewConfig *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugViewConfig>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->singleMode, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DebugViewConfig_singleMode_get) 

static bool js_cc_DebugViewConfig_compositeModeBitCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DebugViewConfig *arg1 = (cc::DebugViewConfig *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugViewConfig>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->compositeModeBitCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DebugViewConfig_compositeModeBitCount_set) 

static bool js_cc_DebugViewConfig_compositeModeBitCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DebugViewConfig *arg1 = (cc::DebugViewConfig *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugViewConfig>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->compositeModeBitCount, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DebugViewConfig_compositeModeBitCount_get) 

static bool js_cc_DebugViewConfig_compositeModeValue_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DebugViewConfig *arg1 = (cc::DebugViewConfig *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugViewConfig>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->compositeModeValue, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DebugViewConfig_compositeModeValue_set) 

static bool js_cc_DebugViewConfig_compositeModeValue_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DebugViewConfig *arg1 = (cc::DebugViewConfig *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugViewConfig>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->compositeModeValue, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DebugViewConfig_compositeModeValue_get) 

static bool js_cc_DebugViewConfig_lightingWithAlbedo_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DebugViewConfig *arg1 = (cc::DebugViewConfig *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugViewConfig>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->lightingWithAlbedo);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DebugViewConfig_lightingWithAlbedo_set) 

static bool js_cc_DebugViewConfig_lightingWithAlbedo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DebugViewConfig *arg1 = (cc::DebugViewConfig *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugViewConfig>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->lightingWithAlbedo, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DebugViewConfig_lightingWithAlbedo_get) 

static bool js_cc_DebugViewConfig_csmLayerColoration_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DebugViewConfig *arg1 = (cc::DebugViewConfig *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugViewConfig>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->csmLayerColoration);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DebugViewConfig_csmLayerColoration_set) 

static bool js_cc_DebugViewConfig_csmLayerColoration_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DebugViewConfig *arg1 = (cc::DebugViewConfig *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugViewConfig>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->csmLayerColoration, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DebugViewConfig_csmLayerColoration_get) 

static bool js_new_cc_DebugViewConfig(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::DebugViewConfig *result;
    result = (cc::DebugViewConfig *)new cc::DebugViewConfig();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_DebugViewConfig, __jsb_cc_DebugViewConfig_class, js_delete_cc_DebugViewConfig)

static bool js_delete_cc_DebugViewConfig(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_DebugViewConfig) 

template<>
bool sevalue_to_native(const se::Value &from, cc::DebugViewConfig * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::DebugViewConfig*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("singleMode", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->singleMode), ctx);
    }
    
    
    json->getProperty("compositeModeBitCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->compositeModeBitCount), ctx);
    }
    
    
    json->getProperty("compositeModeValue", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->compositeModeValue), ctx);
    }
    
    
    json->getProperty("lightingWithAlbedo", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->lightingWithAlbedo), ctx);
    }
    
    
    json->getProperty("csmLayerColoration", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->csmLayerColoration), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_DebugViewConfig(se::Object* obj) {
    auto* cls = se::Class::create("DebugViewConfig", obj, nullptr, _SE(js_new_cc_DebugViewConfig)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("singleMode", _SE(js_cc_DebugViewConfig_singleMode_get), _SE(js_cc_DebugViewConfig_singleMode_set)); 
    cls->defineProperty("compositeModeBitCount", _SE(js_cc_DebugViewConfig_compositeModeBitCount_get), _SE(js_cc_DebugViewConfig_compositeModeBitCount_set)); 
    cls->defineProperty("compositeModeValue", _SE(js_cc_DebugViewConfig_compositeModeValue_get), _SE(js_cc_DebugViewConfig_compositeModeValue_set)); 
    cls->defineProperty("lightingWithAlbedo", _SE(js_cc_DebugViewConfig_lightingWithAlbedo_get), _SE(js_cc_DebugViewConfig_lightingWithAlbedo_set)); 
    cls->defineProperty("csmLayerColoration", _SE(js_cc_DebugViewConfig_csmLayerColoration_get), _SE(js_cc_DebugViewConfig_csmLayerColoration_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_DebugViewConfig));
    
    
    cls->install();
    JSBClassType::registerClass<cc::DebugViewConfig>(cls);
    
    __jsb_cc_DebugViewConfig_proto = cls->getProto();
    __jsb_cc_DebugViewConfig_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Root_class = nullptr;
se::Object* __jsb_cc_Root_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Root) 

static bool js_cc_Root_getInstance_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::Root *)cc::Root::getInstance();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_getInstance_static) 

static bool js_new_cc_Root(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::Root *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::Root *)new cc::Root(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Root, __jsb_cc_Root_class, js_delete_cc_Root)

static bool js_delete_cc_Root(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Root) 

static bool js_cc_Root__initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::gfx::Swapchain *arg2 = (cc::gfx::Swapchain *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->initialize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root__initialize) 

static bool js_cc_Root_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_destroy) 

static bool js_cc_Root_resize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    uint32_t arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->resize(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_resize) 

static bool js_cc_Root_setRenderPipeline__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::pipeline::RenderPipeline *arg2 = (cc::pipeline::RenderPipeline *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (bool)(arg1)->setRenderPipeline(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}

static bool js_cc_Root_setRenderPipeline__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Root *arg1 = (cc::Root *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->setRenderPipeline();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}

static bool js_cc_Root_setRenderPipeline(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_cc_Root_setRenderPipeline__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 0) {
        ok = js_cc_Root_setRenderPipeline__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Root_setRenderPipeline) 

static bool js_cc_Root_onGlobalPipelineStateChanged(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    (arg1)->onGlobalPipelineStateChanged();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_onGlobalPipelineStateChanged) 

static bool js_cc_Root_activeWindow(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::RenderWindow *arg2 = (cc::scene::RenderWindow *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->activeWindow(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_activeWindow) 

static bool js_cc_Root_resetCumulativeTime(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    (arg1)->resetCumulativeTime();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_resetCumulativeTime) 

static bool js_cc_Root_frameMove(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    float arg2 ;
    int32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->frameMove(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_frameMove) 

static bool js_cc_Root_createWindow(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::IRenderWindowInfo *arg2 = 0 ;
    cc::scene::IRenderWindowInfo temp2 ;
    cc::scene::RenderWindow *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::scene::RenderWindow *)(arg1)->createWindow(*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_createWindow) 

static bool js_cc_Root_destroyWindow(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::RenderWindow *arg2 = (cc::scene::RenderWindow *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->destroyWindow(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_destroyWindow) 

static bool js_cc_Root_destroyWindows(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroyWindows();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_destroyWindows) 

static bool js_cc_Root_createSystemWindow_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ISystemWindowInfo *arg1 = 0 ;
    cc::ISystemWindowInfo temp1 ;
    uint32_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = cc::Root::createSystemWindow((cc::ISystemWindowInfo const &)*arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_createSystemWindow_static) 

static bool js_cc_Root_createScene(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::IRenderSceneInfo *arg2 = 0 ;
    cc::scene::IRenderSceneInfo temp2 ;
    cc::scene::RenderScene *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::scene::RenderScene *)(arg1)->createScene((cc::scene::IRenderSceneInfo const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_createScene) 

static bool js_cc_Root_destroyScene(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::RenderScene *arg2 = (cc::scene::RenderScene *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->destroyScene(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_destroyScene) 

static bool js_cc_Root_destroyScenes(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroyScenes();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_destroyScenes) 

static bool js_cc_Root_destroyModel(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::Model *arg2 = (cc::scene::Model *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->destroyModel(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_destroyModel) 

static bool js_cc_Root_destroyLight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::Light *arg2 = (cc::scene::Light *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->destroyLight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_destroyLight) 

static bool js_cc_Root_createCamera(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::Camera *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::Camera *)((cc::Root const *)arg1)->createCamera();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_createCamera) 

static bool js_cc_Root_getBatcher2D(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::Batcher2d *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    result = (cc::Batcher2d *)((cc::Root const *)arg1)->getBatcher2D();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_getBatcher2D) 

static bool js_cc_Root_setDebugViewConfig(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::DebugViewConfig *arg2 = 0 ;
    cc::DebugViewConfig temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setDebugViewConfig((cc::DebugViewConfig const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_setDebugViewConfig) 

static bool js_cc_Root_getDebugViewConfig(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::DebugViewConfig *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    result = (cc::DebugViewConfig *) &((cc::Root const *)arg1)->getDebugViewConfig();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_getDebugViewConfig) 

static bool js_cc_Root_createRenderWindowFromSystemWindow__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Root *arg1 = (cc::Root *) NULL ;
    uint32_t arg2 ;
    cc::scene::RenderWindow *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (cc::scene::RenderWindow *)(arg1)->createRenderWindowFromSystemWindow(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_Root_createRenderWindowFromSystemWindow__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::ISystemWindow *arg2 = (cc::ISystemWindow *) NULL ;
    cc::scene::RenderWindow *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::scene::RenderWindow *)(arg1)->createRenderWindowFromSystemWindow(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_Root_createRenderWindowFromSystemWindow(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_cc_Root_createRenderWindowFromSystemWindow__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_Root_createRenderWindowFromSystemWindow__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Root_createRenderWindowFromSystemWindow) 

static bool js_cc_Root_device_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::gfx::Device *arg2 = (cc::gfx::Device *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_Root_device_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Root_device_set) 

static bool js_cc_Root_device_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::gfx::Device *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Device *)cc_Root_device_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_device_get) 

static bool js_cc_Root__device_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::gfx::Device *arg2 = (cc::gfx::Device *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_Root__device_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Root__device_set) 

static bool js_cc_Root__device_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::gfx::Device *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Device *)cc_Root__device_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root__device_get) 

static bool js_cc_Root_mainWindow_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::RenderWindow *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::RenderWindow *)cc_Root_mainWindow_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_mainWindow_get) 

static bool js_cc_Root_curWindow_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::RenderWindow *arg2 = (cc::scene::RenderWindow *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_Root_curWindow_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Root_curWindow_set) 

static bool js_cc_Root_curWindow_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::RenderWindow *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::RenderWindow *)cc_Root_curWindow_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_curWindow_get) 

static bool js_cc_Root_tempWindow_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::RenderWindow *arg2 = (cc::scene::RenderWindow *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_Root_tempWindow_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Root_tempWindow_set) 

static bool js_cc_Root_tempWindow_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::RenderWindow *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::RenderWindow *)cc_Root_tempWindow_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_tempWindow_get) 

static bool js_cc_Root_windows_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::scene::RenderWindow > > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::IntrusivePtr< cc::scene::RenderWindow > > *) &cc_Root_windows_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_windows_get) 

static bool js_cc_Root_scenes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::scene::RenderScene > > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::IntrusivePtr< cc::scene::RenderScene > > *) &cc_Root_scenes_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_scenes_get) 

static bool js_cc_Root_cumulativeTime_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_Root_cumulativeTime_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_cumulativeTime_get) 

static bool js_cc_Root_frameTime_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_Root_frameTime_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_frameTime_get) 

static bool js_cc_Root_frameCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    result = cc_Root_frameCount_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_frameCount_get) 

static bool js_cc_Root_fps_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    result = cc_Root_fps_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_fps_get) 

static bool js_cc_Root_fixedFPS_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_Root_fixedFPS_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Root_fixedFPS_set) 

static bool js_cc_Root_fixedFPS_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    result = cc_Root_fixedFPS_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_fixedFPS_get) 

static bool js_cc_Root_useDeferredPipeline_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_Root_useDeferredPipeline_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_useDeferredPipeline_get) 

static bool js_cc_Root_usesCustomPipeline_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_Root_usesCustomPipeline_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_usesCustomPipeline_get) 

static bool js_cc_Root_pipeline_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::render::PipelineRuntime *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    result = (cc::render::PipelineRuntime *)cc_Root_pipeline_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_pipeline_get) 

static bool js_cc_Root_customPipeline_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::render::Pipeline *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    result = (cc::render::Pipeline *)cc_Root_customPipeline_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_customPipeline_get) 

static bool js_cc_Root_cameraList_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    ccstd::vector< cc::scene::Camera * > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::scene::Camera * > *) &cc_Root_cameraList_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_cameraList_get) 

bool js_register_cc_Root(se::Object* obj) {
    auto* cls = se::Class::create("Root", obj, nullptr, _SE(js_new_cc_Root)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("device", _SE(js_cc_Root_device_get), _SE(js_cc_Root_device_set)); 
    cls->defineProperty("_device", _SE(js_cc_Root__device_get), _SE(js_cc_Root__device_set)); 
    cls->defineProperty("mainWindow", _SE(js_cc_Root_mainWindow_get), nullptr); 
    cls->defineProperty("curWindow", _SE(js_cc_Root_curWindow_get), _SE(js_cc_Root_curWindow_set)); 
    cls->defineProperty("tempWindow", _SE(js_cc_Root_tempWindow_get), _SE(js_cc_Root_tempWindow_set)); 
    cls->defineProperty("windows", _SE(js_cc_Root_windows_get), nullptr); 
    cls->defineProperty("scenes", _SE(js_cc_Root_scenes_get), nullptr); 
    cls->defineProperty("cumulativeTime", _SE(js_cc_Root_cumulativeTime_get), nullptr); 
    cls->defineProperty("frameTime", _SE(js_cc_Root_frameTime_get), nullptr); 
    cls->defineProperty("frameCount", _SE(js_cc_Root_frameCount_get), nullptr); 
    cls->defineProperty("fps", _SE(js_cc_Root_fps_get), nullptr); 
    cls->defineProperty("fixedFPS", _SE(js_cc_Root_fixedFPS_get), _SE(js_cc_Root_fixedFPS_set)); 
    cls->defineProperty("useDeferredPipeline", _SE(js_cc_Root_useDeferredPipeline_get), nullptr); 
    cls->defineProperty("usesCustomPipeline", _SE(js_cc_Root_usesCustomPipeline_get), nullptr); 
    cls->defineProperty("pipeline", _SE(js_cc_Root_pipeline_get), nullptr); 
    cls->defineProperty("customPipeline", _SE(js_cc_Root_customPipeline_get), nullptr); 
    cls->defineProperty("cameraList", _SE(js_cc_Root_cameraList_get), nullptr); 
    
    cls->defineFunction("_initialize", _SE(js_cc_Root__initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_Root_destroy)); 
    cls->defineFunction("resize", _SE(js_cc_Root_resize)); 
    cls->defineFunction("setRenderPipeline", _SE(js_cc_Root_setRenderPipeline)); 
    cls->defineFunction("onGlobalPipelineStateChanged", _SE(js_cc_Root_onGlobalPipelineStateChanged)); 
    cls->defineFunction("activeWindow", _SE(js_cc_Root_activeWindow)); 
    cls->defineFunction("resetCumulativeTime", _SE(js_cc_Root_resetCumulativeTime)); 
    cls->defineFunction("frameMove", _SE(js_cc_Root_frameMove)); 
    cls->defineFunction("createWindow", _SE(js_cc_Root_createWindow)); 
    cls->defineFunction("destroyWindow", _SE(js_cc_Root_destroyWindow)); 
    cls->defineFunction("destroyWindows", _SE(js_cc_Root_destroyWindows)); 
    cls->defineFunction("createScene", _SE(js_cc_Root_createScene)); 
    cls->defineFunction("destroyScene", _SE(js_cc_Root_destroyScene)); 
    cls->defineFunction("destroyScenes", _SE(js_cc_Root_destroyScenes)); 
    cls->defineFunction("destroyModel", _SE(js_cc_Root_destroyModel)); 
    cls->defineFunction("destroyLight", _SE(js_cc_Root_destroyLight)); 
    cls->defineFunction("createCamera", _SE(js_cc_Root_createCamera)); 
    cls->defineFunction("getBatcher2D", _SE(js_cc_Root_getBatcher2D)); 
    cls->defineFunction("setDebugViewConfig", _SE(js_cc_Root_setDebugViewConfig)); 
    cls->defineFunction("getDebugViewConfig", _SE(js_cc_Root_getDebugViewConfig)); 
    cls->defineFunction("createRenderWindowFromSystemWindow", _SE(js_cc_Root_createRenderWindowFromSystemWindow)); 
    
    
    cls->defineStaticFunction("getInstance", _SE(js_cc_Root_getInstance_static)); 
    cls->defineStaticFunction("createSystemWindow", _SE(js_cc_Root_createSystemWindow_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Root));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Root>(cls);
    
    __jsb_cc_Root_proto = cls->getProto();
    __jsb_cc_Root_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_IMacroPatch_class = nullptr;
se::Object* __jsb_cc_scene_IMacroPatch_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_IMacroPatch) 

static bool js_cc_scene_IMacroPatch_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::IMacroPatch *arg1 = (cc::scene::IMacroPatch *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IMacroPatch>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IMacroPatch_name_set) 

static bool js_cc_scene_IMacroPatch_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::IMacroPatch *arg1 = (cc::scene::IMacroPatch *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IMacroPatch>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IMacroPatch_name_get) 

static bool js_cc_scene_IMacroPatch_value_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::IMacroPatch *arg1 = (cc::scene::IMacroPatch *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IMacroPatch>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->value, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IMacroPatch_value_set) 

static bool js_cc_scene_IMacroPatch_value_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::IMacroPatch *arg1 = (cc::scene::IMacroPatch *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IMacroPatch>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->value, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->value, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IMacroPatch_value_get) 

static bool js_new_cc_scene_IMacroPatch(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::IMacroPatch *result;
    result = (cc::scene::IMacroPatch *)new cc::scene::IMacroPatch();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_IMacroPatch, __jsb_cc_scene_IMacroPatch_class, js_delete_cc_scene_IMacroPatch)

static bool js_delete_cc_scene_IMacroPatch(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_IMacroPatch) 

template<>
bool sevalue_to_native(const se::Value &from, cc::scene::IMacroPatch * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::scene::IMacroPatch*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("value", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->value), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_scene_IMacroPatch(se::Object* obj) {
    auto* cls = se::Class::create("IMacroPatch", obj, nullptr, _SE(js_new_cc_scene_IMacroPatch)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("name", _SE(js_cc_scene_IMacroPatch_name_get), _SE(js_cc_scene_IMacroPatch_name_set)); 
    cls->defineProperty("value", _SE(js_cc_scene_IMacroPatch_value_get), _SE(js_cc_scene_IMacroPatch_value_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_IMacroPatch));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::IMacroPatch>(cls);
    
    __jsb_cc_scene_IMacroPatch_proto = cls->getProto();
    __jsb_cc_scene_IMacroPatch_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_Light_class = nullptr;
se::Object* __jsb_cc_scene_Light_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_Light) 

static bool js_new_cc_scene_Light(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::Light *result;
    result = (cc::scene::Light *)new cc::scene::Light();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_Light, __jsb_cc_scene_Light_class, js_delete_cc_scene_Light)

static bool js_delete_cc_scene_Light(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_Light) 

static bool js_cc_scene_Light_attachToScene(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    cc::scene::RenderScene *arg2 = (cc::scene::RenderScene *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->attachToScene(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Light_attachToScene) 

static bool js_cc_scene_Light_detachFromScene(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    if (nullptr == arg1) return true;
    (arg1)->detachFromScene();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Light_detachFromScene) 

static bool js_cc_scene_Light_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Light_destroy) 

static bool js_cc_scene_Light_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    if (nullptr == arg1) return true;
    (arg1)->initialize();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Light_initialize) 

static bool js_cc_scene_Light_update(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    if (nullptr == arg1) return true;
    (arg1)->update();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Light_update) 

static bool js_cc_scene_Light_getColorTemperatureRGB(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    cc::Vec3 *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    if (nullptr == arg1) return true;
    result = (cc::Vec3 *) &((cc::scene::Light const *)arg1)->getColorTemperatureRGB();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Light_getColorTemperatureRGB) 

static bool js_cc_scene_Light_setColorTemperatureRGB(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setColorTemperatureRGB((cc::Vec3 const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Light_setColorTemperatureRGB) 

static bool js_cc_scene_Light_nt2lm_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float arg1 ;
    float result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (float)cc::scene::Light::nt2lm(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Light_nt2lm_static) 

static bool js_cc_scene_Light_colorTemperatureToRGB_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float arg1 ;
    cc::Vec3 result;
    cc::Vec3 *temp ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = cc::scene::Light::colorTemperatureToRGB(arg1);
    
    temp = ccnew cc::Vec3(result);
    ok &= nativevalue_to_se(temp, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Light_colorTemperatureToRGB_static) 

static bool js_cc_scene_Light_baked_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Light_baked_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Light_baked_set) 

static bool js_cc_scene_Light_baked_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_Light_baked_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Light_baked_get) 

static bool js_cc_scene_Light_color_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_Light_color_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Light_color_set) 

static bool js_cc_scene_Light_color_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    if (nullptr == arg1) return true;
    result = (cc::Vec3 *) &cc_scene_Light_color_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Light_color_get) 

static bool js_cc_scene_Light_useColorTemperature_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Light_useColorTemperature_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Light_useColorTemperature_set) 

static bool js_cc_scene_Light_useColorTemperature_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_Light_useColorTemperature_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Light_useColorTemperature_get) 

static bool js_cc_scene_Light_colorTemperature_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Light_colorTemperature_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Light_colorTemperature_set) 

static bool js_cc_scene_Light_colorTemperature_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_Light_colorTemperature_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Light_colorTemperature_get) 

static bool js_cc_scene_Light_node_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Light_node_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Light_node_set) 

static bool js_cc_scene_Light_node_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    cc::Node *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    if (nullptr == arg1) return true;
    result = (cc::Node *)cc_scene_Light_node_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Light_node_get) 

static bool js_cc_scene_Light_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    cc::scene::LightType arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_scene_Light_type_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Light_type_set) 

static bool js_cc_scene_Light_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    cc::scene::LightType result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::LightType)cc_scene_Light_type_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Light_type_get) 

static bool js_cc_scene_Light_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_Light_name_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Light_name_set) 

static bool js_cc_scene_Light_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    ccstd::string *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::string *) &cc_scene_Light_name_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Light_name_get) 

static bool js_cc_scene_Light_scene_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    cc::scene::RenderScene *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::RenderScene *)cc_scene_Light_scene_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Light_scene_get) 

static bool js_cc_scene_Light_visibility_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_scene_Light_visibility_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Light_visibility_set) 

static bool js_cc_scene_Light_visibility_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_Light_visibility_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Light_visibility_get) 

bool js_register_cc_scene_Light(se::Object* obj) {
    auto* cls = se::Class::create("Light", obj, nullptr, _SE(js_new_cc_scene_Light)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("baked", _SE(js_cc_scene_Light_baked_get), _SE(js_cc_scene_Light_baked_set)); 
    cls->defineProperty("color", _SE(js_cc_scene_Light_color_get), _SE(js_cc_scene_Light_color_set)); 
    cls->defineProperty("useColorTemperature", _SE(js_cc_scene_Light_useColorTemperature_get), _SE(js_cc_scene_Light_useColorTemperature_set)); 
    cls->defineProperty("colorTemperature", _SE(js_cc_scene_Light_colorTemperature_get), _SE(js_cc_scene_Light_colorTemperature_set)); 
    cls->defineProperty("node", _SE(js_cc_scene_Light_node_get), _SE(js_cc_scene_Light_node_set)); 
    cls->defineProperty("type", _SE(js_cc_scene_Light_type_get), _SE(js_cc_scene_Light_type_set)); 
    cls->defineProperty("name", _SE(js_cc_scene_Light_name_get), _SE(js_cc_scene_Light_name_set)); 
    cls->defineProperty("scene", _SE(js_cc_scene_Light_scene_get), nullptr); 
    cls->defineProperty("visibility", _SE(js_cc_scene_Light_visibility_get), _SE(js_cc_scene_Light_visibility_set)); 
    
    cls->defineFunction("attachToScene", _SE(js_cc_scene_Light_attachToScene)); 
    cls->defineFunction("detachFromScene", _SE(js_cc_scene_Light_detachFromScene)); 
    cls->defineFunction("destroy", _SE(js_cc_scene_Light_destroy)); 
    cls->defineFunction("initialize", _SE(js_cc_scene_Light_initialize)); 
    cls->defineFunction("update", _SE(js_cc_scene_Light_update)); 
    cls->defineFunction("getColorTemperatureRGB", _SE(js_cc_scene_Light_getColorTemperatureRGB)); 
    cls->defineFunction("setColorTemperatureRGB", _SE(js_cc_scene_Light_setColorTemperatureRGB)); 
    
    
    cls->defineStaticFunction("nt2lm", _SE(js_cc_scene_Light_nt2lm_static)); 
    cls->defineStaticFunction("colorTemperatureToRGB", _SE(js_cc_scene_Light_colorTemperatureToRGB_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_Light));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::Light>(cls);
    
    __jsb_cc_scene_Light_proto = cls->getProto();
    __jsb_cc_scene_Light_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_LODData_class = nullptr;
se::Object* __jsb_cc_scene_LODData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_LODData) 

static bool js_cc_scene_LODData_addModel(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::LODData *arg1 = (cc::scene::LODData *) NULL ;
    cc::scene::Model *arg2 = (cc::scene::Model *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::LODData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addModel(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_LODData_addModel) 

static bool js_cc_scene_LODData_clearModels(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::LODData *arg1 = (cc::scene::LODData *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::LODData>(s);
    if (nullptr == arg1) return true;
    (arg1)->clearModels();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_LODData_clearModels) 

static bool js_cc_scene_LODData_eraseModel(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::LODData *arg1 = (cc::scene::LODData *) NULL ;
    cc::scene::Model *arg2 = (cc::scene::Model *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::LODData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->eraseModel(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_LODData_eraseModel) 

static bool js_cc_scene_LODData_screenUsagePercentage_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::LODData *arg1 = (cc::scene::LODData *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::LODData>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_LODData_screenUsagePercentage_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_LODData_screenUsagePercentage_set) 

static bool js_cc_scene_LODData_screenUsagePercentage_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::LODData *arg1 = (cc::scene::LODData *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::LODData>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_LODData_screenUsagePercentage_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_LODData_screenUsagePercentage_get) 

static bool js_cc_scene_LODData_models_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::LODData *arg1 = (cc::scene::LODData *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::scene::Model > > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::LODData>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::IntrusivePtr< cc::scene::Model > > *) &cc_scene_LODData_models_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_LODData_models_get) 

static bool js_new_cc_scene_LODData(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::LODData *result;
    result = (cc::scene::LODData *)new cc::scene::LODData();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_LODData, __jsb_cc_scene_LODData_class, js_delete_cc_scene_LODData)

static bool js_delete_cc_scene_LODData(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_LODData) 

bool js_register_cc_scene_LODData(se::Object* obj) {
    auto* cls = se::Class::create("LODData", obj, nullptr, _SE(js_new_cc_scene_LODData)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("screenUsagePercentage", _SE(js_cc_scene_LODData_screenUsagePercentage_get), _SE(js_cc_scene_LODData_screenUsagePercentage_set)); 
    cls->defineProperty("models", _SE(js_cc_scene_LODData_models_get), nullptr); 
    
    cls->defineFunction("addModel", _SE(js_cc_scene_LODData_addModel)); 
    cls->defineFunction("clearModels", _SE(js_cc_scene_LODData_clearModels)); 
    cls->defineFunction("eraseModel", _SE(js_cc_scene_LODData_eraseModel)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_LODData));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::LODData>(cls);
    
    __jsb_cc_scene_LODData_proto = cls->getProto();
    __jsb_cc_scene_LODData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_LODGroup_class = nullptr;
se::Object* __jsb_cc_scene_LODGroup_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_LODGroup) 

static bool js_new_cc_scene_LODGroup(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::LODGroup *result;
    result = (cc::scene::LODGroup *)new cc::scene::LODGroup();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_LODGroup, __jsb_cc_scene_LODGroup_class, js_delete_cc_scene_LODGroup)

static bool js_delete_cc_scene_LODGroup(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_LODGroup) 

static bool js_cc_scene_LODGroup_attachToScene(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::LODGroup *arg1 = (cc::scene::LODGroup *) NULL ;
    cc::scene::RenderScene *arg2 = (cc::scene::RenderScene *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::LODGroup>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->attachToScene(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_LODGroup_attachToScene) 

static bool js_cc_scene_LODGroup_detachFromScene(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::LODGroup *arg1 = (cc::scene::LODGroup *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::LODGroup>(s);
    if (nullptr == arg1) return true;
    (arg1)->detachFromScene();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_LODGroup_detachFromScene) 

static bool js_cc_scene_LODGroup_getVisibleLODLevel(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::LODGroup *arg1 = (cc::scene::LODGroup *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    int8_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::LODGroup>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = ((cc::scene::LODGroup const *)arg1)->getVisibleLODLevel((cc::scene::Camera const *)arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_LODGroup_getVisibleLODLevel) 

static bool js_cc_scene_LODGroup_getLockedLODLevels(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::LODGroup *arg1 = (cc::scene::LODGroup *) NULL ;
    ccstd::vector< uint8_t > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::LODGroup>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< uint8_t > *) &((cc::scene::LODGroup const *)arg1)->getLockedLODLevels();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_LODGroup_getLockedLODLevels) 

static bool js_cc_scene_LODGroup_lockLODLevels(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::LODGroup *arg1 = (cc::scene::LODGroup *) NULL ;
    ccstd::vector< int > *arg2 = 0 ;
    ccstd::vector< int > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::LODGroup>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->lockLODLevels(*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_LODGroup_lockLODLevels) 

static bool js_cc_scene_LODGroup_isLockLevelChanged(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::LODGroup *arg1 = (cc::scene::LODGroup *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::LODGroup>(s);
    if (nullptr == arg1) return true;
    result = (bool)((cc::scene::LODGroup const *)arg1)->isLockLevelChanged();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_LODGroup_isLockLevelChanged) 

static bool js_cc_scene_LODGroup_resetLockChangeFlag(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::LODGroup *arg1 = (cc::scene::LODGroup *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::LODGroup>(s);
    if (nullptr == arg1) return true;
    (arg1)->resetLockChangeFlag();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_LODGroup_resetLockChangeFlag) 

static bool js_cc_scene_LODGroup_clearLODs(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::LODGroup *arg1 = (cc::scene::LODGroup *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::LODGroup>(s);
    if (nullptr == arg1) return true;
    (arg1)->clearLODs();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_LODGroup_clearLODs) 

static bool js_cc_scene_LODGroup_insertLOD(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::LODGroup *arg1 = (cc::scene::LODGroup *) NULL ;
    uint8_t arg2 ;
    cc::scene::LODData *arg3 = (cc::scene::LODData *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::LODGroup>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->insertLOD(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_LODGroup_insertLOD) 

static bool js_cc_scene_LODGroup_updateLOD(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::LODGroup *arg1 = (cc::scene::LODGroup *) NULL ;
    uint8_t arg2 ;
    cc::scene::LODData *arg3 = (cc::scene::LODData *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::LODGroup>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->updateLOD(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_LODGroup_updateLOD) 

static bool js_cc_scene_LODGroup_eraseLOD(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::LODGroup *arg1 = (cc::scene::LODGroup *) NULL ;
    uint8_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::LODGroup>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->eraseLOD(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_LODGroup_eraseLOD) 

static bool js_cc_scene_LODGroup_lodCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::LODGroup *arg1 = (cc::scene::LODGroup *) NULL ;
    uint8_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::LODGroup>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_LODGroup_lodCount_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_LODGroup_lodCount_get) 

static bool js_cc_scene_LODGroup_enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::LODGroup *arg1 = (cc::scene::LODGroup *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::LODGroup>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_LODGroup_enabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_LODGroup_enabled_set) 

static bool js_cc_scene_LODGroup_enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::LODGroup *arg1 = (cc::scene::LODGroup *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::LODGroup>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_LODGroup_enabled_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_LODGroup_enabled_get) 

static bool js_cc_scene_LODGroup_localBoundaryCenter_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::LODGroup *arg1 = (cc::scene::LODGroup *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::LODGroup>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_LODGroup_localBoundaryCenter_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_LODGroup_localBoundaryCenter_set) 

static bool js_cc_scene_LODGroup_localBoundaryCenter_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::LODGroup *arg1 = (cc::scene::LODGroup *) NULL ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::LODGroup>(s);
    if (nullptr == arg1) return true;
    result = (cc::Vec3 *) &cc_scene_LODGroup_localBoundaryCenter_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_LODGroup_localBoundaryCenter_get) 

static bool js_cc_scene_LODGroup_objectSize_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::LODGroup *arg1 = (cc::scene::LODGroup *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::LODGroup>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_LODGroup_objectSize_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_LODGroup_objectSize_set) 

static bool js_cc_scene_LODGroup_objectSize_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::LODGroup *arg1 = (cc::scene::LODGroup *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::LODGroup>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_LODGroup_objectSize_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_LODGroup_objectSize_get) 

static bool js_cc_scene_LODGroup_node_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::LODGroup *arg1 = (cc::scene::LODGroup *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::LODGroup>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_LODGroup_node_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_LODGroup_node_set) 

static bool js_cc_scene_LODGroup_node_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::LODGroup *arg1 = (cc::scene::LODGroup *) NULL ;
    cc::Node *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::LODGroup>(s);
    if (nullptr == arg1) return true;
    result = (cc::Node *)cc_scene_LODGroup_node_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_LODGroup_node_get) 

static bool js_cc_scene_LODGroup_lodDataArray_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::LODGroup *arg1 = (cc::scene::LODGroup *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::scene::LODData > > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::LODGroup>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::IntrusivePtr< cc::scene::LODData > > *) &cc_scene_LODGroup_lodDataArray_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_LODGroup_lodDataArray_get) 

static bool js_cc_scene_LODGroup_scene_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::LODGroup *arg1 = (cc::scene::LODGroup *) NULL ;
    cc::scene::RenderScene *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::LODGroup>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::RenderScene *)cc_scene_LODGroup_scene_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_LODGroup_scene_get) 

bool js_register_cc_scene_LODGroup(se::Object* obj) {
    auto* cls = se::Class::create("LODGroup", obj, nullptr, _SE(js_new_cc_scene_LODGroup)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("lodCount", _SE(js_cc_scene_LODGroup_lodCount_get), nullptr); 
    cls->defineProperty("enabled", _SE(js_cc_scene_LODGroup_enabled_get), _SE(js_cc_scene_LODGroup_enabled_set)); 
    cls->defineProperty("localBoundaryCenter", _SE(js_cc_scene_LODGroup_localBoundaryCenter_get), _SE(js_cc_scene_LODGroup_localBoundaryCenter_set)); 
    cls->defineProperty("objectSize", _SE(js_cc_scene_LODGroup_objectSize_get), _SE(js_cc_scene_LODGroup_objectSize_set)); 
    cls->defineProperty("node", _SE(js_cc_scene_LODGroup_node_get), _SE(js_cc_scene_LODGroup_node_set)); 
    cls->defineProperty("lodDataArray", _SE(js_cc_scene_LODGroup_lodDataArray_get), nullptr); 
    cls->defineProperty("scene", _SE(js_cc_scene_LODGroup_scene_get), nullptr); 
    
    cls->defineFunction("attachToScene", _SE(js_cc_scene_LODGroup_attachToScene)); 
    cls->defineFunction("detachFromScene", _SE(js_cc_scene_LODGroup_detachFromScene)); 
    cls->defineFunction("getVisibleLODLevel", _SE(js_cc_scene_LODGroup_getVisibleLODLevel)); 
    cls->defineFunction("getLockedLODLevels", _SE(js_cc_scene_LODGroup_getLockedLODLevels)); 
    cls->defineFunction("lockLODLevels", _SE(js_cc_scene_LODGroup_lockLODLevels)); 
    cls->defineFunction("isLockLevelChanged", _SE(js_cc_scene_LODGroup_isLockLevelChanged)); 
    cls->defineFunction("resetLockChangeFlag", _SE(js_cc_scene_LODGroup_resetLockChangeFlag)); 
    cls->defineFunction("clearLODs", _SE(js_cc_scene_LODGroup_clearLODs)); 
    cls->defineFunction("insertLOD", _SE(js_cc_scene_LODGroup_insertLOD)); 
    cls->defineFunction("updateLOD", _SE(js_cc_scene_LODGroup_updateLOD)); 
    cls->defineFunction("eraseLOD", _SE(js_cc_scene_LODGroup_eraseLOD)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_LODGroup));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::LODGroup>(cls);
    
    __jsb_cc_scene_LODGroup_proto = cls->getProto();
    __jsb_cc_scene_LODGroup_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_Fog_class = nullptr;
se::Object* __jsb_cc_scene_Fog_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_Fog) 

static bool js_new_cc_scene_Fog(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::Fog *result;
    result = (cc::scene::Fog *)new cc::scene::Fog();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_Fog, __jsb_cc_scene_Fog_class, js_delete_cc_scene_Fog)

static bool js_delete_cc_scene_Fog(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_Fog) 

static bool js_cc_scene_Fog_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    cc::scene::FogInfo *arg2 = 0 ;
    cc::scene::FogInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::scene::FogInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Fog_initialize) 

static bool js_cc_scene_Fog_activate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    if (nullptr == arg1) return true;
    (arg1)->activate();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Fog_activate) 

static bool js_cc_scene_Fog_enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Fog_enabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Fog_enabled_set) 

static bool js_cc_scene_Fog_enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_Fog_enabled_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Fog_enabled_get) 

static bool js_cc_scene_Fog_accurate_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Fog_accurate_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Fog_accurate_set) 

static bool js_cc_scene_Fog_accurate_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_Fog_accurate_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Fog_accurate_get) 

static bool js_cc_scene_Fog_fogColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    cc::Color *arg2 = 0 ;
    cc::Color temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_Fog_fogColor_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Fog_fogColor_set) 

static bool js_cc_scene_Fog_fogColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    cc::Color *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    if (nullptr == arg1) return true;
    result = (cc::Color *) &cc_scene_Fog_fogColor_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Fog_fogColor_get) 

static bool js_cc_scene_Fog_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    cc::scene::FogType arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_scene_Fog_type_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Fog_type_set) 

static bool js_cc_scene_Fog_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    cc::scene::FogType result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::FogType)cc_scene_Fog_type_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Fog_type_get) 

static bool js_cc_scene_Fog_fogDensity_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Fog_fogDensity_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Fog_fogDensity_set) 

static bool js_cc_scene_Fog_fogDensity_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_Fog_fogDensity_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Fog_fogDensity_get) 

static bool js_cc_scene_Fog_fogStart_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Fog_fogStart_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Fog_fogStart_set) 

static bool js_cc_scene_Fog_fogStart_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_Fog_fogStart_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Fog_fogStart_get) 

static bool js_cc_scene_Fog_fogEnd_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Fog_fogEnd_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Fog_fogEnd_set) 

static bool js_cc_scene_Fog_fogEnd_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_Fog_fogEnd_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Fog_fogEnd_get) 

static bool js_cc_scene_Fog_fogAtten_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Fog_fogAtten_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Fog_fogAtten_set) 

static bool js_cc_scene_Fog_fogAtten_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_Fog_fogAtten_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Fog_fogAtten_get) 

static bool js_cc_scene_Fog_fogTop_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Fog_fogTop_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Fog_fogTop_set) 

static bool js_cc_scene_Fog_fogTop_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_Fog_fogTop_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Fog_fogTop_get) 

static bool js_cc_scene_Fog_fogRange_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Fog_fogRange_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Fog_fogRange_set) 

static bool js_cc_scene_Fog_fogRange_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_Fog_fogRange_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Fog_fogRange_get) 

static bool js_cc_scene_Fog_colorArray_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    cc::Vec4 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    if (nullptr == arg1) return true;
    result = (cc::Vec4 *) &cc_scene_Fog_colorArray_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Fog_colorArray_get) 

bool js_register_cc_scene_Fog(se::Object* obj) {
    auto* cls = se::Class::create("Fog", obj, nullptr, _SE(js_new_cc_scene_Fog)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("enabled", _SE(js_cc_scene_Fog_enabled_get), _SE(js_cc_scene_Fog_enabled_set)); 
    cls->defineProperty("accurate", _SE(js_cc_scene_Fog_accurate_get), _SE(js_cc_scene_Fog_accurate_set)); 
    cls->defineProperty("fogColor", _SE(js_cc_scene_Fog_fogColor_get), _SE(js_cc_scene_Fog_fogColor_set)); 
    cls->defineProperty("type", _SE(js_cc_scene_Fog_type_get), _SE(js_cc_scene_Fog_type_set)); 
    cls->defineProperty("fogDensity", _SE(js_cc_scene_Fog_fogDensity_get), _SE(js_cc_scene_Fog_fogDensity_set)); 
    cls->defineProperty("fogStart", _SE(js_cc_scene_Fog_fogStart_get), _SE(js_cc_scene_Fog_fogStart_set)); 
    cls->defineProperty("fogEnd", _SE(js_cc_scene_Fog_fogEnd_get), _SE(js_cc_scene_Fog_fogEnd_set)); 
    cls->defineProperty("fogAtten", _SE(js_cc_scene_Fog_fogAtten_get), _SE(js_cc_scene_Fog_fogAtten_set)); 
    cls->defineProperty("fogTop", _SE(js_cc_scene_Fog_fogTop_get), _SE(js_cc_scene_Fog_fogTop_set)); 
    cls->defineProperty("fogRange", _SE(js_cc_scene_Fog_fogRange_get), _SE(js_cc_scene_Fog_fogRange_set)); 
    cls->defineProperty("colorArray", _SE(js_cc_scene_Fog_colorArray_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_scene_Fog_initialize)); 
    cls->defineFunction("activate", _SE(js_cc_scene_Fog_activate)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_Fog));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::Fog>(cls);
    
    __jsb_cc_scene_Fog_proto = cls->getProto();
    __jsb_cc_scene_Fog_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_FogInfo_class = nullptr;
se::Object* __jsb_cc_scene_FogInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_FogInfo) 

static bool js_new_cc_scene_FogInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::FogInfo *result;
    result = (cc::scene::FogInfo *)new cc::scene::FogInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_FogInfo, __jsb_cc_scene_FogInfo_class, js_delete_cc_scene_FogInfo)

static bool js_delete_cc_scene_FogInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_FogInfo) 

static bool js_cc_scene_FogInfo_activate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    cc::scene::Fog *arg2 = (cc::scene::Fog *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->activate(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_FogInfo_activate) 

static bool js_cc_scene_FogInfo__type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_type, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo__type_set) 

static bool js_cc_scene_FogInfo__type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_type, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_type, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo__type_get) 

static bool js_cc_scene_FogInfo__fogColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_fogColor, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo__fogColor_set) 

static bool js_cc_scene_FogInfo__fogColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_fogColor, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_fogColor, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo__fogColor_get) 

static bool js_cc_scene_FogInfo__enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_isEnabled);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo__enabled_set) 

static bool js_cc_scene_FogInfo__enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_isEnabled, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo__enabled_get) 

static bool js_cc_scene_FogInfo__fogDensity_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_fogDensity, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo__fogDensity_set) 

static bool js_cc_scene_FogInfo__fogDensity_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_fogDensity, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo__fogDensity_get) 

static bool js_cc_scene_FogInfo__fogStart_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_fogStart, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo__fogStart_set) 

static bool js_cc_scene_FogInfo__fogStart_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_fogStart, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo__fogStart_get) 

static bool js_cc_scene_FogInfo__fogEnd_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_fogEnd, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo__fogEnd_set) 

static bool js_cc_scene_FogInfo__fogEnd_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_fogEnd, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo__fogEnd_get) 

static bool js_cc_scene_FogInfo__fogAtten_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_fogAtten, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo__fogAtten_set) 

static bool js_cc_scene_FogInfo__fogAtten_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_fogAtten, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo__fogAtten_get) 

static bool js_cc_scene_FogInfo__fogTop_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_fogTop, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo__fogTop_set) 

static bool js_cc_scene_FogInfo__fogTop_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_fogTop, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo__fogTop_get) 

static bool js_cc_scene_FogInfo__fogRange_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_fogRange, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo__fogRange_set) 

static bool js_cc_scene_FogInfo__fogRange_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_fogRange, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo__fogRange_get) 

static bool js_cc_scene_FogInfo__accurate_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_accurate);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo__accurate_set) 

static bool js_cc_scene_FogInfo__accurate_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_accurate, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo__accurate_get) 

static bool js_cc_scene_FogInfo__resource_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_resource, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo__resource_set) 

static bool js_cc_scene_FogInfo__resource_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_resource, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_resource, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo__resource_get) 

static bool js_cc_scene_FogInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    cc::scene::FogType arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_scene_FogInfo_type_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo_type_set) 

static bool js_cc_scene_FogInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    cc::scene::FogType result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::FogType)cc_scene_FogInfo_type_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo_type_get) 

static bool js_cc_scene_FogInfo_fogColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    cc::Color *arg2 = 0 ;
    cc::Color temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_FogInfo_fogColor_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo_fogColor_set) 

static bool js_cc_scene_FogInfo_fogColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    cc::Color *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::Color *) &cc_scene_FogInfo_fogColor_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo_fogColor_get) 

static bool js_cc_scene_FogInfo_enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_FogInfo_enabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo_enabled_set) 

static bool js_cc_scene_FogInfo_enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_FogInfo_enabled_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo_enabled_get) 

static bool js_cc_scene_FogInfo_accurate_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_FogInfo_accurate_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo_accurate_set) 

static bool js_cc_scene_FogInfo_accurate_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_FogInfo_accurate_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo_accurate_get) 

static bool js_cc_scene_FogInfo_fogDensity_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_FogInfo_fogDensity_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo_fogDensity_set) 

static bool js_cc_scene_FogInfo_fogDensity_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_FogInfo_fogDensity_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo_fogDensity_get) 

static bool js_cc_scene_FogInfo_fogStart_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_FogInfo_fogStart_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo_fogStart_set) 

static bool js_cc_scene_FogInfo_fogStart_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_FogInfo_fogStart_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo_fogStart_get) 

static bool js_cc_scene_FogInfo_fogEnd_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_FogInfo_fogEnd_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo_fogEnd_set) 

static bool js_cc_scene_FogInfo_fogEnd_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_FogInfo_fogEnd_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo_fogEnd_get) 

static bool js_cc_scene_FogInfo_fogAtten_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_FogInfo_fogAtten_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo_fogAtten_set) 

static bool js_cc_scene_FogInfo_fogAtten_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_FogInfo_fogAtten_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo_fogAtten_get) 

static bool js_cc_scene_FogInfo_fogTop_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_FogInfo_fogTop_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo_fogTop_set) 

static bool js_cc_scene_FogInfo_fogTop_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_FogInfo_fogTop_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo_fogTop_get) 

static bool js_cc_scene_FogInfo_fogRange_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_FogInfo_fogRange_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo_fogRange_set) 

static bool js_cc_scene_FogInfo_fogRange_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_FogInfo_fogRange_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo_fogRange_get) 

bool js_register_cc_scene_FogInfo(se::Object* obj) {
    auto* cls = se::Class::create("FogInfo", obj, nullptr, _SE(js_new_cc_scene_FogInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("_type", _SE(js_cc_scene_FogInfo__type_get), _SE(js_cc_scene_FogInfo__type_set)); 
    cls->defineProperty("_fogColor", _SE(js_cc_scene_FogInfo__fogColor_get), _SE(js_cc_scene_FogInfo__fogColor_set)); 
    cls->defineProperty("_enabled", _SE(js_cc_scene_FogInfo__enabled_get), _SE(js_cc_scene_FogInfo__enabled_set)); 
    cls->defineProperty("_fogDensity", _SE(js_cc_scene_FogInfo__fogDensity_get), _SE(js_cc_scene_FogInfo__fogDensity_set)); 
    cls->defineProperty("_fogStart", _SE(js_cc_scene_FogInfo__fogStart_get), _SE(js_cc_scene_FogInfo__fogStart_set)); 
    cls->defineProperty("_fogEnd", _SE(js_cc_scene_FogInfo__fogEnd_get), _SE(js_cc_scene_FogInfo__fogEnd_set)); 
    cls->defineProperty("_fogAtten", _SE(js_cc_scene_FogInfo__fogAtten_get), _SE(js_cc_scene_FogInfo__fogAtten_set)); 
    cls->defineProperty("_fogTop", _SE(js_cc_scene_FogInfo__fogTop_get), _SE(js_cc_scene_FogInfo__fogTop_set)); 
    cls->defineProperty("_fogRange", _SE(js_cc_scene_FogInfo__fogRange_get), _SE(js_cc_scene_FogInfo__fogRange_set)); 
    cls->defineProperty("_accurate", _SE(js_cc_scene_FogInfo__accurate_get), _SE(js_cc_scene_FogInfo__accurate_set)); 
    cls->defineProperty("_resource", _SE(js_cc_scene_FogInfo__resource_get), _SE(js_cc_scene_FogInfo__resource_set)); 
    cls->defineProperty("type", _SE(js_cc_scene_FogInfo_type_get), _SE(js_cc_scene_FogInfo_type_set)); 
    cls->defineProperty("fogColor", _SE(js_cc_scene_FogInfo_fogColor_get), _SE(js_cc_scene_FogInfo_fogColor_set)); 
    cls->defineProperty("enabled", _SE(js_cc_scene_FogInfo_enabled_get), _SE(js_cc_scene_FogInfo_enabled_set)); 
    cls->defineProperty("accurate", _SE(js_cc_scene_FogInfo_accurate_get), _SE(js_cc_scene_FogInfo_accurate_set)); 
    cls->defineProperty("fogDensity", _SE(js_cc_scene_FogInfo_fogDensity_get), _SE(js_cc_scene_FogInfo_fogDensity_set)); 
    cls->defineProperty("fogStart", _SE(js_cc_scene_FogInfo_fogStart_get), _SE(js_cc_scene_FogInfo_fogStart_set)); 
    cls->defineProperty("fogEnd", _SE(js_cc_scene_FogInfo_fogEnd_get), _SE(js_cc_scene_FogInfo_fogEnd_set)); 
    cls->defineProperty("fogAtten", _SE(js_cc_scene_FogInfo_fogAtten_get), _SE(js_cc_scene_FogInfo_fogAtten_set)); 
    cls->defineProperty("fogTop", _SE(js_cc_scene_FogInfo_fogTop_get), _SE(js_cc_scene_FogInfo_fogTop_set)); 
    cls->defineProperty("fogRange", _SE(js_cc_scene_FogInfo_fogRange_get), _SE(js_cc_scene_FogInfo_fogRange_set)); 
    
    cls->defineFunction("activate", _SE(js_cc_scene_FogInfo_activate)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_FogInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::FogInfo>(cls);
    
    __jsb_cc_scene_FogInfo_proto = cls->getProto();
    __jsb_cc_scene_FogInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_ShadowsInfo_class = nullptr;
se::Object* __jsb_cc_scene_ShadowsInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_ShadowsInfo) 

static bool js_new_cc_scene_ShadowsInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::ShadowsInfo *result;
    result = (cc::scene::ShadowsInfo *)new cc::scene::ShadowsInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_ShadowsInfo, __jsb_cc_scene_ShadowsInfo_class, js_delete_cc_scene_ShadowsInfo)

static bool js_delete_cc_scene_ShadowsInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_ShadowsInfo) 

static bool js_cc_scene_ShadowsInfo_setPlaneFromNode(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setPlaneFromNode((cc::Node const *)arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ShadowsInfo_setPlaneFromNode) 

static bool js_cc_scene_ShadowsInfo_activate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    cc::scene::Shadows *arg2 = (cc::scene::Shadows *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->activate(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ShadowsInfo_activate) 

static bool js_cc_scene_ShadowsInfo__enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_enabled);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo__enabled_set) 

static bool js_cc_scene_ShadowsInfo__enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_enabled, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo__enabled_get) 

static bool js_cc_scene_ShadowsInfo__type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_type, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo__type_set) 

static bool js_cc_scene_ShadowsInfo__type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_type, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_type, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo__type_get) 

static bool js_cc_scene_ShadowsInfo__normal_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_normal, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo__normal_set) 

static bool js_cc_scene_ShadowsInfo__normal_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_normal, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_normal, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo__normal_get) 

static bool js_cc_scene_ShadowsInfo__distance_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_distance, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo__distance_set) 

static bool js_cc_scene_ShadowsInfo__distance_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_distance, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo__distance_get) 

static bool js_cc_scene_ShadowsInfo__shadowColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_shadowColor, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo__shadowColor_set) 

static bool js_cc_scene_ShadowsInfo__shadowColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_shadowColor, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_shadowColor, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo__shadowColor_get) 

static bool js_cc_scene_ShadowsInfo__maxReceived_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_maxReceived, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo__maxReceived_set) 

static bool js_cc_scene_ShadowsInfo__maxReceived_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_maxReceived, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo__maxReceived_get) 

static bool js_cc_scene_ShadowsInfo__size_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_size, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo__size_set) 

static bool js_cc_scene_ShadowsInfo__size_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_size, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_size, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo__size_get) 

static bool js_cc_scene_ShadowsInfo__resource_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_resource, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo__resource_set) 

static bool js_cc_scene_ShadowsInfo__resource_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_resource, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_resource, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo__resource_get) 

static bool js_cc_scene_ShadowsInfo_enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_ShadowsInfo_enabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo_enabled_set) 

static bool js_cc_scene_ShadowsInfo_enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_ShadowsInfo_enabled_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo_enabled_get) 

static bool js_cc_scene_ShadowsInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    cc::scene::ShadowType arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_scene_ShadowsInfo_type_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo_type_set) 

static bool js_cc_scene_ShadowsInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    cc::scene::ShadowType result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::ShadowType)cc_scene_ShadowsInfo_type_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo_type_get) 

static bool js_cc_scene_ShadowsInfo_shadowColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    cc::Color *arg2 = 0 ;
    cc::Color temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_ShadowsInfo_shadowColor_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo_shadowColor_set) 

static bool js_cc_scene_ShadowsInfo_shadowColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    cc::Color *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::Color *) &cc_scene_ShadowsInfo_shadowColor_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo_shadowColor_get) 

static bool js_cc_scene_ShadowsInfo_planeDirection_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_ShadowsInfo_planeDirection_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo_planeDirection_set) 

static bool js_cc_scene_ShadowsInfo_planeDirection_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::Vec3 *) &cc_scene_ShadowsInfo_planeDirection_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo_planeDirection_get) 

static bool js_cc_scene_ShadowsInfo_planeHeight_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_ShadowsInfo_planeHeight_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo_planeHeight_set) 

static bool js_cc_scene_ShadowsInfo_planeHeight_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_ShadowsInfo_planeHeight_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo_planeHeight_get) 

static bool js_cc_scene_ShadowsInfo_maxReceived_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_scene_ShadowsInfo_maxReceived_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo_maxReceived_set) 

static bool js_cc_scene_ShadowsInfo_maxReceived_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_ShadowsInfo_maxReceived_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo_maxReceived_get) 

static bool js_cc_scene_ShadowsInfo_shadowMapSize_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_ShadowsInfo_shadowMapSize_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo_shadowMapSize_set) 

static bool js_cc_scene_ShadowsInfo_shadowMapSize_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_ShadowsInfo_shadowMapSize_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo_shadowMapSize_get) 

bool js_register_cc_scene_ShadowsInfo(se::Object* obj) {
    auto* cls = se::Class::create("ShadowsInfo", obj, nullptr, _SE(js_new_cc_scene_ShadowsInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("_enabled", _SE(js_cc_scene_ShadowsInfo__enabled_get), _SE(js_cc_scene_ShadowsInfo__enabled_set)); 
    cls->defineProperty("_type", _SE(js_cc_scene_ShadowsInfo__type_get), _SE(js_cc_scene_ShadowsInfo__type_set)); 
    cls->defineProperty("_normal", _SE(js_cc_scene_ShadowsInfo__normal_get), _SE(js_cc_scene_ShadowsInfo__normal_set)); 
    cls->defineProperty("_distance", _SE(js_cc_scene_ShadowsInfo__distance_get), _SE(js_cc_scene_ShadowsInfo__distance_set)); 
    cls->defineProperty("_shadowColor", _SE(js_cc_scene_ShadowsInfo__shadowColor_get), _SE(js_cc_scene_ShadowsInfo__shadowColor_set)); 
    cls->defineProperty("_maxReceived", _SE(js_cc_scene_ShadowsInfo__maxReceived_get), _SE(js_cc_scene_ShadowsInfo__maxReceived_set)); 
    cls->defineProperty("_size", _SE(js_cc_scene_ShadowsInfo__size_get), _SE(js_cc_scene_ShadowsInfo__size_set)); 
    cls->defineProperty("_resource", _SE(js_cc_scene_ShadowsInfo__resource_get), _SE(js_cc_scene_ShadowsInfo__resource_set)); 
    cls->defineProperty("enabled", _SE(js_cc_scene_ShadowsInfo_enabled_get), _SE(js_cc_scene_ShadowsInfo_enabled_set)); 
    cls->defineProperty("type", _SE(js_cc_scene_ShadowsInfo_type_get), _SE(js_cc_scene_ShadowsInfo_type_set)); 
    cls->defineProperty("shadowColor", _SE(js_cc_scene_ShadowsInfo_shadowColor_get), _SE(js_cc_scene_ShadowsInfo_shadowColor_set)); 
    cls->defineProperty("planeDirection", _SE(js_cc_scene_ShadowsInfo_planeDirection_get), _SE(js_cc_scene_ShadowsInfo_planeDirection_set)); 
    cls->defineProperty("planeHeight", _SE(js_cc_scene_ShadowsInfo_planeHeight_get), _SE(js_cc_scene_ShadowsInfo_planeHeight_set)); 
    cls->defineProperty("maxReceived", _SE(js_cc_scene_ShadowsInfo_maxReceived_get), _SE(js_cc_scene_ShadowsInfo_maxReceived_set)); 
    cls->defineProperty("shadowMapSize", _SE(js_cc_scene_ShadowsInfo_shadowMapSize_get), _SE(js_cc_scene_ShadowsInfo_shadowMapSize_set)); 
    
    cls->defineFunction("setPlaneFromNode", _SE(js_cc_scene_ShadowsInfo_setPlaneFromNode)); 
    cls->defineFunction("activate", _SE(js_cc_scene_ShadowsInfo_activate)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_ShadowsInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::ShadowsInfo>(cls);
    
    __jsb_cc_scene_ShadowsInfo_proto = cls->getProto();
    __jsb_cc_scene_ShadowsInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_Shadows_class = nullptr;
se::Object* __jsb_cc_scene_Shadows_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_Shadows) 

static bool js_cc_scene_Shadows_MAX_FAR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    float result;
    
    result = (float)(float)cc::scene::Shadows::MAX_FAR;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Shadows_MAX_FAR_get) 

static bool js_cc_scene_Shadows_COEFFICIENT_OF_EXPANSION_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    float result;
    
    result = (float)(float)cc::scene::Shadows::COEFFICIENT_OF_EXPANSION;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Shadows_COEFFICIENT_OF_EXPANSION_get) 

static bool js_new_cc_scene_Shadows(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::Shadows *result;
    result = (cc::scene::Shadows *)new cc::scene::Shadows();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_Shadows, __jsb_cc_scene_Shadows_class, js_delete_cc_scene_Shadows)

static bool js_delete_cc_scene_Shadows(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_Shadows) 

static bool js_cc_scene_Shadows_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    cc::scene::ShadowsInfo *arg2 = 0 ;
    cc::scene::ShadowsInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::scene::ShadowsInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Shadows_initialize) 

static bool js_cc_scene_Shadows_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Shadows_destroy) 

static bool js_cc_scene_Shadows_getPlanarShader(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    ccstd::vector< cc::scene::IMacroPatch > *arg2 = 0 ;
    ccstd::vector< cc::scene::IMacroPatch > temp2 ;
    cc::gfx::Shader *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::Shader *)(arg1)->getPlanarShader((ccstd::vector< cc::scene::IMacroPatch > const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Shadows_getPlanarShader) 

static bool js_cc_scene_Shadows_getPlanarInstanceShader(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    ccstd::vector< cc::scene::IMacroPatch > *arg2 = 0 ;
    ccstd::vector< cc::scene::IMacroPatch > temp2 ;
    cc::gfx::Shader *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::Shader *)(arg1)->getPlanarInstanceShader((ccstd::vector< cc::scene::IMacroPatch > const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Shadows_getPlanarInstanceShader) 

static bool js_cc_scene_Shadows_activate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    if (nullptr == arg1) return true;
    (arg1)->activate();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Shadows_activate) 

static bool js_cc_scene_Shadows_getShadowColor4f(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    ccstd::array< float,4 > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::array< float,4 > *) &((cc::scene::Shadows const *)arg1)->getShadowColor4f();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Shadows_getShadowColor4f) 

static bool js_cc_scene_Shadows_setShadowMapSize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setShadowMapSize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Shadows_setShadowMapSize) 

static bool js_cc_scene_Shadows_getShadowMapSize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    if (nullptr == arg1) return true;
    result = (float)((cc::scene::Shadows const *)arg1)->getShadowMapSize();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Shadows_getShadowMapSize) 

static bool js_cc_scene_Shadows_enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Shadows_enabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Shadows_enabled_set) 

static bool js_cc_scene_Shadows_enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_Shadows_enabled_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Shadows_enabled_get) 

static bool js_cc_scene_Shadows_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    cc::scene::ShadowType arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_scene_Shadows_type_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Shadows_type_set) 

static bool js_cc_scene_Shadows_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    cc::scene::ShadowType result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::ShadowType)cc_scene_Shadows_type_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Shadows_type_get) 

static bool js_cc_scene_Shadows_normal_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_Shadows_normal_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Shadows_normal_set) 

static bool js_cc_scene_Shadows_normal_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    if (nullptr == arg1) return true;
    result = (cc::Vec3 *) &cc_scene_Shadows_normal_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Shadows_normal_get) 

static bool js_cc_scene_Shadows_distance_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Shadows_distance_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Shadows_distance_set) 

static bool js_cc_scene_Shadows_distance_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_Shadows_distance_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Shadows_distance_get) 

static bool js_cc_scene_Shadows_shadowColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    cc::Color *arg2 = 0 ;
    cc::Color temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_Shadows_shadowColor_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Shadows_shadowColor_set) 

static bool js_cc_scene_Shadows_shadowColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    cc::Color *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    if (nullptr == arg1) return true;
    result = (cc::Color *) &cc_scene_Shadows_shadowColor_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Shadows_shadowColor_get) 

static bool js_cc_scene_Shadows_maxReceived_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_scene_Shadows_maxReceived_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Shadows_maxReceived_set) 

static bool js_cc_scene_Shadows_maxReceived_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_Shadows_maxReceived_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Shadows_maxReceived_get) 

static bool js_cc_scene_Shadows_size_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_Shadows_size_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Shadows_size_set) 

static bool js_cc_scene_Shadows_size_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    cc::Vec2 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    if (nullptr == arg1) return true;
    result = (cc::Vec2 *) &cc_scene_Shadows_size_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Shadows_size_get) 

static bool js_cc_scene_Shadows_shadowMapDirty_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Shadows_shadowMapDirty_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Shadows_shadowMapDirty_set) 

static bool js_cc_scene_Shadows_shadowMapDirty_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_Shadows_shadowMapDirty_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Shadows_shadowMapDirty_get) 

static bool js_cc_scene_Shadows_matLight_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    cc::Mat4 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    if (nullptr == arg1) return true;
    result = (cc::Mat4 *) &cc_scene_Shadows_matLight_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Shadows_matLight_get) 

static bool js_cc_scene_Shadows_material_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    cc::Material *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    if (nullptr == arg1) return true;
    result = (cc::Material *)cc_scene_Shadows_material_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Shadows_material_get) 

static bool js_cc_scene_Shadows_instancingMaterial_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    cc::Material *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    if (nullptr == arg1) return true;
    result = (cc::Material *)cc_scene_Shadows_instancingMaterial_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Shadows_instancingMaterial_get) 

bool js_register_cc_scene_Shadows(se::Object* obj) {
    auto* cls = se::Class::create("Shadows", obj, nullptr, _SE(js_new_cc_scene_Shadows)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("enabled", _SE(js_cc_scene_Shadows_enabled_get), _SE(js_cc_scene_Shadows_enabled_set)); 
    cls->defineProperty("type", _SE(js_cc_scene_Shadows_type_get), _SE(js_cc_scene_Shadows_type_set)); 
    cls->defineProperty("normal", _SE(js_cc_scene_Shadows_normal_get), _SE(js_cc_scene_Shadows_normal_set)); 
    cls->defineProperty("distance", _SE(js_cc_scene_Shadows_distance_get), _SE(js_cc_scene_Shadows_distance_set)); 
    cls->defineProperty("shadowColor", _SE(js_cc_scene_Shadows_shadowColor_get), _SE(js_cc_scene_Shadows_shadowColor_set)); 
    cls->defineProperty("maxReceived", _SE(js_cc_scene_Shadows_maxReceived_get), _SE(js_cc_scene_Shadows_maxReceived_set)); 
    cls->defineProperty("size", _SE(js_cc_scene_Shadows_size_get), _SE(js_cc_scene_Shadows_size_set)); 
    cls->defineProperty("shadowMapDirty", _SE(js_cc_scene_Shadows_shadowMapDirty_get), _SE(js_cc_scene_Shadows_shadowMapDirty_set)); 
    cls->defineProperty("matLight", _SE(js_cc_scene_Shadows_matLight_get), nullptr); 
    cls->defineProperty("material", _SE(js_cc_scene_Shadows_material_get), nullptr); 
    cls->defineProperty("instancingMaterial", _SE(js_cc_scene_Shadows_instancingMaterial_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_scene_Shadows_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_scene_Shadows_destroy)); 
    cls->defineFunction("getPlanarShader", _SE(js_cc_scene_Shadows_getPlanarShader)); 
    cls->defineFunction("getPlanarInstanceShader", _SE(js_cc_scene_Shadows_getPlanarInstanceShader)); 
    cls->defineFunction("activate", _SE(js_cc_scene_Shadows_activate)); 
    cls->defineFunction("getShadowColor4f", _SE(js_cc_scene_Shadows_getShadowColor4f)); 
    cls->defineFunction("setShadowMapSize", _SE(js_cc_scene_Shadows_setShadowMapSize)); 
    cls->defineFunction("getShadowMapSize", _SE(js_cc_scene_Shadows_getShadowMapSize)); 
    
    cls->defineStaticProperty("MAX_FAR", _SE(js_cc_scene_Shadows_MAX_FAR_get), nullptr); 
    cls->defineStaticProperty("COEFFICIENT_OF_EXPANSION", _SE(js_cc_scene_Shadows_COEFFICIENT_OF_EXPANSION_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_Shadows));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::Shadows>(cls);
    
    __jsb_cc_scene_Shadows_proto = cls->getProto();
    __jsb_cc_scene_Shadows_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_SkyboxInfo_class = nullptr;
se::Object* __jsb_cc_scene_SkyboxInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_SkyboxInfo) 

static bool js_new_cc_scene_SkyboxInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::SkyboxInfo *result;
    result = (cc::scene::SkyboxInfo *)new cc::scene::SkyboxInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_SkyboxInfo, __jsb_cc_scene_SkyboxInfo_class, js_delete_cc_scene_SkyboxInfo)

static bool js_delete_cc_scene_SkyboxInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_SkyboxInfo) 

static bool js_cc_scene_SkyboxInfo_activate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    cc::scene::Skybox *arg2 = (cc::scene::Skybox *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->activate(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SkyboxInfo_activate) 

static bool js_cc_scene_SkyboxInfo__envmapHDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_envmapHDR, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo__envmapHDR_set) 

static bool js_cc_scene_SkyboxInfo__envmapHDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_envmapHDR, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_envmapHDR, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo__envmapHDR_get) 

static bool js_cc_scene_SkyboxInfo__envmapLDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_envmapLDR, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo__envmapLDR_set) 

static bool js_cc_scene_SkyboxInfo__envmapLDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_envmapLDR, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_envmapLDR, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo__envmapLDR_get) 

static bool js_cc_scene_SkyboxInfo__diffuseMapHDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_diffuseMapHDR, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo__diffuseMapHDR_set) 

static bool js_cc_scene_SkyboxInfo__diffuseMapHDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_diffuseMapHDR, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_diffuseMapHDR, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo__diffuseMapHDR_get) 

static bool js_cc_scene_SkyboxInfo__diffuseMapLDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_diffuseMapLDR, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo__diffuseMapLDR_set) 

static bool js_cc_scene_SkyboxInfo__diffuseMapLDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_diffuseMapLDR, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_diffuseMapLDR, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo__diffuseMapLDR_get) 

static bool js_cc_scene_SkyboxInfo__reflectionHDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_reflectionHDR, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo__reflectionHDR_set) 

static bool js_cc_scene_SkyboxInfo__reflectionHDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_reflectionHDR, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_reflectionHDR, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo__reflectionHDR_get) 

static bool js_cc_scene_SkyboxInfo__reflectionLDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_reflectionLDR, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo__reflectionLDR_set) 

static bool js_cc_scene_SkyboxInfo__reflectionLDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_reflectionLDR, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_reflectionLDR, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo__reflectionLDR_get) 

static bool js_cc_scene_SkyboxInfo__enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_enabled);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo__enabled_set) 

static bool js_cc_scene_SkyboxInfo__enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_enabled, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo__enabled_get) 

static bool js_cc_scene_SkyboxInfo__useHDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_useHDR);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo__useHDR_set) 

static bool js_cc_scene_SkyboxInfo__useHDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_useHDR, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo__useHDR_get) 

static bool js_cc_scene_SkyboxInfo__envLightingType_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_envLightingType, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo__envLightingType_set) 

static bool js_cc_scene_SkyboxInfo__envLightingType_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_envLightingType, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_envLightingType, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo__envLightingType_get) 

static bool js_cc_scene_SkyboxInfo__editableMaterial_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_editableMaterial, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo__editableMaterial_set) 

static bool js_cc_scene_SkyboxInfo__editableMaterial_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_editableMaterial, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_editableMaterial, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo__editableMaterial_get) 

static bool js_cc_scene_SkyboxInfo__rotationAngle_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_rotationAngle, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo__rotationAngle_set) 

static bool js_cc_scene_SkyboxInfo__rotationAngle_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_rotationAngle, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo__rotationAngle_get) 

static bool js_cc_scene_SkyboxInfo__resource_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_resource, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo__resource_set) 

static bool js_cc_scene_SkyboxInfo__resource_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_resource, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_resource, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo__resource_get) 

static bool js_cc_scene_SkyboxInfo__envmap_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    cc::TextureCube *arg2 = (cc::TextureCube *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SkyboxInfo__envmap_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo__envmap_set) 

static bool js_cc_scene_SkyboxInfo__envmap_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    cc::TextureCube *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::TextureCube *)cc_scene_SkyboxInfo__envmap_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo__envmap_get) 

static bool js_cc_scene_SkyboxInfo_applyDiffuseMap_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SkyboxInfo_applyDiffuseMap_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo_applyDiffuseMap_set) 

static bool js_cc_scene_SkyboxInfo_applyDiffuseMap_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_SkyboxInfo_applyDiffuseMap_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo_applyDiffuseMap_get) 

static bool js_cc_scene_SkyboxInfo_enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SkyboxInfo_enabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo_enabled_set) 

static bool js_cc_scene_SkyboxInfo_enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_SkyboxInfo_enabled_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo_enabled_get) 

static bool js_cc_scene_SkyboxInfo_useIBL_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SkyboxInfo_useIBL_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo_useIBL_set) 

static bool js_cc_scene_SkyboxInfo_useIBL_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_SkyboxInfo_useIBL_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo_useIBL_get) 

static bool js_cc_scene_SkyboxInfo_useHDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SkyboxInfo_useHDR_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo_useHDR_set) 

static bool js_cc_scene_SkyboxInfo_useHDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_SkyboxInfo_useHDR_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo_useHDR_get) 

static bool js_cc_scene_SkyboxInfo_envmap_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    cc::TextureCube *arg2 = (cc::TextureCube *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SkyboxInfo_envmap_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo_envmap_set) 

static bool js_cc_scene_SkyboxInfo_envmap_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    cc::TextureCube *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::TextureCube *)cc_scene_SkyboxInfo_envmap_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo_envmap_get) 

static bool js_cc_scene_SkyboxInfo_diffuseMap_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    cc::TextureCube *arg2 = (cc::TextureCube *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SkyboxInfo_diffuseMap_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo_diffuseMap_set) 

static bool js_cc_scene_SkyboxInfo_diffuseMap_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    cc::TextureCube *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::TextureCube *)cc_scene_SkyboxInfo_diffuseMap_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo_diffuseMap_get) 

static bool js_cc_scene_SkyboxInfo_reflectionMap_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    cc::TextureCube *arg2 = (cc::TextureCube *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SkyboxInfo_reflectionMap_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo_reflectionMap_set) 

static bool js_cc_scene_SkyboxInfo_reflectionMap_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    cc::TextureCube *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::TextureCube *)cc_scene_SkyboxInfo_reflectionMap_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo_reflectionMap_get) 

static bool js_cc_scene_SkyboxInfo_skyboxMaterial_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    cc::Material *arg2 = (cc::Material *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SkyboxInfo_skyboxMaterial_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo_skyboxMaterial_set) 

static bool js_cc_scene_SkyboxInfo_skyboxMaterial_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    cc::Material *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::Material *)cc_scene_SkyboxInfo_skyboxMaterial_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo_skyboxMaterial_get) 

static bool js_cc_scene_SkyboxInfo_rotationAngle_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SkyboxInfo_rotationAngle_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo_rotationAngle_set) 

static bool js_cc_scene_SkyboxInfo_rotationAngle_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_SkyboxInfo_rotationAngle_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo_rotationAngle_get) 

static bool js_cc_scene_SkyboxInfo_envLightingType_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    cc::scene::EnvironmentLightingType arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_scene_SkyboxInfo_envLightingType_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo_envLightingType_set) 

static bool js_cc_scene_SkyboxInfo_envLightingType_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    cc::scene::EnvironmentLightingType result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::EnvironmentLightingType)cc_scene_SkyboxInfo_envLightingType_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo_envLightingType_get) 

bool js_register_cc_scene_SkyboxInfo(se::Object* obj) {
    auto* cls = se::Class::create("SkyboxInfo", obj, nullptr, _SE(js_new_cc_scene_SkyboxInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("_envmapHDR", _SE(js_cc_scene_SkyboxInfo__envmapHDR_get), _SE(js_cc_scene_SkyboxInfo__envmapHDR_set)); 
    cls->defineProperty("_envmapLDR", _SE(js_cc_scene_SkyboxInfo__envmapLDR_get), _SE(js_cc_scene_SkyboxInfo__envmapLDR_set)); 
    cls->defineProperty("_diffuseMapHDR", _SE(js_cc_scene_SkyboxInfo__diffuseMapHDR_get), _SE(js_cc_scene_SkyboxInfo__diffuseMapHDR_set)); 
    cls->defineProperty("_diffuseMapLDR", _SE(js_cc_scene_SkyboxInfo__diffuseMapLDR_get), _SE(js_cc_scene_SkyboxInfo__diffuseMapLDR_set)); 
    cls->defineProperty("_reflectionHDR", _SE(js_cc_scene_SkyboxInfo__reflectionHDR_get), _SE(js_cc_scene_SkyboxInfo__reflectionHDR_set)); 
    cls->defineProperty("_reflectionLDR", _SE(js_cc_scene_SkyboxInfo__reflectionLDR_get), _SE(js_cc_scene_SkyboxInfo__reflectionLDR_set)); 
    cls->defineProperty("_enabled", _SE(js_cc_scene_SkyboxInfo__enabled_get), _SE(js_cc_scene_SkyboxInfo__enabled_set)); 
    cls->defineProperty("_useHDR", _SE(js_cc_scene_SkyboxInfo__useHDR_get), _SE(js_cc_scene_SkyboxInfo__useHDR_set)); 
    cls->defineProperty("_envLightingType", _SE(js_cc_scene_SkyboxInfo__envLightingType_get), _SE(js_cc_scene_SkyboxInfo__envLightingType_set)); 
    cls->defineProperty("_editableMaterial", _SE(js_cc_scene_SkyboxInfo__editableMaterial_get), _SE(js_cc_scene_SkyboxInfo__editableMaterial_set)); 
    cls->defineProperty("_rotationAngle", _SE(js_cc_scene_SkyboxInfo__rotationAngle_get), _SE(js_cc_scene_SkyboxInfo__rotationAngle_set)); 
    cls->defineProperty("_resource", _SE(js_cc_scene_SkyboxInfo__resource_get), _SE(js_cc_scene_SkyboxInfo__resource_set)); 
    cls->defineProperty("_envmap", _SE(js_cc_scene_SkyboxInfo__envmap_get), _SE(js_cc_scene_SkyboxInfo__envmap_set)); 
    cls->defineProperty("applyDiffuseMap", _SE(js_cc_scene_SkyboxInfo_applyDiffuseMap_get), _SE(js_cc_scene_SkyboxInfo_applyDiffuseMap_set)); 
    cls->defineProperty("enabled", _SE(js_cc_scene_SkyboxInfo_enabled_get), _SE(js_cc_scene_SkyboxInfo_enabled_set)); 
    cls->defineProperty("useIBL", _SE(js_cc_scene_SkyboxInfo_useIBL_get), _SE(js_cc_scene_SkyboxInfo_useIBL_set)); 
    cls->defineProperty("useHDR", _SE(js_cc_scene_SkyboxInfo_useHDR_get), _SE(js_cc_scene_SkyboxInfo_useHDR_set)); 
    cls->defineProperty("envmap", _SE(js_cc_scene_SkyboxInfo_envmap_get), _SE(js_cc_scene_SkyboxInfo_envmap_set)); 
    cls->defineProperty("diffuseMap", _SE(js_cc_scene_SkyboxInfo_diffuseMap_get), _SE(js_cc_scene_SkyboxInfo_diffuseMap_set)); 
    cls->defineProperty("reflectionMap", _SE(js_cc_scene_SkyboxInfo_reflectionMap_get), _SE(js_cc_scene_SkyboxInfo_reflectionMap_set)); 
    cls->defineProperty("skyboxMaterial", _SE(js_cc_scene_SkyboxInfo_skyboxMaterial_get), _SE(js_cc_scene_SkyboxInfo_skyboxMaterial_set)); 
    cls->defineProperty("rotationAngle", _SE(js_cc_scene_SkyboxInfo_rotationAngle_get), _SE(js_cc_scene_SkyboxInfo_rotationAngle_set)); 
    cls->defineProperty("envLightingType", _SE(js_cc_scene_SkyboxInfo_envLightingType_get), _SE(js_cc_scene_SkyboxInfo_envLightingType_set)); 
    
    cls->defineFunction("activate", _SE(js_cc_scene_SkyboxInfo_activate)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_SkyboxInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::SkyboxInfo>(cls);
    
    __jsb_cc_scene_SkyboxInfo_proto = cls->getProto();
    __jsb_cc_scene_SkyboxInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_Skybox_class = nullptr;
se::Object* __jsb_cc_scene_Skybox_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_Skybox) 

static bool js_new_cc_scene_Skybox(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::Skybox *result;
    result = (cc::scene::Skybox *)new cc::scene::Skybox();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_Skybox, __jsb_cc_scene_Skybox_class, js_delete_cc_scene_Skybox)

static bool js_delete_cc_scene_Skybox(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_Skybox) 

static bool js_cc_scene_Skybox_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    cc::scene::SkyboxInfo *arg2 = 0 ;
    cc::scene::SkyboxInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::scene::SkyboxInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Skybox_initialize) 

static bool js_cc_scene_Skybox_setEnvMaps(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    cc::TextureCube *arg2 = (cc::TextureCube *) NULL ;
    cc::TextureCube *arg3 = (cc::TextureCube *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setEnvMaps(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Skybox_setEnvMaps) 

static bool js_cc_scene_Skybox_setDiffuseMaps(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    cc::TextureCube *arg2 = (cc::TextureCube *) NULL ;
    cc::TextureCube *arg3 = (cc::TextureCube *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setDiffuseMaps(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Skybox_setDiffuseMaps) 

static bool js_cc_scene_Skybox_setReflectionMaps(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    cc::TextureCube *arg2 = (cc::TextureCube *) NULL ;
    cc::TextureCube *arg3 = (cc::TextureCube *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setReflectionMaps(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Skybox_setReflectionMaps) 

static bool js_cc_scene_Skybox_activate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    if (nullptr == arg1) return true;
    (arg1)->activate();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Skybox_activate) 

static bool js_cc_scene_Skybox_isUsingConvolutionMap(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    if (nullptr == arg1) return true;
    result = (bool)((cc::scene::Skybox const *)arg1)->isUsingConvolutionMap();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Skybox_isUsingConvolutionMap) 

static bool js_cc_scene_Skybox_setSkyboxMaterial(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    cc::Material *arg2 = (cc::Material *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setSkyboxMaterial(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Skybox_setSkyboxMaterial) 

static bool js_cc_scene_Skybox_setRotationAngle(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRotationAngle(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Skybox_setRotationAngle) 

static bool js_cc_scene_Skybox_getRotationAngle(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    if (nullptr == arg1) return true;
    result = (float)((cc::scene::Skybox const *)arg1)->getRotationAngle();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Skybox_getRotationAngle) 

static bool js_cc_scene_Skybox_getReflectionMap(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    cc::TextureCube *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    if (nullptr == arg1) return true;
    result = (cc::TextureCube *)((cc::scene::Skybox const *)arg1)->getReflectionMap();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Skybox_getReflectionMap) 

static bool js_cc_scene_Skybox_model_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    cc::scene::Model *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::Model *)cc_scene_Skybox_model_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Skybox_model_get) 

static bool js_cc_scene_Skybox_enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Skybox_enabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Skybox_enabled_set) 

static bool js_cc_scene_Skybox_enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_Skybox_enabled_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Skybox_enabled_get) 

static bool js_cc_scene_Skybox_useHDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Skybox_useHDR_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Skybox_useHDR_set) 

static bool js_cc_scene_Skybox_useHDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_Skybox_useHDR_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Skybox_useHDR_get) 

static bool js_cc_scene_Skybox_useIBL_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Skybox_useIBL_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Skybox_useIBL_set) 

static bool js_cc_scene_Skybox_useIBL_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_Skybox_useIBL_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Skybox_useIBL_get) 

static bool js_cc_scene_Skybox_useDiffuseMap_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Skybox_useDiffuseMap_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Skybox_useDiffuseMap_set) 

static bool js_cc_scene_Skybox_useDiffuseMap_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_Skybox_useDiffuseMap_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Skybox_useDiffuseMap_get) 

static bool js_cc_scene_Skybox_isRGBE_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_Skybox_isRGBE_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Skybox_isRGBE_get) 

static bool js_cc_scene_Skybox_envmap_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    cc::TextureCube *arg2 = (cc::TextureCube *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Skybox_envmap_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Skybox_envmap_set) 

static bool js_cc_scene_Skybox_envmap_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    cc::TextureCube *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    if (nullptr == arg1) return true;
    result = (cc::TextureCube *)cc_scene_Skybox_envmap_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Skybox_envmap_get) 

static bool js_cc_scene_Skybox_diffuseMap_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    cc::TextureCube *arg2 = (cc::TextureCube *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Skybox_diffuseMap_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Skybox_diffuseMap_set) 

static bool js_cc_scene_Skybox_diffuseMap_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    cc::TextureCube *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    if (nullptr == arg1) return true;
    result = (cc::TextureCube *)cc_scene_Skybox_diffuseMap_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Skybox_diffuseMap_get) 

bool js_register_cc_scene_Skybox(se::Object* obj) {
    auto* cls = se::Class::create("Skybox", obj, nullptr, _SE(js_new_cc_scene_Skybox)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("model", _SE(js_cc_scene_Skybox_model_get), nullptr); 
    cls->defineProperty("enabled", _SE(js_cc_scene_Skybox_enabled_get), _SE(js_cc_scene_Skybox_enabled_set)); 
    cls->defineProperty("useHDR", _SE(js_cc_scene_Skybox_useHDR_get), _SE(js_cc_scene_Skybox_useHDR_set)); 
    cls->defineProperty("useIBL", _SE(js_cc_scene_Skybox_useIBL_get), _SE(js_cc_scene_Skybox_useIBL_set)); 
    cls->defineProperty("useDiffuseMap", _SE(js_cc_scene_Skybox_useDiffuseMap_get), _SE(js_cc_scene_Skybox_useDiffuseMap_set)); 
    cls->defineProperty("isRGBE", _SE(js_cc_scene_Skybox_isRGBE_get), nullptr); 
    cls->defineProperty("envmap", _SE(js_cc_scene_Skybox_envmap_get), _SE(js_cc_scene_Skybox_envmap_set)); 
    cls->defineProperty("diffuseMap", _SE(js_cc_scene_Skybox_diffuseMap_get), _SE(js_cc_scene_Skybox_diffuseMap_set)); 
    
    cls->defineFunction("initialize", _SE(js_cc_scene_Skybox_initialize)); 
    cls->defineFunction("setEnvMaps", _SE(js_cc_scene_Skybox_setEnvMaps)); 
    cls->defineFunction("setDiffuseMaps", _SE(js_cc_scene_Skybox_setDiffuseMaps)); 
    cls->defineFunction("setReflectionMaps", _SE(js_cc_scene_Skybox_setReflectionMaps)); 
    cls->defineFunction("activate", _SE(js_cc_scene_Skybox_activate)); 
    cls->defineFunction("isUsingConvolutionMap", _SE(js_cc_scene_Skybox_isUsingConvolutionMap)); 
    cls->defineFunction("setSkyboxMaterial", _SE(js_cc_scene_Skybox_setSkyboxMaterial)); 
    cls->defineFunction("setRotationAngle", _SE(js_cc_scene_Skybox_setRotationAngle)); 
    cls->defineFunction("getRotationAngle", _SE(js_cc_scene_Skybox_getRotationAngle)); 
    cls->defineFunction("getReflectionMap", _SE(js_cc_scene_Skybox_getReflectionMap)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_Skybox));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::Skybox>(cls);
    
    __jsb_cc_scene_Skybox_proto = cls->getProto();
    __jsb_cc_scene_Skybox_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_DirectionalLight_class = nullptr;
se::Object* __jsb_cc_scene_DirectionalLight_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_DirectionalLight) 

static bool js_new_cc_scene_DirectionalLight(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::DirectionalLight *result;
    result = (cc::scene::DirectionalLight *)new cc::scene::DirectionalLight();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_DirectionalLight, __jsb_cc_scene_DirectionalLight_class, js_delete_cc_scene_DirectionalLight)

static bool js_delete_cc_scene_DirectionalLight(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_DirectionalLight) 

static bool js_cc_scene_DirectionalLight_direction_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_DirectionalLight_direction_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_direction_set) 

static bool js_cc_scene_DirectionalLight_direction_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    result = (cc::Vec3 *) &cc_scene_DirectionalLight_direction_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_direction_get) 

static bool js_cc_scene_DirectionalLight_illuminance_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_DirectionalLight_illuminance_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_illuminance_set) 

static bool js_cc_scene_DirectionalLight_illuminance_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_DirectionalLight_illuminance_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_illuminance_get) 

static bool js_cc_scene_DirectionalLight_illuminanceHDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_DirectionalLight_illuminanceHDR_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_illuminanceHDR_set) 

static bool js_cc_scene_DirectionalLight_illuminanceHDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_DirectionalLight_illuminanceHDR_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_illuminanceHDR_get) 

static bool js_cc_scene_DirectionalLight_illuminanceLDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_DirectionalLight_illuminanceLDR_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_illuminanceLDR_set) 

static bool js_cc_scene_DirectionalLight_illuminanceLDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_DirectionalLight_illuminanceLDR_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_illuminanceLDR_get) 

static bool js_cc_scene_DirectionalLight_shadowEnabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_DirectionalLight_shadowEnabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_shadowEnabled_set) 

static bool js_cc_scene_DirectionalLight_shadowEnabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_DirectionalLight_shadowEnabled_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_shadowEnabled_get) 

static bool js_cc_scene_DirectionalLight_shadowPcf_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    cc::scene::PCFType arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_scene_DirectionalLight_shadowPcf_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_shadowPcf_set) 

static bool js_cc_scene_DirectionalLight_shadowPcf_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    cc::scene::PCFType result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::PCFType)cc_scene_DirectionalLight_shadowPcf_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_shadowPcf_get) 

static bool js_cc_scene_DirectionalLight_shadowBias_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_DirectionalLight_shadowBias_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_shadowBias_set) 

static bool js_cc_scene_DirectionalLight_shadowBias_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_DirectionalLight_shadowBias_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_shadowBias_get) 

static bool js_cc_scene_DirectionalLight_shadowNormalBias_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_DirectionalLight_shadowNormalBias_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_shadowNormalBias_set) 

static bool js_cc_scene_DirectionalLight_shadowNormalBias_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_DirectionalLight_shadowNormalBias_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_shadowNormalBias_get) 

static bool js_cc_scene_DirectionalLight_shadowSaturation_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_DirectionalLight_shadowSaturation_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_shadowSaturation_set) 

static bool js_cc_scene_DirectionalLight_shadowSaturation_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_DirectionalLight_shadowSaturation_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_shadowSaturation_get) 

static bool js_cc_scene_DirectionalLight_shadowDistance_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_DirectionalLight_shadowDistance_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_shadowDistance_set) 

static bool js_cc_scene_DirectionalLight_shadowDistance_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_DirectionalLight_shadowDistance_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_shadowDistance_get) 

static bool js_cc_scene_DirectionalLight_shadowInvisibleOcclusionRange_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_DirectionalLight_shadowInvisibleOcclusionRange_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_shadowInvisibleOcclusionRange_set) 

static bool js_cc_scene_DirectionalLight_shadowInvisibleOcclusionRange_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_DirectionalLight_shadowInvisibleOcclusionRange_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_shadowInvisibleOcclusionRange_get) 

static bool js_cc_scene_DirectionalLight_shadowFixedArea_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_DirectionalLight_shadowFixedArea_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_shadowFixedArea_set) 

static bool js_cc_scene_DirectionalLight_shadowFixedArea_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_DirectionalLight_shadowFixedArea_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_shadowFixedArea_get) 

static bool js_cc_scene_DirectionalLight_shadowNear_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_DirectionalLight_shadowNear_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_shadowNear_set) 

static bool js_cc_scene_DirectionalLight_shadowNear_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_DirectionalLight_shadowNear_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_shadowNear_get) 

static bool js_cc_scene_DirectionalLight_shadowFar_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_DirectionalLight_shadowFar_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_shadowFar_set) 

static bool js_cc_scene_DirectionalLight_shadowFar_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_DirectionalLight_shadowFar_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_shadowFar_get) 

static bool js_cc_scene_DirectionalLight_shadowOrthoSize_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_DirectionalLight_shadowOrthoSize_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_shadowOrthoSize_set) 

static bool js_cc_scene_DirectionalLight_shadowOrthoSize_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_DirectionalLight_shadowOrthoSize_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_shadowOrthoSize_get) 

static bool js_cc_scene_DirectionalLight_csmLevel_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    cc::scene::CSMLevel arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_scene_DirectionalLight_csmLevel_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_csmLevel_set) 

static bool js_cc_scene_DirectionalLight_csmLevel_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    cc::scene::CSMLevel result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::CSMLevel)cc_scene_DirectionalLight_csmLevel_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_csmLevel_get) 

static bool js_cc_scene_DirectionalLight_csmNeedUpdate_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_DirectionalLight_csmNeedUpdate_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_csmNeedUpdate_set) 

static bool js_cc_scene_DirectionalLight_csmNeedUpdate_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_DirectionalLight_csmNeedUpdate_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_csmNeedUpdate_get) 

static bool js_cc_scene_DirectionalLight_csmLayerLambda_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_DirectionalLight_csmLayerLambda_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_csmLayerLambda_set) 

static bool js_cc_scene_DirectionalLight_csmLayerLambda_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_DirectionalLight_csmLayerLambda_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_csmLayerLambda_get) 

static bool js_cc_scene_DirectionalLight_csmOptimizationMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    cc::scene::CSMOptimizationMode arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_scene_DirectionalLight_csmOptimizationMode_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_csmOptimizationMode_set) 

static bool js_cc_scene_DirectionalLight_csmOptimizationMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    cc::scene::CSMOptimizationMode result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::CSMOptimizationMode)cc_scene_DirectionalLight_csmOptimizationMode_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_csmOptimizationMode_get) 

static bool js_cc_scene_DirectionalLight_csmLayersTransition_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_DirectionalLight_csmLayersTransition_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_csmLayersTransition_set) 

static bool js_cc_scene_DirectionalLight_csmLayersTransition_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_DirectionalLight_csmLayersTransition_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_csmLayersTransition_get) 

static bool js_cc_scene_DirectionalLight_csmTransitionRange_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_DirectionalLight_csmTransitionRange_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_csmTransitionRange_set) 

static bool js_cc_scene_DirectionalLight_csmTransitionRange_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_DirectionalLight_csmTransitionRange_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_csmTransitionRange_get) 

bool js_register_cc_scene_DirectionalLight(se::Object* obj) {
    auto* cls = se::Class::create("DirectionalLight", obj, __jsb_cc_scene_Light_proto, _SE(js_new_cc_scene_DirectionalLight)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("direction", _SE(js_cc_scene_DirectionalLight_direction_get), _SE(js_cc_scene_DirectionalLight_direction_set)); 
    cls->defineProperty("illuminance", _SE(js_cc_scene_DirectionalLight_illuminance_get), _SE(js_cc_scene_DirectionalLight_illuminance_set)); 
    cls->defineProperty("illuminanceHDR", _SE(js_cc_scene_DirectionalLight_illuminanceHDR_get), _SE(js_cc_scene_DirectionalLight_illuminanceHDR_set)); 
    cls->defineProperty("illuminanceLDR", _SE(js_cc_scene_DirectionalLight_illuminanceLDR_get), _SE(js_cc_scene_DirectionalLight_illuminanceLDR_set)); 
    cls->defineProperty("shadowEnabled", _SE(js_cc_scene_DirectionalLight_shadowEnabled_get), _SE(js_cc_scene_DirectionalLight_shadowEnabled_set)); 
    cls->defineProperty("shadowPcf", _SE(js_cc_scene_DirectionalLight_shadowPcf_get), _SE(js_cc_scene_DirectionalLight_shadowPcf_set)); 
    cls->defineProperty("shadowBias", _SE(js_cc_scene_DirectionalLight_shadowBias_get), _SE(js_cc_scene_DirectionalLight_shadowBias_set)); 
    cls->defineProperty("shadowNormalBias", _SE(js_cc_scene_DirectionalLight_shadowNormalBias_get), _SE(js_cc_scene_DirectionalLight_shadowNormalBias_set)); 
    cls->defineProperty("shadowSaturation", _SE(js_cc_scene_DirectionalLight_shadowSaturation_get), _SE(js_cc_scene_DirectionalLight_shadowSaturation_set)); 
    cls->defineProperty("shadowDistance", _SE(js_cc_scene_DirectionalLight_shadowDistance_get), _SE(js_cc_scene_DirectionalLight_shadowDistance_set)); 
    cls->defineProperty("shadowInvisibleOcclusionRange", _SE(js_cc_scene_DirectionalLight_shadowInvisibleOcclusionRange_get), _SE(js_cc_scene_DirectionalLight_shadowInvisibleOcclusionRange_set)); 
    cls->defineProperty("shadowFixedArea", _SE(js_cc_scene_DirectionalLight_shadowFixedArea_get), _SE(js_cc_scene_DirectionalLight_shadowFixedArea_set)); 
    cls->defineProperty("shadowNear", _SE(js_cc_scene_DirectionalLight_shadowNear_get), _SE(js_cc_scene_DirectionalLight_shadowNear_set)); 
    cls->defineProperty("shadowFar", _SE(js_cc_scene_DirectionalLight_shadowFar_get), _SE(js_cc_scene_DirectionalLight_shadowFar_set)); 
    cls->defineProperty("shadowOrthoSize", _SE(js_cc_scene_DirectionalLight_shadowOrthoSize_get), _SE(js_cc_scene_DirectionalLight_shadowOrthoSize_set)); 
    cls->defineProperty("csmLevel", _SE(js_cc_scene_DirectionalLight_csmLevel_get), _SE(js_cc_scene_DirectionalLight_csmLevel_set)); 
    cls->defineProperty("csmNeedUpdate", _SE(js_cc_scene_DirectionalLight_csmNeedUpdate_get), _SE(js_cc_scene_DirectionalLight_csmNeedUpdate_set)); 
    cls->defineProperty("csmLayerLambda", _SE(js_cc_scene_DirectionalLight_csmLayerLambda_get), _SE(js_cc_scene_DirectionalLight_csmLayerLambda_set)); 
    cls->defineProperty("csmOptimizationMode", _SE(js_cc_scene_DirectionalLight_csmOptimizationMode_get), _SE(js_cc_scene_DirectionalLight_csmOptimizationMode_set)); 
    cls->defineProperty("csmLayersTransition", _SE(js_cc_scene_DirectionalLight_csmLayersTransition_get), _SE(js_cc_scene_DirectionalLight_csmLayersTransition_set)); 
    cls->defineProperty("csmTransitionRange", _SE(js_cc_scene_DirectionalLight_csmTransitionRange_get), _SE(js_cc_scene_DirectionalLight_csmTransitionRange_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_DirectionalLight));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::DirectionalLight>(cls);
    
    __jsb_cc_scene_DirectionalLight_proto = cls->getProto();
    __jsb_cc_scene_DirectionalLight_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_SpotLight_class = nullptr;
se::Object* __jsb_cc_scene_SpotLight_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_SpotLight) 

static bool js_new_cc_scene_SpotLight(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::SpotLight *result;
    result = (cc::scene::SpotLight *)new cc::scene::SpotLight();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_SpotLight, __jsb_cc_scene_SpotLight_class, js_delete_cc_scene_SpotLight)

static bool js_delete_cc_scene_SpotLight(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_SpotLight) 

static bool js_cc_scene_SpotLight_position_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    if (nullptr == arg1) return true;
    result = (cc::Vec3 *) &cc_scene_SpotLight_position_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_position_get) 

static bool js_cc_scene_SpotLight_range_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SpotLight_range_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SpotLight_range_set) 

static bool js_cc_scene_SpotLight_range_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_SpotLight_range_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_range_get) 

static bool js_cc_scene_SpotLight_luminance_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SpotLight_luminance_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SpotLight_luminance_set) 

static bool js_cc_scene_SpotLight_luminance_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_SpotLight_luminance_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_luminance_get) 

static bool js_cc_scene_SpotLight_luminanceHDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SpotLight_luminanceHDR_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SpotLight_luminanceHDR_set) 

static bool js_cc_scene_SpotLight_luminanceHDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_SpotLight_luminanceHDR_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_luminanceHDR_get) 

static bool js_cc_scene_SpotLight_luminanceLDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SpotLight_luminanceLDR_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SpotLight_luminanceLDR_set) 

static bool js_cc_scene_SpotLight_luminanceLDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_SpotLight_luminanceLDR_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_luminanceLDR_get) 

static bool js_cc_scene_SpotLight_direction_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    if (nullptr == arg1) return true;
    result = (cc::Vec3 *) &cc_scene_SpotLight_direction_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_direction_get) 

static bool js_cc_scene_SpotLight_spotAngle_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SpotLight_spotAngle_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SpotLight_spotAngle_set) 

static bool js_cc_scene_SpotLight_spotAngle_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_SpotLight_spotAngle_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_spotAngle_get) 

static bool js_cc_scene_SpotLight_angle_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_SpotLight_angle_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_angle_get) 

static bool js_cc_scene_SpotLight_aabb_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    if (nullptr == arg1) return true;
    result = (cc::geometry::AABB *) &cc_scene_SpotLight_aabb_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_aabb_get) 

static bool js_cc_scene_SpotLight_frustum_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    cc::geometry::Frustum *arg2 = 0 ;
    cc::geometry::Frustum temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_SpotLight_frustum_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SpotLight_frustum_set) 

static bool js_cc_scene_SpotLight_frustum_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    cc::geometry::Frustum *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    if (nullptr == arg1) return true;
    result = (cc::geometry::Frustum *) &cc_scene_SpotLight_frustum_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_frustum_get) 

static bool js_cc_scene_SpotLight_shadowEnabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SpotLight_shadowEnabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SpotLight_shadowEnabled_set) 

static bool js_cc_scene_SpotLight_shadowEnabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_SpotLight_shadowEnabled_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_shadowEnabled_get) 

static bool js_cc_scene_SpotLight_shadowPcf_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SpotLight_shadowPcf_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SpotLight_shadowPcf_set) 

static bool js_cc_scene_SpotLight_shadowPcf_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_SpotLight_shadowPcf_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_shadowPcf_get) 

static bool js_cc_scene_SpotLight_shadowBias_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SpotLight_shadowBias_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SpotLight_shadowBias_set) 

static bool js_cc_scene_SpotLight_shadowBias_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_SpotLight_shadowBias_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_shadowBias_get) 

static bool js_cc_scene_SpotLight_shadowNormalBias_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SpotLight_shadowNormalBias_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SpotLight_shadowNormalBias_set) 

static bool js_cc_scene_SpotLight_shadowNormalBias_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_SpotLight_shadowNormalBias_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_shadowNormalBias_get) 

static bool js_cc_scene_SpotLight_size_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SpotLight_size_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SpotLight_size_set) 

static bool js_cc_scene_SpotLight_size_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_SpotLight_size_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_size_get) 

bool js_register_cc_scene_SpotLight(se::Object* obj) {
    auto* cls = se::Class::create("SpotLight", obj, __jsb_cc_scene_Light_proto, _SE(js_new_cc_scene_SpotLight)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("position", _SE(js_cc_scene_SpotLight_position_get), nullptr); 
    cls->defineProperty("range", _SE(js_cc_scene_SpotLight_range_get), _SE(js_cc_scene_SpotLight_range_set)); 
    cls->defineProperty("luminance", _SE(js_cc_scene_SpotLight_luminance_get), _SE(js_cc_scene_SpotLight_luminance_set)); 
    cls->defineProperty("luminanceHDR", _SE(js_cc_scene_SpotLight_luminanceHDR_get), _SE(js_cc_scene_SpotLight_luminanceHDR_set)); 
    cls->defineProperty("luminanceLDR", _SE(js_cc_scene_SpotLight_luminanceLDR_get), _SE(js_cc_scene_SpotLight_luminanceLDR_set)); 
    cls->defineProperty("direction", _SE(js_cc_scene_SpotLight_direction_get), nullptr); 
    cls->defineProperty("spotAngle", _SE(js_cc_scene_SpotLight_spotAngle_get), _SE(js_cc_scene_SpotLight_spotAngle_set)); 
    cls->defineProperty("angle", _SE(js_cc_scene_SpotLight_angle_get), nullptr); 
    cls->defineProperty("aabb", _SE(js_cc_scene_SpotLight_aabb_get), nullptr); 
    cls->defineProperty("frustum", _SE(js_cc_scene_SpotLight_frustum_get), _SE(js_cc_scene_SpotLight_frustum_set)); 
    cls->defineProperty("shadowEnabled", _SE(js_cc_scene_SpotLight_shadowEnabled_get), _SE(js_cc_scene_SpotLight_shadowEnabled_set)); 
    cls->defineProperty("shadowPcf", _SE(js_cc_scene_SpotLight_shadowPcf_get), _SE(js_cc_scene_SpotLight_shadowPcf_set)); 
    cls->defineProperty("shadowBias", _SE(js_cc_scene_SpotLight_shadowBias_get), _SE(js_cc_scene_SpotLight_shadowBias_set)); 
    cls->defineProperty("shadowNormalBias", _SE(js_cc_scene_SpotLight_shadowNormalBias_get), _SE(js_cc_scene_SpotLight_shadowNormalBias_set)); 
    cls->defineProperty("size", _SE(js_cc_scene_SpotLight_size_get), _SE(js_cc_scene_SpotLight_size_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_SpotLight));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::SpotLight>(cls);
    
    __jsb_cc_scene_SpotLight_proto = cls->getProto();
    __jsb_cc_scene_SpotLight_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_SphereLight_class = nullptr;
se::Object* __jsb_cc_scene_SphereLight_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_SphereLight) 

static bool js_new_cc_scene_SphereLight(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::SphereLight *result;
    result = (cc::scene::SphereLight *)new cc::scene::SphereLight();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_SphereLight, __jsb_cc_scene_SphereLight_class, js_delete_cc_scene_SphereLight)

static bool js_delete_cc_scene_SphereLight(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_SphereLight) 

static bool js_cc_scene_SphereLight_position_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SphereLight *arg1 = (cc::scene::SphereLight *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SphereLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_SphereLight_position_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SphereLight_position_set) 

static bool js_cc_scene_SphereLight_position_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SphereLight *arg1 = (cc::scene::SphereLight *) NULL ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SphereLight>(s);
    if (nullptr == arg1) return true;
    result = (cc::Vec3 *) &cc_scene_SphereLight_position_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SphereLight_position_get) 

static bool js_cc_scene_SphereLight_size_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SphereLight *arg1 = (cc::scene::SphereLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SphereLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SphereLight_size_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SphereLight_size_set) 

static bool js_cc_scene_SphereLight_size_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SphereLight *arg1 = (cc::scene::SphereLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SphereLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_SphereLight_size_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SphereLight_size_get) 

static bool js_cc_scene_SphereLight_range_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SphereLight *arg1 = (cc::scene::SphereLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SphereLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SphereLight_range_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SphereLight_range_set) 

static bool js_cc_scene_SphereLight_range_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SphereLight *arg1 = (cc::scene::SphereLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SphereLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_SphereLight_range_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SphereLight_range_get) 

static bool js_cc_scene_SphereLight_luminance_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SphereLight *arg1 = (cc::scene::SphereLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SphereLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SphereLight_luminance_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SphereLight_luminance_set) 

static bool js_cc_scene_SphereLight_luminance_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SphereLight *arg1 = (cc::scene::SphereLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SphereLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_SphereLight_luminance_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SphereLight_luminance_get) 

static bool js_cc_scene_SphereLight_luminanceHDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SphereLight *arg1 = (cc::scene::SphereLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SphereLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SphereLight_luminanceHDR_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SphereLight_luminanceHDR_set) 

static bool js_cc_scene_SphereLight_luminanceHDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SphereLight *arg1 = (cc::scene::SphereLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SphereLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_SphereLight_luminanceHDR_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SphereLight_luminanceHDR_get) 

static bool js_cc_scene_SphereLight_luminanceLDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SphereLight *arg1 = (cc::scene::SphereLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SphereLight>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SphereLight_luminanceLDR_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SphereLight_luminanceLDR_set) 

static bool js_cc_scene_SphereLight_luminanceLDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SphereLight *arg1 = (cc::scene::SphereLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SphereLight>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_SphereLight_luminanceLDR_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SphereLight_luminanceLDR_get) 

static bool js_cc_scene_SphereLight_aabb_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SphereLight *arg1 = (cc::scene::SphereLight *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SphereLight>(s);
    if (nullptr == arg1) return true;
    result = (cc::geometry::AABB *) &cc_scene_SphereLight_aabb_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SphereLight_aabb_get) 

bool js_register_cc_scene_SphereLight(se::Object* obj) {
    auto* cls = se::Class::create("SphereLight", obj, __jsb_cc_scene_Light_proto, _SE(js_new_cc_scene_SphereLight)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("position", _SE(js_cc_scene_SphereLight_position_get), _SE(js_cc_scene_SphereLight_position_set)); 
    cls->defineProperty("size", _SE(js_cc_scene_SphereLight_size_get), _SE(js_cc_scene_SphereLight_size_set)); 
    cls->defineProperty("range", _SE(js_cc_scene_SphereLight_range_get), _SE(js_cc_scene_SphereLight_range_set)); 
    cls->defineProperty("luminance", _SE(js_cc_scene_SphereLight_luminance_get), _SE(js_cc_scene_SphereLight_luminance_set)); 
    cls->defineProperty("luminanceHDR", _SE(js_cc_scene_SphereLight_luminanceHDR_get), _SE(js_cc_scene_SphereLight_luminanceHDR_set)); 
    cls->defineProperty("luminanceLDR", _SE(js_cc_scene_SphereLight_luminanceLDR_get), _SE(js_cc_scene_SphereLight_luminanceLDR_set)); 
    cls->defineProperty("aabb", _SE(js_cc_scene_SphereLight_aabb_get), nullptr); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_SphereLight));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::SphereLight>(cls);
    
    __jsb_cc_scene_SphereLight_proto = cls->getProto();
    __jsb_cc_scene_SphereLight_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_Model_class = nullptr;
se::Object* __jsb_cc_scene_Model_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_Model) 

static bool js_new_cc_scene_Model(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::Model *result;
    result = (cc::scene::Model *)new cc::scene::Model();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_Model, __jsb_cc_scene_Model_class, js_delete_cc_scene_Model)

static bool js_delete_cc_scene_Model(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_Model) 

static bool js_cc_scene_Model_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_destroy) 

static bool js_cc_scene_Model_initSubModel(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    index_t arg2 ;
    cc::RenderingSubMesh *arg3 = (cc::RenderingSubMesh *) NULL ;
    cc::Material *arg4 = (cc::Material *) NULL ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->initSubModel(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_initSubModel) 

static bool js_cc_scene_Model_getMacroPatches(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    index_t arg2 ;
    ccstd::vector< cc::scene::IMacroPatch > result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (arg1)->getMacroPatches(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_getMacroPatches) 

static bool js_cc_scene_Model_setSubModelMaterial(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    index_t arg2 ;
    cc::Material *arg3 = (cc::Material *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setSubModelMaterial(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_setSubModelMaterial) 

static bool js_cc_scene_Model__updateInstancedAttributes(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    ccstd::vector< cc::gfx::Attribute > *arg2 = 0 ;
    cc::scene::SubModel *arg3 = (cc::scene::SubModel *) NULL ;
    ccstd::vector< cc::gfx::Attribute > temp2 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->updateInstancedAttributes((ccstd::vector< cc::gfx::Attribute > const &)*arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model__updateInstancedAttributes) 

static bool js_cc_scene_Model_updateTransform(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->updateTransform(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_updateTransform) 

static bool js_cc_scene_Model_updateUBOs(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->updateUBOs(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_updateUBOs) 

static bool js_cc_scene_Model__updateLocalDescriptors(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    index_t arg2 ;
    cc::gfx::DescriptorSet *arg3 = (cc::gfx::DescriptorSet *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->updateLocalDescriptors(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model__updateLocalDescriptors) 

static bool js_cc_scene_Model__updateLocalSHDescriptors(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    index_t arg2 ;
    cc::gfx::DescriptorSet *arg3 = (cc::gfx::DescriptorSet *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->updateLocalSHDescriptors(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model__updateLocalSHDescriptors) 

static bool js_cc_scene_Model__updateWorldBoundDescriptors(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    index_t arg2 ;
    cc::gfx::DescriptorSet *arg3 = (cc::gfx::DescriptorSet *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->updateWorldBoundDescriptors(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model__updateWorldBoundDescriptors) 

static bool js_cc_scene_Model_createBoundingShape(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    ccstd::optional< cc::Vec3 > *arg2 = 0 ;
    ccstd::optional< cc::Vec3 > *arg3 = 0 ;
    ccstd::optional< cc::Vec3 > temp2 ;
    ccstd::optional< cc::Vec3 > temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->createBoundingShape((ccstd::optional< cc::Vec3 > const &)*arg2,(ccstd::optional< cc::Vec3 > const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_createBoundingShape) 

static bool js_cc_scene_Model_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    (arg1)->initialize();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_initialize) 

static bool js_cc_scene_Model_initLightingmap(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::Texture2D *arg2 = (cc::Texture2D *) NULL ;
    cc::Vec4 *arg3 = 0 ;
    cc::Vec4 temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->initLightingmap(arg2,(cc::Vec4 const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_initLightingmap) 

static bool js_cc_scene_Model__initLocalDescriptors(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    index_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->initLocalDescriptors(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model__initLocalDescriptors) 

static bool js_cc_scene_Model__initLocalSHDescriptors(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    index_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->initLocalSHDescriptors(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model__initLocalSHDescriptors) 

static bool js_cc_scene_Model_initWorldBoundDescriptors(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    index_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->initWorldBoundDescriptors(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_initWorldBoundDescriptors) 

static bool js_cc_scene_Model_onGlobalPipelineStateChanged(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    ((cc::scene::Model const *)arg1)->onGlobalPipelineStateChanged();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_onGlobalPipelineStateChanged) 

static bool js_cc_scene_Model_onMacroPatchesStateChanged(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    (arg1)->onMacroPatchesStateChanged();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_onMacroPatchesStateChanged) 

static bool js_cc_scene_Model_onGeometryChanged(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    (arg1)->onGeometryChanged();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_onGeometryChanged) 

static bool js_cc_scene_Model_setSubModelMesh(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    index_t arg2 ;
    cc::RenderingSubMesh *arg3 = (cc::RenderingSubMesh *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    ((cc::scene::Model const *)arg1)->setSubModelMesh(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_setSubModelMesh) 

static bool js_cc_scene_Model_setInstancedAttribute(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    ccstd::string *arg2 = 0 ;
    float *arg3 = (float *) NULL ;
    uint32_t arg4 ;
    ccstd::string temp2 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setInstancedAttribute((ccstd::string const &)*arg2,(float const *)arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_setInstancedAttribute) 

static bool js_cc_scene_Model_updateWorldBound(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    (arg1)->updateWorldBound();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_updateWorldBound) 

static bool js_cc_scene_Model_updateWorldBoundsForJSSkinningModel(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->updateWorldBoundsForJSSkinningModel((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_updateWorldBoundsForJSSkinningModel) 

static bool js_cc_scene_Model_updateWorldBoundsForJSBakedSkinningModel(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::geometry::AABB *arg2 = (cc::geometry::AABB *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->updateWorldBoundsForJSBakedSkinningModel(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_updateWorldBoundsForJSBakedSkinningModel) 

static bool js_cc_scene_Model_updateLightingmap(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::Texture2D *arg2 = (cc::Texture2D *) NULL ;
    cc::Vec4 *arg3 = 0 ;
    cc::Vec4 temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->updateLightingmap(arg2,(cc::Vec4 const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_updateLightingmap) 

static bool js_cc_scene_Model_clearSHUBOs(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    (arg1)->clearSHUBOs();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_clearSHUBOs) 

static bool js_cc_scene_Model_updateSHUBOs(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    (arg1)->updateSHUBOs();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_updateSHUBOs) 

static bool js_cc_scene_Model_updateWorldBoundUBOs(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    (arg1)->updateWorldBoundUBOs();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_updateWorldBoundUBOs) 

static bool js_cc_scene_Model_updateLocalShadowBias(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    (arg1)->updateLocalShadowBias();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_updateLocalShadowBias) 

static bool js_cc_scene_Model_updateReflectionProbeCubemap(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::TextureCube *arg2 = (cc::TextureCube *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->updateReflectionProbeCubemap(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_updateReflectionProbeCubemap) 

static bool js_cc_scene_Model_updateReflectionProbePlanarMap(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::gfx::Texture *arg2 = (cc::gfx::Texture *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->updateReflectionProbePlanarMap(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_updateReflectionProbePlanarMap) 

static bool js_cc_scene_Model_attachToScene(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::scene::RenderScene *arg2 = (cc::scene::RenderScene *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->attachToScene(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_attachToScene) 

static bool js_cc_scene_Model_detachFromScene(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    (arg1)->detachFromScene();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_detachFromScene) 

static bool js_cc_scene_Model_setLocalSHBuffer(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::gfx::Buffer *arg2 = (cc::gfx::Buffer *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setLocalSHBuffer(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_setLocalSHBuffer) 

static bool js_cc_scene_Model_setBounds(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::geometry::AABB *arg2 = (cc::geometry::AABB *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setBounds(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_setBounds) 

static bool js_cc_scene_Model_showTetrahedron(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = (bool)((cc::scene::Model const *)arg1)->showTetrahedron();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_showTetrahedron) 

static bool js_cc_scene_Model_getLocalSHBuffer(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::gfx::Buffer *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Buffer *)((cc::scene::Model const *)arg1)->getLocalSHBuffer();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_getLocalSHBuffer) 

static bool js_cc_scene_Model_getLocalSHData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::Float32Array result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = ((cc::scene::Model const *)arg1)->getLocalSHData();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_getLocalSHData) 

static bool js_cc_scene_Model_setCalledFromJS(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setCalledFromJS(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_setCalledFromJS) 

static bool js_cc_scene_Model_isModelImplementedInJS(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = (bool)((cc::scene::Model const *)arg1)->isModelImplementedInJS();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_isModelImplementedInJS) 

static bool js_cc_scene_Model_scene_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::scene::RenderScene *arg2 = (cc::scene::RenderScene *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Model_scene_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_scene_set) 

static bool js_cc_scene_Model_scene_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::scene::RenderScene *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::RenderScene *)cc_scene_Model_scene_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_scene_get) 

static bool js_cc_scene_Model__subModels_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::scene::SubModel > > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::IntrusivePtr< cc::scene::SubModel > > *) &cc_scene_Model__subModels_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model__subModels_get) 

static bool js_cc_scene_Model_subModels_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::scene::SubModel > > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::IntrusivePtr< cc::scene::SubModel > > *) &cc_scene_Model_subModels_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_subModels_get) 

static bool js_cc_scene_Model_inited_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_Model_inited_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_inited_get) 

static bool js_cc_scene_Model__localDataUpdated_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Model__localDataUpdated_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model__localDataUpdated_set) 

static bool js_cc_scene_Model__localDataUpdated_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_Model__localDataUpdated_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model__localDataUpdated_get) 

static bool js_cc_scene_Model__worldBounds_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::geometry::AABB *arg2 = (cc::geometry::AABB *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Model__worldBounds_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model__worldBounds_set) 

static bool js_cc_scene_Model__worldBounds_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = (cc::geometry::AABB *)cc_scene_Model__worldBounds_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model__worldBounds_get) 

static bool js_cc_scene_Model_worldBounds_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::geometry::AABB *arg2 = (cc::geometry::AABB *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Model_worldBounds_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_worldBounds_set) 

static bool js_cc_scene_Model_worldBounds_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = (cc::geometry::AABB *)cc_scene_Model_worldBounds_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_worldBounds_get) 

static bool js_cc_scene_Model__modelBounds_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::geometry::AABB *arg2 = (cc::geometry::AABB *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Model__modelBounds_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model__modelBounds_set) 

static bool js_cc_scene_Model__modelBounds_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = (cc::geometry::AABB *)cc_scene_Model__modelBounds_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model__modelBounds_get) 

static bool js_cc_scene_Model_modelBounds_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::geometry::AABB *arg2 = (cc::geometry::AABB *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Model_modelBounds_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_modelBounds_set) 

static bool js_cc_scene_Model_modelBounds_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = (cc::geometry::AABB *)cc_scene_Model_modelBounds_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_modelBounds_get) 

static bool js_cc_scene_Model_worldBoundBuffer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::gfx::Buffer *arg2 = (cc::gfx::Buffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Model_worldBoundBuffer_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_worldBoundBuffer_set) 

static bool js_cc_scene_Model_worldBoundBuffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::gfx::Buffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Buffer *)cc_scene_Model_worldBoundBuffer_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_worldBoundBuffer_get) 

static bool js_cc_scene_Model_localBuffer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::gfx::Buffer *arg2 = (cc::gfx::Buffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Model_localBuffer_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_localBuffer_set) 

static bool js_cc_scene_Model_localBuffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::gfx::Buffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Buffer *)cc_scene_Model_localBuffer_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_localBuffer_get) 

static bool js_cc_scene_Model_updateStamp_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_Model_updateStamp_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_updateStamp_get) 

static bool js_cc_scene_Model_receiveShadow_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Model_receiveShadow_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_receiveShadow_set) 

static bool js_cc_scene_Model_receiveShadow_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_Model_receiveShadow_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_receiveShadow_get) 

static bool js_cc_scene_Model_castShadow_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Model_castShadow_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_castShadow_set) 

static bool js_cc_scene_Model_castShadow_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_Model_castShadow_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_castShadow_get) 

static bool js_cc_scene_Model_shadowBias_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Model_shadowBias_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_shadowBias_set) 

static bool js_cc_scene_Model_shadowBias_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_Model_shadowBias_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_shadowBias_get) 

static bool js_cc_scene_Model_shadowNormalBias_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Model_shadowNormalBias_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_shadowNormalBias_set) 

static bool js_cc_scene_Model_shadowNormalBias_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_Model_shadowNormalBias_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_shadowNormalBias_get) 

static bool js_cc_scene_Model_node_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Model_node_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_node_set) 

static bool js_cc_scene_Model_node_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::Node *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = (cc::Node *)cc_scene_Model_node_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_node_get) 

static bool js_cc_scene_Model_transform_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Model_transform_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_transform_set) 

static bool js_cc_scene_Model_transform_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::Node *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = (cc::Node *)cc_scene_Model_transform_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_transform_get) 

static bool js_cc_scene_Model_visFlags_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::Layers::Enum arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_scene_Model_visFlags_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_visFlags_set) 

static bool js_cc_scene_Model_visFlags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::Layers::Enum result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = (cc::Layers::Enum)cc_scene_Model_visFlags_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_visFlags_get) 

static bool js_cc_scene_Model_enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Model_enabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_enabled_set) 

static bool js_cc_scene_Model_enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_Model_enabled_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_enabled_get) 

static bool js_cc_scene_Model_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::scene::Model::Type arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_scene_Model_type_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_type_set) 

static bool js_cc_scene_Model_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::scene::Model::Type result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::Model::Type)cc_scene_Model_type_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_type_get) 

static bool js_cc_scene_Model_isDynamicBatching_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Model_isDynamicBatching_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_isDynamicBatching_set) 

static bool js_cc_scene_Model_isDynamicBatching_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_Model_isDynamicBatching_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_isDynamicBatching_get) 

static bool js_cc_scene_Model_priority_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_scene_Model_priority_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_priority_set) 

static bool js_cc_scene_Model_priority_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_Model_priority_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_priority_get) 

static bool js_cc_scene_Model_tetrahedronIndex_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    int32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Model_tetrahedronIndex_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_tetrahedronIndex_set) 

static bool js_cc_scene_Model_tetrahedronIndex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    int32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_Model_tetrahedronIndex_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_tetrahedronIndex_get) 

static bool js_cc_scene_Model_useLightProbe_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Model_useLightProbe_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_useLightProbe_set) 

static bool js_cc_scene_Model_useLightProbe_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_Model_useLightProbe_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_useLightProbe_get) 

static bool js_cc_scene_Model_bakeToReflectionProbe_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Model_bakeToReflectionProbe_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_bakeToReflectionProbe_set) 

static bool js_cc_scene_Model_bakeToReflectionProbe_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_Model_bakeToReflectionProbe_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_bakeToReflectionProbe_get) 

static bool js_cc_scene_Model_reflectionProbeType_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_scene_Model_reflectionProbeType_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_reflectionProbeType_set) 

static bool js_cc_scene_Model_reflectionProbeType_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_Model_reflectionProbeType_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_reflectionProbeType_get) 

bool js_register_cc_scene_Model(se::Object* obj) {
    auto* cls = se::Class::create("Model", obj, nullptr, _SE(js_new_cc_scene_Model)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("scene", _SE(js_cc_scene_Model_scene_get), _SE(js_cc_scene_Model_scene_set)); 
    cls->defineProperty("_subModels", _SE(js_cc_scene_Model__subModels_get), nullptr); 
    cls->defineProperty("subModels", _SE(js_cc_scene_Model_subModels_get), nullptr); 
    cls->defineProperty("inited", _SE(js_cc_scene_Model_inited_get), nullptr); 
    cls->defineProperty("_localDataUpdated", _SE(js_cc_scene_Model__localDataUpdated_get), _SE(js_cc_scene_Model__localDataUpdated_set)); 
    cls->defineProperty("_worldBounds", _SE(js_cc_scene_Model__worldBounds_get), _SE(js_cc_scene_Model__worldBounds_set)); 
    cls->defineProperty("worldBounds", _SE(js_cc_scene_Model_worldBounds_get), _SE(js_cc_scene_Model_worldBounds_set)); 
    cls->defineProperty("_modelBounds", _SE(js_cc_scene_Model__modelBounds_get), _SE(js_cc_scene_Model__modelBounds_set)); 
    cls->defineProperty("modelBounds", _SE(js_cc_scene_Model_modelBounds_get), _SE(js_cc_scene_Model_modelBounds_set)); 
    cls->defineProperty("worldBoundBuffer", _SE(js_cc_scene_Model_worldBoundBuffer_get), _SE(js_cc_scene_Model_worldBoundBuffer_set)); 
    cls->defineProperty("localBuffer", _SE(js_cc_scene_Model_localBuffer_get), _SE(js_cc_scene_Model_localBuffer_set)); 
    cls->defineProperty("updateStamp", _SE(js_cc_scene_Model_updateStamp_get), nullptr); 
    cls->defineProperty("receiveShadow", _SE(js_cc_scene_Model_receiveShadow_get), _SE(js_cc_scene_Model_receiveShadow_set)); 
    cls->defineProperty("castShadow", _SE(js_cc_scene_Model_castShadow_get), _SE(js_cc_scene_Model_castShadow_set)); 
    cls->defineProperty("shadowBias", _SE(js_cc_scene_Model_shadowBias_get), _SE(js_cc_scene_Model_shadowBias_set)); 
    cls->defineProperty("shadowNormalBias", _SE(js_cc_scene_Model_shadowNormalBias_get), _SE(js_cc_scene_Model_shadowNormalBias_set)); 
    cls->defineProperty("node", _SE(js_cc_scene_Model_node_get), _SE(js_cc_scene_Model_node_set)); 
    cls->defineProperty("transform", _SE(js_cc_scene_Model_transform_get), _SE(js_cc_scene_Model_transform_set)); 
    cls->defineProperty("visFlags", _SE(js_cc_scene_Model_visFlags_get), _SE(js_cc_scene_Model_visFlags_set)); 
    cls->defineProperty("enabled", _SE(js_cc_scene_Model_enabled_get), _SE(js_cc_scene_Model_enabled_set)); 
    cls->defineProperty("type", _SE(js_cc_scene_Model_type_get), _SE(js_cc_scene_Model_type_set)); 
    cls->defineProperty("isDynamicBatching", _SE(js_cc_scene_Model_isDynamicBatching_get), _SE(js_cc_scene_Model_isDynamicBatching_set)); 
    cls->defineProperty("priority", _SE(js_cc_scene_Model_priority_get), _SE(js_cc_scene_Model_priority_set)); 
    cls->defineProperty("tetrahedronIndex", _SE(js_cc_scene_Model_tetrahedronIndex_get), _SE(js_cc_scene_Model_tetrahedronIndex_set)); 
    cls->defineProperty("useLightProbe", _SE(js_cc_scene_Model_useLightProbe_get), _SE(js_cc_scene_Model_useLightProbe_set)); 
    cls->defineProperty("bakeToReflectionProbe", _SE(js_cc_scene_Model_bakeToReflectionProbe_get), _SE(js_cc_scene_Model_bakeToReflectionProbe_set)); 
    cls->defineProperty("reflectionProbeType", _SE(js_cc_scene_Model_reflectionProbeType_get), _SE(js_cc_scene_Model_reflectionProbeType_set)); 
    
    cls->defineFunction("destroy", _SE(js_cc_scene_Model_destroy)); 
    cls->defineFunction("initSubModel", _SE(js_cc_scene_Model_initSubModel)); 
    cls->defineFunction("getMacroPatches", _SE(js_cc_scene_Model_getMacroPatches)); 
    cls->defineFunction("setSubModelMaterial", _SE(js_cc_scene_Model_setSubModelMaterial)); 
    cls->defineFunction("_updateInstancedAttributes", _SE(js_cc_scene_Model__updateInstancedAttributes)); 
    cls->defineFunction("updateTransform", _SE(js_cc_scene_Model_updateTransform)); 
    cls->defineFunction("updateUBOs", _SE(js_cc_scene_Model_updateUBOs)); 
    cls->defineFunction("_updateLocalDescriptors", _SE(js_cc_scene_Model__updateLocalDescriptors)); 
    cls->defineFunction("_updateLocalSHDescriptors", _SE(js_cc_scene_Model__updateLocalSHDescriptors)); 
    cls->defineFunction("_updateWorldBoundDescriptors", _SE(js_cc_scene_Model__updateWorldBoundDescriptors)); 
    cls->defineFunction("createBoundingShape", _SE(js_cc_scene_Model_createBoundingShape)); 
    cls->defineFunction("initialize", _SE(js_cc_scene_Model_initialize)); 
    cls->defineFunction("initLightingmap", _SE(js_cc_scene_Model_initLightingmap)); 
    cls->defineFunction("_initLocalDescriptors", _SE(js_cc_scene_Model__initLocalDescriptors)); 
    cls->defineFunction("_initLocalSHDescriptors", _SE(js_cc_scene_Model__initLocalSHDescriptors)); 
    cls->defineFunction("initWorldBoundDescriptors", _SE(js_cc_scene_Model_initWorldBoundDescriptors)); 
    cls->defineFunction("onGlobalPipelineStateChanged", _SE(js_cc_scene_Model_onGlobalPipelineStateChanged)); 
    cls->defineFunction("onMacroPatchesStateChanged", _SE(js_cc_scene_Model_onMacroPatchesStateChanged)); 
    cls->defineFunction("onGeometryChanged", _SE(js_cc_scene_Model_onGeometryChanged)); 
    cls->defineFunction("setSubModelMesh", _SE(js_cc_scene_Model_setSubModelMesh)); 
    cls->defineFunction("setInstancedAttribute", _SE(js_cc_scene_Model_setInstancedAttribute)); 
    cls->defineFunction("updateWorldBound", _SE(js_cc_scene_Model_updateWorldBound)); 
    cls->defineFunction("updateWorldBoundsForJSSkinningModel", _SE(js_cc_scene_Model_updateWorldBoundsForJSSkinningModel)); 
    cls->defineFunction("updateWorldBoundsForJSBakedSkinningModel", _SE(js_cc_scene_Model_updateWorldBoundsForJSBakedSkinningModel)); 
    cls->defineFunction("updateLightingmap", _SE(js_cc_scene_Model_updateLightingmap)); 
    cls->defineFunction("clearSHUBOs", _SE(js_cc_scene_Model_clearSHUBOs)); 
    cls->defineFunction("updateSHUBOs", _SE(js_cc_scene_Model_updateSHUBOs)); 
    cls->defineFunction("updateWorldBoundUBOs", _SE(js_cc_scene_Model_updateWorldBoundUBOs)); 
    cls->defineFunction("updateLocalShadowBias", _SE(js_cc_scene_Model_updateLocalShadowBias)); 
    cls->defineFunction("updateReflectionProbeCubemap", _SE(js_cc_scene_Model_updateReflectionProbeCubemap)); 
    cls->defineFunction("updateReflectionProbePlanarMap", _SE(js_cc_scene_Model_updateReflectionProbePlanarMap)); 
    cls->defineFunction("attachToScene", _SE(js_cc_scene_Model_attachToScene)); 
    cls->defineFunction("detachFromScene", _SE(js_cc_scene_Model_detachFromScene)); 
    cls->defineFunction("setLocalSHBuffer", _SE(js_cc_scene_Model_setLocalSHBuffer)); 
    cls->defineFunction("setBounds", _SE(js_cc_scene_Model_setBounds)); 
    cls->defineFunction("showTetrahedron", _SE(js_cc_scene_Model_showTetrahedron)); 
    cls->defineFunction("getLocalSHBuffer", _SE(js_cc_scene_Model_getLocalSHBuffer)); 
    cls->defineFunction("getLocalSHData", _SE(js_cc_scene_Model_getLocalSHData)); 
    cls->defineFunction("setCalledFromJS", _SE(js_cc_scene_Model_setCalledFromJS)); 
    cls->defineFunction("isModelImplementedInJS", _SE(js_cc_scene_Model_isModelImplementedInJS)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_Model));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::Model>(cls);
    
    __jsb_cc_scene_Model_proto = cls->getProto();
    __jsb_cc_scene_Model_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_InstancedAttributeBlock_class = nullptr;
se::Object* __jsb_cc_scene_InstancedAttributeBlock_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_InstancedAttributeBlock) 

static bool js_cc_scene_IInstancedAttributeBlock_buffer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::InstancedAttributeBlock *arg1 = (cc::scene::InstancedAttributeBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::InstancedAttributeBlock>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->buffer, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IInstancedAttributeBlock_buffer_set) 

static bool js_cc_scene_IInstancedAttributeBlock_buffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::InstancedAttributeBlock *arg1 = (cc::scene::InstancedAttributeBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::InstancedAttributeBlock>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->buffer, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->buffer, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IInstancedAttributeBlock_buffer_get) 

static bool js_cc_scene_IInstancedAttributeBlock_views_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::InstancedAttributeBlock *arg1 = (cc::scene::InstancedAttributeBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::InstancedAttributeBlock>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->views, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IInstancedAttributeBlock_views_set) 

static bool js_cc_scene_IInstancedAttributeBlock_views_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::InstancedAttributeBlock *arg1 = (cc::scene::InstancedAttributeBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::InstancedAttributeBlock>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->views, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->views, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IInstancedAttributeBlock_views_get) 

static bool js_cc_scene_IInstancedAttributeBlock_attributes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::InstancedAttributeBlock *arg1 = (cc::scene::InstancedAttributeBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::InstancedAttributeBlock>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->attributes, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IInstancedAttributeBlock_attributes_set) 

static bool js_cc_scene_IInstancedAttributeBlock_attributes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::InstancedAttributeBlock *arg1 = (cc::scene::InstancedAttributeBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::InstancedAttributeBlock>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->attributes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->attributes, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IInstancedAttributeBlock_attributes_get) 

static bool js_new_cc_scene_InstancedAttributeBlock(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::InstancedAttributeBlock *result;
    result = (cc::scene::InstancedAttributeBlock *)new cc::scene::InstancedAttributeBlock();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_InstancedAttributeBlock, __jsb_cc_scene_InstancedAttributeBlock_class, js_delete_cc_scene_InstancedAttributeBlock)

static bool js_delete_cc_scene_InstancedAttributeBlock(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_InstancedAttributeBlock) 

template<>
bool sevalue_to_native(const se::Value &from, cc::scene::InstancedAttributeBlock * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::scene::InstancedAttributeBlock*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("buffer", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->buffer), ctx);
    }
    
    
    json->getProperty("views", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->views), ctx);
    }
    
    
    json->getProperty("attributes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->attributes), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_scene_InstancedAttributeBlock(se::Object* obj) {
    auto* cls = se::Class::create("IInstancedAttributeBlock", obj, nullptr, _SE(js_new_cc_scene_InstancedAttributeBlock)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("buffer", _SE(js_cc_scene_IInstancedAttributeBlock_buffer_get), _SE(js_cc_scene_IInstancedAttributeBlock_buffer_set)); 
    cls->defineProperty("views", _SE(js_cc_scene_IInstancedAttributeBlock_views_get), _SE(js_cc_scene_IInstancedAttributeBlock_views_set)); 
    cls->defineProperty("attributes", _SE(js_cc_scene_IInstancedAttributeBlock_attributes_get), _SE(js_cc_scene_IInstancedAttributeBlock_attributes_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_InstancedAttributeBlock));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::InstancedAttributeBlock>(cls);
    
    __jsb_cc_scene_InstancedAttributeBlock_proto = cls->getProto();
    __jsb_cc_scene_InstancedAttributeBlock_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_SubModel_class = nullptr;
se::Object* __jsb_cc_scene_SubModel_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_SubModel) 

static bool js_new_cc_scene_SubModel(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::SubModel *result;
    result = (cc::scene::SubModel *)new cc::scene::SubModel();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_SubModel, __jsb_cc_scene_SubModel_class, js_delete_cc_scene_SubModel)

static bool js_delete_cc_scene_SubModel(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_SubModel) 

static bool js_cc_scene_SubModel_update(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    (arg1)->update();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_update) 

static bool js_cc_scene_SubModel_getShader(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Shader *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (cc::gfx::Shader *)((cc::scene::SubModel const *)arg1)->getShader(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_getShader) 

static bool js_cc_scene_SubModel_getPass(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    uint32_t arg2 ;
    cc::scene::Pass *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (cc::scene::Pass *)((cc::scene::SubModel const *)arg1)->getPass(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_getPass) 

static bool js_cc_scene_SubModel_setWorldBoundDescriptorSet(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::gfx::DescriptorSet *arg2 = (cc::gfx::DescriptorSet *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setWorldBoundDescriptorSet(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_setWorldBoundDescriptorSet) 

static bool js_cc_scene_SubModel_setOwner(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::scene::Model *arg2 = (cc::scene::Model *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setOwner(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_setOwner) 

static bool js_cc_scene_SubModel_setInstancedAttribute(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    ccstd::string *arg2 = 0 ;
    float *arg3 = (float *) NULL ;
    uint32_t arg4 ;
    ccstd::string temp2 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setInstancedAttribute((ccstd::string const &)*arg2,(float const *)arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_setInstancedAttribute) 

static bool js_cc_scene_SubModel_getWorldBoundDescriptorSet(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::gfx::DescriptorSet *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::DescriptorSet *)((cc::scene::SubModel const *)arg1)->getWorldBoundDescriptorSet();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_getWorldBoundDescriptorSet) 

static bool js_cc_scene_SubModel_getOwner(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::scene::Model *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::Model *)((cc::scene::SubModel const *)arg1)->getOwner();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_getOwner) 

static bool js_cc_scene_SubModel_getId(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    result = ((cc::scene::SubModel const *)arg1)->getId();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_getId) 

static bool js_cc_scene_SubModel_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::RenderingSubMesh *arg2 = (cc::RenderingSubMesh *) NULL ;
    std::shared_ptr< ccstd::vector< cc::IntrusivePtr< cc::scene::Pass > > > *arg3 = 0 ;
    ccstd::vector< cc::scene::IMacroPatch > *arg4 = 0 ;
    std::shared_ptr< ccstd::vector< cc::IntrusivePtr< cc::scene::Pass > > > temp3 ;
    ccstd::vector< cc::scene::IMacroPatch > temp4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    (arg1)->initialize(arg2,(std::shared_ptr< ccstd::vector< cc::IntrusivePtr< cc::scene::Pass > > > const &)*arg3,(ccstd::vector< cc::scene::IMacroPatch > const &)*arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_initialize) 

static bool js_cc_scene_SubModel_initPlanarShadowShader(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    (arg1)->initPlanarShadowShader();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_initPlanarShadowShader) 

static bool js_cc_scene_SubModel_initPlanarShadowInstanceShader(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    (arg1)->initPlanarShadowInstanceShader();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_initPlanarShadowInstanceShader) 

static bool js_cc_scene_SubModel_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_destroy) 

static bool js_cc_scene_SubModel_onPipelineStateChanged(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    (arg1)->onPipelineStateChanged();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_onPipelineStateChanged) 

static bool js_cc_scene_SubModel_onMacroPatchesStateChanged(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    ccstd::vector< cc::scene::IMacroPatch > *arg2 = 0 ;
    ccstd::vector< cc::scene::IMacroPatch > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->onMacroPatchesStateChanged((ccstd::vector< cc::scene::IMacroPatch > const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_onMacroPatchesStateChanged) 

static bool js_cc_scene_SubModel_onGeometryChanged(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    (arg1)->onGeometryChanged();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_onGeometryChanged) 

static bool js_cc_scene_SubModel_getReflectionProbeType(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    int32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    result = ((cc::scene::SubModel const *)arg1)->getReflectionProbeType();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_getReflectionProbeType) 

static bool js_cc_scene_SubModel_setReflectionProbeType(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    int32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setReflectionProbeType(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_setReflectionProbeType) 

static bool js_cc_scene_SubModel_passes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    std::shared_ptr< ccstd::vector< cc::IntrusivePtr< cc::scene::Pass > > > *arg2 = 0 ;
    std::shared_ptr< ccstd::vector< cc::IntrusivePtr< cc::scene::Pass > > > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_SubModel_passes_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SubModel_passes_set) 

static bool js_cc_scene_SubModel_passes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    std::shared_ptr< ccstd::vector< cc::IntrusivePtr< cc::scene::Pass > > > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    result = (std::shared_ptr< ccstd::vector< cc::IntrusivePtr< cc::scene::Pass > > > *) &cc_scene_SubModel_passes_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SubModel_passes_get) 

static bool js_cc_scene_SubModel_shaders_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::gfx::Shader > > *arg2 = 0 ;
    ccstd::vector< cc::IntrusivePtr< cc::gfx::Shader > > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_SubModel_shaders_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SubModel_shaders_set) 

static bool js_cc_scene_SubModel_shaders_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::gfx::Shader > > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::IntrusivePtr< cc::gfx::Shader > > *) &cc_scene_SubModel_shaders_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SubModel_shaders_get) 

static bool js_cc_scene_SubModel_subMesh_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::RenderingSubMesh *arg2 = (cc::RenderingSubMesh *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SubModel_subMesh_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SubModel_subMesh_set) 

static bool js_cc_scene_SubModel_subMesh_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::RenderingSubMesh *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    result = (cc::RenderingSubMesh *)cc_scene_SubModel_subMesh_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SubModel_subMesh_get) 

static bool js_cc_scene_SubModel_priority_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::pipeline::RenderPriority arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_scene_SubModel_priority_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SubModel_priority_set) 

static bool js_cc_scene_SubModel_priority_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::pipeline::RenderPriority result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_SubModel_priority_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SubModel_priority_get) 

static bool js_cc_scene_SubModel_inputAssembler_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::gfx::InputAssembler *arg2 = (cc::gfx::InputAssembler *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SubModel_inputAssembler_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SubModel_inputAssembler_set) 

static bool js_cc_scene_SubModel_inputAssembler_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::gfx::InputAssembler *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::InputAssembler *)cc_scene_SubModel_inputAssembler_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SubModel_inputAssembler_get) 

static bool js_cc_scene_SubModel_descriptorSet_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::gfx::DescriptorSet *arg2 = (cc::gfx::DescriptorSet *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SubModel_descriptorSet_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SubModel_descriptorSet_set) 

static bool js_cc_scene_SubModel_descriptorSet_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::gfx::DescriptorSet *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::DescriptorSet *)cc_scene_SubModel_descriptorSet_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SubModel_descriptorSet_get) 

static bool js_cc_scene_SubModel_patches_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    ccstd::vector< cc::scene::IMacroPatch > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::scene::IMacroPatch > *) &cc_scene_SubModel_patches_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SubModel_patches_get) 

static bool js_cc_scene_SubModel_planarInstanceShader_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::gfx::Shader *arg2 = (cc::gfx::Shader *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SubModel_planarInstanceShader_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SubModel_planarInstanceShader_set) 

static bool js_cc_scene_SubModel_planarInstanceShader_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::gfx::Shader *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Shader *)cc_scene_SubModel_planarInstanceShader_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SubModel_planarInstanceShader_get) 

static bool js_cc_scene_SubModel_planarShader_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::gfx::Shader *arg2 = (cc::gfx::Shader *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_SubModel_planarShader_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SubModel_planarShader_set) 

static bool js_cc_scene_SubModel_planarShader_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::gfx::Shader *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Shader *)cc_scene_SubModel_planarShader_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SubModel_planarShader_get) 

bool js_register_cc_scene_SubModel(se::Object* obj) {
    auto* cls = se::Class::create("SubModel", obj, nullptr, _SE(js_new_cc_scene_SubModel)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("passes", _SE(js_cc_scene_SubModel_passes_get), _SE(js_cc_scene_SubModel_passes_set)); 
    cls->defineProperty("shaders", _SE(js_cc_scene_SubModel_shaders_get), _SE(js_cc_scene_SubModel_shaders_set)); 
    cls->defineProperty("subMesh", _SE(js_cc_scene_SubModel_subMesh_get), _SE(js_cc_scene_SubModel_subMesh_set)); 
    cls->defineProperty("priority", _SE(js_cc_scene_SubModel_priority_get), _SE(js_cc_scene_SubModel_priority_set)); 
    cls->defineProperty("inputAssembler", _SE(js_cc_scene_SubModel_inputAssembler_get), _SE(js_cc_scene_SubModel_inputAssembler_set)); 
    cls->defineProperty("descriptorSet", _SE(js_cc_scene_SubModel_descriptorSet_get), _SE(js_cc_scene_SubModel_descriptorSet_set)); 
    cls->defineProperty("patches", _SE(js_cc_scene_SubModel_patches_get), nullptr); 
    cls->defineProperty("planarInstanceShader", _SE(js_cc_scene_SubModel_planarInstanceShader_get), _SE(js_cc_scene_SubModel_planarInstanceShader_set)); 
    cls->defineProperty("planarShader", _SE(js_cc_scene_SubModel_planarShader_get), _SE(js_cc_scene_SubModel_planarShader_set)); 
    
    cls->defineFunction("update", _SE(js_cc_scene_SubModel_update)); 
    cls->defineFunction("getShader", _SE(js_cc_scene_SubModel_getShader)); 
    cls->defineFunction("getPass", _SE(js_cc_scene_SubModel_getPass)); 
    cls->defineFunction("setWorldBoundDescriptorSet", _SE(js_cc_scene_SubModel_setWorldBoundDescriptorSet)); 
    cls->defineFunction("setOwner", _SE(js_cc_scene_SubModel_setOwner)); 
    cls->defineFunction("setInstancedAttribute", _SE(js_cc_scene_SubModel_setInstancedAttribute)); 
    cls->defineFunction("getWorldBoundDescriptorSet", _SE(js_cc_scene_SubModel_getWorldBoundDescriptorSet)); 
    cls->defineFunction("getOwner", _SE(js_cc_scene_SubModel_getOwner)); 
    cls->defineFunction("getId", _SE(js_cc_scene_SubModel_getId)); 
    cls->defineFunction("initialize", _SE(js_cc_scene_SubModel_initialize)); 
    cls->defineFunction("initPlanarShadowShader", _SE(js_cc_scene_SubModel_initPlanarShadowShader)); 
    cls->defineFunction("initPlanarShadowInstanceShader", _SE(js_cc_scene_SubModel_initPlanarShadowInstanceShader)); 
    cls->defineFunction("destroy", _SE(js_cc_scene_SubModel_destroy)); 
    cls->defineFunction("onPipelineStateChanged", _SE(js_cc_scene_SubModel_onPipelineStateChanged)); 
    cls->defineFunction("onMacroPatchesStateChanged", _SE(js_cc_scene_SubModel_onMacroPatchesStateChanged)); 
    cls->defineFunction("onGeometryChanged", _SE(js_cc_scene_SubModel_onGeometryChanged)); 
    cls->defineFunction("getReflectionProbeType", _SE(js_cc_scene_SubModel_getReflectionProbeType)); 
    cls->defineFunction("setReflectionProbeType", _SE(js_cc_scene_SubModel_setReflectionProbeType)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_SubModel));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::SubModel>(cls);
    
    __jsb_cc_scene_SubModel_proto = cls->getProto();
    __jsb_cc_scene_SubModel_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_PassDynamicsValue_class = nullptr;
se::Object* __jsb_cc_scene_PassDynamicsValue_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_PassDynamicsValue) 

static bool js_cc_scene_PassDynamicsValue_dirty_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::PassDynamicsValue *arg1 = (cc::scene::PassDynamicsValue *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::PassDynamicsValue>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->dirty);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_PassDynamicsValue_dirty_set) 

static bool js_cc_scene_PassDynamicsValue_dirty_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::PassDynamicsValue *arg1 = (cc::scene::PassDynamicsValue *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::PassDynamicsValue>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->dirty, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_PassDynamicsValue_dirty_get) 

static bool js_cc_scene_PassDynamicsValue_value_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::PassDynamicsValue *arg1 = (cc::scene::PassDynamicsValue *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::PassDynamicsValue>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->value, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_PassDynamicsValue_value_set) 

static bool js_cc_scene_PassDynamicsValue_value_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::PassDynamicsValue *arg1 = (cc::scene::PassDynamicsValue *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::PassDynamicsValue>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->value, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_PassDynamicsValue_value_get) 

static bool js_new_cc_scene_PassDynamicsValue(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::PassDynamicsValue *result;
    result = (cc::scene::PassDynamicsValue *)new cc::scene::PassDynamicsValue();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_PassDynamicsValue, __jsb_cc_scene_PassDynamicsValue_class, js_delete_cc_scene_PassDynamicsValue)

static bool js_delete_cc_scene_PassDynamicsValue(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_PassDynamicsValue) 

template<>
bool sevalue_to_native(const se::Value &from, cc::scene::PassDynamicsValue * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::scene::PassDynamicsValue*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("dirty", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dirty), ctx);
    }
    
    
    json->getProperty("value", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->value), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_scene_PassDynamicsValue(se::Object* obj) {
    auto* cls = se::Class::create("PassDynamicsValue", obj, nullptr, _SE(js_new_cc_scene_PassDynamicsValue)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("dirty", _SE(js_cc_scene_PassDynamicsValue_dirty_get), _SE(js_cc_scene_PassDynamicsValue_dirty_set)); 
    cls->defineProperty("value", _SE(js_cc_scene_PassDynamicsValue_value_get), _SE(js_cc_scene_PassDynamicsValue_value_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_PassDynamicsValue));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::PassDynamicsValue>(cls);
    
    __jsb_cc_scene_PassDynamicsValue_proto = cls->getProto();
    __jsb_cc_scene_PassDynamicsValue_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_IBlockRef_class = nullptr;
se::Object* __jsb_cc_scene_IBlockRef_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_IBlockRef) 

static bool js_cc_scene_IBlockRef_data_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::IBlockRef *arg1 = (cc::scene::IBlockRef *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IBlockRef>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->data, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IBlockRef_data_set) 

static bool js_cc_scene_IBlockRef_data_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::IBlockRef *arg1 = (cc::scene::IBlockRef *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IBlockRef>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->data, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->data, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IBlockRef_data_get) 

static bool js_cc_scene_IBlockRef_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::IBlockRef *arg1 = (cc::scene::IBlockRef *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IBlockRef>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->count, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IBlockRef_count_set) 

static bool js_cc_scene_IBlockRef_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::IBlockRef *arg1 = (cc::scene::IBlockRef *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IBlockRef>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IBlockRef_count_get) 

static bool js_cc_scene_IBlockRef_offset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::IBlockRef *arg1 = (cc::scene::IBlockRef *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IBlockRef>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->offset, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IBlockRef_offset_set) 

static bool js_cc_scene_IBlockRef_offset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::IBlockRef *arg1 = (cc::scene::IBlockRef *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IBlockRef>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->offset, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IBlockRef_offset_get) 

static bool js_new_cc_scene_IBlockRef(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::IBlockRef *result;
    result = (cc::scene::IBlockRef *)new cc::scene::IBlockRef();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_IBlockRef, __jsb_cc_scene_IBlockRef_class, js_delete_cc_scene_IBlockRef)

static bool js_delete_cc_scene_IBlockRef(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_IBlockRef) 

template<>
bool sevalue_to_native(const se::Value &from, cc::scene::IBlockRef * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::scene::IBlockRef*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("data", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->data), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("offset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->offset), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_scene_IBlockRef(se::Object* obj) {
    auto* cls = se::Class::create("IBlockRef", obj, nullptr, _SE(js_new_cc_scene_IBlockRef)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("data", _SE(js_cc_scene_IBlockRef_data_get), _SE(js_cc_scene_IBlockRef_data_set)); 
    cls->defineProperty("count", _SE(js_cc_scene_IBlockRef_count_get), _SE(js_cc_scene_IBlockRef_count_set)); 
    cls->defineProperty("offset", _SE(js_cc_scene_IBlockRef_offset_get), _SE(js_cc_scene_IBlockRef_offset_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_IBlockRef));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::IBlockRef>(cls);
    
    __jsb_cc_scene_IBlockRef_proto = cls->getProto();
    __jsb_cc_scene_IBlockRef_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_Pass_class = nullptr;
se::Object* __jsb_cc_scene_Pass_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_Pass) 

static bool js_cc_scene_Pass_getTypeFromHandle_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    uint32_t arg1 ;
    cc::gfx::Type result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = cc::scene::Pass::getTypeFromHandle(SWIG_STD_MOVE(arg1));
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_getTypeFromHandle_static) 

static bool js_cc_scene_Pass_getBindingFromHandle_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    uint32_t arg1 ;
    uint32_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = cc::scene::Pass::getBindingFromHandle(SWIG_STD_MOVE(arg1));
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_getBindingFromHandle_static) 

static bool js_cc_scene_Pass_getCountFromHandle_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    uint32_t arg1 ;
    uint32_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = cc::scene::Pass::getCountFromHandle(SWIG_STD_MOVE(arg1));
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_getCountFromHandle_static) 

static bool js_cc_scene_Pass_getOffsetFromHandle_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    uint32_t arg1 ;
    uint32_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = cc::scene::Pass::getOffsetFromHandle(SWIG_STD_MOVE(arg1));
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_getOffsetFromHandle_static) 

static bool js_cc_scene_Pass_fillPipelineInfo_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::IPassInfoFull *arg2 = 0 ;
    cc::IPassInfoFull temp2 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc::scene::Pass::fillPipelineInfo(arg1,(cc::IPassInfoFull const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_fillPipelineInfo_static) 

static bool js_cc_scene_Pass_getPassHash_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    ccstd::hash_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = cc::scene::Pass::getPassHash(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_getPassHash_static) 

static bool js_new_cc_scene_Pass__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::scene::Pass *result;
    result = (cc::scene::Pass *)new cc::scene::Pass();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_scene_Pass__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::Pass *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::scene::Pass *)new cc::scene::Pass(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_Pass(se::State& s) // NOLINT(readability-identifier-naming)
{
    size_t argc = s.args().size();
    bool ret = false;
    
    if(argc == 0) {
        ret = js_new_cc_scene_Pass__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 1) {
        ret = js_new_cc_scene_Pass__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    SE_REPORT_ERROR("Illegal arguments for construction of Pass");
    return false;
}
SE_BIND_CTOR(js_new_Pass, __jsb_cc_scene_Pass_class, js_delete_cc_scene_Pass)

static bool js_delete_cc_scene_Pass(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_Pass) 

static bool js_cc_scene_Pass_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::IPassInfoFull *arg2 = 0 ;
    cc::IPassInfoFull temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::IPassInfoFull const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_initialize) 

static bool js_cc_scene_Pass_getHandle__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    ccstd::string *arg2 = 0 ;
    uint32_t arg3 ;
    cc::gfx::Type arg4 ;
    ccstd::string temp2 ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = ((cc::scene::Pass const *)arg1)->getHandle((ccstd::string const &)*arg2,arg3,arg4);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}

static bool js_cc_scene_Pass_getHandle__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    ccstd::string *arg2 = 0 ;
    uint32_t arg3 ;
    ccstd::string temp2 ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = ((cc::scene::Pass const *)arg1)->getHandle((ccstd::string const &)*arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}

static bool js_cc_scene_Pass_getHandle__SWIG_2(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = ((cc::scene::Pass const *)arg1)->getHandle((ccstd::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}

static bool js_cc_scene_Pass_getHandle(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_scene_Pass_getHandle__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_scene_Pass_getHandle__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_scene_Pass_getHandle__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_scene_Pass_getHandle) 

static bool js_cc_scene_Pass_getBinding(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    uint32_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = ((cc::scene::Pass const *)arg1)->getBinding((ccstd::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_getBinding) 

static bool js_cc_scene_Pass_setUniform(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    uint32_t arg2 ;
    cc::MaterialProperty *arg3 = 0 ;
    cc::MaterialProperty temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setUniform(arg2,(cc::MaterialProperty const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_setUniform) 

static bool js_cc_scene_Pass_getUniform(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    uint32_t arg2 ;
    cc::MaterialProperty *arg3 = 0 ;
    cc::MaterialProperty temp3 ;
    cc::MaterialProperty *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    result = (cc::MaterialProperty *) &((cc::scene::Pass const *)arg1)->getUniform(arg2,*arg3);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_getUniform) 

static bool js_cc_scene_Pass_setUniformArray(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    uint32_t arg2 ;
    cc::MaterialPropertyList *arg3 = 0 ;
    cc::MaterialPropertyList temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setUniformArray(arg2,(cc::MaterialPropertyList const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_setUniformArray) 

static bool js_cc_scene_Pass_bindTexture__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Texture *arg3 = (cc::gfx::Texture *) NULL ;
    uint32_t arg4 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->bindTexture(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_scene_Pass_bindTexture__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Texture *arg3 = (cc::gfx::Texture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->bindTexture(arg2,arg3);
    
    
    return true;
}

static bool js_cc_scene_Pass_bindTexture(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_scene_Pass_bindTexture__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_scene_Pass_bindTexture__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_scene_Pass_bindTexture) 

static bool js_cc_scene_Pass_bindSampler__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Sampler *arg3 = (cc::gfx::Sampler *) NULL ;
    uint32_t arg4 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->bindSampler(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_scene_Pass_bindSampler__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Sampler *arg3 = (cc::gfx::Sampler *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->bindSampler(arg2,arg3);
    
    
    return true;
}

static bool js_cc_scene_Pass_bindSampler(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_scene_Pass_bindSampler__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_scene_Pass_bindSampler__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_scene_Pass_bindSampler) 

static bool js_cc_scene_Pass_setDynamicState(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::gfx::DynamicStateFlagBit arg2 ;
    float arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setDynamicState(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_setDynamicState) 

static bool js_cc_scene_Pass_overridePipelineStates(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::IPassInfo *arg2 = 0 ;
    cc::PassOverrides *arg3 = 0 ;
    cc::IPassInfo temp2 ;
    cc::PassOverrides temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->overridePipelineStates((cc::IPassInfo const &)*arg2,(cc::PassOverrides const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_overridePipelineStates) 

static bool js_cc_scene_Pass_update(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    (arg1)->update();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_update) 

static bool js_cc_scene_Pass_getInstancedBuffer__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    int32_t arg2 ;
    cc::pipeline::InstancedBuffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::pipeline::InstancedBuffer *)(arg1)->getInstancedBuffer(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_scene_Pass_getInstancedBuffer__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::pipeline::InstancedBuffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = (cc::pipeline::InstancedBuffer *)(arg1)->getInstancedBuffer();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_scene_Pass_getInstancedBuffer(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_cc_scene_Pass_getInstancedBuffer__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 0) {
        ok = js_cc_scene_Pass_getInstancedBuffer__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_scene_Pass_getInstancedBuffer) 

static bool js_cc_scene_Pass_getBatchedBuffer__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    int32_t arg2 ;
    cc::pipeline::BatchedBuffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::pipeline::BatchedBuffer *)(arg1)->getBatchedBuffer(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_scene_Pass_getBatchedBuffer__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::pipeline::BatchedBuffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = (cc::pipeline::BatchedBuffer *)(arg1)->getBatchedBuffer();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_scene_Pass_getBatchedBuffer(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_cc_scene_Pass_getBatchedBuffer__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 0) {
        ok = js_cc_scene_Pass_getBatchedBuffer__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_scene_Pass_getBatchedBuffer) 

static bool js_cc_scene_Pass_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_destroy) 

static bool js_cc_scene_Pass_resetUniform(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->resetUniform((ccstd::string const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_resetUniform) 

static bool js_cc_scene_Pass_resetTexture__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->resetTexture((ccstd::string const &)*arg2);
    
    
    return true;
}

static bool js_cc_scene_Pass_resetTexture__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    ccstd::string *arg2 = 0 ;
    uint32_t arg3 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->resetTexture((ccstd::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_scene_Pass_resetTexture(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_cc_scene_Pass_resetTexture__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_scene_Pass_resetTexture__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_scene_Pass_resetTexture) 

static bool js_cc_scene_Pass_resetUBOs(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    (arg1)->resetUBOs();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_resetUBOs) 

static bool js_cc_scene_Pass_resetTextures(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    (arg1)->resetTextures();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_resetTextures) 

static bool js_cc_scene_Pass_tryCompile__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->tryCompile();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}

static bool js_cc_scene_Pass_tryCompile__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    ccstd::optional< cc::MacroRecord > *arg2 = 0 ;
    ccstd::optional< cc::MacroRecord > temp2 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (bool)(arg1)->tryCompile((ccstd::optional< cc::MacroRecord > const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}

static bool js_cc_scene_Pass_tryCompile(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 0) {
        ok = js_cc_scene_Pass_tryCompile__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_scene_Pass_tryCompile__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_scene_Pass_tryCompile) 

static bool js_cc_scene_Pass_getShaderVariant__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::gfx::Shader *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Shader *)(arg1)->getShaderVariant();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_scene_Pass_getShaderVariant__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    ccstd::vector< cc::scene::IMacroPatch > *arg2 = 0 ;
    ccstd::vector< cc::scene::IMacroPatch > temp2 ;
    cc::gfx::Shader *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::gfx::Shader *)(arg1)->getShaderVariant((ccstd::vector< cc::scene::IMacroPatch > const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_scene_Pass_getShaderVariant(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 0) {
        ok = js_cc_scene_Pass_getShaderVariant__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_scene_Pass_getShaderVariant__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_scene_Pass_getShaderVariant) 

static bool js_cc_scene_Pass_getPassInfoFull(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::IPassInfoFull result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = ((cc::scene::Pass const *)arg1)->getPassInfoFull();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_getPassInfoFull) 

static bool js_cc_scene_Pass_getRootBlock(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::ArrayBuffer *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = (cc::ArrayBuffer *)(arg1)->getRootBlock();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_getRootBlock) 

static bool js_cc_scene_Pass__updatePassHash(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    (arg1)->updatePassHash();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass__updatePassHash) 

static bool js_cc_scene_Pass_beginChangeStatesSilently(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    (arg1)->beginChangeStatesSilently();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_beginChangeStatesSilently) 

static bool js_cc_scene_Pass_endChangeStatesSilently(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    (arg1)->endChangeStatesSilently();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_endChangeStatesSilently) 

static bool js_cc_scene_Pass_root_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::Root *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = (cc::Root *)cc_scene_Pass_root_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_root_get) 

static bool js_cc_scene_Pass_device_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::gfx::Device *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Device *)cc_scene_Pass_device_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_device_get) 

static bool js_cc_scene_Pass_shaderInfo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::IProgramInfo *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = (cc::IProgramInfo *)cc_scene_Pass_shaderInfo_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_shaderInfo_get) 

static bool js_cc_scene_Pass_localSetLayout_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::gfx::DescriptorSetLayout *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::DescriptorSetLayout *)cc_scene_Pass_localSetLayout_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_localSetLayout_get) 

static bool js_cc_scene_Pass_program_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    ccstd::string *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::string *) &cc_scene_Pass_program_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_program_get) 

static bool js_cc_scene_Pass_properties_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    Record< ccstd::string,cc::IPropertyInfo > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = (Record< ccstd::string,cc::IPropertyInfo > *) &cc_scene_Pass_properties_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_properties_get) 

static bool js_cc_scene_Pass_defines_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::MacroRecord *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = (cc::MacroRecord *) &cc_scene_Pass_defines_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_defines_get) 

static bool js_cc_scene_Pass_passIndex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    index_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_Pass_passIndex_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_passIndex_get) 

static bool js_cc_scene_Pass_propertyIndex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    index_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_Pass_propertyIndex_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_propertyIndex_get) 

static bool js_cc_scene_Pass_dynamics_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::scene::IPassDynamics *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::IPassDynamics *) &cc_scene_Pass_dynamics_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_dynamics_get) 

static bool js_cc_scene_Pass_rootBufferDirty_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_Pass_rootBufferDirty_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_rootBufferDirty_get) 

static bool js_cc_scene_Pass__rootBufferDirty_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Pass__rootBufferDirty_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Pass__rootBufferDirty_set) 

static bool js_cc_scene_Pass__rootBufferDirty_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_Pass__rootBufferDirty_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass__rootBufferDirty_get) 

static bool js_cc_scene_Pass_priority_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::pipeline::RenderPriority result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_Pass_priority_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_priority_get) 

static bool js_cc_scene_Pass_primitive_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::gfx::PrimitiveMode result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_Pass_primitive_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_primitive_get) 

static bool js_cc_scene_Pass_stage_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::pipeline::RenderPassStage result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_Pass_stage_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_stage_get) 

static bool js_cc_scene_Pass_phase_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_Pass_phase_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_phase_get) 

static bool js_cc_scene_Pass_rasterizerState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::gfx::RasterizerState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::RasterizerState *)cc_scene_Pass_rasterizerState_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_rasterizerState_get) 

static bool js_cc_scene_Pass_depthStencilState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::gfx::DepthStencilState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::DepthStencilState *)cc_scene_Pass_depthStencilState_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_depthStencilState_get) 

static bool js_cc_scene_Pass_blendState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::gfx::BlendState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::BlendState *)cc_scene_Pass_blendState_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_blendState_get) 

static bool js_cc_scene_Pass_dynamicStates_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::gfx::DynamicStateFlagBit result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_Pass_dynamicStates_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_dynamicStates_get) 

static bool js_cc_scene_Pass_batchingScheme_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::scene::BatchingSchemes result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::BatchingSchemes)cc_scene_Pass_batchingScheme_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_batchingScheme_get) 

static bool js_cc_scene_Pass_descriptorSet_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::gfx::DescriptorSet *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::DescriptorSet *)cc_scene_Pass_descriptorSet_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_descriptorSet_get) 

static bool js_cc_scene_Pass_hash_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    ccstd::hash_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_Pass_hash_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_hash_get) 

static bool js_cc_scene_Pass_pipelineLayout_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::gfx::PipelineLayout *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::PipelineLayout *)cc_scene_Pass_pipelineLayout_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_pipelineLayout_get) 

bool js_register_cc_scene_Pass(se::Object* obj) {
    auto* cls = se::Class::create("Pass", obj, nullptr, _SE(js_new_Pass)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("root", _SE(js_cc_scene_Pass_root_get), nullptr); 
    cls->defineProperty("device", _SE(js_cc_scene_Pass_device_get), nullptr); 
    cls->defineProperty("shaderInfo", _SE(js_cc_scene_Pass_shaderInfo_get), nullptr); 
    cls->defineProperty("localSetLayout", _SE(js_cc_scene_Pass_localSetLayout_get), nullptr); 
    cls->defineProperty("program", _SE(js_cc_scene_Pass_program_get), nullptr); 
    cls->defineProperty("properties", _SE(js_cc_scene_Pass_properties_get), nullptr); 
    cls->defineProperty("defines", _SE(js_cc_scene_Pass_defines_get), nullptr); 
    cls->defineProperty("passIndex", _SE(js_cc_scene_Pass_passIndex_get), nullptr); 
    cls->defineProperty("propertyIndex", _SE(js_cc_scene_Pass_propertyIndex_get), nullptr); 
    cls->defineProperty("dynamics", _SE(js_cc_scene_Pass_dynamics_get), nullptr); 
    cls->defineProperty("rootBufferDirty", _SE(js_cc_scene_Pass_rootBufferDirty_get), nullptr); 
    cls->defineProperty("_rootBufferDirty", _SE(js_cc_scene_Pass__rootBufferDirty_get), _SE(js_cc_scene_Pass__rootBufferDirty_set)); 
    cls->defineProperty("priority", _SE(js_cc_scene_Pass_priority_get), nullptr); 
    cls->defineProperty("primitive", _SE(js_cc_scene_Pass_primitive_get), nullptr); 
    cls->defineProperty("stage", _SE(js_cc_scene_Pass_stage_get), nullptr); 
    cls->defineProperty("phase", _SE(js_cc_scene_Pass_phase_get), nullptr); 
    cls->defineProperty("rasterizerState", _SE(js_cc_scene_Pass_rasterizerState_get), nullptr); 
    cls->defineProperty("depthStencilState", _SE(js_cc_scene_Pass_depthStencilState_get), nullptr); 
    cls->defineProperty("blendState", _SE(js_cc_scene_Pass_blendState_get), nullptr); 
    cls->defineProperty("dynamicStates", _SE(js_cc_scene_Pass_dynamicStates_get), nullptr); 
    cls->defineProperty("batchingScheme", _SE(js_cc_scene_Pass_batchingScheme_get), nullptr); 
    cls->defineProperty("descriptorSet", _SE(js_cc_scene_Pass_descriptorSet_get), nullptr); 
    cls->defineProperty("hash", _SE(js_cc_scene_Pass_hash_get), nullptr); 
    cls->defineProperty("pipelineLayout", _SE(js_cc_scene_Pass_pipelineLayout_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_scene_Pass_initialize)); 
    cls->defineFunction("getHandle", _SE(js_cc_scene_Pass_getHandle)); 
    cls->defineFunction("getBinding", _SE(js_cc_scene_Pass_getBinding)); 
    cls->defineFunction("setUniform", _SE(js_cc_scene_Pass_setUniform)); 
    cls->defineFunction("getUniform", _SE(js_cc_scene_Pass_getUniform)); 
    cls->defineFunction("setUniformArray", _SE(js_cc_scene_Pass_setUniformArray)); 
    cls->defineFunction("bindTexture", _SE(js_cc_scene_Pass_bindTexture)); 
    cls->defineFunction("bindSampler", _SE(js_cc_scene_Pass_bindSampler)); 
    cls->defineFunction("setDynamicState", _SE(js_cc_scene_Pass_setDynamicState)); 
    cls->defineFunction("overridePipelineStates", _SE(js_cc_scene_Pass_overridePipelineStates)); 
    cls->defineFunction("update", _SE(js_cc_scene_Pass_update)); 
    cls->defineFunction("getInstancedBuffer", _SE(js_cc_scene_Pass_getInstancedBuffer)); 
    cls->defineFunction("getBatchedBuffer", _SE(js_cc_scene_Pass_getBatchedBuffer)); 
    cls->defineFunction("destroy", _SE(js_cc_scene_Pass_destroy)); 
    cls->defineFunction("resetUniform", _SE(js_cc_scene_Pass_resetUniform)); 
    cls->defineFunction("resetTexture", _SE(js_cc_scene_Pass_resetTexture)); 
    cls->defineFunction("resetUBOs", _SE(js_cc_scene_Pass_resetUBOs)); 
    cls->defineFunction("resetTextures", _SE(js_cc_scene_Pass_resetTextures)); 
    cls->defineFunction("tryCompile", _SE(js_cc_scene_Pass_tryCompile)); 
    cls->defineFunction("getShaderVariant", _SE(js_cc_scene_Pass_getShaderVariant)); 
    cls->defineFunction("getPassInfoFull", _SE(js_cc_scene_Pass_getPassInfoFull)); 
    cls->defineFunction("getRootBlock", _SE(js_cc_scene_Pass_getRootBlock)); 
    cls->defineFunction("_updatePassHash", _SE(js_cc_scene_Pass__updatePassHash)); 
    cls->defineFunction("beginChangeStatesSilently", _SE(js_cc_scene_Pass_beginChangeStatesSilently)); 
    cls->defineFunction("endChangeStatesSilently", _SE(js_cc_scene_Pass_endChangeStatesSilently)); 
    
    
    cls->defineStaticFunction("getTypeFromHandle", _SE(js_cc_scene_Pass_getTypeFromHandle_static)); 
    cls->defineStaticFunction("getBindingFromHandle", _SE(js_cc_scene_Pass_getBindingFromHandle_static)); 
    cls->defineStaticFunction("getCountFromHandle", _SE(js_cc_scene_Pass_getCountFromHandle_static)); 
    cls->defineStaticFunction("getOffsetFromHandle", _SE(js_cc_scene_Pass_getOffsetFromHandle_static)); 
    cls->defineStaticFunction("fillPipelineInfo", _SE(js_cc_scene_Pass_fillPipelineInfo_static)); 
    cls->defineStaticFunction("getPassHash", _SE(js_cc_scene_Pass_getPassHash_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_Pass));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::Pass>(cls);
    
    __jsb_cc_scene_Pass_proto = cls->getProto();
    __jsb_cc_scene_Pass_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_IRaycastResult_class = nullptr;
se::Object* __jsb_cc_scene_IRaycastResult_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_IRaycastResult) 

static bool js_cc_scene_IRaycastResult_node_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::IRaycastResult *arg1 = (cc::scene::IRaycastResult *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRaycastResult>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->node, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IRaycastResult_node_set) 

static bool js_cc_scene_IRaycastResult_node_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::IRaycastResult *arg1 = (cc::scene::IRaycastResult *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRaycastResult>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->node, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->node, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IRaycastResult_node_get) 

static bool js_cc_scene_IRaycastResult_distance_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::IRaycastResult *arg1 = (cc::scene::IRaycastResult *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRaycastResult>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->distance, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IRaycastResult_distance_set) 

static bool js_cc_scene_IRaycastResult_distance_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::IRaycastResult *arg1 = (cc::scene::IRaycastResult *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRaycastResult>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->distance, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IRaycastResult_distance_get) 

static bool js_new_cc_scene_IRaycastResult(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::IRaycastResult *result;
    result = (cc::scene::IRaycastResult *)new cc::scene::IRaycastResult();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_IRaycastResult, __jsb_cc_scene_IRaycastResult_class, js_delete_cc_scene_IRaycastResult)

static bool js_delete_cc_scene_IRaycastResult(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_IRaycastResult) 

template<>
bool sevalue_to_native(const se::Value &from, cc::scene::IRaycastResult * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::scene::IRaycastResult*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("node", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->node), ctx);
    }
    
    
    json->getProperty("distance", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->distance), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_scene_IRaycastResult(se::Object* obj) {
    auto* cls = se::Class::create("IRaycastResult", obj, nullptr, _SE(js_new_cc_scene_IRaycastResult)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("node", _SE(js_cc_scene_IRaycastResult_node_get), _SE(js_cc_scene_IRaycastResult_node_set)); 
    cls->defineProperty("distance", _SE(js_cc_scene_IRaycastResult_distance_get), _SE(js_cc_scene_IRaycastResult_distance_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_IRaycastResult));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::IRaycastResult>(cls);
    
    __jsb_cc_scene_IRaycastResult_proto = cls->getProto();
    __jsb_cc_scene_IRaycastResult_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_IRenderSceneInfo_class = nullptr;
se::Object* __jsb_cc_scene_IRenderSceneInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_IRenderSceneInfo) 

static bool js_cc_scene_IRenderSceneInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::IRenderSceneInfo *arg1 = (cc::scene::IRenderSceneInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRenderSceneInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IRenderSceneInfo_name_set) 

static bool js_cc_scene_IRenderSceneInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::IRenderSceneInfo *arg1 = (cc::scene::IRenderSceneInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRenderSceneInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IRenderSceneInfo_name_get) 

static bool js_new_cc_scene_IRenderSceneInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::IRenderSceneInfo *result;
    result = (cc::scene::IRenderSceneInfo *)new cc::scene::IRenderSceneInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_IRenderSceneInfo, __jsb_cc_scene_IRenderSceneInfo_class, js_delete_cc_scene_IRenderSceneInfo)

static bool js_delete_cc_scene_IRenderSceneInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_IRenderSceneInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::scene::IRenderSceneInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::scene::IRenderSceneInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_scene_IRenderSceneInfo(se::Object* obj) {
    auto* cls = se::Class::create("IRenderSceneInfo", obj, nullptr, _SE(js_new_cc_scene_IRenderSceneInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("name", _SE(js_cc_scene_IRenderSceneInfo_name_get), _SE(js_cc_scene_IRenderSceneInfo_name_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_IRenderSceneInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::IRenderSceneInfo>(cls);
    
    __jsb_cc_scene_IRenderSceneInfo_proto = cls->getProto();
    __jsb_cc_scene_IRenderSceneInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_RenderScene_class = nullptr;
se::Object* __jsb_cc_scene_RenderScene_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_RenderScene) 

static bool js_new_cc_scene_RenderScene(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::RenderScene *result;
    result = (cc::scene::RenderScene *)new cc::scene::RenderScene();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_RenderScene, __jsb_cc_scene_RenderScene_class, js_delete_cc_scene_RenderScene)

static bool js_delete_cc_scene_RenderScene(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_RenderScene) 

static bool js_cc_scene_RenderScene_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::IRenderSceneInfo *arg2 = 0 ;
    cc::scene::IRenderSceneInfo temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (bool)(arg1)->initialize((cc::scene::IRenderSceneInfo const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_initialize) 

static bool js_cc_scene_RenderScene_update(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->update(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_update) 

static bool js_cc_scene_RenderScene_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_destroy) 

static bool js_cc_scene_RenderScene_activate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    (arg1)->activate();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_activate) 

static bool js_cc_scene_RenderScene_addCamera(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addCamera(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_addCamera) 

static bool js_cc_scene_RenderScene_removeCamera(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->removeCamera(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_removeCamera) 

static bool js_cc_scene_RenderScene_removeCameras(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    (arg1)->removeCameras();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_removeCameras) 

static bool js_cc_scene_RenderScene_addLODGroup(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::LODGroup *arg2 = (cc::scene::LODGroup *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addLODGroup(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_addLODGroup) 

static bool js_cc_scene_RenderScene_removeLODGroup(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::LODGroup *arg2 = (cc::scene::LODGroup *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->removeLODGroup(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_removeLODGroup) 

static bool js_cc_scene_RenderScene_isCulledByLod(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    cc::scene::Model *arg3 = (cc::scene::Model *) NULL ;
    bool result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (bool)((cc::scene::RenderScene const *)arg1)->isCulledByLod((cc::scene::Camera const *)arg2,(cc::scene::Model const *)arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_isCulledByLod) 

static bool js_cc_scene_RenderScene_unsetMainLight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::DirectionalLight *arg2 = (cc::scene::DirectionalLight *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->unsetMainLight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_unsetMainLight) 

static bool js_cc_scene_RenderScene_addDirectionalLight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::DirectionalLight *arg2 = (cc::scene::DirectionalLight *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addDirectionalLight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_addDirectionalLight) 

static bool js_cc_scene_RenderScene_removeDirectionalLight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::DirectionalLight *arg2 = (cc::scene::DirectionalLight *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->removeDirectionalLight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_removeDirectionalLight) 

static bool js_cc_scene_RenderScene_addSphereLight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::SphereLight *arg2 = (cc::scene::SphereLight *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addSphereLight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_addSphereLight) 

static bool js_cc_scene_RenderScene_removeSphereLight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::SphereLight *arg2 = (cc::scene::SphereLight *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->removeSphereLight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_removeSphereLight) 

static bool js_cc_scene_RenderScene_removeSphereLights(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    (arg1)->removeSphereLights();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_removeSphereLights) 

static bool js_cc_scene_RenderScene_addSpotLight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::SpotLight *arg2 = (cc::scene::SpotLight *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addSpotLight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_addSpotLight) 

static bool js_cc_scene_RenderScene_removeSpotLight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::SpotLight *arg2 = (cc::scene::SpotLight *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->removeSpotLight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_removeSpotLight) 

static bool js_cc_scene_RenderScene_removeSpotLights(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    (arg1)->removeSpotLights();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_removeSpotLights) 

static bool js_cc_scene_RenderScene_addModel(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::Model *arg2 = (cc::scene::Model *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addModel(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_addModel) 

static bool js_cc_scene_RenderScene_removeModel(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::Model *arg2 = (cc::scene::Model *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->removeModel(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_removeModel) 

static bool js_cc_scene_RenderScene_removeModels(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    (arg1)->removeModels();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_removeModels) 

static bool js_cc_scene_RenderScene_onGlobalPipelineStateChanged(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    (arg1)->onGlobalPipelineStateChanged();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_onGlobalPipelineStateChanged) 

static bool js_cc_scene_RenderScene_getMainLight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::DirectionalLight *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::DirectionalLight *)((cc::scene::RenderScene const *)arg1)->getMainLight();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_getMainLight) 

static bool js_cc_scene_RenderScene_setMainLight(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::DirectionalLight *arg2 = (cc::scene::DirectionalLight *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setMainLight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_setMainLight) 

static bool js_cc_scene_RenderScene_generateModelId(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    uint64_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    result = (arg1)->generateModelId();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_generateModelId) 

static bool js_cc_scene_RenderScene_getOctree(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::Octree *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::Octree *)((cc::scene::RenderScene const *)arg1)->getOctree();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_getOctree) 

static bool js_cc_scene_RenderScene_updateOctree(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::Model *arg2 = (cc::scene::Model *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->updateOctree(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_updateOctree) 

static bool js_cc_scene_RenderScene_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    ccstd::string *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::string *) &cc_scene_RenderScene_name_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_RenderScene_name_get) 

static bool js_cc_scene_RenderScene_cameras_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::scene::Camera > > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::IntrusivePtr< cc::scene::Camera > > *) &cc_scene_RenderScene_cameras_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_RenderScene_cameras_get) 

static bool js_cc_scene_RenderScene_sphereLights_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::scene::SphereLight > > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::IntrusivePtr< cc::scene::SphereLight > > *) &cc_scene_RenderScene_sphereLights_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_RenderScene_sphereLights_get) 

static bool js_cc_scene_RenderScene_spotLights_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::scene::SpotLight > > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::IntrusivePtr< cc::scene::SpotLight > > *) &cc_scene_RenderScene_spotLights_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_RenderScene_spotLights_get) 

static bool js_cc_scene_RenderScene_models_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::scene::Model > > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::IntrusivePtr< cc::scene::Model > > *) &cc_scene_RenderScene_models_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_RenderScene_models_get) 

static bool js_cc_scene_RenderScene_lodGroups_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::scene::LODGroup > > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::IntrusivePtr< cc::scene::LODGroup > > *) &cc_scene_RenderScene_lodGroups_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_RenderScene_lodGroups_get) 

bool js_register_cc_scene_RenderScene(se::Object* obj) {
    auto* cls = se::Class::create("RenderScene", obj, nullptr, _SE(js_new_cc_scene_RenderScene)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("name", _SE(js_cc_scene_RenderScene_name_get), nullptr); 
    cls->defineProperty("cameras", _SE(js_cc_scene_RenderScene_cameras_get), nullptr); 
    cls->defineProperty("sphereLights", _SE(js_cc_scene_RenderScene_sphereLights_get), nullptr); 
    cls->defineProperty("spotLights", _SE(js_cc_scene_RenderScene_spotLights_get), nullptr); 
    cls->defineProperty("models", _SE(js_cc_scene_RenderScene_models_get), nullptr); 
    cls->defineProperty("lodGroups", _SE(js_cc_scene_RenderScene_lodGroups_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_scene_RenderScene_initialize)); 
    cls->defineFunction("update", _SE(js_cc_scene_RenderScene_update)); 
    cls->defineFunction("destroy", _SE(js_cc_scene_RenderScene_destroy)); 
    cls->defineFunction("activate", _SE(js_cc_scene_RenderScene_activate)); 
    cls->defineFunction("addCamera", _SE(js_cc_scene_RenderScene_addCamera)); 
    cls->defineFunction("removeCamera", _SE(js_cc_scene_RenderScene_removeCamera)); 
    cls->defineFunction("removeCameras", _SE(js_cc_scene_RenderScene_removeCameras)); 
    cls->defineFunction("addLODGroup", _SE(js_cc_scene_RenderScene_addLODGroup)); 
    cls->defineFunction("removeLODGroup", _SE(js_cc_scene_RenderScene_removeLODGroup)); 
    cls->defineFunction("isCulledByLod", _SE(js_cc_scene_RenderScene_isCulledByLod)); 
    cls->defineFunction("unsetMainLight", _SE(js_cc_scene_RenderScene_unsetMainLight)); 
    cls->defineFunction("addDirectionalLight", _SE(js_cc_scene_RenderScene_addDirectionalLight)); 
    cls->defineFunction("removeDirectionalLight", _SE(js_cc_scene_RenderScene_removeDirectionalLight)); 
    cls->defineFunction("addSphereLight", _SE(js_cc_scene_RenderScene_addSphereLight)); 
    cls->defineFunction("removeSphereLight", _SE(js_cc_scene_RenderScene_removeSphereLight)); 
    cls->defineFunction("removeSphereLights", _SE(js_cc_scene_RenderScene_removeSphereLights)); 
    cls->defineFunction("addSpotLight", _SE(js_cc_scene_RenderScene_addSpotLight)); 
    cls->defineFunction("removeSpotLight", _SE(js_cc_scene_RenderScene_removeSpotLight)); 
    cls->defineFunction("removeSpotLights", _SE(js_cc_scene_RenderScene_removeSpotLights)); 
    cls->defineFunction("addModel", _SE(js_cc_scene_RenderScene_addModel)); 
    cls->defineFunction("removeModel", _SE(js_cc_scene_RenderScene_removeModel)); 
    cls->defineFunction("removeModels", _SE(js_cc_scene_RenderScene_removeModels)); 
    cls->defineFunction("onGlobalPipelineStateChanged", _SE(js_cc_scene_RenderScene_onGlobalPipelineStateChanged)); 
    cls->defineFunction("getMainLight", _SE(js_cc_scene_RenderScene_getMainLight)); 
    cls->defineFunction("setMainLight", _SE(js_cc_scene_RenderScene_setMainLight)); 
    cls->defineFunction("generateModelId", _SE(js_cc_scene_RenderScene_generateModelId)); 
    cls->defineFunction("getOctree", _SE(js_cc_scene_RenderScene_getOctree)); 
    cls->defineFunction("updateOctree", _SE(js_cc_scene_RenderScene_updateOctree)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_RenderScene));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::RenderScene>(cls);
    
    __jsb_cc_scene_RenderScene_proto = cls->getProto();
    __jsb_cc_scene_RenderScene_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_IRenderWindowInfo_class = nullptr;
se::Object* __jsb_cc_scene_IRenderWindowInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_IRenderWindowInfo) 

static bool js_cc_scene_IRenderWindowInfo_title_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::IRenderWindowInfo *arg1 = (cc::scene::IRenderWindowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRenderWindowInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->title, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IRenderWindowInfo_title_set) 

static bool js_cc_scene_IRenderWindowInfo_title_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::IRenderWindowInfo *arg1 = (cc::scene::IRenderWindowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRenderWindowInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->title, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->title, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IRenderWindowInfo_title_get) 

static bool js_cc_scene_IRenderWindowInfo_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::IRenderWindowInfo *arg1 = (cc::scene::IRenderWindowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRenderWindowInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->width, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IRenderWindowInfo_width_set) 

static bool js_cc_scene_IRenderWindowInfo_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::IRenderWindowInfo *arg1 = (cc::scene::IRenderWindowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRenderWindowInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->width, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IRenderWindowInfo_width_get) 

static bool js_cc_scene_IRenderWindowInfo_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::IRenderWindowInfo *arg1 = (cc::scene::IRenderWindowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRenderWindowInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->height, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IRenderWindowInfo_height_set) 

static bool js_cc_scene_IRenderWindowInfo_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::IRenderWindowInfo *arg1 = (cc::scene::IRenderWindowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRenderWindowInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->height, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IRenderWindowInfo_height_get) 

static bool js_cc_scene_IRenderWindowInfo_renderPassInfo_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::IRenderWindowInfo *arg1 = (cc::scene::IRenderWindowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRenderWindowInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->renderPassInfo, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IRenderWindowInfo_renderPassInfo_set) 

static bool js_cc_scene_IRenderWindowInfo_renderPassInfo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::IRenderWindowInfo *arg1 = (cc::scene::IRenderWindowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRenderWindowInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->renderPassInfo, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->renderPassInfo, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IRenderWindowInfo_renderPassInfo_get) 

static bool js_cc_scene_IRenderWindowInfo_swapchain_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::IRenderWindowInfo *arg1 = (cc::scene::IRenderWindowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRenderWindowInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->swapchain, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IRenderWindowInfo_swapchain_set) 

static bool js_cc_scene_IRenderWindowInfo_swapchain_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::IRenderWindowInfo *arg1 = (cc::scene::IRenderWindowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRenderWindowInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->swapchain, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->swapchain, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IRenderWindowInfo_swapchain_get) 

static bool js_new_cc_scene_IRenderWindowInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::IRenderWindowInfo *result;
    result = (cc::scene::IRenderWindowInfo *)new cc::scene::IRenderWindowInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_IRenderWindowInfo, __jsb_cc_scene_IRenderWindowInfo_class, js_delete_cc_scene_IRenderWindowInfo)

static bool js_delete_cc_scene_IRenderWindowInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_IRenderWindowInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::scene::IRenderWindowInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::scene::IRenderWindowInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("title", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->title), ctx);
    }
    
    
    json->getProperty("width", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->width), ctx);
    }
    
    
    json->getProperty("height", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->height), ctx);
    }
    
    
    json->getProperty("renderPassInfo", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->renderPassInfo), ctx);
    }
    
    
    json->getProperty("swapchain", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->swapchain), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_scene_IRenderWindowInfo(se::Object* obj) {
    auto* cls = se::Class::create("IRenderWindowInfo", obj, nullptr, _SE(js_new_cc_scene_IRenderWindowInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("title", _SE(js_cc_scene_IRenderWindowInfo_title_get), _SE(js_cc_scene_IRenderWindowInfo_title_set)); 
    cls->defineProperty("width", _SE(js_cc_scene_IRenderWindowInfo_width_get), _SE(js_cc_scene_IRenderWindowInfo_width_set)); 
    cls->defineProperty("height", _SE(js_cc_scene_IRenderWindowInfo_height_get), _SE(js_cc_scene_IRenderWindowInfo_height_set)); 
    cls->defineProperty("renderPassInfo", _SE(js_cc_scene_IRenderWindowInfo_renderPassInfo_get), _SE(js_cc_scene_IRenderWindowInfo_renderPassInfo_set)); 
    cls->defineProperty("swapchain", _SE(js_cc_scene_IRenderWindowInfo_swapchain_get), _SE(js_cc_scene_IRenderWindowInfo_swapchain_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_IRenderWindowInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::IRenderWindowInfo>(cls);
    
    __jsb_cc_scene_IRenderWindowInfo_proto = cls->getProto();
    __jsb_cc_scene_IRenderWindowInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_RenderWindow_class = nullptr;
se::Object* __jsb_cc_scene_RenderWindow_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_RenderWindow) 

static bool js_new_cc_scene_RenderWindow(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::RenderWindow *result;
    result = (cc::scene::RenderWindow *)new cc::scene::RenderWindow();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_RenderWindow, __jsb_cc_scene_RenderWindow_class, js_delete_cc_scene_RenderWindow)

static bool js_delete_cc_scene_RenderWindow(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_RenderWindow) 

static bool js_cc_scene_RenderWindow_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderWindow *arg1 = (cc::scene::RenderWindow *) NULL ;
    cc::gfx::Device *arg2 = (cc::gfx::Device *) NULL ;
    cc::scene::IRenderWindowInfo *arg3 = 0 ;
    cc::scene::IRenderWindowInfo temp3 ;
    bool result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderWindow>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    result = (bool)(arg1)->initialize(arg2,*arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderWindow_initialize) 

static bool js_cc_scene_RenderWindow_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderWindow *arg1 = (cc::scene::RenderWindow *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderWindow>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderWindow_destroy) 

static bool js_cc_scene_RenderWindow_resize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderWindow *arg1 = (cc::scene::RenderWindow *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderWindow>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->resize(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderWindow_resize) 

static bool js_cc_scene_RenderWindow_extractRenderCameras(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderWindow *arg1 = (cc::scene::RenderWindow *) NULL ;
    ccstd::vector< cc::scene::Camera * > *arg2 = 0 ;
    ccstd::vector< cc::scene::Camera * > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderWindow>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->extractRenderCameras(*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderWindow_extractRenderCameras) 

static bool js_cc_scene_RenderWindow_attachCamera(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderWindow *arg1 = (cc::scene::RenderWindow *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderWindow>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->attachCamera(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderWindow_attachCamera) 

static bool js_cc_scene_RenderWindow_detachCamera(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderWindow *arg1 = (cc::scene::RenderWindow *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderWindow>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->detachCamera(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderWindow_detachCamera) 

static bool js_cc_scene_RenderWindow_clearCameras(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderWindow *arg1 = (cc::scene::RenderWindow *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderWindow>(s);
    if (nullptr == arg1) return true;
    (arg1)->clearCameras();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderWindow_clearCameras) 

static bool js_cc_scene_RenderWindow_sortCameras(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderWindow *arg1 = (cc::scene::RenderWindow *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderWindow>(s);
    if (nullptr == arg1) return true;
    (arg1)->sortCameras();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderWindow_sortCameras) 

static bool js_cc_scene_RenderWindow_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::RenderWindow *arg1 = (cc::scene::RenderWindow *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::RenderWindow>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_RenderWindow_width_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_RenderWindow_width_get) 

static bool js_cc_scene_RenderWindow_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::RenderWindow *arg1 = (cc::scene::RenderWindow *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::RenderWindow>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_RenderWindow_height_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_RenderWindow_height_get) 

static bool js_cc_scene_RenderWindow_framebuffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::RenderWindow *arg1 = (cc::scene::RenderWindow *) NULL ;
    cc::gfx::Framebuffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::RenderWindow>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Framebuffer *)cc_scene_RenderWindow_framebuffer_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_RenderWindow_framebuffer_get) 

static bool js_cc_scene_RenderWindow_cameras_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::RenderWindow *arg1 = (cc::scene::RenderWindow *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::scene::Camera > > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::RenderWindow>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::IntrusivePtr< cc::scene::Camera > > *) &cc_scene_RenderWindow_cameras_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_RenderWindow_cameras_get) 

static bool js_cc_scene_RenderWindow_swapchain_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::RenderWindow *arg1 = (cc::scene::RenderWindow *) NULL ;
    cc::gfx::Swapchain *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::RenderWindow>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Swapchain *)cc_scene_RenderWindow_swapchain_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_RenderWindow_swapchain_get) 

bool js_register_cc_scene_RenderWindow(se::Object* obj) {
    auto* cls = se::Class::create("RenderWindow", obj, nullptr, _SE(js_new_cc_scene_RenderWindow)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("width", _SE(js_cc_scene_RenderWindow_width_get), nullptr); 
    cls->defineProperty("height", _SE(js_cc_scene_RenderWindow_height_get), nullptr); 
    cls->defineProperty("framebuffer", _SE(js_cc_scene_RenderWindow_framebuffer_get), nullptr); 
    cls->defineProperty("cameras", _SE(js_cc_scene_RenderWindow_cameras_get), nullptr); 
    cls->defineProperty("swapchain", _SE(js_cc_scene_RenderWindow_swapchain_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_scene_RenderWindow_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_scene_RenderWindow_destroy)); 
    cls->defineFunction("resize", _SE(js_cc_scene_RenderWindow_resize)); 
    cls->defineFunction("extractRenderCameras", _SE(js_cc_scene_RenderWindow_extractRenderCameras)); 
    cls->defineFunction("attachCamera", _SE(js_cc_scene_RenderWindow_attachCamera)); 
    cls->defineFunction("detachCamera", _SE(js_cc_scene_RenderWindow_detachCamera)); 
    cls->defineFunction("clearCameras", _SE(js_cc_scene_RenderWindow_clearCameras)); 
    cls->defineFunction("sortCameras", _SE(js_cc_scene_RenderWindow_sortCameras)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_RenderWindow));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::RenderWindow>(cls);
    
    __jsb_cc_scene_RenderWindow_proto = cls->getProto();
    __jsb_cc_scene_RenderWindow_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_ICameraInfo_class = nullptr;
se::Object* __jsb_cc_scene_ICameraInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_ICameraInfo) 

static bool js_cc_scene_ICameraInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ICameraInfo_name_set) 

static bool js_cc_scene_ICameraInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ICameraInfo_name_get) 

static bool js_cc_scene_ICameraInfo_node_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->node, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ICameraInfo_node_set) 

static bool js_cc_scene_ICameraInfo_node_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->node, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->node, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ICameraInfo_node_get) 

static bool js_cc_scene_ICameraInfo_projection_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->projection, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ICameraInfo_projection_set) 

static bool js_cc_scene_ICameraInfo_projection_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->projection, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->projection, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ICameraInfo_projection_get) 

static bool js_cc_scene_ICameraInfo_targetDisplay_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->targetDisplay, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ICameraInfo_targetDisplay_set) 

static bool js_cc_scene_ICameraInfo_targetDisplay_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->targetDisplay, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->targetDisplay, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ICameraInfo_targetDisplay_get) 

static bool js_cc_scene_ICameraInfo_window_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->window, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ICameraInfo_window_set) 

static bool js_cc_scene_ICameraInfo_window_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->window, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->window, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ICameraInfo_window_get) 

static bool js_cc_scene_ICameraInfo_priority_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->priority, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ICameraInfo_priority_set) 

static bool js_cc_scene_ICameraInfo_priority_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->priority, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ICameraInfo_priority_get) 

static bool js_cc_scene_ICameraInfo_pipeline_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->pipeline, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ICameraInfo_pipeline_set) 

static bool js_cc_scene_ICameraInfo_pipeline_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->pipeline, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->pipeline, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ICameraInfo_pipeline_get) 

static bool js_cc_scene_ICameraInfo_cameraType_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->cameraType, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ICameraInfo_cameraType_set) 

static bool js_cc_scene_ICameraInfo_cameraType_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->cameraType, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->cameraType, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ICameraInfo_cameraType_get) 

static bool js_cc_scene_ICameraInfo_trackingType_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->trackingType, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ICameraInfo_trackingType_set) 

static bool js_cc_scene_ICameraInfo_trackingType_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->trackingType, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->trackingType, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ICameraInfo_trackingType_get) 

static bool js_cc_scene_ICameraInfo_usage_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->usage, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ICameraInfo_usage_set) 

static bool js_cc_scene_ICameraInfo_usage_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->usage, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->usage, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ICameraInfo_usage_get) 

static bool js_new_cc_scene_ICameraInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::ICameraInfo *result;
    result = (cc::scene::ICameraInfo *)new cc::scene::ICameraInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_ICameraInfo, __jsb_cc_scene_ICameraInfo_class, js_delete_cc_scene_ICameraInfo)

static bool js_delete_cc_scene_ICameraInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_ICameraInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::scene::ICameraInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::scene::ICameraInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("node", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->node), ctx);
    }
    
    
    json->getProperty("projection", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->projection), ctx);
    }
    
    
    json->getProperty("targetDisplay", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->targetDisplay), ctx);
    }
    
    
    json->getProperty("window", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->window), ctx);
    }
    
    
    json->getProperty("priority", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->priority), ctx);
    }
    
    
    json->getProperty("pipeline", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->pipeline), ctx);
    }
    
    
    json->getProperty("cameraType", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->cameraType), ctx);
    }
    
    
    json->getProperty("trackingType", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->trackingType), ctx);
    }
    
    
    json->getProperty("usage", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->usage), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_scene_ICameraInfo(se::Object* obj) {
    auto* cls = se::Class::create("ICameraInfo", obj, nullptr, _SE(js_new_cc_scene_ICameraInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("name", _SE(js_cc_scene_ICameraInfo_name_get), _SE(js_cc_scene_ICameraInfo_name_set)); 
    cls->defineProperty("node", _SE(js_cc_scene_ICameraInfo_node_get), _SE(js_cc_scene_ICameraInfo_node_set)); 
    cls->defineProperty("projection", _SE(js_cc_scene_ICameraInfo_projection_get), _SE(js_cc_scene_ICameraInfo_projection_set)); 
    cls->defineProperty("targetDisplay", _SE(js_cc_scene_ICameraInfo_targetDisplay_get), _SE(js_cc_scene_ICameraInfo_targetDisplay_set)); 
    cls->defineProperty("window", _SE(js_cc_scene_ICameraInfo_window_get), _SE(js_cc_scene_ICameraInfo_window_set)); 
    cls->defineProperty("priority", _SE(js_cc_scene_ICameraInfo_priority_get), _SE(js_cc_scene_ICameraInfo_priority_set)); 
    cls->defineProperty("pipeline", _SE(js_cc_scene_ICameraInfo_pipeline_get), _SE(js_cc_scene_ICameraInfo_pipeline_set)); 
    cls->defineProperty("cameraType", _SE(js_cc_scene_ICameraInfo_cameraType_get), _SE(js_cc_scene_ICameraInfo_cameraType_set)); 
    cls->defineProperty("trackingType", _SE(js_cc_scene_ICameraInfo_trackingType_get), _SE(js_cc_scene_ICameraInfo_trackingType_set)); 
    cls->defineProperty("usage", _SE(js_cc_scene_ICameraInfo_usage_get), _SE(js_cc_scene_ICameraInfo_usage_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_ICameraInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::ICameraInfo>(cls);
    
    __jsb_cc_scene_ICameraInfo_proto = cls->getProto();
    __jsb_cc_scene_ICameraInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_Camera_class = nullptr;
se::Object* __jsb_cc_scene_Camera_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_Camera) 

static bool js_cc_scene_Camera_SKYBOX_FLAG_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    int32_t result;
    
    result = (int32_t)cc::scene::Camera::SKYBOX_FLAG;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_SKYBOX_FLAG_get) 

static bool js_new_cc_scene_Camera(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::scene::Camera *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::scene::Camera *)new cc::scene::Camera(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_Camera, __jsb_cc_scene_Camera_class, js_delete_cc_scene_Camera)

static bool js_delete_cc_scene_Camera(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_Camera) 

static bool js_cc_scene_Camera_getStandardExposureValue_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (float)cc::scene::Camera::getStandardExposureValue();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_getStandardExposureValue_static) 

static bool js_cc_scene_Camera_getStandardLightMeterScale_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (float)cc::scene::Camera::getStandardLightMeterScale();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_getStandardLightMeterScale_static) 

static bool js_cc_scene_Camera_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::ICameraInfo *arg2 = 0 ;
    cc::scene::ICameraInfo temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (bool)(arg1)->initialize((cc::scene::ICameraInfo const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_initialize) 

static bool js_cc_scene_Camera_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_destroy) 

static bool js_cc_scene_Camera_attachToScene(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::RenderScene *arg2 = (cc::scene::RenderScene *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->attachToScene(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_attachToScene) 

static bool js_cc_scene_Camera_detachFromScene(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    (arg1)->detachFromScene();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_detachFromScene) 

static bool js_cc_scene_Camera_resize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->resize(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_resize) 

static bool js_cc_scene_Camera_setFixedSize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setFixedSize(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_setFixedSize) 

static bool js_cc_scene_Camera_syncCameraEditor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->syncCameraEditor((cc::scene::Camera const *)arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_syncCameraEditor) 

static bool js_cc_scene_Camera_update__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->update(arg2);
    
    
    return true;
}

static bool js_cc_scene_Camera_update__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    (arg1)->update();
    
    
    return true;
}

static bool js_cc_scene_Camera_update(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_cc_scene_Camera_update__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 0) {
        ok = js_cc_scene_Camera_update__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_scene_Camera_update) 

static bool js_cc_scene_Camera_changeTargetWindow(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::RenderWindow *arg2 = (cc::scene::RenderWindow *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->changeTargetWindow(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_changeTargetWindow) 

static bool js_cc_scene_Camera_setViewportInOrientedSpace(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    Rect *arg2 = 0 ;
    Rect temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setViewportInOrientedSpace((Rect const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_setViewportInOrientedSpace) 

static bool js_cc_scene_Camera_initGeometryRenderer(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    (arg1)->initGeometryRenderer();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_initGeometryRenderer) 

static bool js_cc_scene_Camera_detachCamera(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    (arg1)->detachCamera();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_detachCamera) 

static bool js_cc_scene_Camera_getCameraType(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::CameraType result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::CameraType)((cc::scene::Camera const *)arg1)->getCameraType();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_getCameraType) 

static bool js_cc_scene_Camera_setCameraType(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::CameraType arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->setCameraType(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_setCameraType) 

static bool js_cc_scene_Camera_getTrackingType(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::TrackingType result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::TrackingType)((cc::scene::Camera const *)arg1)->getTrackingType();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_getTrackingType) 

static bool js_cc_scene_Camera_setTrackingType(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::TrackingType arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->setTrackingType(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_setTrackingType) 

static bool js_cc_scene_Camera_isCullingEnabled(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (bool)((cc::scene::Camera const *)arg1)->isCullingEnabled();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_isCullingEnabled) 

static bool js_cc_scene_Camera_setCullingEnable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setCullingEnable(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_setCullingEnable) 

static bool js_cc_scene_Camera_calculateObliqueMat(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::Vec4 *arg2 = 0 ;
    cc::Vec4 temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->calculateObliqueMat((cc::Vec4 const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_calculateObliqueMat) 

static bool js_cc_scene_Camera_iso_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::CameraISO arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_scene_Camera_iso_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_iso_set) 

static bool js_cc_scene_Camera_iso_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::CameraISO result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::CameraISO)cc_scene_Camera_iso_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_iso_get) 

static bool js_cc_scene_Camera_isoValue_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_Camera_isoValue_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_isoValue_get) 

static bool js_cc_scene_Camera_ec_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Camera_ec_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_ec_set) 

static bool js_cc_scene_Camera_ec_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_Camera_ec_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_ec_get) 

static bool js_cc_scene_Camera_exposure_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_Camera_exposure_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_exposure_get) 

static bool js_cc_scene_Camera_shutter_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::CameraShutter arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_scene_Camera_shutter_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_shutter_set) 

static bool js_cc_scene_Camera_shutter_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::CameraShutter result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::CameraShutter)cc_scene_Camera_shutter_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_shutter_get) 

static bool js_cc_scene_Camera_shutterValue_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_Camera_shutterValue_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_shutterValue_get) 

static bool js_cc_scene_Camera_apertureValue_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_Camera_apertureValue_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_apertureValue_get) 

static bool js_cc_scene_Camera_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_Camera_width_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_width_get) 

static bool js_cc_scene_Camera_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_Camera_height_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_height_get) 

static bool js_cc_scene_Camera_aspect_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_Camera_aspect_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_aspect_get) 

static bool js_cc_scene_Camera_scene_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::RenderScene *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::RenderScene *)cc_scene_Camera_scene_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_scene_get) 

static bool js_cc_scene_Camera_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    ccstd::string *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::string *) &cc_scene_Camera_name_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_name_get) 

static bool js_cc_scene_Camera_window_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::RenderWindow *arg2 = (cc::scene::RenderWindow *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Camera_window_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_window_set) 

static bool js_cc_scene_Camera_window_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::RenderWindow *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::RenderWindow *)cc_scene_Camera_window_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_window_get) 

static bool js_cc_scene_Camera_forward_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_Camera_forward_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_forward_set) 

static bool js_cc_scene_Camera_forward_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (cc::Vec3 *) &cc_scene_Camera_forward_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_forward_get) 

static bool js_cc_scene_Camera_aperture_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::CameraAperture arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_scene_Camera_aperture_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_aperture_set) 

static bool js_cc_scene_Camera_aperture_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::CameraAperture result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::CameraAperture)cc_scene_Camera_aperture_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_aperture_get) 

static bool js_cc_scene_Camera_position_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_Camera_position_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_position_set) 

static bool js_cc_scene_Camera_position_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (cc::Vec3 *) &cc_scene_Camera_position_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_position_get) 

static bool js_cc_scene_Camera_projectionType_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::CameraProjection arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_scene_Camera_projectionType_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_projectionType_set) 

static bool js_cc_scene_Camera_projectionType_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::CameraProjection result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::CameraProjection)cc_scene_Camera_projectionType_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_projectionType_get) 

static bool js_cc_scene_Camera_fovAxis_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::CameraFOVAxis arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_scene_Camera_fovAxis_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_fovAxis_set) 

static bool js_cc_scene_Camera_fovAxis_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::CameraFOVAxis result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::CameraFOVAxis)cc_scene_Camera_fovAxis_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_fovAxis_get) 

static bool js_cc_scene_Camera_fov_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Camera_fov_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_fov_set) 

static bool js_cc_scene_Camera_fov_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_Camera_fov_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_fov_get) 

static bool js_cc_scene_Camera_nearClip_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Camera_nearClip_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_nearClip_set) 

static bool js_cc_scene_Camera_nearClip_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_Camera_nearClip_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_nearClip_get) 

static bool js_cc_scene_Camera_farClip_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Camera_farClip_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_farClip_set) 

static bool js_cc_scene_Camera_farClip_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_Camera_farClip_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_farClip_get) 

static bool js_cc_scene_Camera_viewport_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::Rect *arg2 = 0 ;
    cc::Rect temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_Camera_viewport_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_viewport_set) 

static bool js_cc_scene_Camera_viewport_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::Rect *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (cc::Rect *) &cc_scene_Camera_viewport_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_viewport_get) 

static bool js_cc_scene_Camera_orthoHeight_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Camera_orthoHeight_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_orthoHeight_set) 

static bool js_cc_scene_Camera_orthoHeight_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_Camera_orthoHeight_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_orthoHeight_get) 

static bool js_cc_scene_Camera_clearColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::gfx::Color *arg2 = 0 ;
    cc::gfx::Color temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_Camera_clearColor_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_clearColor_set) 

static bool js_cc_scene_Camera_clearColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::gfx::Color *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Color *) &cc_scene_Camera_clearColor_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_clearColor_get) 

static bool js_cc_scene_Camera_clearDepth_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Camera_clearDepth_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_clearDepth_set) 

static bool js_cc_scene_Camera_clearDepth_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_Camera_clearDepth_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_clearDepth_get) 

static bool js_cc_scene_Camera_clearFlag_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::gfx::ClearFlagBit arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_scene_Camera_clearFlag_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_clearFlag_set) 

static bool js_cc_scene_Camera_clearFlag_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::gfx::ClearFlagBit result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_Camera_clearFlag_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_clearFlag_get) 

static bool js_cc_scene_Camera_clearStencil_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Camera_clearStencil_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_clearStencil_set) 

static bool js_cc_scene_Camera_clearStencil_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_Camera_clearStencil_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_clearStencil_get) 

static bool js_cc_scene_Camera_enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Camera_enabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_enabled_set) 

static bool js_cc_scene_Camera_enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_Camera_enabled_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_enabled_get) 

static bool js_cc_scene_Camera_frustum_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::geometry::Frustum *arg2 = 0 ;
    cc::geometry::Frustum temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_Camera_frustum_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_frustum_set) 

static bool js_cc_scene_Camera_frustum_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::geometry::Frustum *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (cc::geometry::Frustum *) &cc_scene_Camera_frustum_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_frustum_get) 

static bool js_cc_scene_Camera_isWindowSize_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Camera_isWindowSize_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_isWindowSize_set) 

static bool js_cc_scene_Camera_isWindowSize_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_Camera_isWindowSize_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_isWindowSize_get) 

static bool js_cc_scene_Camera_priority_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_scene_Camera_priority_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_priority_set) 

static bool js_cc_scene_Camera_priority_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_Camera_priority_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_priority_get) 

static bool js_cc_scene_Camera_screenScale_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Camera_screenScale_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_screenScale_set) 

static bool js_cc_scene_Camera_screenScale_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_Camera_screenScale_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_screenScale_get) 

static bool js_cc_scene_Camera_visibility_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_scene_Camera_visibility_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_visibility_set) 

static bool js_cc_scene_Camera_visibility_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_Camera_visibility_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_visibility_get) 

static bool js_cc_scene_Camera_node_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Camera_node_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_node_set) 

static bool js_cc_scene_Camera_node_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::Node *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (cc::Node *)cc_scene_Camera_node_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_node_get) 

static bool js_cc_scene_Camera_surfaceTransform_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::gfx::SurfaceTransform result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_Camera_surfaceTransform_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_surfaceTransform_get) 

static bool js_cc_scene_Camera_geometryRenderer_get(se::State& s)
{
#if CC_USE_GEOMETRY_RENDERER
    
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::pipeline::GeometryRenderer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (cc::pipeline::GeometryRenderer *)cc_scene_Camera_geometryRenderer_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
#endif // CC_USE_GEOMETRY_RENDERER
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_geometryRenderer_get) 

static bool js_cc_scene_Camera_systemWindowId_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_Camera_systemWindowId_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_systemWindowId_get) 

static bool js_cc_scene_Camera_cameraUsage_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::CameraUsage arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_scene_Camera_cameraUsage_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_cameraUsage_set) 

static bool js_cc_scene_Camera_cameraUsage_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::CameraUsage result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::CameraUsage)cc_scene_Camera_cameraUsage_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_cameraUsage_get) 

bool js_register_cc_scene_Camera(se::Object* obj) {
    auto* cls = se::Class::create("Camera", obj, nullptr, _SE(js_new_cc_scene_Camera)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("iso", _SE(js_cc_scene_Camera_iso_get), _SE(js_cc_scene_Camera_iso_set)); 
    cls->defineProperty("isoValue", _SE(js_cc_scene_Camera_isoValue_get), nullptr); 
    cls->defineProperty("ec", _SE(js_cc_scene_Camera_ec_get), _SE(js_cc_scene_Camera_ec_set)); 
    cls->defineProperty("exposure", _SE(js_cc_scene_Camera_exposure_get), nullptr); 
    cls->defineProperty("shutter", _SE(js_cc_scene_Camera_shutter_get), _SE(js_cc_scene_Camera_shutter_set)); 
    cls->defineProperty("shutterValue", _SE(js_cc_scene_Camera_shutterValue_get), nullptr); 
    cls->defineProperty("apertureValue", _SE(js_cc_scene_Camera_apertureValue_get), nullptr); 
    cls->defineProperty("width", _SE(js_cc_scene_Camera_width_get), nullptr); 
    cls->defineProperty("height", _SE(js_cc_scene_Camera_height_get), nullptr); 
    cls->defineProperty("aspect", _SE(js_cc_scene_Camera_aspect_get), nullptr); 
    cls->defineProperty("scene", _SE(js_cc_scene_Camera_scene_get), nullptr); 
    cls->defineProperty("name", _SE(js_cc_scene_Camera_name_get), nullptr); 
    cls->defineProperty("window", _SE(js_cc_scene_Camera_window_get), _SE(js_cc_scene_Camera_window_set)); 
    cls->defineProperty("forward", _SE(js_cc_scene_Camera_forward_get), _SE(js_cc_scene_Camera_forward_set)); 
    cls->defineProperty("aperture", _SE(js_cc_scene_Camera_aperture_get), _SE(js_cc_scene_Camera_aperture_set)); 
    cls->defineProperty("position", _SE(js_cc_scene_Camera_position_get), _SE(js_cc_scene_Camera_position_set)); 
    cls->defineProperty("projectionType", _SE(js_cc_scene_Camera_projectionType_get), _SE(js_cc_scene_Camera_projectionType_set)); 
    cls->defineProperty("fovAxis", _SE(js_cc_scene_Camera_fovAxis_get), _SE(js_cc_scene_Camera_fovAxis_set)); 
    cls->defineProperty("fov", _SE(js_cc_scene_Camera_fov_get), _SE(js_cc_scene_Camera_fov_set)); 
    cls->defineProperty("nearClip", _SE(js_cc_scene_Camera_nearClip_get), _SE(js_cc_scene_Camera_nearClip_set)); 
    cls->defineProperty("farClip", _SE(js_cc_scene_Camera_farClip_get), _SE(js_cc_scene_Camera_farClip_set)); 
    cls->defineProperty("viewport", _SE(js_cc_scene_Camera_viewport_get), _SE(js_cc_scene_Camera_viewport_set)); 
    cls->defineProperty("orthoHeight", _SE(js_cc_scene_Camera_orthoHeight_get), _SE(js_cc_scene_Camera_orthoHeight_set)); 
    cls->defineProperty("clearColor", _SE(js_cc_scene_Camera_clearColor_get), _SE(js_cc_scene_Camera_clearColor_set)); 
    cls->defineProperty("clearDepth", _SE(js_cc_scene_Camera_clearDepth_get), _SE(js_cc_scene_Camera_clearDepth_set)); 
    cls->defineProperty("clearFlag", _SE(js_cc_scene_Camera_clearFlag_get), _SE(js_cc_scene_Camera_clearFlag_set)); 
    cls->defineProperty("clearStencil", _SE(js_cc_scene_Camera_clearStencil_get), _SE(js_cc_scene_Camera_clearStencil_set)); 
    cls->defineProperty("enabled", _SE(js_cc_scene_Camera_enabled_get), _SE(js_cc_scene_Camera_enabled_set)); 
    cls->defineProperty("frustum", _SE(js_cc_scene_Camera_frustum_get), _SE(js_cc_scene_Camera_frustum_set)); 
    cls->defineProperty("isWindowSize", _SE(js_cc_scene_Camera_isWindowSize_get), _SE(js_cc_scene_Camera_isWindowSize_set)); 
    cls->defineProperty("priority", _SE(js_cc_scene_Camera_priority_get), _SE(js_cc_scene_Camera_priority_set)); 
    cls->defineProperty("screenScale", _SE(js_cc_scene_Camera_screenScale_get), _SE(js_cc_scene_Camera_screenScale_set)); 
    cls->defineProperty("visibility", _SE(js_cc_scene_Camera_visibility_get), _SE(js_cc_scene_Camera_visibility_set)); 
    cls->defineProperty("node", _SE(js_cc_scene_Camera_node_get), _SE(js_cc_scene_Camera_node_set)); 
    cls->defineProperty("surfaceTransform", _SE(js_cc_scene_Camera_surfaceTransform_get), nullptr); 
    cls->defineProperty("geometryRenderer", _SE(js_cc_scene_Camera_geometryRenderer_get), nullptr); 
    cls->defineProperty("systemWindowId", _SE(js_cc_scene_Camera_systemWindowId_get), nullptr); 
    cls->defineProperty("cameraUsage", _SE(js_cc_scene_Camera_cameraUsage_get), _SE(js_cc_scene_Camera_cameraUsage_set)); 
    
    cls->defineFunction("initialize", _SE(js_cc_scene_Camera_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_scene_Camera_destroy)); 
    cls->defineFunction("attachToScene", _SE(js_cc_scene_Camera_attachToScene)); 
    cls->defineFunction("detachFromScene", _SE(js_cc_scene_Camera_detachFromScene)); 
    cls->defineFunction("resize", _SE(js_cc_scene_Camera_resize)); 
    cls->defineFunction("setFixedSize", _SE(js_cc_scene_Camera_setFixedSize)); 
    cls->defineFunction("syncCameraEditor", _SE(js_cc_scene_Camera_syncCameraEditor)); 
    cls->defineFunction("update", _SE(js_cc_scene_Camera_update)); 
    cls->defineFunction("changeTargetWindow", _SE(js_cc_scene_Camera_changeTargetWindow)); 
    cls->defineFunction("setViewportInOrientedSpace", _SE(js_cc_scene_Camera_setViewportInOrientedSpace)); 
    cls->defineFunction("initGeometryRenderer", _SE(js_cc_scene_Camera_initGeometryRenderer)); 
    cls->defineFunction("detachCamera", _SE(js_cc_scene_Camera_detachCamera)); 
    cls->defineFunction("getCameraType", _SE(js_cc_scene_Camera_getCameraType)); 
    cls->defineFunction("setCameraType", _SE(js_cc_scene_Camera_setCameraType)); 
    cls->defineFunction("getTrackingType", _SE(js_cc_scene_Camera_getTrackingType)); 
    cls->defineFunction("setTrackingType", _SE(js_cc_scene_Camera_setTrackingType)); 
    cls->defineFunction("isCullingEnabled", _SE(js_cc_scene_Camera_isCullingEnabled)); 
    cls->defineFunction("setCullingEnable", _SE(js_cc_scene_Camera_setCullingEnable)); 
    cls->defineFunction("calculateObliqueMat", _SE(js_cc_scene_Camera_calculateObliqueMat)); 
    
    cls->defineStaticProperty("SKYBOX_FLAG", _SE(js_cc_scene_Camera_SKYBOX_FLAG_get), nullptr); 
    
    cls->defineStaticFunction("getStandardExposureValue", _SE(js_cc_scene_Camera_getStandardExposureValue_static)); 
    cls->defineStaticFunction("getStandardLightMeterScale", _SE(js_cc_scene_Camera_getStandardLightMeterScale_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_Camera));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::Camera>(cls);
    
    __jsb_cc_scene_Camera_proto = cls->getProto();
    __jsb_cc_scene_Camera_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_Ambient_class = nullptr;
se::Object* __jsb_cc_scene_Ambient_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_Ambient) 

static bool js_cc_scene_Ambient_SUN_ILLUM_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    float result;
    
    result = (float)(float)cc::scene::Ambient::SUN_ILLUM;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Ambient_SUN_ILLUM_get) 

static bool js_cc_scene_Ambient_SKY_ILLUM_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    float result;
    
    result = (float)(float)cc::scene::Ambient::SKY_ILLUM;
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Ambient_SKY_ILLUM_get) 

static bool js_new_cc_scene_Ambient(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::Ambient *result;
    result = (cc::scene::Ambient *)new cc::scene::Ambient();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_Ambient, __jsb_cc_scene_Ambient_class, js_delete_cc_scene_Ambient)

static bool js_delete_cc_scene_Ambient(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_Ambient) 

static bool js_cc_scene_Ambient_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Ambient *arg1 = (cc::scene::Ambient *) NULL ;
    cc::scene::AmbientInfo *arg2 = (cc::scene::AmbientInfo *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Ambient>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->initialize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Ambient_initialize) 

static bool js_cc_scene_Ambient_skyColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Ambient *arg1 = (cc::scene::Ambient *) NULL ;
    cc::Vec4 *arg2 = 0 ;
    cc::Vec4 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Ambient>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_Ambient_skyColor_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Ambient_skyColor_set) 

static bool js_cc_scene_Ambient_skyColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Ambient *arg1 = (cc::scene::Ambient *) NULL ;
    cc::Vec4 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Ambient>(s);
    if (nullptr == arg1) return true;
    result = (cc::Vec4 *) &cc_scene_Ambient_skyColor_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Ambient_skyColor_get) 

static bool js_cc_scene_Ambient_skyIllum_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Ambient *arg1 = (cc::scene::Ambient *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Ambient>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Ambient_skyIllum_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Ambient_skyIllum_set) 

static bool js_cc_scene_Ambient_skyIllum_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Ambient *arg1 = (cc::scene::Ambient *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Ambient>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_Ambient_skyIllum_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Ambient_skyIllum_get) 

static bool js_cc_scene_Ambient_groundAlbedo_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Ambient *arg1 = (cc::scene::Ambient *) NULL ;
    cc::Vec4 *arg2 = 0 ;
    cc::Vec4 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Ambient>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_Ambient_groundAlbedo_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Ambient_groundAlbedo_set) 

static bool js_cc_scene_Ambient_groundAlbedo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Ambient *arg1 = (cc::scene::Ambient *) NULL ;
    cc::Vec4 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Ambient>(s);
    if (nullptr == arg1) return true;
    result = (cc::Vec4 *) &cc_scene_Ambient_groundAlbedo_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Ambient_groundAlbedo_get) 

static bool js_cc_scene_Ambient_enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Ambient *arg1 = (cc::scene::Ambient *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Ambient>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_Ambient_enabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Ambient_enabled_set) 

static bool js_cc_scene_Ambient_enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Ambient *arg1 = (cc::scene::Ambient *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Ambient>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_Ambient_enabled_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Ambient_enabled_get) 

static bool js_cc_scene_Ambient_mipmapCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Ambient *arg1 = (cc::scene::Ambient *) NULL ;
    uint8_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Ambient>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_scene_Ambient_mipmapCount_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Ambient_mipmapCount_set) 

static bool js_cc_scene_Ambient_mipmapCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Ambient *arg1 = (cc::scene::Ambient *) NULL ;
    uint8_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Ambient>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_Ambient_mipmapCount_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Ambient_mipmapCount_get) 

bool js_register_cc_scene_Ambient(se::Object* obj) {
    auto* cls = se::Class::create("Ambient", obj, nullptr, _SE(js_new_cc_scene_Ambient)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("skyColor", _SE(js_cc_scene_Ambient_skyColor_get), _SE(js_cc_scene_Ambient_skyColor_set)); 
    cls->defineProperty("skyIllum", _SE(js_cc_scene_Ambient_skyIllum_get), _SE(js_cc_scene_Ambient_skyIllum_set)); 
    cls->defineProperty("groundAlbedo", _SE(js_cc_scene_Ambient_groundAlbedo_get), _SE(js_cc_scene_Ambient_groundAlbedo_set)); 
    cls->defineProperty("enabled", _SE(js_cc_scene_Ambient_enabled_get), _SE(js_cc_scene_Ambient_enabled_set)); 
    cls->defineProperty("mipmapCount", _SE(js_cc_scene_Ambient_mipmapCount_get), _SE(js_cc_scene_Ambient_mipmapCount_set)); 
    
    cls->defineFunction("initialize", _SE(js_cc_scene_Ambient_initialize)); 
    
    cls->defineStaticProperty("SUN_ILLUM", _SE(js_cc_scene_Ambient_SUN_ILLUM_get), nullptr); 
    cls->defineStaticProperty("SKY_ILLUM", _SE(js_cc_scene_Ambient_SKY_ILLUM_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_Ambient));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::Ambient>(cls);
    
    __jsb_cc_scene_Ambient_proto = cls->getProto();
    __jsb_cc_scene_Ambient_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_AmbientInfo_class = nullptr;
se::Object* __jsb_cc_scene_AmbientInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_AmbientInfo) 

static bool js_new_cc_scene_AmbientInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::AmbientInfo *result;
    result = (cc::scene::AmbientInfo *)new cc::scene::AmbientInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_AmbientInfo, __jsb_cc_scene_AmbientInfo_class, js_delete_cc_scene_AmbientInfo)

static bool js_delete_cc_scene_AmbientInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_AmbientInfo) 

static bool js_cc_scene_AmbientInfo_activate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    cc::scene::Ambient *arg2 = (cc::scene::Ambient *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->activate(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_AmbientInfo_activate) 

static bool js_cc_scene_AmbientInfo__skyColorHDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_skyColorHDR, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo__skyColorHDR_set) 

static bool js_cc_scene_AmbientInfo__skyColorHDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_skyColorHDR, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_skyColorHDR, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo__skyColorHDR_get) 

static bool js_cc_scene_AmbientInfo__skyIllumHDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_skyIllumHDR, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo__skyIllumHDR_set) 

static bool js_cc_scene_AmbientInfo__skyIllumHDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_skyIllumHDR, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo__skyIllumHDR_get) 

static bool js_cc_scene_AmbientInfo__groundAlbedoHDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_groundAlbedoHDR, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo__groundAlbedoHDR_set) 

static bool js_cc_scene_AmbientInfo__groundAlbedoHDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_groundAlbedoHDR, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_groundAlbedoHDR, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo__groundAlbedoHDR_get) 

static bool js_cc_scene_AmbientInfo__skyColorLDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_skyColorLDR, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo__skyColorLDR_set) 

static bool js_cc_scene_AmbientInfo__skyColorLDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_skyColorLDR, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_skyColorLDR, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo__skyColorLDR_get) 

static bool js_cc_scene_AmbientInfo__skyIllumLDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_skyIllumLDR, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo__skyIllumLDR_set) 

static bool js_cc_scene_AmbientInfo__skyIllumLDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_skyIllumLDR, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo__skyIllumLDR_get) 

static bool js_cc_scene_AmbientInfo__groundAlbedoLDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_groundAlbedoLDR, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo__groundAlbedoLDR_set) 

static bool js_cc_scene_AmbientInfo__groundAlbedoLDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_groundAlbedoLDR, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_groundAlbedoLDR, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo__groundAlbedoLDR_get) 

static bool js_cc_scene_AmbientInfo_skyColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    cc::Vec4 *arg2 = 0 ;
    cc::Vec4 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_AmbientInfo_skyColor_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo_skyColor_set) 

static bool js_cc_scene_AmbientInfo_skyIllum_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_AmbientInfo_skyIllum_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo_skyIllum_set) 

static bool js_cc_scene_AmbientInfo_skyIllum_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_AmbientInfo_skyIllum_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo_skyIllum_get) 

static bool js_cc_scene_AmbientInfo_groundAlbedo_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    cc::Vec4 *arg2 = 0 ;
    cc::Vec4 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_AmbientInfo_groundAlbedo_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo_groundAlbedo_set) 

static bool js_cc_scene_AmbientInfo__skyColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    cc::Vec4 *arg2 = 0 ;
    cc::Vec4 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_AmbientInfo__skyColor_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo__skyColor_set) 

static bool js_cc_scene_AmbientInfo__skyColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    cc::Vec4 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::Vec4 *) &cc_scene_AmbientInfo__skyColor_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo__skyColor_get) 

static bool js_cc_scene_AmbientInfo__skyIllum_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_AmbientInfo__skyIllum_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo__skyIllum_set) 

static bool js_cc_scene_AmbientInfo__skyIllum_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_AmbientInfo__skyIllum_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo__skyIllum_get) 

static bool js_cc_scene_AmbientInfo__groundAlbedo_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    cc::Vec4 *arg2 = 0 ;
    cc::Vec4 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_AmbientInfo__groundAlbedo_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo__groundAlbedo_set) 

static bool js_cc_scene_AmbientInfo__groundAlbedo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    cc::Vec4 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::Vec4 *) &cc_scene_AmbientInfo__groundAlbedo_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo__groundAlbedo_get) 

static bool js_cc_scene_AmbientInfo_skyColorLDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    cc::Vec4 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::Vec4 *) &cc_scene_AmbientInfo_skyColorLDR_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo_skyColorLDR_get) 

static bool js_cc_scene_AmbientInfo_groundAlbedoLDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    cc::Vec4 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::Vec4 *) &cc_scene_AmbientInfo_groundAlbedoLDR_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo_groundAlbedoLDR_get) 

static bool js_cc_scene_AmbientInfo_skyIllumLDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    result = (float)cc_scene_AmbientInfo_skyIllumLDR_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo_skyIllumLDR_get) 

static bool js_cc_scene_AmbientInfo_skyLightingColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    cc::Color *arg2 = 0 ;
    cc::Color temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_AmbientInfo_skyLightingColor_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo_skyLightingColor_set) 

static bool js_cc_scene_AmbientInfo_skyLightingColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    cc::Color *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::Color *) &cc_scene_AmbientInfo_skyLightingColor_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo_skyLightingColor_get) 

static bool js_cc_scene_AmbientInfo_groundLightingColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    cc::Color *arg2 = 0 ;
    cc::Color temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_AmbientInfo_groundLightingColor_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo_groundLightingColor_set) 

static bool js_cc_scene_AmbientInfo_groundLightingColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    cc::Color *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::Color *) &cc_scene_AmbientInfo_groundLightingColor_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo_groundLightingColor_get) 

bool js_register_cc_scene_AmbientInfo(se::Object* obj) {
    auto* cls = se::Class::create("AmbientInfo", obj, nullptr, _SE(js_new_cc_scene_AmbientInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("_skyColorHDR", _SE(js_cc_scene_AmbientInfo__skyColorHDR_get), _SE(js_cc_scene_AmbientInfo__skyColorHDR_set)); 
    cls->defineProperty("_skyIllumHDR", _SE(js_cc_scene_AmbientInfo__skyIllumHDR_get), _SE(js_cc_scene_AmbientInfo__skyIllumHDR_set)); 
    cls->defineProperty("_groundAlbedoHDR", _SE(js_cc_scene_AmbientInfo__groundAlbedoHDR_get), _SE(js_cc_scene_AmbientInfo__groundAlbedoHDR_set)); 
    cls->defineProperty("_skyColorLDR", _SE(js_cc_scene_AmbientInfo__skyColorLDR_get), _SE(js_cc_scene_AmbientInfo__skyColorLDR_set)); 
    cls->defineProperty("_skyIllumLDR", _SE(js_cc_scene_AmbientInfo__skyIllumLDR_get), _SE(js_cc_scene_AmbientInfo__skyIllumLDR_set)); 
    cls->defineProperty("_groundAlbedoLDR", _SE(js_cc_scene_AmbientInfo__groundAlbedoLDR_get), _SE(js_cc_scene_AmbientInfo__groundAlbedoLDR_set)); 
    cls->defineProperty("skyColor", nullptr, _SE(js_cc_scene_AmbientInfo_skyColor_set)); 
    cls->defineProperty("skyIllum", _SE(js_cc_scene_AmbientInfo_skyIllum_get), _SE(js_cc_scene_AmbientInfo_skyIllum_set)); 
    cls->defineProperty("groundAlbedo", nullptr, _SE(js_cc_scene_AmbientInfo_groundAlbedo_set)); 
    cls->defineProperty("_skyColor", _SE(js_cc_scene_AmbientInfo__skyColor_get), _SE(js_cc_scene_AmbientInfo__skyColor_set)); 
    cls->defineProperty("_skyIllum", _SE(js_cc_scene_AmbientInfo__skyIllum_get), _SE(js_cc_scene_AmbientInfo__skyIllum_set)); 
    cls->defineProperty("_groundAlbedo", _SE(js_cc_scene_AmbientInfo__groundAlbedo_get), _SE(js_cc_scene_AmbientInfo__groundAlbedo_set)); 
    cls->defineProperty("skyColorLDR", _SE(js_cc_scene_AmbientInfo_skyColorLDR_get), nullptr); 
    cls->defineProperty("groundAlbedoLDR", _SE(js_cc_scene_AmbientInfo_groundAlbedoLDR_get), nullptr); 
    cls->defineProperty("skyIllumLDR", _SE(js_cc_scene_AmbientInfo_skyIllumLDR_get), nullptr); 
    cls->defineProperty("skyLightingColor", _SE(js_cc_scene_AmbientInfo_skyLightingColor_get), _SE(js_cc_scene_AmbientInfo_skyLightingColor_set)); 
    cls->defineProperty("groundLightingColor", _SE(js_cc_scene_AmbientInfo_groundLightingColor_get), _SE(js_cc_scene_AmbientInfo_groundLightingColor_set)); 
    
    cls->defineFunction("activate", _SE(js_cc_scene_AmbientInfo_activate)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_AmbientInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::AmbientInfo>(cls);
    
    __jsb_cc_scene_AmbientInfo_proto = cls->getProto();
    __jsb_cc_scene_AmbientInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_ReflectionProbe_class = nullptr;
se::Object* __jsb_cc_scene_ReflectionProbe_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_ReflectionProbe) 

static bool js_new_cc_scene_ReflectionProbe(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    int32_t arg1 ;
    cc::scene::ReflectionProbe *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::scene::ReflectionProbe *)new cc::scene::ReflectionProbe(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_ReflectionProbe, __jsb_cc_scene_ReflectionProbe_class, js_delete_cc_scene_ReflectionProbe)

static bool js_delete_cc_scene_ReflectionProbe(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_ReflectionProbe) 

static bool js_cc_scene_ReflectionProbe_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    cc::Node *arg3 = (cc::Node *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->initialize(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ReflectionProbe_initialize) 

static bool js_cc_scene_ReflectionProbe_getProbeId(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    int32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    result = ((cc::scene::ReflectionProbe const *)arg1)->getProbeId();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ReflectionProbe_getProbeId) 

static bool js_cc_scene_ReflectionProbe_getCamera(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    cc::scene::Camera *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::Camera *)((cc::scene::ReflectionProbe const *)arg1)->getCamera();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ReflectionProbe_getCamera) 

static bool js_cc_scene_ReflectionProbe_needRender(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    result = (bool)((cc::scene::ReflectionProbe const *)arg1)->needRender();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ReflectionProbe_needRender) 

static bool js_cc_scene_ReflectionProbe_setNeedRender(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setNeedRender(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ReflectionProbe_setNeedRender) 

static bool js_cc_scene_ReflectionProbe_setCameraNode(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setCameraNode(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ReflectionProbe_setCameraNode) 

static bool js_cc_scene_ReflectionProbe_getCameraNode(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    cc::Node *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    result = (cc::Node *)((cc::scene::ReflectionProbe const *)arg1)->getCameraNode();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ReflectionProbe_getCameraNode) 

static bool js_cc_scene_ReflectionProbe_updateBoundingBox(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    (arg1)->updateBoundingBox();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ReflectionProbe_updateBoundingBox) 

static bool js_cc_scene_ReflectionProbe_syncCameraParams(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->syncCameraParams((cc::scene::Camera const *)arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ReflectionProbe_syncCameraParams) 

static bool js_cc_scene_ReflectionProbe_transformReflectionCamera(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->transformReflectionCamera((cc::scene::Camera const *)arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ReflectionProbe_transformReflectionCamera) 

static bool js_cc_scene_ReflectionProbe_renderPlanarReflection(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->renderPlanarReflection((cc::scene::Camera const *)arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ReflectionProbe_renderPlanarReflection) 

static bool js_cc_scene_ReflectionProbe_switchProbeType(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    int32_t arg2 ;
    cc::scene::Camera *arg3 = (cc::scene::Camera *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->switchProbeType(arg2,(cc::scene::Camera const *)arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ReflectionProbe_switchProbeType) 

static bool js_cc_scene_ReflectionProbe_reflect_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec3 *arg1 = 0 ;
    cc::Vec3 *arg2 = 0 ;
    float arg3 ;
    cc::Vec3 temp1 ;
    cc::Vec3 temp2 ;
    cc::Vec3 result;
    cc::Vec3 *temp ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = cc::scene::ReflectionProbe::reflect((cc::Vec3 const &)*arg1,(cc::Vec3 const &)*arg2,arg3);
    
    temp = ccnew cc::Vec3(result);
    ok &= nativevalue_to_se(temp, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ReflectionProbe_reflect_static) 

static bool js_cc_scene_ReflectionProbe_updatePlanarTexture(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    cc::scene::RenderScene *arg2 = (cc::scene::RenderScene *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->updatePlanarTexture((cc::scene::RenderScene const *)arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ReflectionProbe_updatePlanarTexture) 

static bool js_cc_scene_ReflectionProbe_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ReflectionProbe_destroy) 

static bool js_cc_scene_ReflectionProbe_enable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    (arg1)->enable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ReflectionProbe_enable) 

static bool js_cc_scene_ReflectionProbe_disable(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    (arg1)->disable();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ReflectionProbe_disable) 

static bool js_cc_scene_ReflectionProbe_validate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    result = (bool)((cc::scene::ReflectionProbe const *)arg1)->validate();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ReflectionProbe_validate) 

static bool js_cc_scene_ReflectionProbe_initBakedTextures(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    (arg1)->initBakedTextures();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ReflectionProbe_initBakedTextures) 

static bool js_cc_scene_ReflectionProbe_captureCubemap(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    (arg1)->captureCubemap();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ReflectionProbe_captureCubemap) 

static bool js_cc_scene_ReflectionProbe_resetCameraParams(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    (arg1)->resetCameraParams();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ReflectionProbe_resetCameraParams) 

static bool js_cc_scene_ReflectionProbe_updateCameraDir(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    int32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->updateCameraDir(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ReflectionProbe_updateCameraDir) 

static bool js_cc_scene_ReflectionProbe_getRenderArea(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    cc::Vec2 result;
    cc::Vec2 *temp ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    result = ((cc::scene::ReflectionProbe const *)arg1)->getRenderArea();
    
    temp = ccnew cc::Vec2(result);
    ok &= nativevalue_to_se(temp, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ReflectionProbe_getRenderArea) 

static bool js_cc_scene_ReflectionProbe_packBackgroundColor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    (arg1)->packBackgroundColor();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ReflectionProbe_packBackgroundColor) 

static bool js_cc_scene_ReflectionProbe_probeType_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    cc::scene::ReflectionProbe::ProbeType arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_scene_ReflectionProbe_probeType_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ReflectionProbe_probeType_set) 

static bool js_cc_scene_ReflectionProbe_probeType_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    cc::scene::ReflectionProbe::ProbeType result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::ReflectionProbe::ProbeType)cc_scene_ReflectionProbe_probeType_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ReflectionProbe_probeType_get) 

static bool js_cc_scene_ReflectionProbe_resolution_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_scene_ReflectionProbe_resolution_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ReflectionProbe_resolution_set) 

static bool js_cc_scene_ReflectionProbe_resolution_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_ReflectionProbe_resolution_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ReflectionProbe_resolution_get) 

static bool js_cc_scene_ReflectionProbe_clearFlag_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    cc::gfx::ClearFlagBit arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_scene_ReflectionProbe_clearFlag_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ReflectionProbe_clearFlag_set) 

static bool js_cc_scene_ReflectionProbe_clearFlag_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    cc::gfx::ClearFlagBit result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_ReflectionProbe_clearFlag_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ReflectionProbe_clearFlag_get) 

static bool js_cc_scene_ReflectionProbe_backgroundColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    cc::gfx::Color *arg2 = 0 ;
    cc::gfx::Color temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_ReflectionProbe_backgroundColor_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ReflectionProbe_backgroundColor_set) 

static bool js_cc_scene_ReflectionProbe_backgroundColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    cc::gfx::Color *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Color *) &cc_scene_ReflectionProbe_backgroundColor_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ReflectionProbe_backgroundColor_get) 

static bool js_cc_scene_ReflectionProbe_visibility_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_scene_ReflectionProbe_visibility_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ReflectionProbe_visibility_set) 

static bool js_cc_scene_ReflectionProbe_visibility_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_ReflectionProbe_visibility_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ReflectionProbe_visibility_get) 

static bool js_cc_scene_ReflectionProbe_size_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_ReflectionProbe_size_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ReflectionProbe_size_set) 

static bool js_cc_scene_ReflectionProbe_size_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    result = (cc::Vec3 *) &cc_scene_ReflectionProbe_size_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ReflectionProbe_size_get) 

static bool js_cc_scene_ReflectionProbe_boundingBox_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    result = (cc::geometry::AABB *)cc_scene_ReflectionProbe_boundingBox_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ReflectionProbe_boundingBox_get) 

static bool js_cc_scene_ReflectionProbe_previewSphere_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_ReflectionProbe_previewSphere_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ReflectionProbe_previewSphere_set) 

static bool js_cc_scene_ReflectionProbe_previewSphere_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    cc::Node *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    result = (cc::Node *)cc_scene_ReflectionProbe_previewSphere_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ReflectionProbe_previewSphere_get) 

static bool js_cc_scene_ReflectionProbe_previewPlane_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_ReflectionProbe_previewPlane_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ReflectionProbe_previewPlane_set) 

static bool js_cc_scene_ReflectionProbe_previewPlane_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    cc::Node *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    result = (cc::Node *)cc_scene_ReflectionProbe_previewPlane_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ReflectionProbe_previewPlane_get) 

static bool js_cc_scene_ReflectionProbe_bakedCubeTextures_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::RenderTexture > > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::IntrusivePtr< cc::RenderTexture > > *) &cc_scene_ReflectionProbe_bakedCubeTextures_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ReflectionProbe_bakedCubeTextures_get) 

static bool js_cc_scene_ReflectionProbe_cubemap_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    cc::TextureCube *arg2 = (cc::TextureCube *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_ReflectionProbe_cubemap_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ReflectionProbe_cubemap_set) 

static bool js_cc_scene_ReflectionProbe_cubemap_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    cc::TextureCube *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    result = (cc::TextureCube *)cc_scene_ReflectionProbe_cubemap_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ReflectionProbe_cubemap_get) 

static bool js_cc_scene_ReflectionProbe_node_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    cc::Node *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    result = (cc::Node *)cc_scene_ReflectionProbe_node_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ReflectionProbe_node_get) 

static bool js_cc_scene_ReflectionProbe_realtimePlanarTexture_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ReflectionProbe *arg1 = (cc::scene::ReflectionProbe *) NULL ;
    cc::RenderTexture *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ReflectionProbe>(s);
    if (nullptr == arg1) return true;
    result = (cc::RenderTexture *)cc_scene_ReflectionProbe_realtimePlanarTexture_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ReflectionProbe_realtimePlanarTexture_get) 

bool js_register_cc_scene_ReflectionProbe(se::Object* obj) {
    auto* cls = se::Class::create("ReflectionProbe", obj, nullptr, _SE(js_new_cc_scene_ReflectionProbe)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("probeType", _SE(js_cc_scene_ReflectionProbe_probeType_get), _SE(js_cc_scene_ReflectionProbe_probeType_set)); 
    cls->defineProperty("resolution", _SE(js_cc_scene_ReflectionProbe_resolution_get), _SE(js_cc_scene_ReflectionProbe_resolution_set)); 
    cls->defineProperty("clearFlag", _SE(js_cc_scene_ReflectionProbe_clearFlag_get), _SE(js_cc_scene_ReflectionProbe_clearFlag_set)); 
    cls->defineProperty("backgroundColor", _SE(js_cc_scene_ReflectionProbe_backgroundColor_get), _SE(js_cc_scene_ReflectionProbe_backgroundColor_set)); 
    cls->defineProperty("visibility", _SE(js_cc_scene_ReflectionProbe_visibility_get), _SE(js_cc_scene_ReflectionProbe_visibility_set)); 
    cls->defineProperty("size", _SE(js_cc_scene_ReflectionProbe_size_get), _SE(js_cc_scene_ReflectionProbe_size_set)); 
    cls->defineProperty("boundingBox", _SE(js_cc_scene_ReflectionProbe_boundingBox_get), nullptr); 
    cls->defineProperty("previewSphere", _SE(js_cc_scene_ReflectionProbe_previewSphere_get), _SE(js_cc_scene_ReflectionProbe_previewSphere_set)); 
    cls->defineProperty("previewPlane", _SE(js_cc_scene_ReflectionProbe_previewPlane_get), _SE(js_cc_scene_ReflectionProbe_previewPlane_set)); 
    cls->defineProperty("bakedCubeTextures", _SE(js_cc_scene_ReflectionProbe_bakedCubeTextures_get), nullptr); 
    cls->defineProperty("cubemap", _SE(js_cc_scene_ReflectionProbe_cubemap_get), _SE(js_cc_scene_ReflectionProbe_cubemap_set)); 
    cls->defineProperty("node", _SE(js_cc_scene_ReflectionProbe_node_get), nullptr); 
    cls->defineProperty("realtimePlanarTexture", _SE(js_cc_scene_ReflectionProbe_realtimePlanarTexture_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_scene_ReflectionProbe_initialize)); 
    cls->defineFunction("getProbeId", _SE(js_cc_scene_ReflectionProbe_getProbeId)); 
    cls->defineFunction("getCamera", _SE(js_cc_scene_ReflectionProbe_getCamera)); 
    cls->defineFunction("needRender", _SE(js_cc_scene_ReflectionProbe_needRender)); 
    cls->defineFunction("setNeedRender", _SE(js_cc_scene_ReflectionProbe_setNeedRender)); 
    cls->defineFunction("setCameraNode", _SE(js_cc_scene_ReflectionProbe_setCameraNode)); 
    cls->defineFunction("getCameraNode", _SE(js_cc_scene_ReflectionProbe_getCameraNode)); 
    cls->defineFunction("updateBoundingBox", _SE(js_cc_scene_ReflectionProbe_updateBoundingBox)); 
    cls->defineFunction("syncCameraParams", _SE(js_cc_scene_ReflectionProbe_syncCameraParams)); 
    cls->defineFunction("transformReflectionCamera", _SE(js_cc_scene_ReflectionProbe_transformReflectionCamera)); 
    cls->defineFunction("renderPlanarReflection", _SE(js_cc_scene_ReflectionProbe_renderPlanarReflection)); 
    cls->defineFunction("switchProbeType", _SE(js_cc_scene_ReflectionProbe_switchProbeType)); 
    cls->defineFunction("updatePlanarTexture", _SE(js_cc_scene_ReflectionProbe_updatePlanarTexture)); 
    cls->defineFunction("destroy", _SE(js_cc_scene_ReflectionProbe_destroy)); 
    cls->defineFunction("enable", _SE(js_cc_scene_ReflectionProbe_enable)); 
    cls->defineFunction("disable", _SE(js_cc_scene_ReflectionProbe_disable)); 
    cls->defineFunction("validate", _SE(js_cc_scene_ReflectionProbe_validate)); 
    cls->defineFunction("initBakedTextures", _SE(js_cc_scene_ReflectionProbe_initBakedTextures)); 
    cls->defineFunction("captureCubemap", _SE(js_cc_scene_ReflectionProbe_captureCubemap)); 
    cls->defineFunction("resetCameraParams", _SE(js_cc_scene_ReflectionProbe_resetCameraParams)); 
    cls->defineFunction("updateCameraDir", _SE(js_cc_scene_ReflectionProbe_updateCameraDir)); 
    cls->defineFunction("getRenderArea", _SE(js_cc_scene_ReflectionProbe_getRenderArea)); 
    cls->defineFunction("packBackgroundColor", _SE(js_cc_scene_ReflectionProbe_packBackgroundColor)); 
    
    
    cls->defineStaticFunction("reflect", _SE(js_cc_scene_ReflectionProbe_reflect_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_ReflectionProbe));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::ReflectionProbe>(cls);
    
    __jsb_cc_scene_ReflectionProbe_proto = cls->getProto();
    __jsb_cc_scene_ReflectionProbe_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_PassInstance_class = nullptr;
se::Object* __jsb_cc_PassInstance_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_PassInstance) 

static bool js_new_cc_PassInstance(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::MaterialInstance *arg2 = (cc::MaterialInstance *) NULL ;
    cc::PassInstance *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::PassInstance *)new cc::PassInstance(arg1,arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_PassInstance, __jsb_cc_PassInstance_class, js_delete_cc_PassInstance)

static bool js_delete_cc_PassInstance(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_PassInstance) 

static bool js_cc_PassInstance_parent_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::PassInstance *arg1 = (cc::PassInstance *) NULL ;
    cc::scene::Pass *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::PassInstance>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::Pass *)cc_PassInstance_parent_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_PassInstance_parent_get) 

bool js_register_cc_PassInstance(se::Object* obj) {
    auto* cls = se::Class::create("PassInstance", obj, __jsb_cc_scene_Pass_proto, _SE(js_new_cc_PassInstance)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("parent", _SE(js_cc_PassInstance_parent_get), nullptr); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_PassInstance));
    
    
    cls->install();
    JSBClassType::registerClass<cc::PassInstance>(cls);
    
    __jsb_cc_PassInstance_proto = cls->getProto();
    __jsb_cc_PassInstance_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IMaterialInstanceInfo_class = nullptr;
se::Object* __jsb_cc_IMaterialInstanceInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IMaterialInstanceInfo) 

static bool js_cc_IMaterialInstanceInfo_parent_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMaterialInstanceInfo *arg1 = (cc::IMaterialInstanceInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInstanceInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->parent, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMaterialInstanceInfo_parent_set) 

static bool js_cc_IMaterialInstanceInfo_parent_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMaterialInstanceInfo *arg1 = (cc::IMaterialInstanceInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInstanceInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->parent, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->parent, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMaterialInstanceInfo_parent_get) 

static bool js_cc_IMaterialInstanceInfo_subModelIdx_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMaterialInstanceInfo *arg1 = (cc::IMaterialInstanceInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInstanceInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->subModelIdx, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMaterialInstanceInfo_subModelIdx_set) 

static bool js_cc_IMaterialInstanceInfo_subModelIdx_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMaterialInstanceInfo *arg1 = (cc::IMaterialInstanceInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInstanceInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->subModelIdx, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMaterialInstanceInfo_subModelIdx_get) 

static bool js_new_cc_IMaterialInstanceInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IMaterialInstanceInfo *result;
    result = (cc::IMaterialInstanceInfo *)new cc::IMaterialInstanceInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IMaterialInstanceInfo, __jsb_cc_IMaterialInstanceInfo_class, js_delete_cc_IMaterialInstanceInfo)

static bool js_delete_cc_IMaterialInstanceInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IMaterialInstanceInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IMaterialInstanceInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IMaterialInstanceInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("parent", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->parent), ctx);
    }
    
    
    json->getProperty("subModelIdx", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->subModelIdx), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IMaterialInstanceInfo(se::Object* obj) {
    auto* cls = se::Class::create("IMaterialInstanceInfo", obj, nullptr, _SE(js_new_cc_IMaterialInstanceInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("parent", _SE(js_cc_IMaterialInstanceInfo_parent_get), _SE(js_cc_IMaterialInstanceInfo_parent_set)); 
    cls->defineProperty("subModelIdx", _SE(js_cc_IMaterialInstanceInfo_subModelIdx_get), _SE(js_cc_IMaterialInstanceInfo_subModelIdx_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IMaterialInstanceInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IMaterialInstanceInfo>(cls);
    
    __jsb_cc_IMaterialInstanceInfo_proto = cls->getProto();
    __jsb_cc_IMaterialInstanceInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_MaterialInstance_class = nullptr;
se::Object* __jsb_cc_MaterialInstance_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_MaterialInstance) 

static bool js_new_cc_MaterialInstance(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    cc::IMaterialInstanceInfo *arg1 = 0 ;
    cc::IMaterialInstanceInfo temp1 ;
    cc::MaterialInstance *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = (cc::MaterialInstance *)new cc::MaterialInstance((cc::IMaterialInstanceInfo const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_MaterialInstance, __jsb_cc_MaterialInstance_class, js_delete_cc_MaterialInstance)

static bool js_cc_MaterialInstance_recompileShaders__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::MaterialInstance *arg1 = (cc::MaterialInstance *) NULL ;
    cc::MacroRecord *arg2 = 0 ;
    cc::MacroRecord temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::MaterialInstance>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->recompileShaders((cc::MacroRecord const &)*arg2);
    
    
    return true;
}

static bool js_cc_MaterialInstance_recompileShaders__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::MaterialInstance *arg1 = (cc::MaterialInstance *) NULL ;
    cc::MacroRecord *arg2 = 0 ;
    index_t arg3 ;
    cc::MacroRecord temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::MaterialInstance>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->recompileShaders((cc::MacroRecord const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_MaterialInstance_recompileShaders(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_cc_MaterialInstance_recompileShaders__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_MaterialInstance_recompileShaders__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_MaterialInstance_recompileShaders) 

static bool js_cc_MaterialInstance_overridePipelineStates__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::MaterialInstance *arg1 = (cc::MaterialInstance *) NULL ;
    cc::PassOverrides *arg2 = 0 ;
    cc::PassOverrides temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::MaterialInstance>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->overridePipelineStates((cc::PassOverrides const &)*arg2);
    
    
    return true;
}

static bool js_cc_MaterialInstance_overridePipelineStates__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::MaterialInstance *arg1 = (cc::MaterialInstance *) NULL ;
    cc::PassOverrides *arg2 = 0 ;
    index_t arg3 ;
    cc::PassOverrides temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::MaterialInstance>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->overridePipelineStates((cc::PassOverrides const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_MaterialInstance_overridePipelineStates(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_cc_MaterialInstance_overridePipelineStates__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_MaterialInstance_overridePipelineStates__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_MaterialInstance_overridePipelineStates) 

static bool js_cc_MaterialInstance_onPassStateChange(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MaterialInstance *arg1 = (cc::MaterialInstance *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::MaterialInstance>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->onPassStateChange(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_MaterialInstance_onPassStateChange) 

static bool js_cc_MaterialInstance_setRebuildPSOCallback(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MaterialInstance *arg1 = (cc::MaterialInstance *) NULL ;
    cc::MaterialInstance::RebuildPSOCallback *arg2 = 0 ;
    cc::MaterialInstance::RebuildPSOCallback temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::MaterialInstance>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setRebuildPSOCallback((cc::MaterialInstance::RebuildPSOCallback const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_MaterialInstance_setRebuildPSOCallback) 

static bool js_delete_cc_MaterialInstance(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_MaterialInstance) 

bool js_register_cc_MaterialInstance(se::Object* obj) {
    auto* cls = se::Class::create("MaterialInstance", obj, __jsb_cc_Material_proto, _SE(js_new_cc_MaterialInstance)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("recompileShaders", _SE(js_cc_MaterialInstance_recompileShaders)); 
    cls->defineFunction("overridePipelineStates", _SE(js_cc_MaterialInstance_overridePipelineStates)); 
    cls->defineFunction("onPassStateChange", _SE(js_cc_MaterialInstance_onPassStateChange)); 
    cls->defineFunction("setRebuildPSOCallback", _SE(js_cc_MaterialInstance_setRebuildPSOCallback)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_MaterialInstance));
    
    
    cls->install();
    JSBClassType::registerClass<cc::MaterialInstance>(cls);
    
    __jsb_cc_MaterialInstance_proto = cls->getProto();
    __jsb_cc_MaterialInstance_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_MorphModel_class = nullptr;
se::Object* __jsb_cc_MorphModel_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_MorphModel) 

static bool js_new_cc_MorphModel(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::MorphModel *result;
    result = (cc::MorphModel *)new cc::MorphModel();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_MorphModel, __jsb_cc_MorphModel_class, js_delete_cc_MorphModel)

static bool js_delete_cc_MorphModel(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_MorphModel) 

static bool js_cc_MorphModel_setMorphRendering(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MorphModel *arg1 = (cc::MorphModel *) NULL ;
    cc::MorphRenderingInstance *arg2 = (cc::MorphRenderingInstance *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::MorphModel>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setMorphRendering(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_MorphModel_setMorphRendering) 

bool js_register_cc_MorphModel(se::Object* obj) {
    auto* cls = se::Class::create("MorphModel", obj, __jsb_cc_scene_Model_proto, _SE(js_new_cc_MorphModel)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("setMorphRendering", _SE(js_cc_MorphModel_setMorphRendering)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_MorphModel));
    
    
    cls->install();
    JSBClassType::registerClass<cc::MorphModel>(cls);
    
    __jsb_cc_MorphModel_proto = cls->getProto();
    __jsb_cc_MorphModel_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_SkinningModel_class = nullptr;
se::Object* __jsb_cc_SkinningModel_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_SkinningModel) 

static bool js_new_cc_SkinningModel(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::SkinningModel *result;
    result = (cc::SkinningModel *)new cc::SkinningModel();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_SkinningModel, __jsb_cc_SkinningModel_class, js_delete_cc_SkinningModel)

static bool js_delete_cc_SkinningModel(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_SkinningModel) 

static bool js_cc_SkinningModel_bindSkeleton(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SkinningModel *arg1 = (cc::SkinningModel *) NULL ;
    cc::Skeleton *arg2 = (cc::Skeleton *) NULL ;
    cc::Node *arg3 = (cc::Node *) NULL ;
    cc::Mesh *arg4 = (cc::Mesh *) NULL ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SkinningModel>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->bindSkeleton(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SkinningModel_bindSkeleton) 

bool js_register_cc_SkinningModel(se::Object* obj) {
    auto* cls = se::Class::create("SkinningModel", obj, __jsb_cc_MorphModel_proto, _SE(js_new_cc_SkinningModel)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("bindSkeleton", _SE(js_cc_SkinningModel_bindSkeleton)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_SkinningModel));
    
    
    cls->install();
    JSBClassType::registerClass<cc::SkinningModel>(cls);
    
    __jsb_cc_SkinningModel_proto = cls->getProto();
    __jsb_cc_SkinningModel_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_BakedSkinningModel_class = nullptr;
se::Object* __jsb_cc_BakedSkinningModel_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_BakedSkinningModel) 

static bool js_new_cc_BakedSkinningModel(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::BakedSkinningModel *result;
    result = (cc::BakedSkinningModel *)new cc::BakedSkinningModel();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_BakedSkinningModel, __jsb_cc_BakedSkinningModel_class, js_delete_cc_BakedSkinningModel)

static bool js_delete_cc_BakedSkinningModel(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_BakedSkinningModel) 

static bool js_cc_BakedSkinningModel_updateInstancedJointTextureInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BakedSkinningModel *arg1 = (cc::BakedSkinningModel *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BakedSkinningModel>(s);
    if (nullptr == arg1) return true;
    (arg1)->updateInstancedJointTextureInfo();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BakedSkinningModel_updateInstancedJointTextureInfo) 

static bool js_cc_BakedSkinningModel_bindSkeleton(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BakedSkinningModel *arg1 = (cc::BakedSkinningModel *) NULL ;
    cc::Skeleton *arg2 = (cc::Skeleton *) NULL ;
    cc::Node *arg3 = (cc::Node *) NULL ;
    cc::Mesh *arg4 = (cc::Mesh *) NULL ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BakedSkinningModel>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->bindSkeleton(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BakedSkinningModel_bindSkeleton) 

static bool js_cc_BakedSkinningModel_updateModelBounds(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BakedSkinningModel *arg1 = (cc::BakedSkinningModel *) NULL ;
    cc::geometry::AABB *arg2 = (cc::geometry::AABB *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BakedSkinningModel>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->updateModelBounds(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BakedSkinningModel_updateModelBounds) 

static bool js_cc_BakedSkinningModel_syncAnimInfoForJS(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BakedSkinningModel *arg1 = (cc::BakedSkinningModel *) NULL ;
    cc::gfx::Buffer *arg2 = (cc::gfx::Buffer *) NULL ;
    cc::Float32Array *arg3 = 0 ;
    cc::Uint8Array *arg4 = 0 ;
    cc::Float32Array temp3 ;
    cc::Uint8Array temp4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BakedSkinningModel>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    (arg1)->syncAnimInfoForJS(arg2,(cc::Float32Array const &)*arg3,*arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BakedSkinningModel_syncAnimInfoForJS) 

static bool js_cc_BakedSkinningModel_syncDataForJS(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BakedSkinningModel *arg1 = (cc::BakedSkinningModel *) NULL ;
    ccstd::vector< ccstd::optional< cc::geometry::AABB > > *arg2 = 0 ;
    ccstd::optional< cc::geometry::AABB > *arg3 = 0 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    cc::gfx::Texture *arg8 = (cc::gfx::Texture *) NULL ;
    cc::Float32Array *arg9 = 0 ;
    ccstd::vector< ccstd::optional< cc::geometry::AABB > > temp2 ;
    ccstd::optional< cc::geometry::AABB > temp3 ;
    cc::Float32Array temp9 ;
    
    if(argc != 8) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 8);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BakedSkinningModel>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg8, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &temp9, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg9 = &temp9;
    
    (arg1)->syncDataForJS((ccstd::vector< ccstd::optional< cc::geometry::AABB > > const &)*arg2,(ccstd::optional< cc::geometry::AABB > const &)*arg3,arg4,arg5,arg6,arg7,arg8,(cc::Float32Array const &)*arg9);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BakedSkinningModel_syncDataForJS) 

static bool js_cc_BakedSkinningModel_setUploadedAnimForJS(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BakedSkinningModel *arg1 = (cc::BakedSkinningModel *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BakedSkinningModel>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setUploadedAnimForJS(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BakedSkinningModel_setUploadedAnimForJS) 

bool js_register_cc_BakedSkinningModel(se::Object* obj) {
    auto* cls = se::Class::create("BakedSkinningModel", obj, __jsb_cc_MorphModel_proto, _SE(js_new_cc_BakedSkinningModel)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("updateInstancedJointTextureInfo", _SE(js_cc_BakedSkinningModel_updateInstancedJointTextureInfo)); 
    cls->defineFunction("bindSkeleton", _SE(js_cc_BakedSkinningModel_bindSkeleton)); 
    cls->defineFunction("updateModelBounds", _SE(js_cc_BakedSkinningModel_updateModelBounds)); 
    cls->defineFunction("syncAnimInfoForJS", _SE(js_cc_BakedSkinningModel_syncAnimInfoForJS)); 
    cls->defineFunction("syncDataForJS", _SE(js_cc_BakedSkinningModel_syncDataForJS)); 
    cls->defineFunction("setUploadedAnimForJS", _SE(js_cc_BakedSkinningModel_setUploadedAnimForJS)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_BakedSkinningModel));
    
    
    cls->install();
    JSBClassType::registerClass<cc::BakedSkinningModel>(cls);
    
    __jsb_cc_BakedSkinningModel_proto = cls->getProto();
    __jsb_cc_BakedSkinningModel_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IDefineRecord_class = nullptr;
se::Object* __jsb_cc_IDefineRecord_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IDefineRecord) 

static bool js_cc_IDefineRecord_map_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDefineRecord *arg1 = (cc::IDefineRecord *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineRecord>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->map, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDefineRecord_map_set) 

static bool js_cc_IDefineRecord_map_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDefineRecord *arg1 = (cc::IDefineRecord *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineRecord>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->map, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->map, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDefineRecord_map_get) 

static bool js_cc_IDefineRecord_offset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDefineRecord *arg1 = (cc::IDefineRecord *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineRecord>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->offset, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDefineRecord_offset_set) 

static bool js_cc_IDefineRecord_offset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDefineRecord *arg1 = (cc::IDefineRecord *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineRecord>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->offset, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDefineRecord_offset_get) 

static bool js_new_cc_IDefineRecord(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IDefineRecord *result;
    result = (cc::IDefineRecord *)new cc::IDefineRecord();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IDefineRecord, __jsb_cc_IDefineRecord_class, js_delete_cc_IDefineRecord)

static bool js_delete_cc_IDefineRecord(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IDefineRecord) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IDefineRecord * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IDefineRecord*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("map", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->map), ctx);
    }
    
    
    json->getProperty("offset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->offset), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IDefineRecord(se::Object* obj) {
    auto* cls = se::Class::create("IDefineRecord", obj, __jsb_cc_IDefineInfo_proto, _SE(js_new_cc_IDefineRecord)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("map", _SE(js_cc_IDefineRecord_map_get), _SE(js_cc_IDefineRecord_map_set)); 
    cls->defineProperty("offset", _SE(js_cc_IDefineRecord_offset_get), _SE(js_cc_IDefineRecord_offset_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IDefineRecord));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IDefineRecord>(cls);
    
    __jsb_cc_IDefineRecord_proto = cls->getProto();
    __jsb_cc_IDefineRecord_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IMacroInfo_class = nullptr;
se::Object* __jsb_cc_IMacroInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IMacroInfo) 

static bool js_cc_IMacroInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMacroInfo *arg1 = (cc::IMacroInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMacroInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMacroInfo_name_set) 

static bool js_cc_IMacroInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMacroInfo *arg1 = (cc::IMacroInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMacroInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMacroInfo_name_get) 

static bool js_cc_IMacroInfo_value_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMacroInfo *arg1 = (cc::IMacroInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMacroInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->value, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMacroInfo_value_set) 

static bool js_cc_IMacroInfo_value_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMacroInfo *arg1 = (cc::IMacroInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMacroInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->value, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->value, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMacroInfo_value_get) 

static bool js_cc_IMacroInfo_isDefault_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMacroInfo *arg1 = (cc::IMacroInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMacroInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->isDefault);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMacroInfo_isDefault_set) 

static bool js_cc_IMacroInfo_isDefault_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMacroInfo *arg1 = (cc::IMacroInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMacroInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->isDefault, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMacroInfo_isDefault_get) 

static bool js_new_cc_IMacroInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IMacroInfo *result;
    result = (cc::IMacroInfo *)new cc::IMacroInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IMacroInfo, __jsb_cc_IMacroInfo_class, js_delete_cc_IMacroInfo)

static bool js_delete_cc_IMacroInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IMacroInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IMacroInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IMacroInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("value", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->value), ctx);
    }
    
    
    json->getProperty("isDefault", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isDefault), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IMacroInfo(se::Object* obj) {
    auto* cls = se::Class::create("IMacroInfo", obj, nullptr, _SE(js_new_cc_IMacroInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("name", _SE(js_cc_IMacroInfo_name_get), _SE(js_cc_IMacroInfo_name_set)); 
    cls->defineProperty("value", _SE(js_cc_IMacroInfo_value_get), _SE(js_cc_IMacroInfo_value_set)); 
    cls->defineProperty("isDefault", _SE(js_cc_IMacroInfo_isDefault_get), _SE(js_cc_IMacroInfo_isDefault_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IMacroInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IMacroInfo>(cls);
    
    __jsb_cc_IMacroInfo_proto = cls->getProto();
    __jsb_cc_IMacroInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IProgramInfo_class = nullptr;
se::Object* __jsb_cc_IProgramInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IProgramInfo) 

static bool js_cc_IProgramInfo_effectName_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IProgramInfo *arg1 = (cc::IProgramInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IProgramInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->effectName, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IProgramInfo_effectName_set) 

static bool js_cc_IProgramInfo_effectName_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IProgramInfo *arg1 = (cc::IProgramInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IProgramInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->effectName, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->effectName, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IProgramInfo_effectName_get) 

static bool js_cc_IProgramInfo_defines_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IProgramInfo *arg1 = (cc::IProgramInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IProgramInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->defines, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IProgramInfo_defines_set) 

static bool js_cc_IProgramInfo_defines_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IProgramInfo *arg1 = (cc::IProgramInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IProgramInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->defines, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->defines, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IProgramInfo_defines_get) 

static bool js_cc_IProgramInfo_constantMacros_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IProgramInfo *arg1 = (cc::IProgramInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IProgramInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->constantMacros, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IProgramInfo_constantMacros_set) 

static bool js_cc_IProgramInfo_constantMacros_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IProgramInfo *arg1 = (cc::IProgramInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IProgramInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->constantMacros, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->constantMacros, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IProgramInfo_constantMacros_get) 

static bool js_cc_IProgramInfo_uber_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IProgramInfo *arg1 = (cc::IProgramInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IProgramInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->uber);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IProgramInfo_uber_set) 

static bool js_cc_IProgramInfo_uber_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IProgramInfo *arg1 = (cc::IProgramInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IProgramInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->uber, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IProgramInfo_uber_get) 

static bool js_cc_IProgramInfo_copyFrom(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IProgramInfo *arg1 = (cc::IProgramInfo *) NULL ;
    cc::IShaderInfo *arg2 = 0 ;
    cc::IShaderInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::IProgramInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->copyFrom((cc::IShaderInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_IProgramInfo_copyFrom) 

static bool js_new_cc_IProgramInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IProgramInfo *result;
    result = (cc::IProgramInfo *)new cc::IProgramInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IProgramInfo, __jsb_cc_IProgramInfo_class, js_delete_cc_IProgramInfo)

static bool js_delete_cc_IProgramInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IProgramInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IProgramInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IProgramInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("effectName", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->effectName), ctx);
    }
    
    
    json->getProperty("defines", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->defines), ctx);
    }
    
    
    json->getProperty("constantMacros", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->constantMacros), ctx);
    }
    
    
    json->getProperty("uber", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->uber), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IProgramInfo(se::Object* obj) {
    auto* cls = se::Class::create("IProgramInfo", obj, __jsb_cc_IShaderInfo_proto, _SE(js_new_cc_IProgramInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("effectName", _SE(js_cc_IProgramInfo_effectName_get), _SE(js_cc_IProgramInfo_effectName_set)); 
    cls->defineProperty("defines", _SE(js_cc_IProgramInfo_defines_get), _SE(js_cc_IProgramInfo_defines_set)); 
    cls->defineProperty("constantMacros", _SE(js_cc_IProgramInfo_constantMacros_get), _SE(js_cc_IProgramInfo_constantMacros_set)); 
    cls->defineProperty("uber", _SE(js_cc_IProgramInfo_uber_get), _SE(js_cc_IProgramInfo_uber_set)); 
    
    cls->defineFunction("copyFrom", _SE(js_cc_IProgramInfo_copyFrom)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IProgramInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IProgramInfo>(cls);
    
    __jsb_cc_IProgramInfo_proto = cls->getProto();
    __jsb_cc_IProgramInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


static bool js_cc_getDeviceShaderVersion(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    char *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (char *)cc::getDeviceShaderVersion((cc::gfx::Device const *)arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), nullptr /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_getDeviceShaderVersion) 

se::Class* __jsb_cc_ProgramLib_class = nullptr;
se::Object* __jsb_cc_ProgramLib_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_ProgramLib) 

static bool js_cc_ProgramLib_getInstance_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ProgramLib *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::ProgramLib *)cc::ProgramLib::getInstance();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ProgramLib_getInstance_static) 

static bool js_new_cc_ProgramLib(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::ProgramLib *result;
    result = (cc::ProgramLib *)new cc::ProgramLib();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_ProgramLib, __jsb_cc_ProgramLib_class, js_delete_cc_ProgramLib)

static bool js_delete_cc_ProgramLib(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_ProgramLib) 

static bool js_cc_ProgramLib_cpp_keyword_register(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ProgramLib *arg1 = (cc::ProgramLib *) NULL ;
    cc::EffectAsset *arg2 = (cc::EffectAsset *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ProgramLib>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->registerEffect(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ProgramLib_cpp_keyword_register) 

static bool js_cc_ProgramLib_define(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ProgramLib *arg1 = (cc::ProgramLib *) NULL ;
    cc::IShaderInfo *arg2 = 0 ;
    cc::IShaderInfo temp2 ;
    cc::IProgramInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ProgramLib>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::IProgramInfo *)(arg1)->define(*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ProgramLib_define) 

static bool js_cc_ProgramLib_getTemplate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ProgramLib *arg1 = (cc::ProgramLib *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    cc::IProgramInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ProgramLib>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::IProgramInfo *)(arg1)->getTemplate((ccstd::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ProgramLib_getTemplate) 

static bool js_cc_ProgramLib_getTemplateInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ProgramLib *arg1 = (cc::ProgramLib *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    cc::ITemplateInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ProgramLib>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::ITemplateInfo *)(arg1)->getTemplateInfo((ccstd::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ProgramLib_getTemplateInfo) 

static bool js_cc_ProgramLib_getDescriptorSetLayout__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::ProgramLib *arg1 = (cc::ProgramLib *) NULL ;
    cc::gfx::Device *arg2 = (cc::gfx::Device *) NULL ;
    ccstd::string *arg3 = 0 ;
    bool arg4 ;
    ccstd::string temp3 ;
    cc::gfx::DescriptorSetLayout *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::ProgramLib>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::gfx::DescriptorSetLayout *)(arg1)->getDescriptorSetLayout(arg2,(ccstd::string const &)*arg3,arg4);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_ProgramLib_getDescriptorSetLayout__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::ProgramLib *arg1 = (cc::ProgramLib *) NULL ;
    cc::gfx::Device *arg2 = (cc::gfx::Device *) NULL ;
    ccstd::string *arg3 = 0 ;
    ccstd::string temp3 ;
    cc::gfx::DescriptorSetLayout *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::ProgramLib>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    result = (cc::gfx::DescriptorSetLayout *)(arg1)->getDescriptorSetLayout(arg2,(ccstd::string const &)*arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_ProgramLib_getDescriptorSetLayout(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 3) {
        ok = js_cc_ProgramLib_getDescriptorSetLayout__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 2) {
        ok = js_cc_ProgramLib_getDescriptorSetLayout__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_ProgramLib_getDescriptorSetLayout) 

static bool js_cc_ProgramLib_hasProgram(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ProgramLib *arg1 = (cc::ProgramLib *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ProgramLib>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (bool)((cc::ProgramLib const *)arg1)->hasProgram((ccstd::string const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ProgramLib_hasProgram) 

static bool js_cc_ProgramLib_getKey(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ProgramLib *arg1 = (cc::ProgramLib *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::MacroRecord *arg3 = 0 ;
    ccstd::string temp2 ;
    cc::MacroRecord temp3 ;
    ccstd::string result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ProgramLib>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    result = (arg1)->getKey((ccstd::string const &)*arg2,(cc::MacroRecord const &)*arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ProgramLib_getKey) 

static bool js_cc_ProgramLib_destroyShaderByDefines(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ProgramLib *arg1 = (cc::ProgramLib *) NULL ;
    cc::MacroRecord *arg2 = 0 ;
    cc::MacroRecord temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ProgramLib>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->destroyShaderByDefines((cc::MacroRecord const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ProgramLib_destroyShaderByDefines) 

static bool js_cc_ProgramLib_getGFXShader__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::ProgramLib *arg1 = (cc::ProgramLib *) NULL ;
    cc::gfx::Device *arg2 = (cc::gfx::Device *) NULL ;
    ccstd::string *arg3 = 0 ;
    cc::MacroRecord *arg4 = 0 ;
    cc::render::PipelineRuntime *arg5 = (cc::render::PipelineRuntime *) NULL ;
    ccstd::string *arg6 = (ccstd::string *) NULL ;
    ccstd::string temp3 ;
    cc::MacroRecord temp4 ;
    cc::gfx::Shader *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::ProgramLib>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::gfx::Shader *)(arg1)->getGFXShader(arg2,(ccstd::string const &)*arg3,*arg4,arg5,arg6);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_ProgramLib_getGFXShader__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::ProgramLib *arg1 = (cc::ProgramLib *) NULL ;
    cc::gfx::Device *arg2 = (cc::gfx::Device *) NULL ;
    ccstd::string *arg3 = 0 ;
    cc::MacroRecord *arg4 = 0 ;
    cc::render::PipelineRuntime *arg5 = (cc::render::PipelineRuntime *) NULL ;
    ccstd::string temp3 ;
    cc::MacroRecord temp4 ;
    cc::gfx::Shader *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::ProgramLib>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg4 = &temp4;
    
    
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::gfx::Shader *)(arg1)->getGFXShader(arg2,(ccstd::string const &)*arg3,*arg4,arg5);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_ProgramLib_getGFXShader(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 5) {
        ok = js_cc_ProgramLib_getGFXShader__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 4) {
        ok = js_cc_ProgramLib_getGFXShader__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_ProgramLib_getGFXShader) 

bool js_register_cc_ProgramLib(se::Object* obj) {
    auto* cls = se::Class::create("ProgramLib", obj, nullptr, _SE(js_new_cc_ProgramLib)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("register", _SE(js_cc_ProgramLib_cpp_keyword_register)); 
    cls->defineFunction("define", _SE(js_cc_ProgramLib_define)); 
    cls->defineFunction("getTemplate", _SE(js_cc_ProgramLib_getTemplate)); 
    cls->defineFunction("getTemplateInfo", _SE(js_cc_ProgramLib_getTemplateInfo)); 
    cls->defineFunction("getDescriptorSetLayout", _SE(js_cc_ProgramLib_getDescriptorSetLayout)); 
    cls->defineFunction("hasProgram", _SE(js_cc_ProgramLib_hasProgram)); 
    cls->defineFunction("getKey", _SE(js_cc_ProgramLib_getKey)); 
    cls->defineFunction("destroyShaderByDefines", _SE(js_cc_ProgramLib_destroyShaderByDefines)); 
    cls->defineFunction("getGFXShader", _SE(js_cc_ProgramLib_getGFXShader)); 
    
    
    cls->defineStaticFunction("getInstance", _SE(js_cc_ProgramLib_getInstance_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_ProgramLib));
    
    
    cls->install();
    JSBClassType::registerClass<cc::ProgramLib>(cls);
    
    __jsb_cc_ProgramLib_proto = cls->getProto();
    __jsb_cc_ProgramLib_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_OctreeInfo_class = nullptr;
se::Object* __jsb_cc_scene_OctreeInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_OctreeInfo) 

static bool js_new_cc_scene_OctreeInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::OctreeInfo *result;
    result = (cc::scene::OctreeInfo *)new cc::scene::OctreeInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_OctreeInfo, __jsb_cc_scene_OctreeInfo_class, js_delete_cc_scene_OctreeInfo)

static bool js_delete_cc_scene_OctreeInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_OctreeInfo) 

static bool js_cc_scene_OctreeInfo_activate(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    cc::scene::Octree *arg2 = (cc::scene::Octree *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->activate(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_OctreeInfo_activate) 

static bool js_cc_scene_OctreeInfo__enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_enabled);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_OctreeInfo__enabled_set) 

static bool js_cc_scene_OctreeInfo__enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_enabled, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_OctreeInfo__enabled_get) 

static bool js_cc_scene_OctreeInfo__minPos_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_minPos, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_OctreeInfo__minPos_set) 

static bool js_cc_scene_OctreeInfo__minPos_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_minPos, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_minPos, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_OctreeInfo__minPos_get) 

static bool js_cc_scene_OctreeInfo__maxPos_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_maxPos, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_OctreeInfo__maxPos_set) 

static bool js_cc_scene_OctreeInfo__maxPos_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_maxPos, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_maxPos, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_OctreeInfo__maxPos_get) 

static bool js_cc_scene_OctreeInfo__depth_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_depth, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_OctreeInfo__depth_set) 

static bool js_cc_scene_OctreeInfo__depth_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_depth, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_OctreeInfo__depth_get) 

static bool js_cc_scene_OctreeInfo_enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_scene_OctreeInfo_enabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_OctreeInfo_enabled_set) 

static bool js_cc_scene_OctreeInfo_enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_scene_OctreeInfo_enabled_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_OctreeInfo_enabled_get) 

static bool js_cc_scene_OctreeInfo_minPos_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_OctreeInfo_minPos_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_OctreeInfo_minPos_set) 

static bool js_cc_scene_OctreeInfo_minPos_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::Vec3 *) &cc_scene_OctreeInfo_minPos_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_OctreeInfo_minPos_get) 

static bool js_cc_scene_OctreeInfo_maxPos_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    cc_scene_OctreeInfo_maxPos_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_OctreeInfo_maxPos_set) 

static bool js_cc_scene_OctreeInfo_maxPos_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::Vec3 *) &cc_scene_OctreeInfo_maxPos_get(arg1);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_OctreeInfo_maxPos_get) 

static bool js_cc_scene_OctreeInfo_depth_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_scene_OctreeInfo_depth_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_OctreeInfo_depth_set) 

static bool js_cc_scene_OctreeInfo_depth_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    if (nullptr == arg1) return true;
    result = cc_scene_OctreeInfo_depth_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_OctreeInfo_depth_get) 

bool js_register_cc_scene_OctreeInfo(se::Object* obj) {
    auto* cls = se::Class::create("OctreeInfo", obj, nullptr, _SE(js_new_cc_scene_OctreeInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("_enabled", _SE(js_cc_scene_OctreeInfo__enabled_get), _SE(js_cc_scene_OctreeInfo__enabled_set)); 
    cls->defineProperty("_minPos", _SE(js_cc_scene_OctreeInfo__minPos_get), _SE(js_cc_scene_OctreeInfo__minPos_set)); 
    cls->defineProperty("_maxPos", _SE(js_cc_scene_OctreeInfo__maxPos_get), _SE(js_cc_scene_OctreeInfo__maxPos_set)); 
    cls->defineProperty("_depth", _SE(js_cc_scene_OctreeInfo__depth_get), _SE(js_cc_scene_OctreeInfo__depth_set)); 
    cls->defineProperty("enabled", _SE(js_cc_scene_OctreeInfo_enabled_get), _SE(js_cc_scene_OctreeInfo_enabled_set)); 
    cls->defineProperty("minPos", _SE(js_cc_scene_OctreeInfo_minPos_get), _SE(js_cc_scene_OctreeInfo_minPos_set)); 
    cls->defineProperty("maxPos", _SE(js_cc_scene_OctreeInfo_maxPos_get), _SE(js_cc_scene_OctreeInfo_maxPos_set)); 
    cls->defineProperty("depth", _SE(js_cc_scene_OctreeInfo_depth_get), _SE(js_cc_scene_OctreeInfo_depth_set)); 
    
    cls->defineFunction("activate", _SE(js_cc_scene_OctreeInfo_activate)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_OctreeInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::OctreeInfo>(cls);
    
    __jsb_cc_scene_OctreeInfo_proto = cls->getProto();
    __jsb_cc_scene_OctreeInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_BBox_class = nullptr;
se::Object* __jsb_cc_scene_BBox_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_BBox) 

static bool js_cc_scene_BBox_min_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::BBox *arg1 = (cc::scene::BBox *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::BBox>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->min, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_BBox_min_set) 

static bool js_cc_scene_BBox_min_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::BBox *arg1 = (cc::scene::BBox *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::BBox>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->min, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->min, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_BBox_min_get) 

static bool js_cc_scene_BBox_max_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::BBox *arg1 = (cc::scene::BBox *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::BBox>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->max, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_BBox_max_set) 

static bool js_cc_scene_BBox_max_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::BBox *arg1 = (cc::scene::BBox *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::BBox>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->max, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->max, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_BBox_max_get) 

static bool js_new_cc_scene_BBox__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::scene::BBox *result;
    result = (cc::scene::BBox *)new cc::scene::BBox();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_scene_BBox__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::AABB *arg1 = 0 ;
    cc::geometry::AABB temp1 ;
    cc::scene::BBox *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = (cc::scene::BBox *)new cc::scene::BBox((cc::geometry::AABB const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_scene_BBox__SWIG_2(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::Vec3 *arg1 = 0 ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp1 ;
    cc::Vec3 temp2 ;
    cc::scene::BBox *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::scene::BBox *)new cc::scene::BBox((cc::Vec3 const &)*arg1,(cc::Vec3 const &)*arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_BBox(se::State& s) // NOLINT(readability-identifier-naming)
{
    size_t argc = s.args().size();
    bool ret = false;
    
    if(argc == 0) {
        ret = js_new_cc_scene_BBox__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 1) {
        ret = js_new_cc_scene_BBox__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 2) {
        ret = js_new_cc_scene_BBox__SWIG_2(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    SE_REPORT_ERROR("Illegal arguments for construction of BBox");
    return false;
}
SE_BIND_CTOR(js_new_BBox, __jsb_cc_scene_BBox_class, js_delete_cc_scene_BBox)

static bool js_cc_scene_BBox_getCenter(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::BBox *arg1 = (cc::scene::BBox *) NULL ;
    cc::Vec3 result;
    cc::Vec3 *temp ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::BBox>(s);
    if (nullptr == arg1) return true;
    result = ((cc::scene::BBox const *)arg1)->getCenter();
    
    temp = ccnew cc::Vec3(result);
    ok &= nativevalue_to_se(temp, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_BBox_getCenter) 

static bool js_cc_scene_BBox_contain__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::BBox *arg1 = (cc::scene::BBox *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::BBox>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (bool)((cc::scene::BBox const *)arg1)->contain((cc::Vec3 const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}

static bool js_cc_scene_BBox_contain__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::BBox *arg1 = (cc::scene::BBox *) NULL ;
    cc::scene::BBox *arg2 = 0 ;
    cc::scene::BBox temp2 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::BBox>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (bool)((cc::scene::BBox const *)arg1)->contain((cc::scene::BBox const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}

static bool js_cc_scene_BBox_contain(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_cc_scene_BBox_contain__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_scene_BBox_contain__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_scene_BBox_contain) 

static bool js_cc_scene_BBox_intersect(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::BBox *arg1 = (cc::scene::BBox *) NULL ;
    cc::scene::BBox *arg2 = 0 ;
    cc::scene::BBox temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::BBox>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (bool)((cc::scene::BBox const *)arg1)->intersect((cc::scene::BBox const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_BBox_intersect) 

static bool js_delete_cc_scene_BBox(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_BBox) 

template<>
bool sevalue_to_native(const se::Value &from, cc::scene::BBox * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::scene::BBox*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("min", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->min), ctx);
    }
    
    
    json->getProperty("max", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->max), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_scene_BBox(se::Object* obj) {
    auto* cls = se::Class::create("BBox", obj, nullptr, _SE(js_new_BBox)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("min", _SE(js_cc_scene_BBox_min_get), _SE(js_cc_scene_BBox_min_set)); 
    cls->defineProperty("max", _SE(js_cc_scene_BBox_max_get), _SE(js_cc_scene_BBox_max_set)); 
    
    cls->defineFunction("getCenter", _SE(js_cc_scene_BBox_getCenter)); 
    cls->defineFunction("contain", _SE(js_cc_scene_BBox_contain)); 
    cls->defineFunction("intersect", _SE(js_cc_scene_BBox_intersect)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_BBox));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::BBox>(cls);
    
    __jsb_cc_scene_BBox_proto = cls->getProto();
    __jsb_cc_scene_BBox_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_OctreeNode_class = nullptr;
se::Object* __jsb_cc_scene_OctreeNode_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_OctreeNode) 

bool js_register_cc_scene_OctreeNode(se::Object* obj) {
    auto* cls = se::Class::create("OctreeNode", obj, nullptr, nullptr); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    
    
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::OctreeNode>(cls);
    
    __jsb_cc_scene_OctreeNode_proto = cls->getProto();
    __jsb_cc_scene_OctreeNode_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_Octree_class = nullptr;
se::Object* __jsb_cc_scene_Octree_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_Octree) 

static bool js_new_cc_scene_Octree(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::Octree *result;
    result = (cc::scene::Octree *)new cc::scene::Octree();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_Octree, __jsb_cc_scene_Octree_class, js_delete_cc_scene_Octree)

static bool js_delete_cc_scene_Octree(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_Octree) 

static bool js_cc_scene_Octree_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    cc::scene::OctreeInfo *arg2 = 0 ;
    cc::scene::OctreeInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::scene::OctreeInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_initialize) 

static bool js_cc_scene_Octree_setEnabled(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_setEnabled) 

static bool js_cc_scene_Octree_isEnabled(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    if (nullptr == arg1) return true;
    result = (bool)((cc::scene::Octree const *)arg1)->isEnabled();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_isEnabled) 

static bool js_cc_scene_Octree_setMinPos(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setMinPos((cc::Vec3 const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_setMinPos) 

static bool js_cc_scene_Octree_getMinPos(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    cc::Vec3 *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    if (nullptr == arg1) return true;
    result = (cc::Vec3 *) &((cc::scene::Octree const *)arg1)->getMinPos();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_getMinPos) 

static bool js_cc_scene_Octree_setMaxPos(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setMaxPos((cc::Vec3 const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_setMaxPos) 

static bool js_cc_scene_Octree_getMaxPos(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    cc::Vec3 *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    if (nullptr == arg1) return true;
    result = (cc::Vec3 *) &((cc::scene::Octree const *)arg1)->getMaxPos();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_getMaxPos) 

static bool js_cc_scene_Octree_resize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    uint32_t arg4 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->resize((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_resize) 

static bool js_cc_scene_Octree_insert(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    cc::scene::Model *arg2 = (cc::scene::Model *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->insert(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_insert) 

static bool js_cc_scene_Octree_remove(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    cc::scene::Model *arg2 = (cc::scene::Model *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->remove(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_remove) 

static bool js_cc_scene_Octree_update(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    cc::scene::Model *arg2 = (cc::scene::Model *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->update(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_update) 

static bool js_cc_scene_Octree_setMaxDepth(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setMaxDepth(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_setMaxDepth) 

static bool js_cc_scene_Octree_getMaxDepth(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    if (nullptr == arg1) return true;
    result = ((cc::scene::Octree const *)arg1)->getMaxDepth();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_getMaxDepth) 

static bool js_cc_scene_Octree_queryVisibility(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    cc::geometry::Frustum *arg3 = 0 ;
    bool arg4 ;
    ccstd::vector< cc::scene::Model * > *arg5 = 0 ;
    cc::geometry::Frustum temp3 ;
    ccstd::vector< cc::scene::Model * > temp5 ;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg5 = &temp5;
    
    ((cc::scene::Octree const *)arg1)->queryVisibility((cc::scene::Camera const *)arg2,(cc::geometry::Frustum const &)*arg3,arg4,*arg5);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_queryVisibility) 

bool js_register_cc_scene_Octree(se::Object* obj) {
    auto* cls = se::Class::create("Octree", obj, nullptr, _SE(js_new_cc_scene_Octree)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("initialize", _SE(js_cc_scene_Octree_initialize)); 
    cls->defineFunction("setEnabled", _SE(js_cc_scene_Octree_setEnabled)); 
    cls->defineFunction("isEnabled", _SE(js_cc_scene_Octree_isEnabled)); 
    cls->defineFunction("setMinPos", _SE(js_cc_scene_Octree_setMinPos)); 
    cls->defineFunction("getMinPos", _SE(js_cc_scene_Octree_getMinPos)); 
    cls->defineFunction("setMaxPos", _SE(js_cc_scene_Octree_setMaxPos)); 
    cls->defineFunction("getMaxPos", _SE(js_cc_scene_Octree_getMaxPos)); 
    cls->defineFunction("resize", _SE(js_cc_scene_Octree_resize)); 
    cls->defineFunction("insert", _SE(js_cc_scene_Octree_insert)); 
    cls->defineFunction("remove", _SE(js_cc_scene_Octree_remove)); 
    cls->defineFunction("update", _SE(js_cc_scene_Octree_update)); 
    cls->defineFunction("setMaxDepth", _SE(js_cc_scene_Octree_setMaxDepth)); 
    cls->defineFunction("getMaxDepth", _SE(js_cc_scene_Octree_getMaxDepth)); 
    cls->defineFunction("queryVisibility", _SE(js_cc_scene_Octree_queryVisibility)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_Octree));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::Octree>(cls);
    
    __jsb_cc_scene_Octree_proto = cls->getProto();
    __jsb_cc_scene_Octree_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}




bool register_all_scene(se::Object* obj) {
    // Get the ns
    se::Value nsVal;
    if (!obj->getProperty("jsb", &nsVal, true))
    {
        se::HandleObject jsobj(se::Object::createPlainObject());
        nsVal.setObject(jsobj);
        obj->setProperty("jsb", nsVal);
    }
    se::Object* ns = nsVal.toObject();
    /* Register classes */
    js_register_cc_Layers(ns); 
    js_register_cc_Node(ns); 
    js_register_cc_Node_UserData(ns); 
    js_register_cc_Scene(ns); 
    js_register_cc_SceneGlobals(ns); 
    js_register_cc_DebugViewConfig(ns); 
    js_register_cc_Root(ns); 
    js_register_cc_scene_IMacroPatch(ns); 
    js_register_cc_scene_Light(ns); 
    js_register_cc_scene_LODData(ns); 
    js_register_cc_scene_LODGroup(ns); 
    js_register_cc_scene_Fog(ns); 
    js_register_cc_scene_FogInfo(ns); 
    js_register_cc_scene_ShadowsInfo(ns); 
    js_register_cc_scene_Shadows(ns); 
    js_register_cc_scene_SkyboxInfo(ns); 
    js_register_cc_scene_Skybox(ns); 
    js_register_cc_scene_DirectionalLight(ns); 
    js_register_cc_scene_SpotLight(ns); 
    js_register_cc_scene_SphereLight(ns); 
    js_register_cc_scene_Model(ns); 
    js_register_cc_scene_InstancedAttributeBlock(ns); 
    js_register_cc_scene_SubModel(ns); 
    js_register_cc_scene_PassDynamicsValue(ns); 
    js_register_cc_scene_IBlockRef(ns); 
    js_register_cc_scene_Pass(ns); 
    js_register_cc_scene_IRaycastResult(ns); 
    js_register_cc_scene_IRenderSceneInfo(ns); 
    js_register_cc_scene_RenderScene(ns); 
    js_register_cc_scene_IRenderWindowInfo(ns); 
    js_register_cc_scene_RenderWindow(ns); 
    js_register_cc_scene_ICameraInfo(ns); 
    js_register_cc_scene_Camera(ns); 
    js_register_cc_scene_Ambient(ns); 
    js_register_cc_scene_AmbientInfo(ns); 
    js_register_cc_scene_ReflectionProbe(ns); 
    js_register_cc_PassInstance(ns); 
    js_register_cc_IMaterialInstanceInfo(ns); 
    js_register_cc_MaterialInstance(ns); 
    js_register_cc_MorphModel(ns); 
    js_register_cc_SkinningModel(ns); 
    js_register_cc_BakedSkinningModel(ns); 
    js_register_cc_IDefineRecord(ns); 
    js_register_cc_IMacroInfo(ns); 
    js_register_cc_IProgramInfo(ns); 
    js_register_cc_ProgramLib(ns); 
    js_register_cc_scene_OctreeInfo(ns); 
    js_register_cc_scene_BBox(ns); 
    js_register_cc_scene_OctreeNode(ns); 
    js_register_cc_scene_Octree(ns); 
    
    /* Register global variables & global functions */
    
    
    
    return true;
}


#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif
// clang-format on
