// clang-format off

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.1.0
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

/****************************************************************************
 Copyright (c) 2022 Xiamen Yaji Software Co., Ltd.

 http://www.cocos.com

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated engine source code (the "Software"), a limited,
 worldwide, royalty-free, non-assignable, revocable and non-exclusive license
 to use Cocos Creator solely to develop games on your target platforms. You shall
 not use Cocos Creator software for developing other software or tools that's
 used for developing games. You are not granted to publish, distribute,
 sublicense, and/or sell copies of Cocos Creator.

 The software or tools in this License Agreement are licensed, not sold.
 Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
****************************************************************************/

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static 
#endif



#include <stdio.h>


#include "bindings/jswrapper/SeApi.h"
#include "bindings/manual/jsb_conversions.h"
#include "bindings/manual/jsb_global.h"


#include "bindings/auto/jsb_scene_auto.h"
#include "bindings/auto/jsb_gfx_auto.h"
#include "bindings/auto/jsb_pipeline_auto.h"
#include "bindings/auto/jsb_geometry_auto.h"
#include "bindings/auto/jsb_assets_auto.h"
#include "bindings/auto/jsb_render_auto.h"
#include "bindings/auto/jsb_cocos_auto.h"
#include "bindings/auto/jsb_2d_auto.h"

using namespace cc;


#define cc_Root_device_get(self_) self_->getDevice()
#define cc_Root_device_set(self_, val_) self_->setDevice(val_)
  

#define cc_Root__device_get(self_) self_->getDevice()
#define cc_Root__device_set(self_, val_) self_->setDevice(val_)
  

#define cc_Root_mainWindow_get(self_) self_->getMainWindow()
  

#define cc_Root_curWindow_get(self_) self_->getCurWindow()
#define cc_Root_curWindow_set(self_, val_) self_->setCurWindow(val_)
  

#define cc_Root_tempWindow_get(self_) self_->getTempWindow()
#define cc_Root_tempWindow_set(self_, val_) self_->setTempWindow(val_)
  

#define cc_Root_windows_get(self_) self_->getWindows()
  

#define cc_Root_scenes_get(self_) self_->getScenes()
  

#define cc_Root_cumulativeTime_get(self_) self_->getCumulativeTime()
  

#define cc_Root_frameTime_get(self_) self_->getFrameTime()
  

#define cc_Root_frameCount_get(self_) self_->getFrameCount()
  

#define cc_Root_fps_get(self_) self_->getFps()
  

#define cc_Root_fixedFPS_get(self_) self_->getFixedFPS()
#define cc_Root_fixedFPS_set(self_, val_) self_->setFixedFPS(val_)
  

#define cc_Root_useDeferredPipeline_get(self_) self_->isUsingDeferredPipeline()
  

#define cc_Root_usesCustomPipeline_get(self_) self_->usesCustomPipeline()
  

#define cc_Root_pipeline_get(self_) self_->getPipeline()
  

#define cc_Root_customPipeline_get(self_) self_->getCustomPipeline()
  

#define cc_scene_RenderWindow_width_get(self_) self_->getWidth()
  

#define cc_scene_RenderWindow_height_get(self_) self_->getHeight()
  

#define cc_scene_RenderWindow_framebuffer_get(self_) self_->getFramebuffer()
  

#define cc_scene_RenderWindow_cameras_get(self_) self_->getCameras()
  

#define cc_scene_RenderWindow_swapchain_get(self_) self_->getSwapchain()
  

#define cc_scene_Pass_root_get(self_) self_->getRoot()
  

#define cc_scene_Pass_device_get(self_) self_->getDevice()
  

#define cc_scene_Pass_shaderInfo_get(self_) self_->getShaderInfo()
  

#define cc_scene_Pass_localSetLayout_get(self_) self_->getLocalSetLayout()
  

#define cc_scene_Pass_program_get(self_) self_->getProgram()
  

#define cc_scene_Pass_properties_get(self_) self_->getProperties()
  

#define cc_scene_Pass_defines_get(self_) self_->getDefines()
  

#define cc_scene_Pass_passIndex_get(self_) self_->getPassIndex()
  

#define cc_scene_Pass_propertyIndex_get(self_) self_->getPropertyIndex()
  

#define cc_scene_Pass_dynamics_get(self_) self_->getDynamics()
  

#define cc_scene_Pass_rootBufferDirty_get(self_) self_->isRootBufferDirty()
  

#define cc_scene_Pass__rootBufferDirty_get(self_) self_->isRootBufferDirty()
#define cc_scene_Pass__rootBufferDirty_set(self_, val_) self_->_setRootBufferDirty(val_)
  

#define cc_scene_Pass_priority_get(self_) self_->getPriority()
  

#define cc_scene_Pass_primitive_get(self_) self_->getPrimitive()
  

#define cc_scene_Pass_stage_get(self_) self_->getStage()
  

#define cc_scene_Pass_phase_get(self_) self_->getPhase()
  

#define cc_scene_Pass_rasterizerState_get(self_) self_->getRasterizerState()
  

#define cc_scene_Pass_depthStencilState_get(self_) self_->getDepthStencilState()
  

#define cc_scene_Pass_blendState_get(self_) self_->getBlendState()
  

#define cc_scene_Pass_dynamicStates_get(self_) self_->getDynamicStates()
  

#define cc_scene_Pass_batchingScheme_get(self_) self_->getBatchingScheme()
  

#define cc_scene_Pass_descriptorSet_get(self_) self_->getDescriptorSet()
  

#define cc_scene_Pass_hash_get(self_) self_->getHash()
  

#define cc_scene_Pass_pipelineLayout_get(self_) self_->getPipelineLayout()
  

#define cc_PassInstance_parent_get(self_) self_->getParent()
  

#define cc_Node_uuid_get(self_) self_->getUuid()
  

#define cc_Node_angle_get(self_) self_->getAngle()
#define cc_Node_angle_set(self_, val_) self_->setAngle(val_)
  

#define cc_Node_matrix_set(self_, val_) self_->setMatrix(val_)
  

#define cc_Node_hasChangedFlags_get(self_) self_->getChangedFlags()
#define cc_Node_hasChangedFlags_set(self_, val_) self_->setChangedFlags(val_)
  

#define cc_Node__persistNode_get(self_) self_->isPersistNode()
#define cc_Node__persistNode_set(self_, val_) self_->setPersistNode(val_)
  

#define cc_scene_Ambient_skyColor_get(self_) self_->getSkyColor()
#define cc_scene_Ambient_skyColor_set(self_, val_) self_->setSkyColor(val_)
  

#define cc_scene_Ambient_skyIllum_get(self_) self_->getSkyIllum()
#define cc_scene_Ambient_skyIllum_set(self_, val_) self_->setSkyIllum(val_)
  

#define cc_scene_Ambient_groundAlbedo_get(self_) self_->getGroundAlbedo()
#define cc_scene_Ambient_groundAlbedo_set(self_, val_) self_->setGroundAlbedo(val_)
  

#define cc_scene_Ambient_enabled_get(self_) self_->isEnabled()
#define cc_scene_Ambient_enabled_set(self_, val_) self_->setEnabled(val_)
  

#define cc_scene_Ambient_mipmapCount_get(self_) self_->getMipmapCount()
#define cc_scene_Ambient_mipmapCount_set(self_, val_) self_->setMipmapCount(val_)
  

#define cc_scene_Light_baked_get(self_) self_->isBaked()
#define cc_scene_Light_baked_set(self_, val_) self_->setBaked(val_)
  

#define cc_scene_Light_color_get(self_) self_->getColor()
#define cc_scene_Light_color_set(self_, val_) self_->setColor(val_)
  

#define cc_scene_Light_useColorTemperature_get(self_) self_->isUseColorTemperature()
#define cc_scene_Light_useColorTemperature_set(self_, val_) self_->setUseColorTemperature(val_)
  

#define cc_scene_Light_colorTemperature_get(self_) self_->getColorTemperature()
#define cc_scene_Light_colorTemperature_set(self_, val_) self_->setColorTemperature(val_)
  

#define cc_scene_Light_node_get(self_) self_->getNode()
#define cc_scene_Light_node_set(self_, val_) self_->setNode(val_)
  

#define cc_scene_Light_type_get(self_) self_->getType()
#define cc_scene_Light_type_set(self_, val_) self_->setType(val_)
  

#define cc_scene_Light_name_get(self_) self_->getName()
#define cc_scene_Light_name_set(self_, val_) self_->setName(val_)
  

#define cc_scene_Light_scene_get(self_) self_->getScene()
  

#define cc_scene_DirectionalLight_direction_get(self_) self_->getDirection()
#define cc_scene_DirectionalLight_direction_set(self_, val_) self_->setDirection(val_)
  

#define cc_scene_DirectionalLight_illuminance_get(self_) self_->getIlluminance()
#define cc_scene_DirectionalLight_illuminance_set(self_, val_) self_->setIlluminance(val_)
  

#define cc_scene_DirectionalLight_illuminanceHDR_get(self_) self_->getIlluminanceHDR()
#define cc_scene_DirectionalLight_illuminanceHDR_set(self_, val_) self_->setIlluminanceHDR(val_)
  

#define cc_scene_DirectionalLight_illuminanceLDR_get(self_) self_->getIlluminanceLDR()
#define cc_scene_DirectionalLight_illuminanceLDR_set(self_, val_) self_->setIlluminanceLDR(val_)
  

#define cc_scene_DirectionalLight_shadowEnabled_get(self_) self_->isShadowEnabled()
#define cc_scene_DirectionalLight_shadowEnabled_set(self_, val_) self_->setShadowEnabled(val_)
  

#define cc_scene_DirectionalLight_shadowPcf_get(self_) self_->getShadowPcf()
#define cc_scene_DirectionalLight_shadowPcf_set(self_, val_) self_->setShadowPcf(val_)
  

#define cc_scene_DirectionalLight_shadowBias_get(self_) self_->getShadowBias()
#define cc_scene_DirectionalLight_shadowBias_set(self_, val_) self_->setShadowBias(val_)
  

#define cc_scene_DirectionalLight_shadowNormalBias_get(self_) self_->getShadowNormalBias()
#define cc_scene_DirectionalLight_shadowNormalBias_set(self_, val_) self_->setShadowNormalBias(val_)
  

#define cc_scene_DirectionalLight_shadowSaturation_get(self_) self_->getShadowSaturation()
#define cc_scene_DirectionalLight_shadowSaturation_set(self_, val_) self_->setShadowSaturation(val_)
  

#define cc_scene_DirectionalLight_shadowDistance_get(self_) self_->getShadowDistance()
#define cc_scene_DirectionalLight_shadowDistance_set(self_, val_) self_->setShadowDistance(val_)
  

#define cc_scene_DirectionalLight_shadowInvisibleOcclusionRange_get(self_) self_->getShadowInvisibleOcclusionRange()
#define cc_scene_DirectionalLight_shadowInvisibleOcclusionRange_set(self_, val_) self_->setShadowInvisibleOcclusionRange(val_)
  

#define cc_scene_DirectionalLight_shadowFixedArea_get(self_) self_->isShadowFixedArea()
#define cc_scene_DirectionalLight_shadowFixedArea_set(self_, val_) self_->setShadowFixedArea(val_)
  

#define cc_scene_DirectionalLight_shadowNear_get(self_) self_->getShadowNear()
#define cc_scene_DirectionalLight_shadowNear_set(self_, val_) self_->setShadowNear(val_)
  

#define cc_scene_DirectionalLight_shadowFar_get(self_) self_->getShadowFar()
#define cc_scene_DirectionalLight_shadowFar_set(self_, val_) self_->setShadowFar(val_)
  

#define cc_scene_DirectionalLight_shadowOrthoSize_get(self_) self_->getShadowOrthoSize()
#define cc_scene_DirectionalLight_shadowOrthoSize_set(self_, val_) self_->setShadowOrthoSize(val_)
  

#define cc_scene_DirectionalLight_csmLevel_get(self_) self_->getCSMLevel()
#define cc_scene_DirectionalLight_csmLevel_set(self_, val_) self_->setCSMLevel(val_)
  

#define cc_scene_DirectionalLight_csmNeedUpdate_get(self_) self_->isCSMNeedUpdate()
#define cc_scene_DirectionalLight_csmNeedUpdate_set(self_, val_) self_->setCSMNeedUpdate(val_)
  

#define cc_scene_DirectionalLight_csmLayerLambda_get(self_) self_->getCSMLayerLambda()
#define cc_scene_DirectionalLight_csmLayerLambda_set(self_, val_) self_->setCSMLayerLambda(val_)
  

#define cc_scene_DirectionalLight_csmOptimizationMode_get(self_) self_->getCSMOptimizationMode()
#define cc_scene_DirectionalLight_csmOptimizationMode_set(self_, val_) self_->setCSMOptimizationMode(val_)
  

#define cc_scene_SpotLight_position_get(self_) self_->getPosition()
  

#define cc_scene_SpotLight_range_get(self_) self_->getRange()
#define cc_scene_SpotLight_range_set(self_, val_) self_->setRange(val_)
  

#define cc_scene_SpotLight_luminance_get(self_) self_->getLuminance()
#define cc_scene_SpotLight_luminance_set(self_, val_) self_->setLuminance(val_)
  

#define cc_scene_SpotLight_luminanceHDR_get(self_) self_->getLuminanceHDR()
#define cc_scene_SpotLight_luminanceHDR_set(self_, val_) self_->setLuminanceHDR(val_)
  

#define cc_scene_SpotLight_luminanceLDR_get(self_) self_->getLuminanceLDR()
#define cc_scene_SpotLight_luminanceLDR_set(self_, val_) self_->setLuminanceLDR(val_)
  

#define cc_scene_SpotLight_direction_get(self_) self_->getDirection()
  

#define cc_scene_SpotLight_spotAngle_get(self_) self_->getSpotAngle()
#define cc_scene_SpotLight_spotAngle_set(self_, val_) self_->setSpotAngle(val_)
  

#define cc_scene_SpotLight_angle_get(self_) self_->getAngle()
  

#define cc_scene_SpotLight_aabb_get(self_) self_->getAABB()
  

#define cc_scene_SpotLight_frustum_get(self_) self_->getFrustum()
#define cc_scene_SpotLight_frustum_set(self_, val_) self_->setFrustum(val_)
  

#define cc_scene_SpotLight_shadowEnabled_get(self_) self_->isShadowEnabled()
#define cc_scene_SpotLight_shadowEnabled_set(self_, val_) self_->setShadowEnabled(val_)
  

#define cc_scene_SpotLight_shadowPcf_get(self_) self_->getShadowPcf()
#define cc_scene_SpotLight_shadowPcf_set(self_, val_) self_->setShadowPcf(val_)
  

#define cc_scene_SpotLight_shadowBias_get(self_) self_->getShadowBias()
#define cc_scene_SpotLight_shadowBias_set(self_, val_) self_->setShadowBias(val_)
  

#define cc_scene_SpotLight_shadowNormalBias_get(self_) self_->getShadowNormalBias()
#define cc_scene_SpotLight_shadowNormalBias_set(self_, val_) self_->setShadowNormalBias(val_)
  

#define cc_scene_SpotLight_size_get(self_) self_->getSize()
#define cc_scene_SpotLight_size_set(self_, val_) self_->setSize(val_)
  

#define cc_scene_SphereLight_position_get(self_) self_->getPosition()
#define cc_scene_SphereLight_position_set(self_, val_) self_->setPosition(val_)
  

#define cc_scene_SphereLight_size_get(self_) self_->getSize()
#define cc_scene_SphereLight_size_set(self_, val_) self_->setSize(val_)
  

#define cc_scene_SphereLight_range_get(self_) self_->getRange()
#define cc_scene_SphereLight_range_set(self_, val_) self_->setRange(val_)
  

#define cc_scene_SphereLight_luminance_get(self_) self_->getLuminance()
#define cc_scene_SphereLight_luminance_set(self_, val_) self_->setLuminance(val_)
  

#define cc_scene_SphereLight_luminanceHDR_get(self_) self_->getLuminanceHDR()
#define cc_scene_SphereLight_luminanceHDR_set(self_, val_) self_->setLuminanceHDR(val_)
  

#define cc_scene_SphereLight_luminanceLDR_get(self_) self_->getLuminanceLDR()
#define cc_scene_SphereLight_luminanceLDR_set(self_, val_) self_->setLuminanceLDR(val_)
  

#define cc_scene_SphereLight_aabb_get(self_) self_->getAABB()
  

#define cc_scene_Camera_iso_get(self_) self_->getIso()
#define cc_scene_Camera_iso_set(self_, val_) self_->setIso(val_)
  

#define cc_scene_Camera_isoValue_get(self_) self_->getIsoValue()
  

#define cc_scene_Camera_ec_get(self_) self_->getEc()
#define cc_scene_Camera_ec_set(self_, val_) self_->setEc(val_)
  

#define cc_scene_Camera_exposure_get(self_) self_->getExposure()
  

#define cc_scene_Camera_shutter_get(self_) self_->getShutter()
#define cc_scene_Camera_shutter_set(self_, val_) self_->setShutter(val_)
  

#define cc_scene_Camera_shutterValue_get(self_) self_->getShutterValue()
  

#define cc_scene_Camera_apertureValue_get(self_) self_->getApertureValue()
  

#define cc_scene_Camera_width_get(self_) self_->getWidth()
  

#define cc_scene_Camera_height_get(self_) self_->getHeight()
  

#define cc_scene_Camera_aspect_get(self_) self_->getAspect()
  

#define cc_scene_Camera_scene_get(self_) self_->getScene()
  

#define cc_scene_Camera_name_get(self_) self_->getName()
  

#define cc_scene_Camera_window_get(self_) self_->getWindow()
#define cc_scene_Camera_window_set(self_, val_) self_->setWindow(val_)
  

#define cc_scene_Camera_forward_get(self_) self_->getForward()
#define cc_scene_Camera_forward_set(self_, val_) self_->setForward(val_)
  

#define cc_scene_Camera_aperture_get(self_) self_->getAperture()
#define cc_scene_Camera_aperture_set(self_, val_) self_->setAperture(val_)
  

#define cc_scene_Camera_position_get(self_) self_->getPosition()
#define cc_scene_Camera_position_set(self_, val_) self_->setPosition(val_)
  

#define cc_scene_Camera_projectionType_get(self_) self_->getProjectionType()
#define cc_scene_Camera_projectionType_set(self_, val_) self_->setProjectionType(val_)
  

#define cc_scene_Camera_fovAxis_get(self_) self_->getFovAxis()
#define cc_scene_Camera_fovAxis_set(self_, val_) self_->setFovAxis(val_)
  

#define cc_scene_Camera_fov_get(self_) self_->getFov()
#define cc_scene_Camera_fov_set(self_, val_) self_->setFov(val_)
  

#define cc_scene_Camera_nearClip_get(self_) self_->getNearClip()
#define cc_scene_Camera_nearClip_set(self_, val_) self_->setNearClip(val_)
  

#define cc_scene_Camera_farClip_get(self_) self_->getFarClip()
#define cc_scene_Camera_farClip_set(self_, val_) self_->setFarClip(val_)
  

#define cc_scene_Camera_viewport_get(self_) self_->getViewport()
#define cc_scene_Camera_viewport_set(self_, val_) self_->setViewport(val_)
  

#define cc_scene_Camera_orthoHeight_get(self_) self_->getOrthoHeight()
#define cc_scene_Camera_orthoHeight_set(self_, val_) self_->setOrthoHeight(val_)
  

#define cc_scene_Camera_clearColor_get(self_) self_->getClearColor()
#define cc_scene_Camera_clearColor_set(self_, val_) self_->setClearColor(val_)
  

#define cc_scene_Camera_clearDepth_get(self_) self_->getClearDepth()
#define cc_scene_Camera_clearDepth_set(self_, val_) self_->setClearDepth(val_)
  

#define cc_scene_Camera_clearFlag_get(self_) self_->getClearFlag()
#define cc_scene_Camera_clearFlag_set(self_, val_) self_->setClearFlag(val_)
  

#define cc_scene_Camera_clearStencil_get(self_) self_->getClearStencil()
#define cc_scene_Camera_clearStencil_set(self_, val_) self_->setClearStencil(val_)
  

#define cc_scene_Camera_enabled_get(self_) self_->isEnabled()
#define cc_scene_Camera_enabled_set(self_, val_) self_->setEnabled(val_)
  

#define cc_scene_Camera_exposure_get(self_) self_->getExposure()
  

#define cc_scene_Camera_frustum_get(self_) self_->getFrustum()
#define cc_scene_Camera_frustum_set(self_, val_) self_->setFrustum(val_)
  

#define cc_scene_Camera_isWindowSize_get(self_) self_->isWindowSize()
#define cc_scene_Camera_isWindowSize_set(self_, val_) self_->setWindowSize(val_)
  

#define cc_scene_Camera_priority_get(self_) self_->getPriority()
#define cc_scene_Camera_priority_set(self_, val_) self_->setPriority(val_)
  

#define cc_scene_Camera_screenScale_get(self_) self_->getScreenScale()
#define cc_scene_Camera_screenScale_set(self_, val_) self_->setScreenScale(val_)
  

#define cc_scene_Camera_visibility_get(self_) self_->getVisibility()
#define cc_scene_Camera_visibility_set(self_, val_) self_->setVisibility(val_)
  

#define cc_scene_Camera_node_get(self_) self_->getNode()
#define cc_scene_Camera_node_set(self_, val_) self_->setNode(val_)
  

#define cc_scene_Camera_surfaceTransform_get(self_) self_->getSurfaceTransform()
  

#define cc_scene_Camera_geometryRenderer_get(self_) self_->getGeometryRenderer()
  

#define cc_scene_RenderScene_name_get(self_) self_->getName()
  

#define cc_scene_RenderScene_cameras_get(self_) self_->getCameras()
  

#define cc_scene_RenderScene_sphereLights_get(self_) self_->getSphereLights()
  

#define cc_scene_RenderScene_spotLights_get(self_) self_->getSpotLights()
  

#define cc_scene_RenderScene_models_get(self_) self_->getModels()
  

#define cc_scene_Skybox_model_get(self_) self_->getModel()
  

#define cc_scene_Skybox_enabled_get(self_) self_->isEnabled()
#define cc_scene_Skybox_enabled_set(self_, val_) self_->setEnabled(val_)
  

#define cc_scene_Skybox_useHDR_get(self_) self_->isUseHDR()
#define cc_scene_Skybox_useHDR_set(self_, val_) self_->setUseHDR(val_)
  

#define cc_scene_Skybox_useIBL_get(self_) self_->isUseIBL()
#define cc_scene_Skybox_useIBL_set(self_, val_) self_->setUseIBL(val_)
  

#define cc_scene_Skybox_useDiffuseMap_get(self_) self_->isUseDiffuseMap()
#define cc_scene_Skybox_useDiffuseMap_set(self_, val_) self_->setUseDiffuseMap(val_)
  

#define cc_scene_Skybox_isRGBE_get(self_) self_->isRGBE()
  

#define cc_scene_Skybox_envmap_get(self_) self_->getEnvmap()
#define cc_scene_Skybox_envmap_set(self_, val_) self_->setEnvmap(val_)
  

#define cc_scene_Skybox_diffuseMap_get(self_) self_->getDiffuseMap()
#define cc_scene_Skybox_diffuseMap_set(self_, val_) self_->setDiffuseMap(val_)
  

#define cc_scene_Fog_enabled_get(self_) self_->isEnabled()
#define cc_scene_Fog_enabled_set(self_, val_) self_->setEnabled(val_)
  

#define cc_scene_Fog_accurate_get(self_) self_->isAccurate()
#define cc_scene_Fog_accurate_set(self_, val_) self_->setAccurate(val_)
  

#define cc_scene_Fog_fogColor_get(self_) self_->getFogColor()
#define cc_scene_Fog_fogColor_set(self_, val_) self_->setFogColor(val_)
  

#define cc_scene_Fog_type_get(self_) self_->getType()
#define cc_scene_Fog_type_set(self_, val_) self_->setType(val_)
  

#define cc_scene_Fog_fogDensity_get(self_) self_->getFogDensity()
#define cc_scene_Fog_fogDensity_set(self_, val_) self_->setFogDensity(val_)
  

#define cc_scene_Fog_fogStart_get(self_) self_->getFogStart()
#define cc_scene_Fog_fogStart_set(self_, val_) self_->setFogStart(val_)
  

#define cc_scene_Fog_fogEnd_get(self_) self_->getFogEnd()
#define cc_scene_Fog_fogEnd_set(self_, val_) self_->setFogEnd(val_)
  

#define cc_scene_Fog_fogAtten_get(self_) self_->getFogAtten()
#define cc_scene_Fog_fogAtten_set(self_, val_) self_->setFogAtten(val_)
  

#define cc_scene_Fog_fogTop_get(self_) self_->getFogTop()
#define cc_scene_Fog_fogTop_set(self_, val_) self_->setFogTop(val_)
  

#define cc_scene_Fog_fogRange_get(self_) self_->getFogRange()
#define cc_scene_Fog_fogRange_set(self_, val_) self_->setFogRange(val_)
  

#define cc_scene_Fog_colorArray_get(self_) self_->getColorArray()
  

#define cc_scene_Model_scene_get(self_) self_->getScene()
#define cc_scene_Model_scene_set(self_, val_) self_->setScene(val_)
  

#define cc_scene_Model__subModels_get(self_) self_->getSubModels()
  

#define cc_scene_Model_subModels_get(self_) self_->getSubModels()
  

#define cc_scene_Model_inited_get(self_) self_->isInited()
  

#define cc_scene_Model__localDataUpdated_get(self_) self_->isLocalDataUpdated()
#define cc_scene_Model__localDataUpdated_set(self_, val_) self_->setLocalDataUpdated(val_)
  

#define cc_scene_Model__worldBounds_get(self_) self_->getWorldBounds()
#define cc_scene_Model__worldBounds_set(self_, val_) self_->setWorldBounds(val_)
  

#define cc_scene_Model_worldBounds_get(self_) self_->getWorldBounds()
#define cc_scene_Model_worldBounds_set(self_, val_) self_->setWorldBounds(val_)
  

#define cc_scene_Model__modelBounds_get(self_) self_->getModelBounds()
#define cc_scene_Model__modelBounds_set(self_, val_) self_->setModelBounds(val_)
  

#define cc_scene_Model_modelBounds_get(self_) self_->getModelBounds()
#define cc_scene_Model_modelBounds_set(self_, val_) self_->setModelBounds(val_)
  

#define cc_scene_Model_worldBoundBuffer_get(self_) self_->getWorldBoundBuffer()
#define cc_scene_Model_worldBoundBuffer_set(self_, val_) self_->setWorldBoundBuffer(val_)
  

#define cc_scene_Model_localBuffer_get(self_) self_->getLocalBuffer()
#define cc_scene_Model_localBuffer_set(self_, val_) self_->setLocalBuffer(val_)
  

#define cc_scene_Model_updateStamp_get(self_) self_->getUpdateStamp()
  

#define cc_scene_Model_isInstancingEnabled_get(self_) self_->isInstancingEnabled()
  

#define cc_scene_Model_receiveShadow_get(self_) self_->isReceiveShadow()
#define cc_scene_Model_receiveShadow_set(self_, val_) self_->setReceiveShadow(val_)
  

#define cc_scene_Model_castShadow_get(self_) self_->isCastShadow()
#define cc_scene_Model_castShadow_set(self_, val_) self_->setCastShadow(val_)
  

#define cc_scene_Model_shadowBias_get(self_) self_->getShadowBias()
#define cc_scene_Model_shadowBias_set(self_, val_) self_->setShadowBias(val_)
  

#define cc_scene_Model_shadowNormalBias_get(self_) self_->getShadowNormalBias()
#define cc_scene_Model_shadowNormalBias_set(self_, val_) self_->setShadowNormalBias(val_)
  

#define cc_scene_Model_node_get(self_) self_->getNode()
#define cc_scene_Model_node_set(self_, val_) self_->setNode(val_)
  

#define cc_scene_Model_transform_get(self_) self_->getTransform()
#define cc_scene_Model_transform_set(self_, val_) self_->setTransform(val_)
  

#define cc_scene_Model_visFlags_get(self_) self_->getVisFlags()
#define cc_scene_Model_visFlags_set(self_, val_) self_->setVisFlags(val_)
  

#define cc_scene_Model_enabled_get(self_) self_->isEnabled()
#define cc_scene_Model_enabled_set(self_, val_) self_->setEnabled(val_)
  

#define cc_scene_Model_type_get(self_) self_->getType()
#define cc_scene_Model_type_set(self_, val_) self_->setType(val_)
  

#define cc_scene_Model_instancedAttributes_get(self_) self_->getInstancedAttributeBlock()
#define cc_scene_Model_instancedAttributes_set(self_, val_) self_->setInstancedAttributeBlock(val_)
  

#define cc_scene_Model_isDynamicBatching_get(self_) self_->isDynamicBatching()
#define cc_scene_Model_isDynamicBatching_set(self_, val_) self_->setDynamicBatching(val_)
  

#define cc_scene_Model_priority_get(self_) self_->getPriority()
#define cc_scene_Model_priority_set(self_, val_) self_->setPriority(val_)
  

#define cc_scene_SubModel_passes_get(self_) self_->getPasses()
#define cc_scene_SubModel_passes_set(self_, val_) self_->setPasses(val_)
  

#define cc_scene_SubModel_shaders_get(self_) self_->getShaders()
#define cc_scene_SubModel_shaders_set(self_, val_) self_->setShaders(val_)
  

#define cc_scene_SubModel_subMesh_get(self_) self_->getSubMesh()
#define cc_scene_SubModel_subMesh_set(self_, val_) self_->setSubMesh(val_)
  

#define cc_scene_SubModel_priority_get(self_) self_->getPriority()
#define cc_scene_SubModel_priority_set(self_, val_) self_->setPriority(val_)
  

#define cc_scene_SubModel_inputAssembler_get(self_) self_->getInputAssembler()
#define cc_scene_SubModel_inputAssembler_set(self_, val_) self_->setInputAssembler(val_)
  

#define cc_scene_SubModel_descriptorSet_get(self_) self_->getDescriptorSet()
#define cc_scene_SubModel_descriptorSet_set(self_, val_) self_->setDescriptorSet(val_)
  

#define cc_scene_SubModel_patches_get(self_) self_->getPatches()
  

#define cc_scene_SubModel_planarInstanceShader_get(self_) self_->getPlanarInstanceShader()
#define cc_scene_SubModel_planarInstanceShader_set(self_, val_) self_->setPlanarInstanceShader(val_)
  

#define cc_scene_SubModel_planarShader_get(self_) self_->getPlanarShader()
#define cc_scene_SubModel_planarShader_set(self_, val_) self_->setPlanarShader(val_)
  

#define cc_scene_ShadowsInfo_enabled_get(self_) self_->isEnabled()
#define cc_scene_ShadowsInfo_enabled_set(self_, val_) self_->setEnabled(val_)
  

#define cc_scene_ShadowsInfo_type_get(self_) self_->getType()
#define cc_scene_ShadowsInfo_type_set(self_, val_) self_->setType(val_)
  

#define cc_scene_ShadowsInfo_shadowColor_get(self_) self_->getShadowColor()
#define cc_scene_ShadowsInfo_shadowColor_set(self_, val_) self_->setShadowColor(val_)
  

#define cc_scene_ShadowsInfo_planeDirection_get(self_) self_->getPlaneDirection()
#define cc_scene_ShadowsInfo_planeDirection_set(self_, val_) self_->setPlaneDirection(val_)
  

#define cc_scene_ShadowsInfo_planeHeight_get(self_) self_->getPlaneHeight()
#define cc_scene_ShadowsInfo_planeHeight_set(self_, val_) self_->setPlaneHeight(val_)
  

#define cc_scene_ShadowsInfo_maxReceived_get(self_) self_->getMaxReceived()
#define cc_scene_ShadowsInfo_maxReceived_set(self_, val_) self_->setMaxReceived(val_)
  

#define cc_scene_ShadowsInfo_shadowMapSize_get(self_) self_->getShadowMapSize()
#define cc_scene_ShadowsInfo_shadowMapSize_set(self_, val_) self_->setShadowMapSize(val_)
  

#define cc_scene_Shadows_enabled_get(self_) self_->isEnabled()
#define cc_scene_Shadows_enabled_set(self_, val_) self_->setEnabled(val_)
  

#define cc_scene_Shadows_type_get(self_) self_->getType()
#define cc_scene_Shadows_type_set(self_, val_) self_->setType(val_)
  

#define cc_scene_Shadows_normal_get(self_) self_->getNormal()
#define cc_scene_Shadows_normal_set(self_, val_) self_->setNormal(val_)
  

#define cc_scene_Shadows_distance_get(self_) self_->getDistance()
#define cc_scene_Shadows_distance_set(self_, val_) self_->setDistance(val_)
  

#define cc_scene_Shadows_shadowColor_get(self_) self_->getShadowColor()
#define cc_scene_Shadows_shadowColor_set(self_, val_) self_->setShadowColor(val_)
  

#define cc_scene_Shadows_maxReceived_get(self_) self_->getMaxReceived()
#define cc_scene_Shadows_maxReceived_set(self_, val_) self_->setMaxReceived(val_)
  

#define cc_scene_Shadows_size_get(self_) self_->getSize()
#define cc_scene_Shadows_size_set(self_, val_) self_->setSize(val_)
  

#define cc_scene_Shadows_shadowMapDirty_get(self_) self_->isShadowMapDirty()
#define cc_scene_Shadows_shadowMapDirty_set(self_, val_) self_->setShadowMapDirty(val_)
  

#define cc_scene_Shadows_matLight_get(self_) self_->getMatLight()
  

#define cc_scene_Shadows_material_get(self_) self_->getMaterial()
  

#define cc_scene_Shadows_instancingMaterial_get(self_) self_->getInstancingMaterial()
  

#define cc_scene_AmbientInfo_skyColor_set(self_, val_) self_->setSkyColor(val_)
  

#define cc_scene_AmbientInfo_skyIllum_get(self_) self_->getSkyIllum()
#define cc_scene_AmbientInfo_skyIllum_set(self_, val_) self_->setSkyIllum(val_)
  

#define cc_scene_AmbientInfo_groundAlbedo_set(self_, val_) self_->setGroundAlbedo(val_)
  

#define cc_scene_AmbientInfo__skyColor_get(self_) self_->getSkyColorHDR()
#define cc_scene_AmbientInfo__skyColor_set(self_, val_) self_->setSkyColorHDR(val_)
  

#define cc_scene_AmbientInfo__skyIllum_get(self_) self_->getSkyIllumHDR()
#define cc_scene_AmbientInfo__skyIllum_set(self_, val_) self_->setSkyIllumHDR(val_)
  

#define cc_scene_AmbientInfo__groundAlbedo_get(self_) self_->getGroundAlbedoHDR()
#define cc_scene_AmbientInfo__groundAlbedo_set(self_, val_) self_->setGroundAlbedoHDR(val_)
  

#define cc_scene_AmbientInfo_skyColorLDR_get(self_) self_->getSkyColorLDR()
  

#define cc_scene_AmbientInfo_groundAlbedoLDR_get(self_) self_->getGroundAlbedoLDR()
  

#define cc_scene_AmbientInfo_skyIllumLDR_get(self_) self_->getSkyIllumLDR()
  

#define cc_scene_AmbientInfo_skyLightingColor_get(self_) self_->getSkyLightingColor()
#define cc_scene_AmbientInfo_skyLightingColor_set(self_, val_) self_->setSkyLightingColor(val_)
  

#define cc_scene_AmbientInfo_groundLightingColor_get(self_) self_->getGroundLightingColor()
#define cc_scene_AmbientInfo_groundLightingColor_set(self_, val_) self_->setGroundLightingColor(val_)
  

#define cc_scene_FogInfo_type_get(self_) self_->getType()
#define cc_scene_FogInfo_type_set(self_, val_) self_->setType(val_)
  

#define cc_scene_FogInfo_fogColor_get(self_) self_->getFogColor()
#define cc_scene_FogInfo_fogColor_set(self_, val_) self_->setFogColor(val_)
  

#define cc_scene_FogInfo_enabled_get(self_) self_->isEnabled()
#define cc_scene_FogInfo_enabled_set(self_, val_) self_->setEnabled(val_)
  

#define cc_scene_FogInfo_accurate_get(self_) self_->isAccurate()
#define cc_scene_FogInfo_accurate_set(self_, val_) self_->setAccurate(val_)
  

#define cc_scene_FogInfo_fogDensity_get(self_) self_->getFogDensity()
#define cc_scene_FogInfo_fogDensity_set(self_, val_) self_->setFogDensity(val_)
  

#define cc_scene_FogInfo_fogStart_get(self_) self_->getFogStart()
#define cc_scene_FogInfo_fogStart_set(self_, val_) self_->setFogStart(val_)
  

#define cc_scene_FogInfo_fogEnd_get(self_) self_->getFogEnd()
#define cc_scene_FogInfo_fogEnd_set(self_, val_) self_->setFogEnd(val_)
  

#define cc_scene_FogInfo_fogAtten_get(self_) self_->getFogAtten()
#define cc_scene_FogInfo_fogAtten_set(self_, val_) self_->setFogAtten(val_)
  

#define cc_scene_FogInfo_fogTop_get(self_) self_->getFogTop()
#define cc_scene_FogInfo_fogTop_set(self_, val_) self_->setFogTop(val_)
  

#define cc_scene_FogInfo_fogRange_get(self_) self_->getFogRange()
#define cc_scene_FogInfo_fogRange_set(self_, val_) self_->setFogRange(val_)
  

#define cc_scene_SkyboxInfo__envmap_get(self_) self_->getEnvmapForJS()
#define cc_scene_SkyboxInfo__envmap_set(self_, val_) self_->setEnvmapForJS(val_)
  

#define cc_scene_SkyboxInfo_applyDiffuseMap_get(self_) self_->isApplyDiffuseMap()
#define cc_scene_SkyboxInfo_applyDiffuseMap_set(self_, val_) self_->setApplyDiffuseMap(val_)
  

#define cc_scene_SkyboxInfo_enabled_get(self_) self_->isEnabled()
#define cc_scene_SkyboxInfo_enabled_set(self_, val_) self_->setEnabled(val_)
  

#define cc_scene_SkyboxInfo_useIBL_get(self_) self_->isUseIBL()
#define cc_scene_SkyboxInfo_useIBL_set(self_, val_) self_->setUseIBL(val_)
  

#define cc_scene_SkyboxInfo_useHDR_get(self_) self_->isUseHDR()
#define cc_scene_SkyboxInfo_useHDR_set(self_, val_) self_->setUseHDR(val_)
  

#define cc_scene_SkyboxInfo_envmap_get(self_) self_->getEnvmap()
#define cc_scene_SkyboxInfo_envmap_set(self_, val_) self_->setEnvmap(val_)
  

#define cc_scene_SkyboxInfo_diffuseMap_get(self_) self_->getDiffuseMap()
#define cc_scene_SkyboxInfo_diffuseMap_set(self_, val_) self_->setDiffuseMap(val_)
  

#define cc_scene_SkyboxInfo_envLightingType_get(self_) self_->getEnvLightingType()
#define cc_scene_SkyboxInfo_envLightingType_set(self_, val_) self_->setEnvLightingType(val_)
  

#define cc_scene_OctreeInfo_enabled_get(self_) self_->isEnabled()
#define cc_scene_OctreeInfo_enabled_set(self_, val_) self_->setEnabled(val_)
  

#define cc_scene_OctreeInfo_minPos_get(self_) self_->getMinPos()
#define cc_scene_OctreeInfo_minPos_set(self_, val_) self_->setMinPos(val_)
  

#define cc_scene_OctreeInfo_maxPos_get(self_) self_->getMaxPos()
#define cc_scene_OctreeInfo_maxPos_set(self_, val_) self_->setMaxPos(val_)
  

#define cc_scene_OctreeInfo_depth_get(self_) self_->getDepth()
#define cc_scene_OctreeInfo_depth_set(self_, val_) self_->setDepth(val_)
  

#define cc_Scene_autoReleaseAssets_get(self_) self_->isAutoReleaseAssets()
#define cc_Scene_autoReleaseAssets_set(self_, val_) self_->setAutoReleaseAssets(val_)
  


static bool js_cc_hasFlag__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::TransformBit arg1 ;
    cc::TransformBit arg2 ;
    int32_t temp1 ;
    int32_t temp2 ;
    bool result;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "hasFlag,1,SWIGTYPE_cc__TransformBit");
    arg1 = (cc::TransformBit)temp1;
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[1], &temp2);
    SE_PRECONDITION2(ok, false, "hasFlag,2,SWIGTYPE_cc__TransformBit");
    arg2 = (cc::TransformBit)temp2;
    result = (bool)cc::hasFlag(arg1,arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_cc_hasAnyFlags__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::TransformBit arg1 ;
    cc::TransformBit arg2 ;
    int32_t temp1 ;
    int32_t temp2 ;
    bool result;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "hasAnyFlags,1,SWIGTYPE_cc__TransformBit");
    arg1 = (cc::TransformBit)temp1;
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[1], &temp2);
    SE_PRECONDITION2(ok, false, "hasAnyFlags,2,SWIGTYPE_cc__TransformBit");
    arg2 = (cc::TransformBit)temp2;
    result = (bool)cc::hasAnyFlags(arg1,arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_cc_hasAllFlags__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::TransformBit arg1 ;
    cc::TransformBit arg2 ;
    int32_t temp1 ;
    int32_t temp2 ;
    bool result;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "hasAllFlags,1,SWIGTYPE_cc__TransformBit");
    arg1 = (cc::TransformBit)temp1;
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[1], &temp2);
    SE_PRECONDITION2(ok, false, "hasAllFlags,2,SWIGTYPE_cc__TransformBit");
    arg2 = (cc::TransformBit)temp2;
    result = (bool)cc::hasAllFlags(arg1,arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_cc_addFlags__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::TransformBit *arg1 = 0 ;
    cc::TransformBit arg2 ;
    cc::TransformBit temp1 ;
    int32_t temp2 ;
    cc::TransformBit result;
    int32_t temp ;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "addFlags,1,SWIGTYPE_p_cc__TransformBit");
    arg1 = &temp1;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[1], &temp2);
    SE_PRECONDITION2(ok, false, "addFlags,2,SWIGTYPE_cc__TransformBit");
    arg2 = (cc::TransformBit)temp2;
    result = (cc::TransformBit)cc::addFlags(*arg1,arg2);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}

static bool js_cc_removeFlags__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::TransformBit *arg1 = 0 ;
    cc::TransformBit arg2 ;
    cc::TransformBit temp1 ;
    int32_t temp2 ;
    cc::TransformBit result;
    int32_t temp ;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "removeFlags,1,SWIGTYPE_p_cc__TransformBit");
    arg1 = &temp1;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[1], &temp2);
    SE_PRECONDITION2(ok, false, "removeFlags,2,SWIGTYPE_cc__TransformBit");
    arg2 = (cc::TransformBit)temp2;
    result = (cc::TransformBit)cc::removeFlags(*arg1,arg2);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}

static bool js_cc_toNumber__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::TransformBit arg1 ;
    int32_t temp1 ;
    std::underlying_type< cc::TransformBit >::type result;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "toNumber,1,SWIGTYPE_cc__TransformBit");
    arg1 = (cc::TransformBit)temp1;
    result = cc::toNumber(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "toNumber, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

se::Class* __jsb_cc_Layers_class = nullptr;
se::Object* __jsb_cc_Layers_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Layers) 

static bool js_cc_Layers_makeMaskInclude_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    ccstd::vector< uint32_t > *arg1 = 0 ;
    ccstd::vector< uint32_t > temp1 ;
    uint32_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Layers_makeMaskInclude,1,SWIGTYPE_p_ccstd__vectorT_uint32_t_t");
    arg1 = &temp1;
    
    result = cc::Layers::makeMaskInclude((ccstd::vector< uint32_t > const &)*arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Layers_makeMaskInclude, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Layers_makeMaskInclude_static) 

static bool js_cc_Layers_makeMaskExclude_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    ccstd::vector< uint32_t > *arg1 = 0 ;
    ccstd::vector< uint32_t > temp1 ;
    uint32_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Layers_makeMaskExclude,1,SWIGTYPE_p_ccstd__vectorT_uint32_t_t");
    arg1 = &temp1;
    
    result = cc::Layers::makeMaskExclude((ccstd::vector< uint32_t > const &)*arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Layers_makeMaskExclude, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Layers_makeMaskExclude_static) 

bool js_register_cc_Layers(se::Object* obj) {
    auto* cls = se::Class::create("Layers", obj, nullptr, nullptr); 
    
    
    
    
    cls->defineStaticFunction("makeMaskInclude", _SE(js_cc_Layers_makeMaskInclude_static)); 
    cls->defineStaticFunction("makeMaskExclude", _SE(js_cc_Layers_makeMaskExclude_static)); 
    
    
    cls->install();
    JSBClassType::registerClass<cc::Layers>(cls);
    
    __jsb_cc_Layers_proto = cls->getProto();
    __jsb_cc_Layers_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


static bool js_cc_hasFlag__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Layers::LayerList arg1 ;
    cc::Layers::LayerList arg2 ;
    int32_t temp1 ;
    int32_t temp2 ;
    bool result;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "hasFlag,1,SWIGTYPE_cc__Layers__LayerList");
    arg1 = (cc::Layers::LayerList)temp1;
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[1], &temp2);
    SE_PRECONDITION2(ok, false, "hasFlag,2,SWIGTYPE_cc__Layers__LayerList");
    arg2 = (cc::Layers::LayerList)temp2;
    result = (bool)cc::hasFlag(arg1,arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_cc_hasFlag(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_hasFlag__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_hasFlag__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_hasFlag) 

static bool js_cc_hasAnyFlags__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Layers::LayerList arg1 ;
    cc::Layers::LayerList arg2 ;
    int32_t temp1 ;
    int32_t temp2 ;
    bool result;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "hasAnyFlags,1,SWIGTYPE_cc__Layers__LayerList");
    arg1 = (cc::Layers::LayerList)temp1;
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[1], &temp2);
    SE_PRECONDITION2(ok, false, "hasAnyFlags,2,SWIGTYPE_cc__Layers__LayerList");
    arg2 = (cc::Layers::LayerList)temp2;
    result = (bool)cc::hasAnyFlags(arg1,arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_cc_hasAnyFlags(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_hasAnyFlags__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_hasAnyFlags__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_hasAnyFlags) 

static bool js_cc_hasAllFlags__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Layers::LayerList arg1 ;
    cc::Layers::LayerList arg2 ;
    int32_t temp1 ;
    int32_t temp2 ;
    bool result;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "hasAllFlags,1,SWIGTYPE_cc__Layers__LayerList");
    arg1 = (cc::Layers::LayerList)temp1;
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[1], &temp2);
    SE_PRECONDITION2(ok, false, "hasAllFlags,2,SWIGTYPE_cc__Layers__LayerList");
    arg2 = (cc::Layers::LayerList)temp2;
    result = (bool)cc::hasAllFlags(arg1,arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_cc_hasAllFlags(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_hasAllFlags__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_hasAllFlags__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_hasAllFlags) 

static bool js_cc_addFlags__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Layers::LayerList *arg1 = 0 ;
    cc::Layers::LayerList arg2 ;
    cc::Layers::LayerList temp1 ;
    int32_t temp2 ;
    cc::Layers::LayerList result;
    int32_t temp ;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "addFlags,1,SWIGTYPE_p_cc__Layers__LayerList");
    arg1 = &temp1;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[1], &temp2);
    SE_PRECONDITION2(ok, false, "addFlags,2,SWIGTYPE_cc__Layers__LayerList");
    arg2 = (cc::Layers::LayerList)temp2;
    result = (cc::Layers::LayerList)cc::addFlags(*arg1,arg2);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}

static bool js_cc_addFlags(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_addFlags__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_addFlags__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_addFlags) 

static bool js_cc_removeFlags__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Layers::LayerList *arg1 = 0 ;
    cc::Layers::LayerList arg2 ;
    cc::Layers::LayerList temp1 ;
    int32_t temp2 ;
    cc::Layers::LayerList result;
    int32_t temp ;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "removeFlags,1,SWIGTYPE_p_cc__Layers__LayerList");
    arg1 = &temp1;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[1], &temp2);
    SE_PRECONDITION2(ok, false, "removeFlags,2,SWIGTYPE_cc__Layers__LayerList");
    arg2 = (cc::Layers::LayerList)temp2;
    result = (cc::Layers::LayerList)cc::removeFlags(*arg1,arg2);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}

static bool js_cc_removeFlags(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_removeFlags__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_removeFlags__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_removeFlags) 

static bool js_cc_toNumber__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Layers::LayerList arg1 ;
    int32_t temp1 ;
    std::underlying_type< cc::Layers::LayerList >::type result;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "toNumber,1,SWIGTYPE_cc__Layers__LayerList");
    arg1 = (cc::Layers::LayerList)temp1;
    result = cc::toNumber(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "toNumber, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_toNumber(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_toNumber__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_toNumber__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_toNumber) 

se::Class* __jsb_cc_BaseNode_class = nullptr;
se::Object* __jsb_cc_BaseNode_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_BaseNode) 

// js_ctor
static bool js_new_cc_BaseNode(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::BaseNode *result;
    result = (cc::BaseNode *)new cc::BaseNode();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_BaseNode, __jsb_cc_BaseNode_class, js_delete_cc_BaseNode)

static bool js_delete_cc_BaseNode(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_BaseNode) 

bool js_register_cc_BaseNode(se::Object* obj) {
    auto* cls = se::Class::create("BaseNode", obj, __jsb_cc_CCObject_proto, _SE(js_new_cc_BaseNode)); 
    
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_BaseNode));
    
    
    cls->install();
    JSBClassType::registerClass<cc::BaseNode>(cls);
    
    __jsb_cc_BaseNode_proto = cls->getProto();
    __jsb_cc_BaseNode_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Node_class = nullptr;
se::Object* __jsb_cc_Node_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Node) 

se::Class* __jsb_cc_Node_UserData_class = nullptr;
se::Object* __jsb_cc_Node_UserData_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Node_UserData) 

static bool js_delete_cc_Node_UserData(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Node_UserData) 

bool js_register_cc_Node_UserData(se::Object* obj) {
    auto* cls = se::Class::create({"Node", "UserData"}, obj, nullptr, nullptr); 
    
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Node_UserData));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Node::UserData>(cls);
    
    __jsb_cc_Node_UserData_proto = cls->getProto();
    __jsb_cc_Node_UserData_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


static bool js_cc_Node_TRANSFORM_ON_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    uint32_t result;
    
    result = (uint32_t)cc::Node::TRANSFORM_ON;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Node_TRANSFORM_ON_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Node_TRANSFORM_ON_get) 

static bool js_cc_Node_instantiate_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    bool arg2 ;
    cc::Node *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_instantiate,1,SWIGTYPE_p_cc__Node"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[1], &arg2);
    SE_PRECONDITION2(ok, false, "Node_instantiate,2,SWIGTYPE_bool"); 
    result = (cc::Node *)cc::Node::instantiate(arg1,arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Node_instantiate, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_instantiate_static) 

static bool js_cc_Node_setScene_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_setScene,1,SWIGTYPE_p_cc__Node"); 
    cc::Node::setScene(arg1);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setScene_static) 

static bool js_cc_Node_resetHasChangedFlags_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    cc::Node::resetChangedFlags();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_resetHasChangedFlags_static) 

static bool js_cc_Node_clearNodeArray_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    cc::Node::clearNodeArray();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_clearNodeArray_static) 

static bool js_new_cc_Node__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::Node *result;
    result = (cc::Node *)new cc::Node();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_Node__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    ccstd::string *arg1 = 0 ;
    ccstd::string temp1 ;
    cc::Node *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Node,1,SWIGTYPE_p_ccstd__string");
    arg1 = &temp1;
    
    result = (cc::Node *)new cc::Node((ccstd::string const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_Node(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_ctor_dispatcher
    size_t argc = s.args().size();
    bool ret = false;
    
    // switch all cases by means of series of if-returns.
    
    // js_ctor_dispatch_case
    if(argc == 0) {
        ret = js_new_cc_Node__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_Node__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    
    // default:
    SE_REPORT_ERROR("Illegal arguments for construction of Node");
    return false;
}
SE_BIND_CTOR(js_new_Node, __jsb_cc_Node_class, js_delete_cc_Node)

static bool js_delete_cc_Node(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Node) 

static bool js_cc_Node_onPostActivated(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Node_onPostActivated,2,SWIGTYPE_bool"); 
    (arg1)->onPostActivated(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_onPostActivated) 

static bool js_cc_Node_setParent__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    bool arg3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_setParent,2,SWIGTYPE_p_cc__Node"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "Node_setParent,3,SWIGTYPE_bool"); 
    (arg1)->setParent(arg2,arg3);
    
    
    return true;
}

static bool js_cc_Node_setParent__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_setParent,2,SWIGTYPE_p_cc__Node"); 
    (arg1)->setParent(arg2);
    
    
    return true;
}

static bool js_cc_Node_setParent(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Node_setParent__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Node_setParent__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Node_setParent) 

static bool js_cc_Node_getScene(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Scene *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Scene *)((cc::Node const *)arg1)->getScene();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Node_getScene, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_getScene) 

static bool js_cc_Node_walk__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Node::WalkCallback *arg2 = 0 ;
    cc::Node::WalkCallback temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_walk,2,SWIGTYPE_p_std__functionT_void_fcc__Node_pF_t");
    arg2 = &temp2;
    
    (arg1)->walk((cc::Node::WalkCallback const &)*arg2);
    
    
    return true;
}

static bool js_cc_Node_walk__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Node::WalkCallback *arg2 = 0 ;
    cc::Node::WalkCallback *arg3 = 0 ;
    cc::Node::WalkCallback temp2 ;
    cc::Node::WalkCallback temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_walk,2,SWIGTYPE_p_std__functionT_void_fcc__Node_pF_t");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_walk,3,SWIGTYPE_p_std__functionT_void_fcc__Node_pF_t");
    arg3 = &temp3;
    
    (arg1)->walk((cc::Node::WalkCallback const &)*arg2,(cc::Node::WalkCallback const &)*arg3);
    
    
    return true;
}

static bool js_cc_Node_walk(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Node_walk__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Node_walk__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Node_walk) 

static bool js_cc_Node_destroyAllChildren(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroyAllChildren();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_destroyAllChildren) 

static bool js_cc_Node__updateSiblingIndex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->updateSiblingIndex();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node__updateSiblingIndex) 

static bool js_cc_Node_addChild(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_addChild,2,SWIGTYPE_p_cc__Node"); 
    (arg1)->addChild(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_addChild) 

static bool js_cc_Node_removeChild(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_removeChild,2,SWIGTYPE_p_cc__Node"); 
    ((cc::Node const *)arg1)->removeChild(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_removeChild) 

static bool js_cc_Node_removeFromParent(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->removeFromParent();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_removeFromParent) 

static bool js_cc_Node_removeAllChildren(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->removeAllChildren();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_removeAllChildren) 

static bool js_cc_Node_isChildOf(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_isChildOf,2,SWIGTYPE_p_cc__Node"); 
    result = (bool)((cc::Node const *)arg1)->isChildOf(arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_isChildOf) 

static bool js_cc_Node_setActive(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Node_setActive,2,SWIGTYPE_bool"); 
    (arg1)->setActive(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setActive) 

static bool js_cc_Node_setSiblingIndex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    index_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_setSiblingIndex,2,SWIGTYPE_int32_t"); 
    
    (arg1)->setSiblingIndex(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setSiblingIndex) 

static bool js_cc_Node_isActive(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((cc::Node const *)arg1)->isActive();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_isActive) 

static bool js_cc_Node_getParent(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Node *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Node *)((cc::Node const *)arg1)->getParent();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Node_getParent, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_getParent) 

static bool js_cc_Node_getEventProcessor(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::NodeEventProcessor *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::NodeEventProcessor *)((cc::Node const *)arg1)->getEventProcessor();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Node_getEventProcessor, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_getEventProcessor) 

static bool js_cc_Node_getChildByUuid(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    cc::Node *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_getChildByUuid,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = (cc::Node *)((cc::Node const *)arg1)->getChildByUuid((ccstd::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Node_getChildByUuid, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_getChildByUuid) 

static bool js_cc_Node_getChildByName(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    cc::Node *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_getChildByName,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = (cc::Node *)((cc::Node const *)arg1)->getChildByName((ccstd::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Node_getChildByName, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_getChildByName) 

static bool js_cc_Node_getChildByPath(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    cc::Node *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_getChildByPath,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = (cc::Node *)((cc::Node const *)arg1)->getChildByPath((ccstd::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Node_getChildByPath, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_getChildByPath) 

static bool js_cc_Node_getSiblingIndex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    index_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::Node const *)arg1)->getSiblingIndex();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Node_getSiblingIndex, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_getSiblingIndex) 

static bool js_cc_Node_insertChild(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    index_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_insertChild,2,SWIGTYPE_p_cc__Node"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_insertChild,3,SWIGTYPE_int32_t"); 
    
    (arg1)->insertChild(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_insertChild) 

static bool js_cc_Node_invalidateChildren(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::TransformBit arg2 ;
    int32_t temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "Node_invalidateChildren,2,SWIGTYPE_cc__TransformBit");
    arg2 = (cc::TransformBit)temp2;
    (arg1)->invalidateChildren(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_invalidateChildren) 

static bool js_cc_Node_translate__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::NodeSpace arg3 ;
    cc::Vec3 temp2 ;
    int32_t temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_translate,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp3)
    ok &= sevalue_to_native(args[1], &temp3);
    SE_PRECONDITION2(ok, false, "Node_translate,3,SWIGTYPE_cc__NodeSpace");
    arg3 = (cc::NodeSpace)temp3;
    (arg1)->translate((cc::Vec3 const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_Node_translate__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_translate,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    (arg1)->translate((cc::Vec3 const &)*arg2);
    
    
    return true;
}

static bool js_cc_Node_translate(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Node_translate__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Node_translate__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Node_translate) 

static bool js_cc_Node_lookAt__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_lookAt,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_lookAt,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    (arg1)->lookAt((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3);
    
    
    return true;
}

static bool js_cc_Node_lookAt__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_lookAt,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    (arg1)->lookAt((cc::Vec3 const &)*arg2);
    
    
    return true;
}

static bool js_cc_Node_lookAt(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Node_lookAt__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Node_lookAt__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Node_lookAt) 

static bool js_cc_Node_pauseSystemEvents(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Node_pauseSystemEvents,2,SWIGTYPE_bool"); 
    (arg1)->pauseSystemEvents(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_pauseSystemEvents) 

static bool js_cc_Node_resumeSystemEvents(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Node_resumeSystemEvents,2,SWIGTYPE_bool"); 
    (arg1)->resumeSystemEvents(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_resumeSystemEvents) 

static bool js_cc_Node_getPathInHierarchy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    ccstd::string result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::Node const *)arg1)->getPathInHierarchy();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Node_getPathInHierarchy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_getPathInHierarchy) 

static bool js_cc_Node_setPositionInternal__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    float arg3 ;
    bool arg4 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setPositionInternal,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setPositionInternal,3,SWIGTYPE_float"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "Node_setPositionInternal,4,SWIGTYPE_bool"); 
    (arg1)->setPositionInternal(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_Node_setPositionInternal__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    bool arg5 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setPositionInternal,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setPositionInternal,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setPositionInternal,4,SWIGTYPE_float"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "Node_setPositionInternal,5,SWIGTYPE_bool"); 
    (arg1)->setPositionInternal(arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_Node_setPositionInternal(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Node_setPositionInternal__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_Node_setPositionInternal__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Node_setPositionInternal) 

static bool js_cc_Node_setPositionForJS(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setPositionForJS,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setPositionForJS,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setPositionForJS,4,SWIGTYPE_float"); 
    (arg1)->setPositionForJS(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setPositionForJS) 

static bool js_cc_Node_setRotationInternal(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    bool arg6 ;
    
    if(argc != 5) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setRotationInternal,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setRotationInternal,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setRotationInternal,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setRotationInternal,5,SWIGTYPE_float"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[4], &arg6);
    SE_PRECONDITION2(ok, false, "Node_setRotationInternal,6,SWIGTYPE_bool"); 
    (arg1)->setRotationInternal(arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setRotationInternal) 

static bool js_cc_Node_setRotationForJS(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setRotationForJS,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setRotationForJS,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setRotationForJS,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setRotationForJS,5,SWIGTYPE_float"); 
    (arg1)->setRotationForJS(arg2,arg3,arg4,arg5);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setRotationForJS) 

static bool js_cc_Node_setEulerAngles(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_setEulerAngles,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    (arg1)->setEulerAngles((cc::Vec3 const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setEulerAngles) 

static bool js_cc_Node_setRotationFromEulerForJS(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setRotationFromEulerForJS,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setRotationFromEulerForJS,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setRotationFromEulerForJS,4,SWIGTYPE_float"); 
    (arg1)->setRotationFromEulerForJS(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setRotationFromEulerForJS) 

static bool js_cc_Node_setScaleInternal__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    float arg3 ;
    bool arg4 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setScaleInternal,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setScaleInternal,3,SWIGTYPE_float"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "Node_setScaleInternal,4,SWIGTYPE_bool"); 
    (arg1)->setScaleInternal(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_Node_setScaleInternal__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    bool arg5 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setScaleInternal,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setScaleInternal,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setScaleInternal,4,SWIGTYPE_float"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[3], &arg5);
    SE_PRECONDITION2(ok, false, "Node_setScaleInternal,5,SWIGTYPE_bool"); 
    (arg1)->setScaleInternal(arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_Node_setScaleInternal(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Node_setScaleInternal__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_Node_setScaleInternal__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Node_setScaleInternal) 

static bool js_cc_Node_setScaleForJS(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setScaleForJS,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setScaleForJS,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setScaleForJS,4,SWIGTYPE_float"); 
    (arg1)->setScaleForJS(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setScaleForJS) 

static bool js_cc_Node_inverseTransformPoint(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    cc::Vec3 result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_inverseTransformPoint,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    result = (arg1)->inverseTransformPoint((cc::Vec3 const &)*arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Node_inverseTransformPoint, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_inverseTransformPoint) 

static bool js_cc_Node_setWorldPosition__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_setWorldPosition,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    (arg1)->setWorldPosition((cc::Vec3 const &)*arg2);
    
    
    return true;
}

static bool js_cc_Node_setWorldPosition__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setWorldPosition,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setWorldPosition,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setWorldPosition,4,SWIGTYPE_float"); 
    (arg1)->setWorldPosition(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_Node_setWorldPosition(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Node_setWorldPosition__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Node_setWorldPosition__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Node_setWorldPosition) 

static bool js_cc_Node_setWorldRotation__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Quaternion *arg2 = 0 ;
    cc::Quaternion temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_setWorldRotation,2,SWIGTYPE_p_cc__Quaternion");
    arg2 = &temp2;
    
    (arg1)->setWorldRotation((cc::Quaternion const &)*arg2);
    
    
    return true;
}

static bool js_cc_Node_setWorldRotation__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setWorldRotation,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setWorldRotation,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setWorldRotation,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setWorldRotation,5,SWIGTYPE_float"); 
    (arg1)->setWorldRotation(arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_Node_setWorldRotation(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Node_setWorldRotation__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_Node_setWorldRotation__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Node_setWorldRotation) 

static bool js_cc_Node_setWorldScale__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_setWorldScale,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    (arg1)->setWorldScale((cc::Vec3 const &)*arg2);
    
    
    return true;
}

static bool js_cc_Node_setWorldScale__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setWorldScale,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setWorldScale,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setWorldScale,4,SWIGTYPE_float"); 
    (arg1)->setWorldScale(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_Node_setWorldScale(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Node_setWorldScale__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Node_setWorldScale__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Node_setWorldScale) 

static bool js_cc_Node_setWorldRotationFromEuler(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setWorldRotationFromEuler,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setWorldRotationFromEuler,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Node_setWorldRotationFromEuler,4,SWIGTYPE_float"); 
    (arg1)->setWorldRotationFromEuler(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setWorldRotationFromEuler) 

static bool js_cc_Node_updateWorldTransform(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->updateWorldTransform();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_updateWorldTransform) 

static bool js_cc_Node_setForward(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_setForward,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    (arg1)->setForward((cc::Vec3 const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setForward) 

static bool js_cc_Node_isStatic(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((cc::Node const *)arg1)->isStatic();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_isStatic) 

static bool js_cc_Node_setStatic(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Node_setStatic,2,SWIGTYPE_bool"); 
    (arg1)->setStatic(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setStatic) 

static bool js_cc_Node_setDirtyFlag(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_setDirtyFlag,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setDirtyFlag(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setDirtyFlag) 

static bool js_cc_Node_getDirtyFlag(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::Node const *)arg1)->getDirtyFlag();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Node_getDirtyFlag, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_getDirtyFlag) 

static bool js_cc_Node_setLayer(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_setLayer,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setLayer(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_setLayer) 

static bool js_cc_Node_getLayer(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::Node const *)arg1)->getLayer();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Node_getLayer, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node_getLayer) 

static bool js_cc_Node__setChildren(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::Node > > *arg2 = 0 ;
    ccstd::vector< cc::IntrusivePtr< cc::Node > > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node__setChildren,2,SWIGTYPE_p_ccstd__vectorT_cc__IntrusivePtrT_cc__Node_t_t");
    arg2 = &temp2;
    
    (arg1)->_setChildren((ccstd::vector< cc::IntrusivePtr< cc::Node > > &&)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node__setChildren) 

static bool js_cc_Node__getSharedArrayBufferObject(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    se::Object *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (se::Object *)((cc::Node const *)arg1)->_getSharedArrayBufferObject();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Node__getSharedArrayBufferObject, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node__getSharedArrayBufferObject) 

static bool js_cc_Node__onPreDestroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->onPreDestroy();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node__onPreDestroy) 

static bool js_cc_Node__onPreDestroyBase(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->onPreDestroyBase();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Node__onPreDestroyBase) 

static bool js_cc_Node_onSiblingIndexChanged_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->onSiblingIndexChanged, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_onSiblingIndexChanged_set,2,SWIGTYPE_std__functionT_void_fint32_tF_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Node_onSiblingIndexChanged_set) 

static bool js_cc_Node_onSiblingIndexChanged_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Node *arg1 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->onSiblingIndexChanged, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Node_onSiblingIndexChanged_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->onSiblingIndexChanged, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Node_onSiblingIndexChanged_get) 

static bool js_cc_Node__id_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_id, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node__id_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Node__id_set) 

static bool js_cc_Node__id_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Node *arg1 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_id, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Node__id_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_id, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Node__id_get) 

static bool js_cc_Node__parentInternal_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->_parent, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node__parentInternal_set,2,SWIGTYPE_p_cc__Node"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Node__parentInternal_set) 

static bool js_cc_Node__parentInternal_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Node *arg1 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->_parent, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Node__parentInternal_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_parent, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Node__parentInternal_get) 

static bool js_cc_Node_uuid_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Node *arg1 = (cc::Node *) NULL ;
    ccstd::string *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::string *) &cc_Node_uuid_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Node_uuid_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Node_uuid_get) 

static bool js_cc_Node_angle_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Node_angle_set,2,SWIGTYPE_float"); 
    cc_Node_angle_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Node_angle_set) 

static bool js_cc_Node_angle_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Node *arg1 = (cc::Node *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_Node_angle_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Node_angle_get) 

static bool js_cc_Node_matrix_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    cc::Mat4 *arg2 = 0 ;
    cc::Mat4 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_matrix_set,2,SWIGTYPE_p_cc__Mat4");
    arg2 = &temp2;
    
    cc_Node_matrix_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Node_matrix_set) 

static bool js_cc_Node_hasChangedFlags_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Node_hasChangedFlags_set,2,SWIGTYPE_uint32_t"); 
    
    cc_Node_hasChangedFlags_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Node_hasChangedFlags_set) 

static bool js_cc_Node_hasChangedFlags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Node *arg1 = (cc::Node *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_Node_hasChangedFlags_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Node_hasChangedFlags_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Node_hasChangedFlags_get) 

static bool js_cc_Node__persistNode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Node *arg1 = (cc::Node *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Node__persistNode_set,2,SWIGTYPE_bool"); 
    cc_Node__persistNode_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Node__persistNode_set) 

static bool js_cc_Node__persistNode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Node *arg1 = (cc::Node *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::Node>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_Node__persistNode_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Node__persistNode_get) 

bool js_register_cc_Node(se::Object* obj) {
    auto* cls = se::Class::create("Node", obj, __jsb_cc_BaseNode_proto, _SE(js_new_Node)); 
    
    cls->defineProperty("onSiblingIndexChanged", _SE(js_cc_Node_onSiblingIndexChanged_get), _SE(js_cc_Node_onSiblingIndexChanged_set)); 
    cls->defineProperty("_id", _SE(js_cc_Node__id_get), _SE(js_cc_Node__id_set)); 
    cls->defineProperty("_parentInternal", _SE(js_cc_Node__parentInternal_get), _SE(js_cc_Node__parentInternal_set)); 
    cls->defineProperty("uuid", _SE(js_cc_Node_uuid_get), nullptr); 
    cls->defineProperty("angle", _SE(js_cc_Node_angle_get), _SE(js_cc_Node_angle_set)); 
    cls->defineProperty("matrix", nullptr, _SE(js_cc_Node_matrix_set)); 
    cls->defineProperty("hasChangedFlags", _SE(js_cc_Node_hasChangedFlags_get), _SE(js_cc_Node_hasChangedFlags_set)); 
    cls->defineProperty("_persistNode", _SE(js_cc_Node__persistNode_get), _SE(js_cc_Node__persistNode_set)); 
    
    cls->defineFunction("onPostActivated", _SE(js_cc_Node_onPostActivated)); 
    cls->defineFunction("setParent", _SE(js_cc_Node_setParent)); 
    cls->defineFunction("getScene", _SE(js_cc_Node_getScene)); 
    cls->defineFunction("walk", _SE(js_cc_Node_walk)); 
    cls->defineFunction("destroyAllChildren", _SE(js_cc_Node_destroyAllChildren)); 
    cls->defineFunction("_updateSiblingIndex", _SE(js_cc_Node__updateSiblingIndex)); 
    cls->defineFunction("addChild", _SE(js_cc_Node_addChild)); 
    cls->defineFunction("removeChild", _SE(js_cc_Node_removeChild)); 
    cls->defineFunction("removeFromParent", _SE(js_cc_Node_removeFromParent)); 
    cls->defineFunction("removeAllChildren", _SE(js_cc_Node_removeAllChildren)); 
    cls->defineFunction("isChildOf", _SE(js_cc_Node_isChildOf)); 
    cls->defineFunction("setActive", _SE(js_cc_Node_setActive)); 
    cls->defineFunction("setSiblingIndex", _SE(js_cc_Node_setSiblingIndex)); 
    cls->defineFunction("isActive", _SE(js_cc_Node_isActive)); 
    cls->defineFunction("getParent", _SE(js_cc_Node_getParent)); 
    cls->defineFunction("getEventProcessor", _SE(js_cc_Node_getEventProcessor)); 
    cls->defineFunction("getChildByUuid", _SE(js_cc_Node_getChildByUuid)); 
    cls->defineFunction("getChildByName", _SE(js_cc_Node_getChildByName)); 
    cls->defineFunction("getChildByPath", _SE(js_cc_Node_getChildByPath)); 
    cls->defineFunction("getSiblingIndex", _SE(js_cc_Node_getSiblingIndex)); 
    cls->defineFunction("insertChild", _SE(js_cc_Node_insertChild)); 
    cls->defineFunction("invalidateChildren", _SE(js_cc_Node_invalidateChildren)); 
    cls->defineFunction("translate", _SE(js_cc_Node_translate)); 
    cls->defineFunction("lookAt", _SE(js_cc_Node_lookAt)); 
    cls->defineFunction("pauseSystemEvents", _SE(js_cc_Node_pauseSystemEvents)); 
    cls->defineFunction("resumeSystemEvents", _SE(js_cc_Node_resumeSystemEvents)); 
    cls->defineFunction("getPathInHierarchy", _SE(js_cc_Node_getPathInHierarchy)); 
    cls->defineFunction("setPositionInternal", _SE(js_cc_Node_setPositionInternal)); 
    cls->defineFunction("setPositionForJS", _SE(js_cc_Node_setPositionForJS)); 
    cls->defineFunction("setRotationInternal", _SE(js_cc_Node_setRotationInternal)); 
    cls->defineFunction("setRotationForJS", _SE(js_cc_Node_setRotationForJS)); 
    cls->defineFunction("setEulerAngles", _SE(js_cc_Node_setEulerAngles)); 
    cls->defineFunction("setRotationFromEulerForJS", _SE(js_cc_Node_setRotationFromEulerForJS)); 
    cls->defineFunction("setScaleInternal", _SE(js_cc_Node_setScaleInternal)); 
    cls->defineFunction("setScaleForJS", _SE(js_cc_Node_setScaleForJS)); 
    cls->defineFunction("inverseTransformPoint", _SE(js_cc_Node_inverseTransformPoint)); 
    cls->defineFunction("setWorldPosition", _SE(js_cc_Node_setWorldPosition)); 
    cls->defineFunction("setWorldRotation", _SE(js_cc_Node_setWorldRotation)); 
    cls->defineFunction("setWorldScale", _SE(js_cc_Node_setWorldScale)); 
    cls->defineFunction("setWorldRotationFromEuler", _SE(js_cc_Node_setWorldRotationFromEuler)); 
    cls->defineFunction("updateWorldTransform", _SE(js_cc_Node_updateWorldTransform)); 
    cls->defineFunction("setForward", _SE(js_cc_Node_setForward)); 
    cls->defineFunction("isStatic", _SE(js_cc_Node_isStatic)); 
    cls->defineFunction("setStatic", _SE(js_cc_Node_setStatic)); 
    cls->defineFunction("setDirtyFlag", _SE(js_cc_Node_setDirtyFlag)); 
    cls->defineFunction("getDirtyFlag", _SE(js_cc_Node_getDirtyFlag)); 
    cls->defineFunction("setLayer", _SE(js_cc_Node_setLayer)); 
    cls->defineFunction("getLayer", _SE(js_cc_Node_getLayer)); 
    cls->defineFunction("_setChildren", _SE(js_cc_Node__setChildren)); 
    cls->defineFunction("_getSharedArrayBufferObject", _SE(js_cc_Node__getSharedArrayBufferObject)); 
    cls->defineFunction("_onPreDestroy", _SE(js_cc_Node__onPreDestroy)); 
    cls->defineFunction("_onPreDestroyBase", _SE(js_cc_Node__onPreDestroyBase)); 
    
    cls->defineStaticProperty("TRANSFORM_ON", _SE(js_cc_Node_TRANSFORM_ON_get), nullptr); 
    
    cls->defineStaticFunction("instantiate", _SE(js_cc_Node_instantiate_static)); 
    cls->defineStaticFunction("setScene", _SE(js_cc_Node_setScene_static)); 
    cls->defineStaticFunction("resetHasChangedFlags", _SE(js_cc_Node_resetHasChangedFlags_static)); 
    cls->defineStaticFunction("clearNodeArray", _SE(js_cc_Node_clearNodeArray_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Node));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Node>(cls);
    
    __jsb_cc_Node_proto = cls->getProto();
    __jsb_cc_Node_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Scene_class = nullptr;
se::Object* __jsb_cc_Scene_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Scene) 

static bool js_new_cc_Scene__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    ccstd::string *arg1 = 0 ;
    ccstd::string temp1 ;
    cc::Scene *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Scene,1,SWIGTYPE_p_ccstd__string");
    arg1 = &temp1;
    
    result = (cc::Scene *)new cc::Scene((ccstd::string const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_Scene__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::Scene *result;
    result = (cc::Scene *)new cc::Scene();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_Scene(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_ctor_dispatcher
    size_t argc = s.args().size();
    bool ret = false;
    
    // switch all cases by means of series of if-returns.
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_Scene__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 0) {
        ret = js_new_cc_Scene__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    
    // default:
    SE_REPORT_ERROR("Illegal arguments for construction of Scene");
    return false;
}
SE_BIND_CTOR(js_new_Scene, __jsb_cc_Scene_class, js_delete_cc_Scene)

static bool js_delete_cc_Scene(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Scene) 

static bool js_cc_Scene_getRenderScene(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Scene *arg1 = (cc::Scene *) NULL ;
    cc::scene::RenderScene *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Scene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::RenderScene *)((cc::Scene const *)arg1)->getRenderScene();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Scene_getRenderScene, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Scene_getRenderScene) 

static bool js_cc_Scene_getSceneGlobals(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Scene *arg1 = (cc::Scene *) NULL ;
    cc::SceneGlobals *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Scene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::SceneGlobals *)((cc::Scene const *)arg1)->getSceneGlobals();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Scene_getSceneGlobals, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Scene_getSceneGlobals) 

static bool js_cc_Scene_setSceneGlobals(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Scene *arg1 = (cc::Scene *) NULL ;
    cc::SceneGlobals *arg2 = (cc::SceneGlobals *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Scene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Scene_setSceneGlobals,2,SWIGTYPE_p_cc__SceneGlobals"); 
    (arg1)->setSceneGlobals(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Scene_setSceneGlobals) 

static bool js_cc_Scene__load(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Scene *arg1 = (cc::Scene *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Scene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->load();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Scene__load) 

static bool js_cc_Scene__activate__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Scene *arg1 = (cc::Scene *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Scene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Scene__activate,2,SWIGTYPE_bool"); 
    (arg1)->activate(arg2);
    
    
    return true;
}

static bool js_cc_Scene__activate__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Scene *arg1 = (cc::Scene *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Scene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->activate();
    
    
    return true;
}

static bool js_cc_Scene__activate(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Scene__activate__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 0) {
        ok = js_cc_Scene__activate__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Scene__activate) 

static bool js_cc_Scene_onBatchCreated(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Scene *arg1 = (cc::Scene *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Scene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Scene_onBatchCreated,2,SWIGTYPE_bool"); 
    (arg1)->onBatchCreated(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Scene_onBatchCreated) 

static bool js_cc_Scene_autoReleaseAssets_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Scene *arg1 = (cc::Scene *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Scene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Scene_autoReleaseAssets_set,2,SWIGTYPE_bool"); 
    cc_Scene_autoReleaseAssets_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Scene_autoReleaseAssets_set) 

static bool js_cc_Scene_autoReleaseAssets_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Scene *arg1 = (cc::Scene *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::Scene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_Scene_autoReleaseAssets_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Scene_autoReleaseAssets_get) 

bool js_register_cc_Scene(se::Object* obj) {
    auto* cls = se::Class::create("Scene", obj, __jsb_cc_Node_proto, _SE(js_new_Scene)); 
    
    cls->defineProperty("autoReleaseAssets", _SE(js_cc_Scene_autoReleaseAssets_get), _SE(js_cc_Scene_autoReleaseAssets_set)); 
    
    cls->defineFunction("getRenderScene", _SE(js_cc_Scene_getRenderScene)); 
    cls->defineFunction("getSceneGlobals", _SE(js_cc_Scene_getSceneGlobals)); 
    cls->defineFunction("setSceneGlobals", _SE(js_cc_Scene_setSceneGlobals)); 
    cls->defineFunction("_load", _SE(js_cc_Scene__load)); 
    cls->defineFunction("_activate", _SE(js_cc_Scene__activate)); 
    cls->defineFunction("onBatchCreated", _SE(js_cc_Scene_onBatchCreated)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Scene));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Scene>(cls);
    
    __jsb_cc_Scene_proto = cls->getProto();
    __jsb_cc_Scene_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_SceneGlobals_class = nullptr;
se::Object* __jsb_cc_SceneGlobals_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_SceneGlobals) 

// js_ctor
static bool js_new_cc_SceneGlobals(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::SceneGlobals *result;
    result = (cc::SceneGlobals *)new cc::SceneGlobals();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_SceneGlobals, __jsb_cc_SceneGlobals_class, js_delete_cc_SceneGlobals)

static bool js_delete_cc_SceneGlobals(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_SceneGlobals) 

static bool js_cc_SceneGlobals_activate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->activate();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneGlobals_activate) 

static bool js_cc_SceneGlobals_getAmbientInfo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;
    cc::scene::AmbientInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::AmbientInfo *)((cc::SceneGlobals const *)arg1)->getAmbientInfo();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SceneGlobals_getAmbientInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneGlobals_getAmbientInfo) 

static bool js_cc_SceneGlobals_getShadowsInfo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;
    cc::scene::ShadowsInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::ShadowsInfo *)((cc::SceneGlobals const *)arg1)->getShadowsInfo();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SceneGlobals_getShadowsInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneGlobals_getShadowsInfo) 

static bool js_cc_SceneGlobals_getSkyboxInfo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;
    cc::scene::SkyboxInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::SkyboxInfo *)((cc::SceneGlobals const *)arg1)->getSkyboxInfo();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SceneGlobals_getSkyboxInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneGlobals_getSkyboxInfo) 

static bool js_cc_SceneGlobals_getFogInfo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;
    cc::scene::FogInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::FogInfo *)((cc::SceneGlobals const *)arg1)->getFogInfo();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SceneGlobals_getFogInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneGlobals_getFogInfo) 

static bool js_cc_SceneGlobals_getOctreeInfo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;
    cc::scene::OctreeInfo *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::OctreeInfo *)((cc::SceneGlobals const *)arg1)->getOctreeInfo();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SceneGlobals_getOctreeInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneGlobals_getOctreeInfo) 

static bool js_cc_SceneGlobals_setAmbientInfo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;
    cc::scene::AmbientInfo *arg2 = (cc::scene::AmbientInfo *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SceneGlobals_setAmbientInfo,2,SWIGTYPE_p_cc__scene__AmbientInfo"); 
    (arg1)->setAmbientInfo(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneGlobals_setAmbientInfo) 

static bool js_cc_SceneGlobals_setShadowsInfo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;
    cc::scene::ShadowsInfo *arg2 = (cc::scene::ShadowsInfo *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SceneGlobals_setShadowsInfo,2,SWIGTYPE_p_cc__scene__ShadowsInfo"); 
    (arg1)->setShadowsInfo(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneGlobals_setShadowsInfo) 

static bool js_cc_SceneGlobals_setSkyboxInfo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;
    cc::scene::SkyboxInfo *arg2 = (cc::scene::SkyboxInfo *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SceneGlobals_setSkyboxInfo,2,SWIGTYPE_p_cc__scene__SkyboxInfo"); 
    (arg1)->setSkyboxInfo(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneGlobals_setSkyboxInfo) 

static bool js_cc_SceneGlobals_setFogInfo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;
    cc::scene::FogInfo *arg2 = (cc::scene::FogInfo *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SceneGlobals_setFogInfo,2,SWIGTYPE_p_cc__scene__FogInfo"); 
    (arg1)->setFogInfo(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneGlobals_setFogInfo) 

static bool js_cc_SceneGlobals_setOctreeInfo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SceneGlobals *arg1 = (cc::SceneGlobals *) NULL ;
    cc::scene::OctreeInfo *arg2 = (cc::scene::OctreeInfo *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SceneGlobals>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SceneGlobals_setOctreeInfo,2,SWIGTYPE_p_cc__scene__OctreeInfo"); 
    (arg1)->setOctreeInfo(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SceneGlobals_setOctreeInfo) 

bool js_register_cc_SceneGlobals(se::Object* obj) {
    auto* cls = se::Class::create("SceneGlobals", obj, nullptr, _SE(js_new_cc_SceneGlobals)); 
    
    
    cls->defineFunction("activate", _SE(js_cc_SceneGlobals_activate)); 
    cls->defineFunction("getAmbientInfo", _SE(js_cc_SceneGlobals_getAmbientInfo)); 
    cls->defineFunction("getShadowsInfo", _SE(js_cc_SceneGlobals_getShadowsInfo)); 
    cls->defineFunction("getSkyboxInfo", _SE(js_cc_SceneGlobals_getSkyboxInfo)); 
    cls->defineFunction("getFogInfo", _SE(js_cc_SceneGlobals_getFogInfo)); 
    cls->defineFunction("getOctreeInfo", _SE(js_cc_SceneGlobals_getOctreeInfo)); 
    cls->defineFunction("setAmbientInfo", _SE(js_cc_SceneGlobals_setAmbientInfo)); 
    cls->defineFunction("setShadowsInfo", _SE(js_cc_SceneGlobals_setShadowsInfo)); 
    cls->defineFunction("setSkyboxInfo", _SE(js_cc_SceneGlobals_setSkyboxInfo)); 
    cls->defineFunction("setFogInfo", _SE(js_cc_SceneGlobals_setFogInfo)); 
    cls->defineFunction("setOctreeInfo", _SE(js_cc_SceneGlobals_setOctreeInfo)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_SceneGlobals));
    
    
    cls->install();
    JSBClassType::registerClass<cc::SceneGlobals>(cls);
    
    __jsb_cc_SceneGlobals_proto = cls->getProto();
    __jsb_cc_SceneGlobals_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_DebugViewConfig_class = nullptr;
se::Object* __jsb_cc_DebugViewConfig_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_DebugViewConfig) 

static bool js_cc_DebugViewConfig_singleMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DebugViewConfig *arg1 = (cc::DebugViewConfig *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugViewConfig>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->singleMode, s.thisObject());
    SE_PRECONDITION2(ok, false, "DebugViewConfig_singleMode_set,2,SWIGTYPE_uint8_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DebugViewConfig_singleMode_set) 

static bool js_cc_DebugViewConfig_singleMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DebugViewConfig *arg1 = (cc::DebugViewConfig *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugViewConfig>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->singleMode, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DebugViewConfig_singleMode_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->singleMode, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DebugViewConfig_singleMode_get) 

static bool js_cc_DebugViewConfig_compositeModeBitCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DebugViewConfig *arg1 = (cc::DebugViewConfig *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugViewConfig>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->compositeModeBitCount, s.thisObject());
    SE_PRECONDITION2(ok, false, "DebugViewConfig_compositeModeBitCount_set,2,SWIGTYPE_uint8_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DebugViewConfig_compositeModeBitCount_set) 

static bool js_cc_DebugViewConfig_compositeModeBitCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DebugViewConfig *arg1 = (cc::DebugViewConfig *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugViewConfig>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->compositeModeBitCount, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DebugViewConfig_compositeModeBitCount_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->compositeModeBitCount, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DebugViewConfig_compositeModeBitCount_get) 

static bool js_cc_DebugViewConfig_compositeModeValue_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DebugViewConfig *arg1 = (cc::DebugViewConfig *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugViewConfig>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->compositeModeValue, s.thisObject());
    SE_PRECONDITION2(ok, false, "DebugViewConfig_compositeModeValue_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DebugViewConfig_compositeModeValue_set) 

static bool js_cc_DebugViewConfig_compositeModeValue_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DebugViewConfig *arg1 = (cc::DebugViewConfig *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugViewConfig>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->compositeModeValue, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DebugViewConfig_compositeModeValue_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->compositeModeValue, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DebugViewConfig_compositeModeValue_get) 

static bool js_cc_DebugViewConfig_lightingWithAlbedo_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DebugViewConfig *arg1 = (cc::DebugViewConfig *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugViewConfig>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->lightingWithAlbedo);
    SE_PRECONDITION2(ok, false, "DebugViewConfig_lightingWithAlbedo_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DebugViewConfig_lightingWithAlbedo_set) 

static bool js_cc_DebugViewConfig_lightingWithAlbedo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DebugViewConfig *arg1 = (cc::DebugViewConfig *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugViewConfig>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->lightingWithAlbedo, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DebugViewConfig_lightingWithAlbedo_get) 

static bool js_cc_DebugViewConfig_csmLayerColoration_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DebugViewConfig *arg1 = (cc::DebugViewConfig *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugViewConfig>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->csmLayerColoration);
    SE_PRECONDITION2(ok, false, "DebugViewConfig_csmLayerColoration_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DebugViewConfig_csmLayerColoration_set) 

static bool js_cc_DebugViewConfig_csmLayerColoration_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DebugViewConfig *arg1 = (cc::DebugViewConfig *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugViewConfig>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->csmLayerColoration, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DebugViewConfig_csmLayerColoration_get) 

// js_ctor
static bool js_new_cc_DebugViewConfig(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::DebugViewConfig *result;
    result = (cc::DebugViewConfig *)new cc::DebugViewConfig();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_DebugViewConfig, __jsb_cc_DebugViewConfig_class, js_delete_cc_DebugViewConfig)

static bool js_delete_cc_DebugViewConfig(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_DebugViewConfig) 

template<>
bool sevalue_to_native(const se::Value &from, cc::DebugViewConfig * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::DebugViewConfig*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("singleMode", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->singleMode), ctx);
    }
    
    
    json->getProperty("compositeModeBitCount", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->compositeModeBitCount), ctx);
    }
    
    
    json->getProperty("compositeModeValue", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->compositeModeValue), ctx);
    }
    
    
    json->getProperty("lightingWithAlbedo", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->lightingWithAlbedo), ctx);
    }
    
    
    json->getProperty("csmLayerColoration", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->csmLayerColoration), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_DebugViewConfig(se::Object* obj) {
    auto* cls = se::Class::create("DebugViewConfig", obj, nullptr, _SE(js_new_cc_DebugViewConfig)); 
    
    cls->defineProperty("singleMode", _SE(js_cc_DebugViewConfig_singleMode_get), _SE(js_cc_DebugViewConfig_singleMode_set)); 
    cls->defineProperty("compositeModeBitCount", _SE(js_cc_DebugViewConfig_compositeModeBitCount_get), _SE(js_cc_DebugViewConfig_compositeModeBitCount_set)); 
    cls->defineProperty("compositeModeValue", _SE(js_cc_DebugViewConfig_compositeModeValue_get), _SE(js_cc_DebugViewConfig_compositeModeValue_set)); 
    cls->defineProperty("lightingWithAlbedo", _SE(js_cc_DebugViewConfig_lightingWithAlbedo_get), _SE(js_cc_DebugViewConfig_lightingWithAlbedo_set)); 
    cls->defineProperty("csmLayerColoration", _SE(js_cc_DebugViewConfig_csmLayerColoration_get), _SE(js_cc_DebugViewConfig_csmLayerColoration_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_DebugViewConfig));
    
    
    cls->install();
    JSBClassType::registerClass<cc::DebugViewConfig>(cls);
    
    __jsb_cc_DebugViewConfig_proto = cls->getProto();
    __jsb_cc_DebugViewConfig_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Root_class = nullptr;
se::Object* __jsb_cc_Root_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Root) 

static bool js_cc_Root_getInstance_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::Root *)cc::Root::getInstance();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Root_getInstance, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_getInstance_static) 

// js_ctor
static bool js_new_cc_Root(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 1) {
        SE_REPORT_ERROR("js_new_cc_Root: wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::Root *result;
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Root,1,SWIGTYPE_p_cc__gfx__Device"); 
    result = (cc::Root *)new cc::Root(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Root, __jsb_cc_Root_class, js_delete_cc_Root)

static bool js_delete_cc_Root(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Root) 

static bool js_cc_Root__initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::gfx::Swapchain *arg2 = (cc::gfx::Swapchain *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Root__initialize,2,SWIGTYPE_p_cc__gfx__Swapchain"); 
    (arg1)->initialize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root__initialize) 

static bool js_cc_Root_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_destroy) 

static bool js_cc_Root_resize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Root_resize,2,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Root_resize,3,SWIGTYPE_uint32_t"); 
    
    (arg1)->resize(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_resize) 

static bool js_cc_Root_setRenderPipeline__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::pipeline::RenderPipeline *arg2 = (cc::pipeline::RenderPipeline *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Root_setRenderPipeline,2,SWIGTYPE_p_cc__pipeline__RenderPipeline"); 
    result = (bool)(arg1)->setRenderPipeline(arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_cc_Root_setRenderPipeline__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Root *arg1 = (cc::Root *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->setRenderPipeline();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_cc_Root_setRenderPipeline(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Root_setRenderPipeline__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 0) {
        ok = js_cc_Root_setRenderPipeline__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Root_setRenderPipeline) 

static bool js_cc_Root_onGlobalPipelineStateChanged(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onGlobalPipelineStateChanged();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_onGlobalPipelineStateChanged) 

static bool js_cc_Root_activeWindow(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::RenderWindow *arg2 = (cc::scene::RenderWindow *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Root_activeWindow,2,SWIGTYPE_p_cc__scene__RenderWindow"); 
    (arg1)->activeWindow(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_activeWindow) 

static bool js_cc_Root_resetCumulativeTime(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->resetCumulativeTime();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_resetCumulativeTime) 

static bool js_cc_Root_frameMove(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    float arg2 ;
    int32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Root_frameMove,2,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Root_frameMove,3,SWIGTYPE_int32_t"); 
    
    (arg1)->frameMove(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_frameMove) 

static bool js_cc_Root_createWindow(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::IRenderWindowInfo *arg2 = 0 ;
    cc::scene::IRenderWindowInfo temp2 ;
    cc::scene::RenderWindow *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Root_createWindow,2,SWIGTYPE_p_cc__scene__IRenderWindowInfo");
    arg2 = &temp2;
    
    result = (cc::scene::RenderWindow *)(arg1)->createWindow(*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Root_createWindow, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_createWindow) 

static bool js_cc_Root_destroyWindow(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::RenderWindow *arg2 = (cc::scene::RenderWindow *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Root_destroyWindow,2,SWIGTYPE_p_cc__scene__RenderWindow"); 
    (arg1)->destroyWindow(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_destroyWindow) 

static bool js_cc_Root_destroyWindows(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroyWindows();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_destroyWindows) 

static bool js_cc_Root_createScene(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::IRenderSceneInfo *arg2 = 0 ;
    cc::scene::IRenderSceneInfo temp2 ;
    cc::scene::RenderScene *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Root_createScene,2,SWIGTYPE_p_cc__scene__IRenderSceneInfo");
    arg2 = &temp2;
    
    result = (cc::scene::RenderScene *)(arg1)->createScene((cc::scene::IRenderSceneInfo const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Root_createScene, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_createScene) 

static bool js_cc_Root_destroyScene(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::RenderScene *arg2 = (cc::scene::RenderScene *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Root_destroyScene,2,SWIGTYPE_p_cc__scene__RenderScene"); 
    (arg1)->destroyScene(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_destroyScene) 

static bool js_cc_Root_destroyScenes(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroyScenes();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_destroyScenes) 

static bool js_cc_Root_destroyModel(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::Model *arg2 = (cc::scene::Model *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Root_destroyModel,2,SWIGTYPE_p_cc__scene__Model"); 
    (arg1)->destroyModel(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_destroyModel) 

static bool js_cc_Root_destroyLight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::Light *arg2 = (cc::scene::Light *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Root_destroyLight,2,SWIGTYPE_p_cc__scene__Light"); 
    (arg1)->destroyLight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_destroyLight) 

static bool js_cc_Root_createCamera(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::Camera *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::Camera *)((cc::Root const *)arg1)->createCamera();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Root_createCamera, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_createCamera) 

static bool js_cc_Root_getBatcher2D(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::Batcher2d *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Batcher2d *)((cc::Root const *)arg1)->getBatcher2D();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Root_getBatcher2D, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_getBatcher2D) 

static bool js_cc_Root_setDebugViewConfig(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::DebugViewConfig *arg2 = 0 ;
    cc::DebugViewConfig temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Root_setDebugViewConfig,2,SWIGTYPE_p_cc__DebugViewConfig");
    arg2 = &temp2;
    
    (arg1)->setDebugViewConfig((cc::DebugViewConfig const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_setDebugViewConfig) 

static bool js_cc_Root_getDebugViewConfig(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::DebugViewConfig *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::DebugViewConfig *) &((cc::Root const *)arg1)->getDebugViewConfig();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Root_getDebugViewConfig, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_getDebugViewConfig) 

static bool js_cc_Root_getEventProcessor(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::CallbacksInvoker *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::CallbacksInvoker *)((cc::Root const *)arg1)->getEventProcessor();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Root_getEventProcessor, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Root_getEventProcessor) 

static bool js_cc_Root_device_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::gfx::Device *arg2 = (cc::gfx::Device *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Root_device_set,2,SWIGTYPE_p_cc__gfx__Device"); 
    cc_Root_device_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Root_device_set) 

static bool js_cc_Root_device_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::gfx::Device *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Device *)cc_Root_device_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Root_device_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_device_get) 

static bool js_cc_Root__device_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::gfx::Device *arg2 = (cc::gfx::Device *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Root__device_set,2,SWIGTYPE_p_cc__gfx__Device"); 
    cc_Root__device_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Root__device_set) 

static bool js_cc_Root__device_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::gfx::Device *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Device *)cc_Root__device_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Root__device_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root__device_get) 

static bool js_cc_Root_mainWindow_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::RenderWindow *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::RenderWindow *)cc_Root_mainWindow_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Root_mainWindow_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_mainWindow_get) 

static bool js_cc_Root_curWindow_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::RenderWindow *arg2 = (cc::scene::RenderWindow *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Root_curWindow_set,2,SWIGTYPE_p_cc__scene__RenderWindow"); 
    cc_Root_curWindow_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Root_curWindow_set) 

static bool js_cc_Root_curWindow_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::RenderWindow *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::RenderWindow *)cc_Root_curWindow_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Root_curWindow_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_curWindow_get) 

static bool js_cc_Root_tempWindow_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::RenderWindow *arg2 = (cc::scene::RenderWindow *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Root_tempWindow_set,2,SWIGTYPE_p_cc__scene__RenderWindow"); 
    cc_Root_tempWindow_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Root_tempWindow_set) 

static bool js_cc_Root_tempWindow_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::RenderWindow *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::RenderWindow *)cc_Root_tempWindow_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Root_tempWindow_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_tempWindow_get) 

static bool js_cc_Root_windows_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::scene::RenderWindow > > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::IntrusivePtr< cc::scene::RenderWindow > > *) &cc_Root_windows_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Root_windows_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_windows_get) 

static bool js_cc_Root_scenes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::scene::RenderScene > > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::IntrusivePtr< cc::scene::RenderScene > > *) &cc_Root_scenes_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Root_scenes_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_scenes_get) 

static bool js_cc_Root_cumulativeTime_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_Root_cumulativeTime_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_cumulativeTime_get) 

static bool js_cc_Root_frameTime_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_Root_frameTime_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_frameTime_get) 

static bool js_cc_Root_frameCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_Root_frameCount_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Root_frameCount_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_frameCount_get) 

static bool js_cc_Root_fps_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_Root_fps_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Root_fps_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_fps_get) 

static bool js_cc_Root_fixedFPS_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Root *arg1 = (cc::Root *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Root_fixedFPS_set,2,SWIGTYPE_uint32_t"); 
    
    cc_Root_fixedFPS_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Root_fixedFPS_set) 

static bool js_cc_Root_fixedFPS_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_Root_fixedFPS_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Root_fixedFPS_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_fixedFPS_get) 

static bool js_cc_Root_useDeferredPipeline_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_Root_useDeferredPipeline_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_useDeferredPipeline_get) 

static bool js_cc_Root_usesCustomPipeline_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_Root_usesCustomPipeline_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_usesCustomPipeline_get) 

static bool js_cc_Root_pipeline_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::render::PipelineRuntime *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::render::PipelineRuntime *)cc_Root_pipeline_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Root_pipeline_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_pipeline_get) 

static bool js_cc_Root_customPipeline_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::render::Pipeline *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::Root>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::render::Pipeline *)cc_Root_customPipeline_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Root_customPipeline_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Root_customPipeline_get) 

bool js_register_cc_Root(se::Object* obj) {
    auto* cls = se::Class::create("Root", obj, nullptr, _SE(js_new_cc_Root)); 
    
    cls->defineProperty("device", _SE(js_cc_Root_device_get), _SE(js_cc_Root_device_set)); 
    cls->defineProperty("_device", _SE(js_cc_Root__device_get), _SE(js_cc_Root__device_set)); 
    cls->defineProperty("mainWindow", _SE(js_cc_Root_mainWindow_get), nullptr); 
    cls->defineProperty("curWindow", _SE(js_cc_Root_curWindow_get), _SE(js_cc_Root_curWindow_set)); 
    cls->defineProperty("tempWindow", _SE(js_cc_Root_tempWindow_get), _SE(js_cc_Root_tempWindow_set)); 
    cls->defineProperty("windows", _SE(js_cc_Root_windows_get), nullptr); 
    cls->defineProperty("scenes", _SE(js_cc_Root_scenes_get), nullptr); 
    cls->defineProperty("cumulativeTime", _SE(js_cc_Root_cumulativeTime_get), nullptr); 
    cls->defineProperty("frameTime", _SE(js_cc_Root_frameTime_get), nullptr); 
    cls->defineProperty("frameCount", _SE(js_cc_Root_frameCount_get), nullptr); 
    cls->defineProperty("fps", _SE(js_cc_Root_fps_get), nullptr); 
    cls->defineProperty("fixedFPS", _SE(js_cc_Root_fixedFPS_get), _SE(js_cc_Root_fixedFPS_set)); 
    cls->defineProperty("useDeferredPipeline", _SE(js_cc_Root_useDeferredPipeline_get), nullptr); 
    cls->defineProperty("usesCustomPipeline", _SE(js_cc_Root_usesCustomPipeline_get), nullptr); 
    cls->defineProperty("pipeline", _SE(js_cc_Root_pipeline_get), nullptr); 
    cls->defineProperty("customPipeline", _SE(js_cc_Root_customPipeline_get), nullptr); 
    
    cls->defineFunction("_initialize", _SE(js_cc_Root__initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_Root_destroy)); 
    cls->defineFunction("resize", _SE(js_cc_Root_resize)); 
    cls->defineFunction("setRenderPipeline", _SE(js_cc_Root_setRenderPipeline)); 
    cls->defineFunction("onGlobalPipelineStateChanged", _SE(js_cc_Root_onGlobalPipelineStateChanged)); 
    cls->defineFunction("activeWindow", _SE(js_cc_Root_activeWindow)); 
    cls->defineFunction("resetCumulativeTime", _SE(js_cc_Root_resetCumulativeTime)); 
    cls->defineFunction("frameMove", _SE(js_cc_Root_frameMove)); 
    cls->defineFunction("createWindow", _SE(js_cc_Root_createWindow)); 
    cls->defineFunction("destroyWindow", _SE(js_cc_Root_destroyWindow)); 
    cls->defineFunction("destroyWindows", _SE(js_cc_Root_destroyWindows)); 
    cls->defineFunction("createScene", _SE(js_cc_Root_createScene)); 
    cls->defineFunction("destroyScene", _SE(js_cc_Root_destroyScene)); 
    cls->defineFunction("destroyScenes", _SE(js_cc_Root_destroyScenes)); 
    cls->defineFunction("destroyModel", _SE(js_cc_Root_destroyModel)); 
    cls->defineFunction("destroyLight", _SE(js_cc_Root_destroyLight)); 
    cls->defineFunction("createCamera", _SE(js_cc_Root_createCamera)); 
    cls->defineFunction("getBatcher2D", _SE(js_cc_Root_getBatcher2D)); 
    cls->defineFunction("setDebugViewConfig", _SE(js_cc_Root_setDebugViewConfig)); 
    cls->defineFunction("getDebugViewConfig", _SE(js_cc_Root_getDebugViewConfig)); 
    cls->defineFunction("getEventProcessor", _SE(js_cc_Root_getEventProcessor)); 
    
    
    cls->defineStaticFunction("getInstance", _SE(js_cc_Root_getInstance_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Root));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Root>(cls);
    
    __jsb_cc_Root_proto = cls->getProto();
    __jsb_cc_Root_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_IMacroPatch_class = nullptr;
se::Object* __jsb_cc_scene_IMacroPatch_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_IMacroPatch) 

static bool js_cc_scene_IMacroPatch_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::IMacroPatch *arg1 = (cc::scene::IMacroPatch *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IMacroPatch>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "IMacroPatch_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IMacroPatch_name_set) 

static bool js_cc_scene_IMacroPatch_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::IMacroPatch *arg1 = (cc::scene::IMacroPatch *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IMacroPatch>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IMacroPatch_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IMacroPatch_name_get) 

static bool js_cc_scene_IMacroPatch_value_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::IMacroPatch *arg1 = (cc::scene::IMacroPatch *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IMacroPatch>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->value, s.thisObject());
    SE_PRECONDITION2(ok, false, "IMacroPatch_value_set,2,SWIGTYPE_ccstd__variantT_int32_t_bool_ccstd__string_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IMacroPatch_value_set) 

static bool js_cc_scene_IMacroPatch_value_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::IMacroPatch *arg1 = (cc::scene::IMacroPatch *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IMacroPatch>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->value, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IMacroPatch_value_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->value, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IMacroPatch_value_get) 

// js_ctor
static bool js_new_cc_scene_IMacroPatch(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::IMacroPatch *result;
    result = (cc::scene::IMacroPatch *)new cc::scene::IMacroPatch();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_IMacroPatch, __jsb_cc_scene_IMacroPatch_class, js_delete_cc_scene_IMacroPatch)

static bool js_delete_cc_scene_IMacroPatch(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_IMacroPatch) 

template<>
bool sevalue_to_native(const se::Value &from, cc::scene::IMacroPatch * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::scene::IMacroPatch*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("value", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->value), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_scene_IMacroPatch(se::Object* obj) {
    auto* cls = se::Class::create("IMacroPatch", obj, nullptr, _SE(js_new_cc_scene_IMacroPatch)); 
    
    cls->defineProperty("name", _SE(js_cc_scene_IMacroPatch_name_get), _SE(js_cc_scene_IMacroPatch_name_set)); 
    cls->defineProperty("value", _SE(js_cc_scene_IMacroPatch_value_get), _SE(js_cc_scene_IMacroPatch_value_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_IMacroPatch));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::IMacroPatch>(cls);
    
    __jsb_cc_scene_IMacroPatch_proto = cls->getProto();
    __jsb_cc_scene_IMacroPatch_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_Light_class = nullptr;
se::Object* __jsb_cc_scene_Light_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_Light) 

// js_ctor
static bool js_new_cc_scene_Light(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::Light *result;
    result = (cc::scene::Light *)new cc::scene::Light();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_Light, __jsb_cc_scene_Light_class, js_delete_cc_scene_Light)

static bool js_delete_cc_scene_Light(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_Light) 

static bool js_cc_scene_Light_attachToScene(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    cc::scene::RenderScene *arg2 = (cc::scene::RenderScene *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Light_attachToScene,2,SWIGTYPE_p_cc__scene__RenderScene"); 
    (arg1)->attachToScene(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Light_attachToScene) 

static bool js_cc_scene_Light_detachFromScene(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->detachFromScene();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Light_detachFromScene) 

static bool js_cc_scene_Light_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Light_destroy) 

static bool js_cc_scene_Light_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->initialize();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Light_initialize) 

static bool js_cc_scene_Light_update(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->update();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Light_update) 

static bool js_cc_scene_Light_getColorTemperatureRGB(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    cc::Vec3 *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Vec3 *) &((cc::scene::Light const *)arg1)->getColorTemperatureRGB();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Light_getColorTemperatureRGB, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Light_getColorTemperatureRGB) 

static bool js_cc_scene_Light_setColorTemperatureRGB(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Light_setColorTemperatureRGB,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    (arg1)->setColorTemperatureRGB((cc::Vec3 const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Light_setColorTemperatureRGB) 

static bool js_cc_scene_Light_nt2lm_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float arg1 ;
    float result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "Light_nt2lm,1,SWIGTYPE_float"); 
    result = (float)cc::scene::Light::nt2lm(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Light_nt2lm_static) 

static bool js_cc_scene_Light_colorTemperatureToRGB_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float arg1 ;
    cc::Vec3 result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "Light_colorTemperatureToRGB,1,SWIGTYPE_float"); 
    result = cc::scene::Light::colorTemperatureToRGB(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Light_colorTemperatureToRGB, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Light_colorTemperatureToRGB_static) 

static bool js_cc_scene_Light_baked_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Light_baked_set,2,SWIGTYPE_bool"); 
    cc_scene_Light_baked_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Light_baked_set) 

static bool js_cc_scene_Light_baked_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_Light_baked_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Light_baked_get) 

static bool js_cc_scene_Light_color_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Light_color_set,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    cc_scene_Light_color_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Light_color_set) 

static bool js_cc_scene_Light_color_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Vec3 *) &cc_scene_Light_color_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Light_color_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Light_color_get) 

static bool js_cc_scene_Light_useColorTemperature_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Light_useColorTemperature_set,2,SWIGTYPE_bool"); 
    cc_scene_Light_useColorTemperature_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Light_useColorTemperature_set) 

static bool js_cc_scene_Light_useColorTemperature_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_Light_useColorTemperature_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Light_useColorTemperature_get) 

static bool js_cc_scene_Light_colorTemperature_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Light_colorTemperature_set,2,SWIGTYPE_float"); 
    cc_scene_Light_colorTemperature_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Light_colorTemperature_set) 

static bool js_cc_scene_Light_colorTemperature_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_Light_colorTemperature_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Light_colorTemperature_get) 

static bool js_cc_scene_Light_node_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Light_node_set,2,SWIGTYPE_p_cc__Node"); 
    cc_scene_Light_node_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Light_node_set) 

static bool js_cc_scene_Light_node_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    cc::Node *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Node *)cc_scene_Light_node_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Light_node_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Light_node_get) 

static bool js_cc_scene_Light_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    cc::scene::LightType arg2 ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "Light_type_set,2,SWIGTYPE_cc__scene__LightType");
    arg2 = (cc::scene::LightType)temp2;
    cc_scene_Light_type_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Light_type_set) 

static bool js_cc_scene_Light_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    cc::scene::LightType result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::LightType)cc_scene_Light_type_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Light_type_get) 

static bool js_cc_scene_Light_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Light_name_set,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    cc_scene_Light_name_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Light_name_set) 

static bool js_cc_scene_Light_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    ccstd::string *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::string *) &cc_scene_Light_name_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Light_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Light_name_get) 

static bool js_cc_scene_Light_scene_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Light *arg1 = (cc::scene::Light *) NULL ;
    cc::scene::RenderScene *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Light>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::RenderScene *)cc_scene_Light_scene_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Light_scene_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Light_scene_get) 

bool js_register_cc_scene_Light(se::Object* obj) {
    auto* cls = se::Class::create("Light", obj, nullptr, _SE(js_new_cc_scene_Light)); 
    
    cls->defineProperty("baked", _SE(js_cc_scene_Light_baked_get), _SE(js_cc_scene_Light_baked_set)); 
    cls->defineProperty("color", _SE(js_cc_scene_Light_color_get), _SE(js_cc_scene_Light_color_set)); 
    cls->defineProperty("useColorTemperature", _SE(js_cc_scene_Light_useColorTemperature_get), _SE(js_cc_scene_Light_useColorTemperature_set)); 
    cls->defineProperty("colorTemperature", _SE(js_cc_scene_Light_colorTemperature_get), _SE(js_cc_scene_Light_colorTemperature_set)); 
    cls->defineProperty("node", _SE(js_cc_scene_Light_node_get), _SE(js_cc_scene_Light_node_set)); 
    cls->defineProperty("type", _SE(js_cc_scene_Light_type_get), _SE(js_cc_scene_Light_type_set)); 
    cls->defineProperty("name", _SE(js_cc_scene_Light_name_get), _SE(js_cc_scene_Light_name_set)); 
    cls->defineProperty("scene", _SE(js_cc_scene_Light_scene_get), nullptr); 
    
    cls->defineFunction("attachToScene", _SE(js_cc_scene_Light_attachToScene)); 
    cls->defineFunction("detachFromScene", _SE(js_cc_scene_Light_detachFromScene)); 
    cls->defineFunction("destroy", _SE(js_cc_scene_Light_destroy)); 
    cls->defineFunction("initialize", _SE(js_cc_scene_Light_initialize)); 
    cls->defineFunction("update", _SE(js_cc_scene_Light_update)); 
    cls->defineFunction("getColorTemperatureRGB", _SE(js_cc_scene_Light_getColorTemperatureRGB)); 
    cls->defineFunction("setColorTemperatureRGB", _SE(js_cc_scene_Light_setColorTemperatureRGB)); 
    
    
    cls->defineStaticFunction("nt2lm", _SE(js_cc_scene_Light_nt2lm_static)); 
    cls->defineStaticFunction("colorTemperatureToRGB", _SE(js_cc_scene_Light_colorTemperatureToRGB_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_Light));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::Light>(cls);
    
    __jsb_cc_scene_Light_proto = cls->getProto();
    __jsb_cc_scene_Light_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_Fog_class = nullptr;
se::Object* __jsb_cc_scene_Fog_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_Fog) 

// js_ctor
static bool js_new_cc_scene_Fog(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::Fog *result;
    result = (cc::scene::Fog *)new cc::scene::Fog();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_Fog, __jsb_cc_scene_Fog_class, js_delete_cc_scene_Fog)

static bool js_delete_cc_scene_Fog(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_Fog) 

static bool js_cc_scene_Fog_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    cc::scene::FogInfo *arg2 = 0 ;
    cc::scene::FogInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Fog_initialize,2,SWIGTYPE_p_cc__scene__FogInfo");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::scene::FogInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Fog_initialize) 

static bool js_cc_scene_Fog_activate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->activate();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Fog_activate) 

static bool js_cc_scene_Fog_enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Fog_enabled_set,2,SWIGTYPE_bool"); 
    cc_scene_Fog_enabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Fog_enabled_set) 

static bool js_cc_scene_Fog_enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_Fog_enabled_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Fog_enabled_get) 

static bool js_cc_scene_Fog_accurate_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Fog_accurate_set,2,SWIGTYPE_bool"); 
    cc_scene_Fog_accurate_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Fog_accurate_set) 

static bool js_cc_scene_Fog_accurate_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_Fog_accurate_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Fog_accurate_get) 

static bool js_cc_scene_Fog_fogColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    cc::Color *arg2 = 0 ;
    cc::Color temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Fog_fogColor_set,2,SWIGTYPE_p_cc__Color");
    arg2 = &temp2;
    
    cc_scene_Fog_fogColor_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Fog_fogColor_set) 

static bool js_cc_scene_Fog_fogColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    cc::Color *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Color *) &cc_scene_Fog_fogColor_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Fog_fogColor_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Fog_fogColor_get) 

static bool js_cc_scene_Fog_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    cc::scene::FogType arg2 ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "Fog_type_set,2,SWIGTYPE_cc__scene__FogType");
    arg2 = (cc::scene::FogType)temp2;
    cc_scene_Fog_type_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Fog_type_set) 

static bool js_cc_scene_Fog_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    cc::scene::FogType result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::FogType)cc_scene_Fog_type_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Fog_type_get) 

static bool js_cc_scene_Fog_fogDensity_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Fog_fogDensity_set,2,SWIGTYPE_float"); 
    cc_scene_Fog_fogDensity_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Fog_fogDensity_set) 

static bool js_cc_scene_Fog_fogDensity_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_Fog_fogDensity_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Fog_fogDensity_get) 

static bool js_cc_scene_Fog_fogStart_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Fog_fogStart_set,2,SWIGTYPE_float"); 
    cc_scene_Fog_fogStart_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Fog_fogStart_set) 

static bool js_cc_scene_Fog_fogStart_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_Fog_fogStart_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Fog_fogStart_get) 

static bool js_cc_scene_Fog_fogEnd_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Fog_fogEnd_set,2,SWIGTYPE_float"); 
    cc_scene_Fog_fogEnd_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Fog_fogEnd_set) 

static bool js_cc_scene_Fog_fogEnd_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_Fog_fogEnd_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Fog_fogEnd_get) 

static bool js_cc_scene_Fog_fogAtten_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Fog_fogAtten_set,2,SWIGTYPE_float"); 
    cc_scene_Fog_fogAtten_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Fog_fogAtten_set) 

static bool js_cc_scene_Fog_fogAtten_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_Fog_fogAtten_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Fog_fogAtten_get) 

static bool js_cc_scene_Fog_fogTop_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Fog_fogTop_set,2,SWIGTYPE_float"); 
    cc_scene_Fog_fogTop_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Fog_fogTop_set) 

static bool js_cc_scene_Fog_fogTop_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_Fog_fogTop_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Fog_fogTop_get) 

static bool js_cc_scene_Fog_fogRange_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Fog_fogRange_set,2,SWIGTYPE_float"); 
    cc_scene_Fog_fogRange_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Fog_fogRange_set) 

static bool js_cc_scene_Fog_fogRange_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_Fog_fogRange_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Fog_fogRange_get) 

static bool js_cc_scene_Fog_colorArray_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Fog *arg1 = (cc::scene::Fog *) NULL ;
    cc::Vec4 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Fog>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Vec4 *) &cc_scene_Fog_colorArray_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Fog_colorArray_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Fog_colorArray_get) 

bool js_register_cc_scene_Fog(se::Object* obj) {
    auto* cls = se::Class::create("Fog", obj, nullptr, _SE(js_new_cc_scene_Fog)); 
    
    cls->defineProperty("enabled", _SE(js_cc_scene_Fog_enabled_get), _SE(js_cc_scene_Fog_enabled_set)); 
    cls->defineProperty("accurate", _SE(js_cc_scene_Fog_accurate_get), _SE(js_cc_scene_Fog_accurate_set)); 
    cls->defineProperty("fogColor", _SE(js_cc_scene_Fog_fogColor_get), _SE(js_cc_scene_Fog_fogColor_set)); 
    cls->defineProperty("type", _SE(js_cc_scene_Fog_type_get), _SE(js_cc_scene_Fog_type_set)); 
    cls->defineProperty("fogDensity", _SE(js_cc_scene_Fog_fogDensity_get), _SE(js_cc_scene_Fog_fogDensity_set)); 
    cls->defineProperty("fogStart", _SE(js_cc_scene_Fog_fogStart_get), _SE(js_cc_scene_Fog_fogStart_set)); 
    cls->defineProperty("fogEnd", _SE(js_cc_scene_Fog_fogEnd_get), _SE(js_cc_scene_Fog_fogEnd_set)); 
    cls->defineProperty("fogAtten", _SE(js_cc_scene_Fog_fogAtten_get), _SE(js_cc_scene_Fog_fogAtten_set)); 
    cls->defineProperty("fogTop", _SE(js_cc_scene_Fog_fogTop_get), _SE(js_cc_scene_Fog_fogTop_set)); 
    cls->defineProperty("fogRange", _SE(js_cc_scene_Fog_fogRange_get), _SE(js_cc_scene_Fog_fogRange_set)); 
    cls->defineProperty("colorArray", _SE(js_cc_scene_Fog_colorArray_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_scene_Fog_initialize)); 
    cls->defineFunction("activate", _SE(js_cc_scene_Fog_activate)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_Fog));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::Fog>(cls);
    
    __jsb_cc_scene_Fog_proto = cls->getProto();
    __jsb_cc_scene_Fog_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_FogInfo_class = nullptr;
se::Object* __jsb_cc_scene_FogInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_FogInfo) 

// js_ctor
static bool js_new_cc_scene_FogInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::FogInfo *result;
    result = (cc::scene::FogInfo *)new cc::scene::FogInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_FogInfo, __jsb_cc_scene_FogInfo_class, js_delete_cc_scene_FogInfo)

static bool js_delete_cc_scene_FogInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_FogInfo) 

static bool js_cc_scene_FogInfo_activate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    cc::scene::Fog *arg2 = (cc::scene::Fog *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FogInfo_activate,2,SWIGTYPE_p_cc__scene__Fog"); 
    (arg1)->activate(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_FogInfo_activate) 

static bool js_cc_scene_FogInfo__type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "FogInfo__type_set,2,SWIGTYPE_cc__scene__FogType");
    arg1->_type = (cc::scene::FogType)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo__type_set) 

static bool js_cc_scene_FogInfo__type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->_type));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo__type_get) 

static bool js_cc_scene_FogInfo__fogColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_fogColor, s.thisObject());
    SE_PRECONDITION2(ok, false, "FogInfo__fogColor_set,2,SWIGTYPE_cc__Color"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo__fogColor_set) 

static bool js_cc_scene_FogInfo__fogColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_fogColor, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FogInfo__fogColor_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_fogColor, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo__fogColor_get) 

static bool js_cc_scene_FogInfo__enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->_isEnabled);
    SE_PRECONDITION2(ok, false, "FogInfo__enabled_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo__enabled_set) 

static bool js_cc_scene_FogInfo__enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->_isEnabled, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo__enabled_get) 

static bool js_cc_scene_FogInfo__fogDensity_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->_fogDensity, nullptr);
    SE_PRECONDITION2(ok, false, "FogInfo__fogDensity_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo__fogDensity_set) 

static bool js_cc_scene_FogInfo__fogDensity_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->_fogDensity, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo__fogDensity_get) 

static bool js_cc_scene_FogInfo__fogStart_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->_fogStart, nullptr);
    SE_PRECONDITION2(ok, false, "FogInfo__fogStart_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo__fogStart_set) 

static bool js_cc_scene_FogInfo__fogStart_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->_fogStart, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo__fogStart_get) 

static bool js_cc_scene_FogInfo__fogEnd_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->_fogEnd, nullptr);
    SE_PRECONDITION2(ok, false, "FogInfo__fogEnd_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo__fogEnd_set) 

static bool js_cc_scene_FogInfo__fogEnd_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->_fogEnd, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo__fogEnd_get) 

static bool js_cc_scene_FogInfo__fogAtten_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->_fogAtten, nullptr);
    SE_PRECONDITION2(ok, false, "FogInfo__fogAtten_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo__fogAtten_set) 

static bool js_cc_scene_FogInfo__fogAtten_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->_fogAtten, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo__fogAtten_get) 

static bool js_cc_scene_FogInfo__fogTop_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->_fogTop, nullptr);
    SE_PRECONDITION2(ok, false, "FogInfo__fogTop_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo__fogTop_set) 

static bool js_cc_scene_FogInfo__fogTop_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->_fogTop, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo__fogTop_get) 

static bool js_cc_scene_FogInfo__fogRange_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->_fogRange, nullptr);
    SE_PRECONDITION2(ok, false, "FogInfo__fogRange_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo__fogRange_set) 

static bool js_cc_scene_FogInfo__fogRange_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->_fogRange, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo__fogRange_get) 

static bool js_cc_scene_FogInfo__accurate_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->_accurate);
    SE_PRECONDITION2(ok, false, "FogInfo__accurate_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo__accurate_set) 

static bool js_cc_scene_FogInfo__accurate_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->_accurate, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo__accurate_get) 

static bool js_cc_scene_FogInfo__resource_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->_resource, s.thisObject());
    SE_PRECONDITION2(ok, false, "FogInfo__resource_set,2,SWIGTYPE_p_cc__scene__Fog"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo__resource_set) 

static bool js_cc_scene_FogInfo__resource_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->_resource, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FogInfo__resource_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_resource, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo__resource_get) 

static bool js_cc_scene_FogInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    cc::scene::FogType arg2 ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "FogInfo_type_set,2,SWIGTYPE_cc__scene__FogType");
    arg2 = (cc::scene::FogType)temp2;
    cc_scene_FogInfo_type_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo_type_set) 

static bool js_cc_scene_FogInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    cc::scene::FogType result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::FogType)cc_scene_FogInfo_type_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo_type_get) 

static bool js_cc_scene_FogInfo_fogColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    cc::Color *arg2 = 0 ;
    cc::Color temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FogInfo_fogColor_set,2,SWIGTYPE_p_cc__Color");
    arg2 = &temp2;
    
    cc_scene_FogInfo_fogColor_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo_fogColor_set) 

static bool js_cc_scene_FogInfo_fogColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    cc::Color *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Color *) &cc_scene_FogInfo_fogColor_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FogInfo_fogColor_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo_fogColor_get) 

static bool js_cc_scene_FogInfo_enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "FogInfo_enabled_set,2,SWIGTYPE_bool"); 
    cc_scene_FogInfo_enabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo_enabled_set) 

static bool js_cc_scene_FogInfo_enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_FogInfo_enabled_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo_enabled_get) 

static bool js_cc_scene_FogInfo_accurate_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "FogInfo_accurate_set,2,SWIGTYPE_bool"); 
    cc_scene_FogInfo_accurate_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo_accurate_set) 

static bool js_cc_scene_FogInfo_accurate_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_FogInfo_accurate_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo_accurate_get) 

static bool js_cc_scene_FogInfo_fogDensity_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "FogInfo_fogDensity_set,2,SWIGTYPE_float"); 
    cc_scene_FogInfo_fogDensity_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo_fogDensity_set) 

static bool js_cc_scene_FogInfo_fogDensity_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_FogInfo_fogDensity_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo_fogDensity_get) 

static bool js_cc_scene_FogInfo_fogStart_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "FogInfo_fogStart_set,2,SWIGTYPE_float"); 
    cc_scene_FogInfo_fogStart_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo_fogStart_set) 

static bool js_cc_scene_FogInfo_fogStart_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_FogInfo_fogStart_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo_fogStart_get) 

static bool js_cc_scene_FogInfo_fogEnd_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "FogInfo_fogEnd_set,2,SWIGTYPE_float"); 
    cc_scene_FogInfo_fogEnd_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo_fogEnd_set) 

static bool js_cc_scene_FogInfo_fogEnd_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_FogInfo_fogEnd_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo_fogEnd_get) 

static bool js_cc_scene_FogInfo_fogAtten_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "FogInfo_fogAtten_set,2,SWIGTYPE_float"); 
    cc_scene_FogInfo_fogAtten_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo_fogAtten_set) 

static bool js_cc_scene_FogInfo_fogAtten_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_FogInfo_fogAtten_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo_fogAtten_get) 

static bool js_cc_scene_FogInfo_fogTop_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "FogInfo_fogTop_set,2,SWIGTYPE_float"); 
    cc_scene_FogInfo_fogTop_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo_fogTop_set) 

static bool js_cc_scene_FogInfo_fogTop_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_FogInfo_fogTop_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo_fogTop_get) 

static bool js_cc_scene_FogInfo_fogRange_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "FogInfo_fogRange_set,2,SWIGTYPE_float"); 
    cc_scene_FogInfo_fogRange_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_FogInfo_fogRange_set) 

static bool js_cc_scene_FogInfo_fogRange_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::FogInfo *arg1 = (cc::scene::FogInfo *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::FogInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_FogInfo_fogRange_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_FogInfo_fogRange_get) 

bool js_register_cc_scene_FogInfo(se::Object* obj) {
    auto* cls = se::Class::create("FogInfo", obj, nullptr, _SE(js_new_cc_scene_FogInfo)); 
    
    cls->defineProperty("_type", _SE(js_cc_scene_FogInfo__type_get), _SE(js_cc_scene_FogInfo__type_set)); 
    cls->defineProperty("_fogColor", _SE(js_cc_scene_FogInfo__fogColor_get), _SE(js_cc_scene_FogInfo__fogColor_set)); 
    cls->defineProperty("_enabled", _SE(js_cc_scene_FogInfo__enabled_get), _SE(js_cc_scene_FogInfo__enabled_set)); 
    cls->defineProperty("_fogDensity", _SE(js_cc_scene_FogInfo__fogDensity_get), _SE(js_cc_scene_FogInfo__fogDensity_set)); 
    cls->defineProperty("_fogStart", _SE(js_cc_scene_FogInfo__fogStart_get), _SE(js_cc_scene_FogInfo__fogStart_set)); 
    cls->defineProperty("_fogEnd", _SE(js_cc_scene_FogInfo__fogEnd_get), _SE(js_cc_scene_FogInfo__fogEnd_set)); 
    cls->defineProperty("_fogAtten", _SE(js_cc_scene_FogInfo__fogAtten_get), _SE(js_cc_scene_FogInfo__fogAtten_set)); 
    cls->defineProperty("_fogTop", _SE(js_cc_scene_FogInfo__fogTop_get), _SE(js_cc_scene_FogInfo__fogTop_set)); 
    cls->defineProperty("_fogRange", _SE(js_cc_scene_FogInfo__fogRange_get), _SE(js_cc_scene_FogInfo__fogRange_set)); 
    cls->defineProperty("_accurate", _SE(js_cc_scene_FogInfo__accurate_get), _SE(js_cc_scene_FogInfo__accurate_set)); 
    cls->defineProperty("_resource", _SE(js_cc_scene_FogInfo__resource_get), _SE(js_cc_scene_FogInfo__resource_set)); 
    cls->defineProperty("type", _SE(js_cc_scene_FogInfo_type_get), _SE(js_cc_scene_FogInfo_type_set)); 
    cls->defineProperty("fogColor", _SE(js_cc_scene_FogInfo_fogColor_get), _SE(js_cc_scene_FogInfo_fogColor_set)); 
    cls->defineProperty("enabled", _SE(js_cc_scene_FogInfo_enabled_get), _SE(js_cc_scene_FogInfo_enabled_set)); 
    cls->defineProperty("accurate", _SE(js_cc_scene_FogInfo_accurate_get), _SE(js_cc_scene_FogInfo_accurate_set)); 
    cls->defineProperty("fogDensity", _SE(js_cc_scene_FogInfo_fogDensity_get), _SE(js_cc_scene_FogInfo_fogDensity_set)); 
    cls->defineProperty("fogStart", _SE(js_cc_scene_FogInfo_fogStart_get), _SE(js_cc_scene_FogInfo_fogStart_set)); 
    cls->defineProperty("fogEnd", _SE(js_cc_scene_FogInfo_fogEnd_get), _SE(js_cc_scene_FogInfo_fogEnd_set)); 
    cls->defineProperty("fogAtten", _SE(js_cc_scene_FogInfo_fogAtten_get), _SE(js_cc_scene_FogInfo_fogAtten_set)); 
    cls->defineProperty("fogTop", _SE(js_cc_scene_FogInfo_fogTop_get), _SE(js_cc_scene_FogInfo_fogTop_set)); 
    cls->defineProperty("fogRange", _SE(js_cc_scene_FogInfo_fogRange_get), _SE(js_cc_scene_FogInfo_fogRange_set)); 
    
    cls->defineFunction("activate", _SE(js_cc_scene_FogInfo_activate)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_FogInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::FogInfo>(cls);
    
    __jsb_cc_scene_FogInfo_proto = cls->getProto();
    __jsb_cc_scene_FogInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_ShadowsInfo_class = nullptr;
se::Object* __jsb_cc_scene_ShadowsInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_ShadowsInfo) 

// js_ctor
static bool js_new_cc_scene_ShadowsInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::ShadowsInfo *result;
    result = (cc::scene::ShadowsInfo *)new cc::scene::ShadowsInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_ShadowsInfo, __jsb_cc_scene_ShadowsInfo_class, js_delete_cc_scene_ShadowsInfo)

static bool js_delete_cc_scene_ShadowsInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_ShadowsInfo) 

static bool js_cc_scene_ShadowsInfo_setPlaneFromNode(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowsInfo_setPlaneFromNode,2,SWIGTYPE_p_cc__Node"); 
    (arg1)->setPlaneFromNode((cc::Node const *)arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ShadowsInfo_setPlaneFromNode) 

static bool js_cc_scene_ShadowsInfo_activate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    cc::scene::Shadows *arg2 = (cc::scene::Shadows *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowsInfo_activate,2,SWIGTYPE_p_cc__scene__Shadows"); 
    (arg1)->activate(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_ShadowsInfo_activate) 

static bool js_cc_scene_ShadowsInfo__enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->_enabled);
    SE_PRECONDITION2(ok, false, "ShadowsInfo__enabled_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo__enabled_set) 

static bool js_cc_scene_ShadowsInfo__enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->_enabled, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo__enabled_get) 

static bool js_cc_scene_ShadowsInfo__type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "ShadowsInfo__type_set,2,SWIGTYPE_cc__scene__ShadowType");
    arg1->_type = (cc::scene::ShadowType)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo__type_set) 

static bool js_cc_scene_ShadowsInfo__type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->_type));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo__type_get) 

static bool js_cc_scene_ShadowsInfo__normal_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_normal, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowsInfo__normal_set,2,SWIGTYPE_cc__Vec3"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo__normal_set) 

static bool js_cc_scene_ShadowsInfo__normal_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_normal, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShadowsInfo__normal_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_normal, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo__normal_get) 

static bool js_cc_scene_ShadowsInfo__distance_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->_distance, nullptr);
    SE_PRECONDITION2(ok, false, "ShadowsInfo__distance_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo__distance_set) 

static bool js_cc_scene_ShadowsInfo__distance_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->_distance, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo__distance_get) 

static bool js_cc_scene_ShadowsInfo__shadowColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_shadowColor, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowsInfo__shadowColor_set,2,SWIGTYPE_cc__Color"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo__shadowColor_set) 

static bool js_cc_scene_ShadowsInfo__shadowColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_shadowColor, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShadowsInfo__shadowColor_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_shadowColor, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo__shadowColor_get) 

static bool js_cc_scene_ShadowsInfo__maxReceived_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_maxReceived, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowsInfo__maxReceived_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo__maxReceived_set) 

static bool js_cc_scene_ShadowsInfo__maxReceived_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_maxReceived, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShadowsInfo__maxReceived_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_maxReceived, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo__maxReceived_get) 

static bool js_cc_scene_ShadowsInfo__size_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_size, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowsInfo__size_set,2,SWIGTYPE_cc__Vec2"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo__size_set) 

static bool js_cc_scene_ShadowsInfo__size_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_size, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShadowsInfo__size_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_size, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo__size_get) 

static bool js_cc_scene_ShadowsInfo__resource_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->_resource, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowsInfo__resource_set,2,SWIGTYPE_p_cc__scene__Shadows"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo__resource_set) 

static bool js_cc_scene_ShadowsInfo__resource_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->_resource, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShadowsInfo__resource_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_resource, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo__resource_get) 

static bool js_cc_scene_ShadowsInfo_enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "ShadowsInfo_enabled_set,2,SWIGTYPE_bool"); 
    cc_scene_ShadowsInfo_enabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo_enabled_set) 

static bool js_cc_scene_ShadowsInfo_enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_ShadowsInfo_enabled_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo_enabled_get) 

static bool js_cc_scene_ShadowsInfo_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    cc::scene::ShadowType arg2 ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "ShadowsInfo_type_set,2,SWIGTYPE_cc__scene__ShadowType");
    arg2 = (cc::scene::ShadowType)temp2;
    cc_scene_ShadowsInfo_type_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo_type_set) 

static bool js_cc_scene_ShadowsInfo_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    cc::scene::ShadowType result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::ShadowType)cc_scene_ShadowsInfo_type_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo_type_get) 

static bool js_cc_scene_ShadowsInfo_shadowColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    cc::Color *arg2 = 0 ;
    cc::Color temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowsInfo_shadowColor_set,2,SWIGTYPE_p_cc__Color");
    arg2 = &temp2;
    
    cc_scene_ShadowsInfo_shadowColor_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo_shadowColor_set) 

static bool js_cc_scene_ShadowsInfo_shadowColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    cc::Color *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Color *) &cc_scene_ShadowsInfo_shadowColor_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShadowsInfo_shadowColor_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo_shadowColor_get) 

static bool js_cc_scene_ShadowsInfo_planeDirection_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowsInfo_planeDirection_set,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    cc_scene_ShadowsInfo_planeDirection_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo_planeDirection_set) 

static bool js_cc_scene_ShadowsInfo_planeDirection_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Vec3 *) &cc_scene_ShadowsInfo_planeDirection_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShadowsInfo_planeDirection_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo_planeDirection_get) 

static bool js_cc_scene_ShadowsInfo_planeHeight_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ShadowsInfo_planeHeight_set,2,SWIGTYPE_float"); 
    cc_scene_ShadowsInfo_planeHeight_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo_planeHeight_set) 

static bool js_cc_scene_ShadowsInfo_planeHeight_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_ShadowsInfo_planeHeight_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo_planeHeight_get) 

static bool js_cc_scene_ShadowsInfo_maxReceived_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ShadowsInfo_maxReceived_set,2,SWIGTYPE_uint32_t"); 
    
    cc_scene_ShadowsInfo_maxReceived_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo_maxReceived_set) 

static bool js_cc_scene_ShadowsInfo_maxReceived_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_scene_ShadowsInfo_maxReceived_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ShadowsInfo_maxReceived_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo_maxReceived_get) 

static bool js_cc_scene_ShadowsInfo_shadowMapSize_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ShadowsInfo_shadowMapSize_set,2,SWIGTYPE_float"); 
    cc_scene_ShadowsInfo_shadowMapSize_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ShadowsInfo_shadowMapSize_set) 

static bool js_cc_scene_ShadowsInfo_shadowMapSize_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ShadowsInfo *arg1 = (cc::scene::ShadowsInfo *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ShadowsInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_ShadowsInfo_shadowMapSize_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ShadowsInfo_shadowMapSize_get) 

bool js_register_cc_scene_ShadowsInfo(se::Object* obj) {
    auto* cls = se::Class::create("ShadowsInfo", obj, nullptr, _SE(js_new_cc_scene_ShadowsInfo)); 
    
    cls->defineProperty("_enabled", _SE(js_cc_scene_ShadowsInfo__enabled_get), _SE(js_cc_scene_ShadowsInfo__enabled_set)); 
    cls->defineProperty("_type", _SE(js_cc_scene_ShadowsInfo__type_get), _SE(js_cc_scene_ShadowsInfo__type_set)); 
    cls->defineProperty("_normal", _SE(js_cc_scene_ShadowsInfo__normal_get), _SE(js_cc_scene_ShadowsInfo__normal_set)); 
    cls->defineProperty("_distance", _SE(js_cc_scene_ShadowsInfo__distance_get), _SE(js_cc_scene_ShadowsInfo__distance_set)); 
    cls->defineProperty("_shadowColor", _SE(js_cc_scene_ShadowsInfo__shadowColor_get), _SE(js_cc_scene_ShadowsInfo__shadowColor_set)); 
    cls->defineProperty("_maxReceived", _SE(js_cc_scene_ShadowsInfo__maxReceived_get), _SE(js_cc_scene_ShadowsInfo__maxReceived_set)); 
    cls->defineProperty("_size", _SE(js_cc_scene_ShadowsInfo__size_get), _SE(js_cc_scene_ShadowsInfo__size_set)); 
    cls->defineProperty("_resource", _SE(js_cc_scene_ShadowsInfo__resource_get), _SE(js_cc_scene_ShadowsInfo__resource_set)); 
    cls->defineProperty("enabled", _SE(js_cc_scene_ShadowsInfo_enabled_get), _SE(js_cc_scene_ShadowsInfo_enabled_set)); 
    cls->defineProperty("type", _SE(js_cc_scene_ShadowsInfo_type_get), _SE(js_cc_scene_ShadowsInfo_type_set)); 
    cls->defineProperty("shadowColor", _SE(js_cc_scene_ShadowsInfo_shadowColor_get), _SE(js_cc_scene_ShadowsInfo_shadowColor_set)); 
    cls->defineProperty("planeDirection", _SE(js_cc_scene_ShadowsInfo_planeDirection_get), _SE(js_cc_scene_ShadowsInfo_planeDirection_set)); 
    cls->defineProperty("planeHeight", _SE(js_cc_scene_ShadowsInfo_planeHeight_get), _SE(js_cc_scene_ShadowsInfo_planeHeight_set)); 
    cls->defineProperty("maxReceived", _SE(js_cc_scene_ShadowsInfo_maxReceived_get), _SE(js_cc_scene_ShadowsInfo_maxReceived_set)); 
    cls->defineProperty("shadowMapSize", _SE(js_cc_scene_ShadowsInfo_shadowMapSize_get), _SE(js_cc_scene_ShadowsInfo_shadowMapSize_set)); 
    
    cls->defineFunction("setPlaneFromNode", _SE(js_cc_scene_ShadowsInfo_setPlaneFromNode)); 
    cls->defineFunction("activate", _SE(js_cc_scene_ShadowsInfo_activate)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_ShadowsInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::ShadowsInfo>(cls);
    
    __jsb_cc_scene_ShadowsInfo_proto = cls->getProto();
    __jsb_cc_scene_ShadowsInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_Shadows_class = nullptr;
se::Object* __jsb_cc_scene_Shadows_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_Shadows) 

static bool js_cc_scene_Shadows_MAX_FAR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    float result;
    
    result = (float)(float)cc::scene::Shadows::MAX_FAR;
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Shadows_MAX_FAR_get) 

static bool js_cc_scene_Shadows_COEFFICIENT_OF_EXPANSION_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    float result;
    
    result = (float)(float)cc::scene::Shadows::COEFFICIENT_OF_EXPANSION;
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Shadows_COEFFICIENT_OF_EXPANSION_get) 

// js_ctor
static bool js_new_cc_scene_Shadows(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::Shadows *result;
    result = (cc::scene::Shadows *)new cc::scene::Shadows();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_Shadows, __jsb_cc_scene_Shadows_class, js_delete_cc_scene_Shadows)

static bool js_delete_cc_scene_Shadows(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_Shadows) 

static bool js_cc_scene_Shadows_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    cc::scene::ShadowsInfo *arg2 = 0 ;
    cc::scene::ShadowsInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Shadows_initialize,2,SWIGTYPE_p_cc__scene__ShadowsInfo");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::scene::ShadowsInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Shadows_initialize) 

static bool js_cc_scene_Shadows_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Shadows_destroy) 

static bool js_cc_scene_Shadows_getPlanarShader(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    ccstd::vector< cc::scene::IMacroPatch > *arg2 = 0 ;
    ccstd::vector< cc::scene::IMacroPatch > temp2 ;
    cc::gfx::Shader *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Shadows_getPlanarShader,2,SWIGTYPE_p_ccstd__vectorT_cc__scene__IMacroPatch_t");
    arg2 = &temp2;
    
    result = (cc::gfx::Shader *)(arg1)->getPlanarShader((ccstd::vector< cc::scene::IMacroPatch > const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Shadows_getPlanarShader, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Shadows_getPlanarShader) 

static bool js_cc_scene_Shadows_getPlanarInstanceShader(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    ccstd::vector< cc::scene::IMacroPatch > *arg2 = 0 ;
    ccstd::vector< cc::scene::IMacroPatch > temp2 ;
    cc::gfx::Shader *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Shadows_getPlanarInstanceShader,2,SWIGTYPE_p_ccstd__vectorT_cc__scene__IMacroPatch_t");
    arg2 = &temp2;
    
    result = (cc::gfx::Shader *)(arg1)->getPlanarInstanceShader((ccstd::vector< cc::scene::IMacroPatch > const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Shadows_getPlanarInstanceShader, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Shadows_getPlanarInstanceShader) 

static bool js_cc_scene_Shadows_activate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->activate();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Shadows_activate) 

static bool js_cc_scene_Shadows_getShadowColor4f(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    ccstd::array< float,4 > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::array< float,4 > *) &((cc::scene::Shadows const *)arg1)->getShadowColor4f();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Shadows_getShadowColor4f, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Shadows_getShadowColor4f) 

static bool js_cc_scene_Shadows_setShadowMapSize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Shadows_setShadowMapSize,2,SWIGTYPE_float"); 
    (arg1)->setShadowMapSize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Shadows_setShadowMapSize) 

static bool js_cc_scene_Shadows_getShadowMapSize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)((cc::scene::Shadows const *)arg1)->getShadowMapSize();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Shadows_getShadowMapSize) 

static bool js_cc_scene_Shadows_enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Shadows_enabled_set,2,SWIGTYPE_bool"); 
    cc_scene_Shadows_enabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Shadows_enabled_set) 

static bool js_cc_scene_Shadows_enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_Shadows_enabled_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Shadows_enabled_get) 

static bool js_cc_scene_Shadows_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    cc::scene::ShadowType arg2 ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "Shadows_type_set,2,SWIGTYPE_cc__scene__ShadowType");
    arg2 = (cc::scene::ShadowType)temp2;
    cc_scene_Shadows_type_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Shadows_type_set) 

static bool js_cc_scene_Shadows_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    cc::scene::ShadowType result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::ShadowType)cc_scene_Shadows_type_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Shadows_type_get) 

static bool js_cc_scene_Shadows_normal_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Shadows_normal_set,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    cc_scene_Shadows_normal_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Shadows_normal_set) 

static bool js_cc_scene_Shadows_normal_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Vec3 *) &cc_scene_Shadows_normal_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Shadows_normal_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Shadows_normal_get) 

static bool js_cc_scene_Shadows_distance_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Shadows_distance_set,2,SWIGTYPE_float"); 
    cc_scene_Shadows_distance_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Shadows_distance_set) 

static bool js_cc_scene_Shadows_distance_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_Shadows_distance_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Shadows_distance_get) 

static bool js_cc_scene_Shadows_shadowColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    cc::Color *arg2 = 0 ;
    cc::Color temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Shadows_shadowColor_set,2,SWIGTYPE_p_cc__Color");
    arg2 = &temp2;
    
    cc_scene_Shadows_shadowColor_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Shadows_shadowColor_set) 

static bool js_cc_scene_Shadows_shadowColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    cc::Color *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Color *) &cc_scene_Shadows_shadowColor_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Shadows_shadowColor_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Shadows_shadowColor_get) 

static bool js_cc_scene_Shadows_maxReceived_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Shadows_maxReceived_set,2,SWIGTYPE_uint32_t"); 
    
    cc_scene_Shadows_maxReceived_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Shadows_maxReceived_set) 

static bool js_cc_scene_Shadows_maxReceived_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_scene_Shadows_maxReceived_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Shadows_maxReceived_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Shadows_maxReceived_get) 

static bool js_cc_scene_Shadows_size_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Shadows_size_set,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    cc_scene_Shadows_size_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Shadows_size_set) 

static bool js_cc_scene_Shadows_size_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    cc::Vec2 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Vec2 *) &cc_scene_Shadows_size_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Shadows_size_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Shadows_size_get) 

static bool js_cc_scene_Shadows_shadowMapDirty_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Shadows_shadowMapDirty_set,2,SWIGTYPE_bool"); 
    cc_scene_Shadows_shadowMapDirty_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Shadows_shadowMapDirty_set) 

static bool js_cc_scene_Shadows_shadowMapDirty_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_Shadows_shadowMapDirty_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Shadows_shadowMapDirty_get) 

static bool js_cc_scene_Shadows_matLight_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    cc::Mat4 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Mat4 *) &cc_scene_Shadows_matLight_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Shadows_matLight_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Shadows_matLight_get) 

static bool js_cc_scene_Shadows_material_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    cc::Material *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Material *)cc_scene_Shadows_material_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Shadows_material_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Shadows_material_get) 

static bool js_cc_scene_Shadows_instancingMaterial_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Shadows *arg1 = (cc::scene::Shadows *) NULL ;
    cc::Material *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Shadows>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Material *)cc_scene_Shadows_instancingMaterial_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Shadows_instancingMaterial_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Shadows_instancingMaterial_get) 

bool js_register_cc_scene_Shadows(se::Object* obj) {
    auto* cls = se::Class::create("Shadows", obj, nullptr, _SE(js_new_cc_scene_Shadows)); 
    
    cls->defineProperty("enabled", _SE(js_cc_scene_Shadows_enabled_get), _SE(js_cc_scene_Shadows_enabled_set)); 
    cls->defineProperty("type", _SE(js_cc_scene_Shadows_type_get), _SE(js_cc_scene_Shadows_type_set)); 
    cls->defineProperty("normal", _SE(js_cc_scene_Shadows_normal_get), _SE(js_cc_scene_Shadows_normal_set)); 
    cls->defineProperty("distance", _SE(js_cc_scene_Shadows_distance_get), _SE(js_cc_scene_Shadows_distance_set)); 
    cls->defineProperty("shadowColor", _SE(js_cc_scene_Shadows_shadowColor_get), _SE(js_cc_scene_Shadows_shadowColor_set)); 
    cls->defineProperty("maxReceived", _SE(js_cc_scene_Shadows_maxReceived_get), _SE(js_cc_scene_Shadows_maxReceived_set)); 
    cls->defineProperty("size", _SE(js_cc_scene_Shadows_size_get), _SE(js_cc_scene_Shadows_size_set)); 
    cls->defineProperty("shadowMapDirty", _SE(js_cc_scene_Shadows_shadowMapDirty_get), _SE(js_cc_scene_Shadows_shadowMapDirty_set)); 
    cls->defineProperty("matLight", _SE(js_cc_scene_Shadows_matLight_get), nullptr); 
    cls->defineProperty("material", _SE(js_cc_scene_Shadows_material_get), nullptr); 
    cls->defineProperty("instancingMaterial", _SE(js_cc_scene_Shadows_instancingMaterial_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_scene_Shadows_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_scene_Shadows_destroy)); 
    cls->defineFunction("getPlanarShader", _SE(js_cc_scene_Shadows_getPlanarShader)); 
    cls->defineFunction("getPlanarInstanceShader", _SE(js_cc_scene_Shadows_getPlanarInstanceShader)); 
    cls->defineFunction("activate", _SE(js_cc_scene_Shadows_activate)); 
    cls->defineFunction("getShadowColor4f", _SE(js_cc_scene_Shadows_getShadowColor4f)); 
    cls->defineFunction("setShadowMapSize", _SE(js_cc_scene_Shadows_setShadowMapSize)); 
    cls->defineFunction("getShadowMapSize", _SE(js_cc_scene_Shadows_getShadowMapSize)); 
    
    cls->defineStaticProperty("MAX_FAR", _SE(js_cc_scene_Shadows_MAX_FAR_get), nullptr); 
    cls->defineStaticProperty("COEFFICIENT_OF_EXPANSION", _SE(js_cc_scene_Shadows_COEFFICIENT_OF_EXPANSION_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_Shadows));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::Shadows>(cls);
    
    __jsb_cc_scene_Shadows_proto = cls->getProto();
    __jsb_cc_scene_Shadows_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_SkyboxInfo_class = nullptr;
se::Object* __jsb_cc_scene_SkyboxInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_SkyboxInfo) 

// js_ctor
static bool js_new_cc_scene_SkyboxInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::SkyboxInfo *result;
    result = (cc::scene::SkyboxInfo *)new cc::scene::SkyboxInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_SkyboxInfo, __jsb_cc_scene_SkyboxInfo_class, js_delete_cc_scene_SkyboxInfo)

static bool js_delete_cc_scene_SkyboxInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_SkyboxInfo) 

static bool js_cc_scene_SkyboxInfo_setReflectionMap(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    cc::TextureCube *arg2 = (cc::TextureCube *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkyboxInfo_setReflectionMap,2,SWIGTYPE_p_cc__TextureCube"); 
    (arg1)->setReflectionMap(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SkyboxInfo_setReflectionMap) 

static bool js_cc_scene_SkyboxInfo_activate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    cc::scene::Skybox *arg2 = (cc::scene::Skybox *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkyboxInfo_activate,2,SWIGTYPE_p_cc__scene__Skybox"); 
    (arg1)->activate(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SkyboxInfo_activate) 

static bool js_cc_scene_SkyboxInfo__envmapHDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->_envmapHDR, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkyboxInfo__envmapHDR_set,2,SWIGTYPE_p_cc__TextureCube"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo__envmapHDR_set) 

static bool js_cc_scene_SkyboxInfo__envmapHDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->_envmapHDR, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkyboxInfo__envmapHDR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_envmapHDR, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo__envmapHDR_get) 

static bool js_cc_scene_SkyboxInfo__envmapLDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->_envmapLDR, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkyboxInfo__envmapLDR_set,2,SWIGTYPE_p_cc__TextureCube"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo__envmapLDR_set) 

static bool js_cc_scene_SkyboxInfo__envmapLDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->_envmapLDR, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkyboxInfo__envmapLDR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_envmapLDR, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo__envmapLDR_get) 

static bool js_cc_scene_SkyboxInfo__diffuseMapHDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->_diffuseMapHDR, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkyboxInfo__diffuseMapHDR_set,2,SWIGTYPE_p_cc__TextureCube"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo__diffuseMapHDR_set) 

static bool js_cc_scene_SkyboxInfo__diffuseMapHDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->_diffuseMapHDR, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkyboxInfo__diffuseMapHDR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_diffuseMapHDR, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo__diffuseMapHDR_get) 

static bool js_cc_scene_SkyboxInfo__diffuseMapLDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->_diffuseMapLDR, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkyboxInfo__diffuseMapLDR_set,2,SWIGTYPE_p_cc__TextureCube"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo__diffuseMapLDR_set) 

static bool js_cc_scene_SkyboxInfo__diffuseMapLDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->_diffuseMapLDR, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkyboxInfo__diffuseMapLDR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_diffuseMapLDR, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo__diffuseMapLDR_get) 

static bool js_cc_scene_SkyboxInfo__reflectionHDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->_reflectionHDR, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkyboxInfo__reflectionHDR_set,2,SWIGTYPE_p_cc__TextureCube"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo__reflectionHDR_set) 

static bool js_cc_scene_SkyboxInfo__reflectionHDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->_reflectionHDR, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkyboxInfo__reflectionHDR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_reflectionHDR, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo__reflectionHDR_get) 

static bool js_cc_scene_SkyboxInfo__reflectionLDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->_reflectionLDR, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkyboxInfo__reflectionLDR_set,2,SWIGTYPE_p_cc__TextureCube"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo__reflectionLDR_set) 

static bool js_cc_scene_SkyboxInfo__reflectionLDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->_reflectionLDR, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkyboxInfo__reflectionLDR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_reflectionLDR, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo__reflectionLDR_get) 

static bool js_cc_scene_SkyboxInfo__enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->_enabled);
    SE_PRECONDITION2(ok, false, "SkyboxInfo__enabled_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo__enabled_set) 

static bool js_cc_scene_SkyboxInfo__enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->_enabled, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo__enabled_get) 

static bool js_cc_scene_SkyboxInfo__useHDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->_useHDR);
    SE_PRECONDITION2(ok, false, "SkyboxInfo__useHDR_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo__useHDR_set) 

static bool js_cc_scene_SkyboxInfo__useHDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->_useHDR, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo__useHDR_get) 

static bool js_cc_scene_SkyboxInfo__envLightingType_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "SkyboxInfo__envLightingType_set,2,SWIGTYPE_cc__scene__EnvironmentLightingType");
    arg1->_envLightingType = (cc::scene::EnvironmentLightingType)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo__envLightingType_set) 

static bool js_cc_scene_SkyboxInfo__envLightingType_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->_envLightingType));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo__envLightingType_get) 

static bool js_cc_scene_SkyboxInfo__editableMaterial_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_editableMaterial, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkyboxInfo__editableMaterial_set,2,SWIGTYPE_cc__IntrusivePtrT_cc__Material_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo__editableMaterial_set) 

static bool js_cc_scene_SkyboxInfo__editableMaterial_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_editableMaterial, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkyboxInfo__editableMaterial_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_editableMaterial, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo__editableMaterial_get) 

static bool js_cc_scene_SkyboxInfo__resource_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->_resource, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkyboxInfo__resource_set,2,SWIGTYPE_p_cc__scene__Skybox"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo__resource_set) 

static bool js_cc_scene_SkyboxInfo__resource_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->_resource, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkyboxInfo__resource_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_resource, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo__resource_get) 

static bool js_cc_scene_SkyboxInfo__envmap_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    cc::TextureCube *arg2 = (cc::TextureCube *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkyboxInfo__envmap_set,2,SWIGTYPE_p_cc__TextureCube"); 
    cc_scene_SkyboxInfo__envmap_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo__envmap_set) 

static bool js_cc_scene_SkyboxInfo__envmap_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    cc::TextureCube *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::TextureCube *)cc_scene_SkyboxInfo__envmap_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkyboxInfo__envmap_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo__envmap_get) 

static bool js_cc_scene_SkyboxInfo_applyDiffuseMap_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "SkyboxInfo_applyDiffuseMap_set,2,SWIGTYPE_bool"); 
    cc_scene_SkyboxInfo_applyDiffuseMap_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo_applyDiffuseMap_set) 

static bool js_cc_scene_SkyboxInfo_applyDiffuseMap_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_SkyboxInfo_applyDiffuseMap_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo_applyDiffuseMap_get) 

static bool js_cc_scene_SkyboxInfo_enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "SkyboxInfo_enabled_set,2,SWIGTYPE_bool"); 
    cc_scene_SkyboxInfo_enabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo_enabled_set) 

static bool js_cc_scene_SkyboxInfo_enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_SkyboxInfo_enabled_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo_enabled_get) 

static bool js_cc_scene_SkyboxInfo_useIBL_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "SkyboxInfo_useIBL_set,2,SWIGTYPE_bool"); 
    cc_scene_SkyboxInfo_useIBL_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo_useIBL_set) 

static bool js_cc_scene_SkyboxInfo_useIBL_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_SkyboxInfo_useIBL_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo_useIBL_get) 

static bool js_cc_scene_SkyboxInfo_useHDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "SkyboxInfo_useHDR_set,2,SWIGTYPE_bool"); 
    cc_scene_SkyboxInfo_useHDR_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo_useHDR_set) 

static bool js_cc_scene_SkyboxInfo_useHDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_SkyboxInfo_useHDR_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo_useHDR_get) 

static bool js_cc_scene_SkyboxInfo_envmap_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    cc::TextureCube *arg2 = (cc::TextureCube *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkyboxInfo_envmap_set,2,SWIGTYPE_p_cc__TextureCube"); 
    cc_scene_SkyboxInfo_envmap_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo_envmap_set) 

static bool js_cc_scene_SkyboxInfo_envmap_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    cc::TextureCube *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::TextureCube *)cc_scene_SkyboxInfo_envmap_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkyboxInfo_envmap_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo_envmap_get) 

static bool js_cc_scene_SkyboxInfo_diffuseMap_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    cc::TextureCube *arg2 = (cc::TextureCube *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkyboxInfo_diffuseMap_set,2,SWIGTYPE_p_cc__TextureCube"); 
    cc_scene_SkyboxInfo_diffuseMap_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo_diffuseMap_set) 

static bool js_cc_scene_SkyboxInfo_diffuseMap_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    cc::TextureCube *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::TextureCube *)cc_scene_SkyboxInfo_diffuseMap_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SkyboxInfo_diffuseMap_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo_diffuseMap_get) 

static bool js_cc_scene_SkyboxInfo_envLightingType_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    cc::scene::EnvironmentLightingType arg2 ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "SkyboxInfo_envLightingType_set,2,SWIGTYPE_cc__scene__EnvironmentLightingType");
    arg2 = (cc::scene::EnvironmentLightingType)temp2;
    cc_scene_SkyboxInfo_envLightingType_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SkyboxInfo_envLightingType_set) 

static bool js_cc_scene_SkyboxInfo_envLightingType_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SkyboxInfo *arg1 = (cc::scene::SkyboxInfo *) NULL ;
    cc::scene::EnvironmentLightingType result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SkyboxInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::EnvironmentLightingType)cc_scene_SkyboxInfo_envLightingType_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SkyboxInfo_envLightingType_get) 

bool js_register_cc_scene_SkyboxInfo(se::Object* obj) {
    auto* cls = se::Class::create("SkyboxInfo", obj, nullptr, _SE(js_new_cc_scene_SkyboxInfo)); 
    
    cls->defineProperty("_envmapHDR", _SE(js_cc_scene_SkyboxInfo__envmapHDR_get), _SE(js_cc_scene_SkyboxInfo__envmapHDR_set)); 
    cls->defineProperty("_envmapLDR", _SE(js_cc_scene_SkyboxInfo__envmapLDR_get), _SE(js_cc_scene_SkyboxInfo__envmapLDR_set)); 
    cls->defineProperty("_diffuseMapHDR", _SE(js_cc_scene_SkyboxInfo__diffuseMapHDR_get), _SE(js_cc_scene_SkyboxInfo__diffuseMapHDR_set)); 
    cls->defineProperty("_diffuseMapLDR", _SE(js_cc_scene_SkyboxInfo__diffuseMapLDR_get), _SE(js_cc_scene_SkyboxInfo__diffuseMapLDR_set)); 
    cls->defineProperty("_reflectionHDR", _SE(js_cc_scene_SkyboxInfo__reflectionHDR_get), _SE(js_cc_scene_SkyboxInfo__reflectionHDR_set)); 
    cls->defineProperty("_reflectionLDR", _SE(js_cc_scene_SkyboxInfo__reflectionLDR_get), _SE(js_cc_scene_SkyboxInfo__reflectionLDR_set)); 
    cls->defineProperty("_enabled", _SE(js_cc_scene_SkyboxInfo__enabled_get), _SE(js_cc_scene_SkyboxInfo__enabled_set)); 
    cls->defineProperty("_useHDR", _SE(js_cc_scene_SkyboxInfo__useHDR_get), _SE(js_cc_scene_SkyboxInfo__useHDR_set)); 
    cls->defineProperty("_envLightingType", _SE(js_cc_scene_SkyboxInfo__envLightingType_get), _SE(js_cc_scene_SkyboxInfo__envLightingType_set)); 
    cls->defineProperty("_editableMaterial", _SE(js_cc_scene_SkyboxInfo__editableMaterial_get), _SE(js_cc_scene_SkyboxInfo__editableMaterial_set)); 
    cls->defineProperty("_resource", _SE(js_cc_scene_SkyboxInfo__resource_get), _SE(js_cc_scene_SkyboxInfo__resource_set)); 
    cls->defineProperty("_envmap", _SE(js_cc_scene_SkyboxInfo__envmap_get), _SE(js_cc_scene_SkyboxInfo__envmap_set)); 
    cls->defineProperty("applyDiffuseMap", _SE(js_cc_scene_SkyboxInfo_applyDiffuseMap_get), _SE(js_cc_scene_SkyboxInfo_applyDiffuseMap_set)); 
    cls->defineProperty("enabled", _SE(js_cc_scene_SkyboxInfo_enabled_get), _SE(js_cc_scene_SkyboxInfo_enabled_set)); 
    cls->defineProperty("useIBL", _SE(js_cc_scene_SkyboxInfo_useIBL_get), _SE(js_cc_scene_SkyboxInfo_useIBL_set)); 
    cls->defineProperty("useHDR", _SE(js_cc_scene_SkyboxInfo_useHDR_get), _SE(js_cc_scene_SkyboxInfo_useHDR_set)); 
    cls->defineProperty("envmap", _SE(js_cc_scene_SkyboxInfo_envmap_get), _SE(js_cc_scene_SkyboxInfo_envmap_set)); 
    cls->defineProperty("diffuseMap", _SE(js_cc_scene_SkyboxInfo_diffuseMap_get), _SE(js_cc_scene_SkyboxInfo_diffuseMap_set)); 
    cls->defineProperty("envLightingType", _SE(js_cc_scene_SkyboxInfo_envLightingType_get), _SE(js_cc_scene_SkyboxInfo_envLightingType_set)); 
    
    cls->defineFunction("setReflectionMap", _SE(js_cc_scene_SkyboxInfo_setReflectionMap)); 
    cls->defineFunction("activate", _SE(js_cc_scene_SkyboxInfo_activate)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_SkyboxInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::SkyboxInfo>(cls);
    
    __jsb_cc_scene_SkyboxInfo_proto = cls->getProto();
    __jsb_cc_scene_SkyboxInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_Skybox_class = nullptr;
se::Object* __jsb_cc_scene_Skybox_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_Skybox) 

// js_ctor
static bool js_new_cc_scene_Skybox(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::Skybox *result;
    result = (cc::scene::Skybox *)new cc::scene::Skybox();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_Skybox, __jsb_cc_scene_Skybox_class, js_delete_cc_scene_Skybox)

static bool js_delete_cc_scene_Skybox(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_Skybox) 

static bool js_cc_scene_Skybox_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    cc::scene::SkyboxInfo *arg2 = 0 ;
    cc::scene::SkyboxInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skybox_initialize,2,SWIGTYPE_p_cc__scene__SkyboxInfo");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::scene::SkyboxInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Skybox_initialize) 

static bool js_cc_scene_Skybox_setEnvMaps(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    cc::TextureCube *arg2 = (cc::TextureCube *) NULL ;
    cc::TextureCube *arg3 = (cc::TextureCube *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skybox_setEnvMaps,2,SWIGTYPE_p_cc__TextureCube"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skybox_setEnvMaps,3,SWIGTYPE_p_cc__TextureCube"); 
    (arg1)->setEnvMaps(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Skybox_setEnvMaps) 

static bool js_cc_scene_Skybox_setDiffuseMaps(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    cc::TextureCube *arg2 = (cc::TextureCube *) NULL ;
    cc::TextureCube *arg3 = (cc::TextureCube *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skybox_setDiffuseMaps,2,SWIGTYPE_p_cc__TextureCube"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skybox_setDiffuseMaps,3,SWIGTYPE_p_cc__TextureCube"); 
    (arg1)->setDiffuseMaps(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Skybox_setDiffuseMaps) 

static bool js_cc_scene_Skybox_setReflectionMaps(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    cc::TextureCube *arg2 = (cc::TextureCube *) NULL ;
    cc::TextureCube *arg3 = (cc::TextureCube *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skybox_setReflectionMaps,2,SWIGTYPE_p_cc__TextureCube"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skybox_setReflectionMaps,3,SWIGTYPE_p_cc__TextureCube"); 
    (arg1)->setReflectionMaps(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Skybox_setReflectionMaps) 

static bool js_cc_scene_Skybox_activate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->activate();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Skybox_activate) 

static bool js_cc_scene_Skybox_isUsingConvolutionMap(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((cc::scene::Skybox const *)arg1)->isUsingConvolutionMap();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Skybox_isUsingConvolutionMap) 

static bool js_cc_scene_Skybox_setSkyboxMaterial(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    cc::Material *arg2 = (cc::Material *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skybox_setSkyboxMaterial,2,SWIGTYPE_p_cc__Material"); 
    (arg1)->setSkyboxMaterial(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Skybox_setSkyboxMaterial) 

static bool js_cc_scene_Skybox_getReflectionMap(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    cc::TextureCube *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::TextureCube *)((cc::scene::Skybox const *)arg1)->getReflectionMap();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skybox_getReflectionMap, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Skybox_getReflectionMap) 

static bool js_cc_scene_Skybox_model_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    cc::scene::Model *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::Model *)cc_scene_Skybox_model_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skybox_model_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Skybox_model_get) 

static bool js_cc_scene_Skybox_enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Skybox_enabled_set,2,SWIGTYPE_bool"); 
    cc_scene_Skybox_enabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Skybox_enabled_set) 

static bool js_cc_scene_Skybox_enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_Skybox_enabled_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Skybox_enabled_get) 

static bool js_cc_scene_Skybox_useHDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Skybox_useHDR_set,2,SWIGTYPE_bool"); 
    cc_scene_Skybox_useHDR_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Skybox_useHDR_set) 

static bool js_cc_scene_Skybox_useHDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_Skybox_useHDR_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Skybox_useHDR_get) 

static bool js_cc_scene_Skybox_useIBL_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Skybox_useIBL_set,2,SWIGTYPE_bool"); 
    cc_scene_Skybox_useIBL_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Skybox_useIBL_set) 

static bool js_cc_scene_Skybox_useIBL_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_Skybox_useIBL_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Skybox_useIBL_get) 

static bool js_cc_scene_Skybox_useDiffuseMap_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Skybox_useDiffuseMap_set,2,SWIGTYPE_bool"); 
    cc_scene_Skybox_useDiffuseMap_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Skybox_useDiffuseMap_set) 

static bool js_cc_scene_Skybox_useDiffuseMap_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_Skybox_useDiffuseMap_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Skybox_useDiffuseMap_get) 

static bool js_cc_scene_Skybox_isRGBE_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_Skybox_isRGBE_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Skybox_isRGBE_get) 

static bool js_cc_scene_Skybox_envmap_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    cc::TextureCube *arg2 = (cc::TextureCube *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skybox_envmap_set,2,SWIGTYPE_p_cc__TextureCube"); 
    cc_scene_Skybox_envmap_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Skybox_envmap_set) 

static bool js_cc_scene_Skybox_envmap_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    cc::TextureCube *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::TextureCube *)cc_scene_Skybox_envmap_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skybox_envmap_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Skybox_envmap_get) 

static bool js_cc_scene_Skybox_diffuseMap_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    cc::TextureCube *arg2 = (cc::TextureCube *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Skybox_diffuseMap_set,2,SWIGTYPE_p_cc__TextureCube"); 
    cc_scene_Skybox_diffuseMap_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Skybox_diffuseMap_set) 

static bool js_cc_scene_Skybox_diffuseMap_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Skybox *arg1 = (cc::scene::Skybox *) NULL ;
    cc::TextureCube *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Skybox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::TextureCube *)cc_scene_Skybox_diffuseMap_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Skybox_diffuseMap_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Skybox_diffuseMap_get) 

bool js_register_cc_scene_Skybox(se::Object* obj) {
    auto* cls = se::Class::create("Skybox", obj, nullptr, _SE(js_new_cc_scene_Skybox)); 
    
    cls->defineProperty("model", _SE(js_cc_scene_Skybox_model_get), nullptr); 
    cls->defineProperty("enabled", _SE(js_cc_scene_Skybox_enabled_get), _SE(js_cc_scene_Skybox_enabled_set)); 
    cls->defineProperty("useHDR", _SE(js_cc_scene_Skybox_useHDR_get), _SE(js_cc_scene_Skybox_useHDR_set)); 
    cls->defineProperty("useIBL", _SE(js_cc_scene_Skybox_useIBL_get), _SE(js_cc_scene_Skybox_useIBL_set)); 
    cls->defineProperty("useDiffuseMap", _SE(js_cc_scene_Skybox_useDiffuseMap_get), _SE(js_cc_scene_Skybox_useDiffuseMap_set)); 
    cls->defineProperty("isRGBE", _SE(js_cc_scene_Skybox_isRGBE_get), nullptr); 
    cls->defineProperty("envmap", _SE(js_cc_scene_Skybox_envmap_get), _SE(js_cc_scene_Skybox_envmap_set)); 
    cls->defineProperty("diffuseMap", _SE(js_cc_scene_Skybox_diffuseMap_get), _SE(js_cc_scene_Skybox_diffuseMap_set)); 
    
    cls->defineFunction("initialize", _SE(js_cc_scene_Skybox_initialize)); 
    cls->defineFunction("setEnvMaps", _SE(js_cc_scene_Skybox_setEnvMaps)); 
    cls->defineFunction("setDiffuseMaps", _SE(js_cc_scene_Skybox_setDiffuseMaps)); 
    cls->defineFunction("setReflectionMaps", _SE(js_cc_scene_Skybox_setReflectionMaps)); 
    cls->defineFunction("activate", _SE(js_cc_scene_Skybox_activate)); 
    cls->defineFunction("isUsingConvolutionMap", _SE(js_cc_scene_Skybox_isUsingConvolutionMap)); 
    cls->defineFunction("setSkyboxMaterial", _SE(js_cc_scene_Skybox_setSkyboxMaterial)); 
    cls->defineFunction("getReflectionMap", _SE(js_cc_scene_Skybox_getReflectionMap)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_Skybox));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::Skybox>(cls);
    
    __jsb_cc_scene_Skybox_proto = cls->getProto();
    __jsb_cc_scene_Skybox_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_DirectionalLight_class = nullptr;
se::Object* __jsb_cc_scene_DirectionalLight_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_DirectionalLight) 

// js_ctor
static bool js_new_cc_scene_DirectionalLight(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::DirectionalLight *result;
    result = (cc::scene::DirectionalLight *)new cc::scene::DirectionalLight();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_DirectionalLight, __jsb_cc_scene_DirectionalLight_class, js_delete_cc_scene_DirectionalLight)

static bool js_delete_cc_scene_DirectionalLight(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_DirectionalLight) 

static bool js_cc_scene_DirectionalLight_direction_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DirectionalLight_direction_set,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    cc_scene_DirectionalLight_direction_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_direction_set) 

static bool js_cc_scene_DirectionalLight_direction_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Vec3 *) &cc_scene_DirectionalLight_direction_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DirectionalLight_direction_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_direction_get) 

static bool js_cc_scene_DirectionalLight_illuminance_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "DirectionalLight_illuminance_set,2,SWIGTYPE_float"); 
    cc_scene_DirectionalLight_illuminance_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_illuminance_set) 

static bool js_cc_scene_DirectionalLight_illuminance_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_DirectionalLight_illuminance_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_illuminance_get) 

static bool js_cc_scene_DirectionalLight_illuminanceHDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "DirectionalLight_illuminanceHDR_set,2,SWIGTYPE_float"); 
    cc_scene_DirectionalLight_illuminanceHDR_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_illuminanceHDR_set) 

static bool js_cc_scene_DirectionalLight_illuminanceHDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_DirectionalLight_illuminanceHDR_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_illuminanceHDR_get) 

static bool js_cc_scene_DirectionalLight_illuminanceLDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "DirectionalLight_illuminanceLDR_set,2,SWIGTYPE_float"); 
    cc_scene_DirectionalLight_illuminanceLDR_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_illuminanceLDR_set) 

static bool js_cc_scene_DirectionalLight_illuminanceLDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_DirectionalLight_illuminanceLDR_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_illuminanceLDR_get) 

static bool js_cc_scene_DirectionalLight_shadowEnabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "DirectionalLight_shadowEnabled_set,2,SWIGTYPE_bool"); 
    cc_scene_DirectionalLight_shadowEnabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_shadowEnabled_set) 

static bool js_cc_scene_DirectionalLight_shadowEnabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_DirectionalLight_shadowEnabled_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_shadowEnabled_get) 

static bool js_cc_scene_DirectionalLight_shadowPcf_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    cc::scene::PCFType arg2 ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "DirectionalLight_shadowPcf_set,2,SWIGTYPE_cc__scene__PCFType");
    arg2 = (cc::scene::PCFType)temp2;
    cc_scene_DirectionalLight_shadowPcf_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_shadowPcf_set) 

static bool js_cc_scene_DirectionalLight_shadowPcf_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    cc::scene::PCFType result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::PCFType)cc_scene_DirectionalLight_shadowPcf_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_shadowPcf_get) 

static bool js_cc_scene_DirectionalLight_shadowBias_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "DirectionalLight_shadowBias_set,2,SWIGTYPE_float"); 
    cc_scene_DirectionalLight_shadowBias_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_shadowBias_set) 

static bool js_cc_scene_DirectionalLight_shadowBias_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_DirectionalLight_shadowBias_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_shadowBias_get) 

static bool js_cc_scene_DirectionalLight_shadowNormalBias_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "DirectionalLight_shadowNormalBias_set,2,SWIGTYPE_float"); 
    cc_scene_DirectionalLight_shadowNormalBias_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_shadowNormalBias_set) 

static bool js_cc_scene_DirectionalLight_shadowNormalBias_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_DirectionalLight_shadowNormalBias_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_shadowNormalBias_get) 

static bool js_cc_scene_DirectionalLight_shadowSaturation_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "DirectionalLight_shadowSaturation_set,2,SWIGTYPE_float"); 
    cc_scene_DirectionalLight_shadowSaturation_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_shadowSaturation_set) 

static bool js_cc_scene_DirectionalLight_shadowSaturation_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_DirectionalLight_shadowSaturation_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_shadowSaturation_get) 

static bool js_cc_scene_DirectionalLight_shadowDistance_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "DirectionalLight_shadowDistance_set,2,SWIGTYPE_float"); 
    cc_scene_DirectionalLight_shadowDistance_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_shadowDistance_set) 

static bool js_cc_scene_DirectionalLight_shadowDistance_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_DirectionalLight_shadowDistance_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_shadowDistance_get) 

static bool js_cc_scene_DirectionalLight_shadowInvisibleOcclusionRange_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "DirectionalLight_shadowInvisibleOcclusionRange_set,2,SWIGTYPE_float"); 
    cc_scene_DirectionalLight_shadowInvisibleOcclusionRange_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_shadowInvisibleOcclusionRange_set) 

static bool js_cc_scene_DirectionalLight_shadowInvisibleOcclusionRange_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_DirectionalLight_shadowInvisibleOcclusionRange_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_shadowInvisibleOcclusionRange_get) 

static bool js_cc_scene_DirectionalLight_shadowFixedArea_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "DirectionalLight_shadowFixedArea_set,2,SWIGTYPE_bool"); 
    cc_scene_DirectionalLight_shadowFixedArea_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_shadowFixedArea_set) 

static bool js_cc_scene_DirectionalLight_shadowFixedArea_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_DirectionalLight_shadowFixedArea_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_shadowFixedArea_get) 

static bool js_cc_scene_DirectionalLight_shadowNear_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "DirectionalLight_shadowNear_set,2,SWIGTYPE_float"); 
    cc_scene_DirectionalLight_shadowNear_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_shadowNear_set) 

static bool js_cc_scene_DirectionalLight_shadowNear_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_DirectionalLight_shadowNear_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_shadowNear_get) 

static bool js_cc_scene_DirectionalLight_shadowFar_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "DirectionalLight_shadowFar_set,2,SWIGTYPE_float"); 
    cc_scene_DirectionalLight_shadowFar_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_shadowFar_set) 

static bool js_cc_scene_DirectionalLight_shadowFar_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_DirectionalLight_shadowFar_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_shadowFar_get) 

static bool js_cc_scene_DirectionalLight_shadowOrthoSize_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "DirectionalLight_shadowOrthoSize_set,2,SWIGTYPE_float"); 
    cc_scene_DirectionalLight_shadowOrthoSize_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_shadowOrthoSize_set) 

static bool js_cc_scene_DirectionalLight_shadowOrthoSize_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_DirectionalLight_shadowOrthoSize_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_shadowOrthoSize_get) 

static bool js_cc_scene_DirectionalLight_csmLevel_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    cc::scene::CSMLevel arg2 ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "DirectionalLight_csmLevel_set,2,SWIGTYPE_cc__scene__CSMLevel");
    arg2 = (cc::scene::CSMLevel)temp2;
    cc_scene_DirectionalLight_csmLevel_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_csmLevel_set) 

static bool js_cc_scene_DirectionalLight_csmLevel_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    cc::scene::CSMLevel result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::CSMLevel)cc_scene_DirectionalLight_csmLevel_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_csmLevel_get) 

static bool js_cc_scene_DirectionalLight_csmNeedUpdate_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "DirectionalLight_csmNeedUpdate_set,2,SWIGTYPE_bool"); 
    cc_scene_DirectionalLight_csmNeedUpdate_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_csmNeedUpdate_set) 

static bool js_cc_scene_DirectionalLight_csmNeedUpdate_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_DirectionalLight_csmNeedUpdate_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_csmNeedUpdate_get) 

static bool js_cc_scene_DirectionalLight_csmLayerLambda_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "DirectionalLight_csmLayerLambda_set,2,SWIGTYPE_float"); 
    cc_scene_DirectionalLight_csmLayerLambda_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_csmLayerLambda_set) 

static bool js_cc_scene_DirectionalLight_csmLayerLambda_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_DirectionalLight_csmLayerLambda_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_csmLayerLambda_get) 

static bool js_cc_scene_DirectionalLight_csmOptimizationMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    cc::scene::CSMOptimizationMode arg2 ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "DirectionalLight_csmOptimizationMode_set,2,SWIGTYPE_cc__scene__CSMOptimizationMode");
    arg2 = (cc::scene::CSMOptimizationMode)temp2;
    cc_scene_DirectionalLight_csmOptimizationMode_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_DirectionalLight_csmOptimizationMode_set) 

static bool js_cc_scene_DirectionalLight_csmOptimizationMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::DirectionalLight *arg1 = (cc::scene::DirectionalLight *) NULL ;
    cc::scene::CSMOptimizationMode result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::DirectionalLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::CSMOptimizationMode)cc_scene_DirectionalLight_csmOptimizationMode_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_DirectionalLight_csmOptimizationMode_get) 

bool js_register_cc_scene_DirectionalLight(se::Object* obj) {
    auto* cls = se::Class::create("DirectionalLight", obj, __jsb_cc_scene_Light_proto, _SE(js_new_cc_scene_DirectionalLight)); 
    
    cls->defineProperty("direction", _SE(js_cc_scene_DirectionalLight_direction_get), _SE(js_cc_scene_DirectionalLight_direction_set)); 
    cls->defineProperty("illuminance", _SE(js_cc_scene_DirectionalLight_illuminance_get), _SE(js_cc_scene_DirectionalLight_illuminance_set)); 
    cls->defineProperty("illuminanceHDR", _SE(js_cc_scene_DirectionalLight_illuminanceHDR_get), _SE(js_cc_scene_DirectionalLight_illuminanceHDR_set)); 
    cls->defineProperty("illuminanceLDR", _SE(js_cc_scene_DirectionalLight_illuminanceLDR_get), _SE(js_cc_scene_DirectionalLight_illuminanceLDR_set)); 
    cls->defineProperty("shadowEnabled", _SE(js_cc_scene_DirectionalLight_shadowEnabled_get), _SE(js_cc_scene_DirectionalLight_shadowEnabled_set)); 
    cls->defineProperty("shadowPcf", _SE(js_cc_scene_DirectionalLight_shadowPcf_get), _SE(js_cc_scene_DirectionalLight_shadowPcf_set)); 
    cls->defineProperty("shadowBias", _SE(js_cc_scene_DirectionalLight_shadowBias_get), _SE(js_cc_scene_DirectionalLight_shadowBias_set)); 
    cls->defineProperty("shadowNormalBias", _SE(js_cc_scene_DirectionalLight_shadowNormalBias_get), _SE(js_cc_scene_DirectionalLight_shadowNormalBias_set)); 
    cls->defineProperty("shadowSaturation", _SE(js_cc_scene_DirectionalLight_shadowSaturation_get), _SE(js_cc_scene_DirectionalLight_shadowSaturation_set)); 
    cls->defineProperty("shadowDistance", _SE(js_cc_scene_DirectionalLight_shadowDistance_get), _SE(js_cc_scene_DirectionalLight_shadowDistance_set)); 
    cls->defineProperty("shadowInvisibleOcclusionRange", _SE(js_cc_scene_DirectionalLight_shadowInvisibleOcclusionRange_get), _SE(js_cc_scene_DirectionalLight_shadowInvisibleOcclusionRange_set)); 
    cls->defineProperty("shadowFixedArea", _SE(js_cc_scene_DirectionalLight_shadowFixedArea_get), _SE(js_cc_scene_DirectionalLight_shadowFixedArea_set)); 
    cls->defineProperty("shadowNear", _SE(js_cc_scene_DirectionalLight_shadowNear_get), _SE(js_cc_scene_DirectionalLight_shadowNear_set)); 
    cls->defineProperty("shadowFar", _SE(js_cc_scene_DirectionalLight_shadowFar_get), _SE(js_cc_scene_DirectionalLight_shadowFar_set)); 
    cls->defineProperty("shadowOrthoSize", _SE(js_cc_scene_DirectionalLight_shadowOrthoSize_get), _SE(js_cc_scene_DirectionalLight_shadowOrthoSize_set)); 
    cls->defineProperty("csmLevel", _SE(js_cc_scene_DirectionalLight_csmLevel_get), _SE(js_cc_scene_DirectionalLight_csmLevel_set)); 
    cls->defineProperty("csmNeedUpdate", _SE(js_cc_scene_DirectionalLight_csmNeedUpdate_get), _SE(js_cc_scene_DirectionalLight_csmNeedUpdate_set)); 
    cls->defineProperty("csmLayerLambda", _SE(js_cc_scene_DirectionalLight_csmLayerLambda_get), _SE(js_cc_scene_DirectionalLight_csmLayerLambda_set)); 
    cls->defineProperty("csmOptimizationMode", _SE(js_cc_scene_DirectionalLight_csmOptimizationMode_get), _SE(js_cc_scene_DirectionalLight_csmOptimizationMode_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_DirectionalLight));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::DirectionalLight>(cls);
    
    __jsb_cc_scene_DirectionalLight_proto = cls->getProto();
    __jsb_cc_scene_DirectionalLight_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_SpotLight_class = nullptr;
se::Object* __jsb_cc_scene_SpotLight_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_SpotLight) 

// js_ctor
static bool js_new_cc_scene_SpotLight(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::SpotLight *result;
    result = (cc::scene::SpotLight *)new cc::scene::SpotLight();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_SpotLight, __jsb_cc_scene_SpotLight_class, js_delete_cc_scene_SpotLight)

static bool js_delete_cc_scene_SpotLight(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_SpotLight) 

static bool js_cc_scene_SpotLight_position_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Vec3 *) &cc_scene_SpotLight_position_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SpotLight_position_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_position_get) 

static bool js_cc_scene_SpotLight_range_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SpotLight_range_set,2,SWIGTYPE_float"); 
    cc_scene_SpotLight_range_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SpotLight_range_set) 

static bool js_cc_scene_SpotLight_range_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_SpotLight_range_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_range_get) 

static bool js_cc_scene_SpotLight_luminance_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SpotLight_luminance_set,2,SWIGTYPE_float"); 
    cc_scene_SpotLight_luminance_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SpotLight_luminance_set) 

static bool js_cc_scene_SpotLight_luminance_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_SpotLight_luminance_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_luminance_get) 

static bool js_cc_scene_SpotLight_luminanceHDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SpotLight_luminanceHDR_set,2,SWIGTYPE_float"); 
    cc_scene_SpotLight_luminanceHDR_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SpotLight_luminanceHDR_set) 

static bool js_cc_scene_SpotLight_luminanceHDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_SpotLight_luminanceHDR_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_luminanceHDR_get) 

static bool js_cc_scene_SpotLight_luminanceLDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SpotLight_luminanceLDR_set,2,SWIGTYPE_float"); 
    cc_scene_SpotLight_luminanceLDR_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SpotLight_luminanceLDR_set) 

static bool js_cc_scene_SpotLight_luminanceLDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_SpotLight_luminanceLDR_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_luminanceLDR_get) 

static bool js_cc_scene_SpotLight_direction_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Vec3 *) &cc_scene_SpotLight_direction_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SpotLight_direction_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_direction_get) 

static bool js_cc_scene_SpotLight_spotAngle_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SpotLight_spotAngle_set,2,SWIGTYPE_float"); 
    cc_scene_SpotLight_spotAngle_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SpotLight_spotAngle_set) 

static bool js_cc_scene_SpotLight_spotAngle_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_SpotLight_spotAngle_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_spotAngle_get) 

static bool js_cc_scene_SpotLight_angle_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_SpotLight_angle_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_angle_get) 

static bool js_cc_scene_SpotLight_aabb_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::geometry::AABB *) &cc_scene_SpotLight_aabb_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SpotLight_aabb_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_aabb_get) 

static bool js_cc_scene_SpotLight_frustum_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    cc::geometry::Frustum *arg2 = 0 ;
    cc::geometry::Frustum temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SpotLight_frustum_set,2,SWIGTYPE_p_cc__geometry__Frustum");
    arg2 = &temp2;
    
    cc_scene_SpotLight_frustum_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SpotLight_frustum_set) 

static bool js_cc_scene_SpotLight_frustum_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    cc::geometry::Frustum *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::geometry::Frustum *) &cc_scene_SpotLight_frustum_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SpotLight_frustum_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_frustum_get) 

static bool js_cc_scene_SpotLight_shadowEnabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "SpotLight_shadowEnabled_set,2,SWIGTYPE_bool"); 
    cc_scene_SpotLight_shadowEnabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SpotLight_shadowEnabled_set) 

static bool js_cc_scene_SpotLight_shadowEnabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_SpotLight_shadowEnabled_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_shadowEnabled_get) 

static bool js_cc_scene_SpotLight_shadowPcf_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SpotLight_shadowPcf_set,2,SWIGTYPE_float"); 
    cc_scene_SpotLight_shadowPcf_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SpotLight_shadowPcf_set) 

static bool js_cc_scene_SpotLight_shadowPcf_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_SpotLight_shadowPcf_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_shadowPcf_get) 

static bool js_cc_scene_SpotLight_shadowBias_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SpotLight_shadowBias_set,2,SWIGTYPE_float"); 
    cc_scene_SpotLight_shadowBias_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SpotLight_shadowBias_set) 

static bool js_cc_scene_SpotLight_shadowBias_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_SpotLight_shadowBias_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_shadowBias_get) 

static bool js_cc_scene_SpotLight_shadowNormalBias_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SpotLight_shadowNormalBias_set,2,SWIGTYPE_float"); 
    cc_scene_SpotLight_shadowNormalBias_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SpotLight_shadowNormalBias_set) 

static bool js_cc_scene_SpotLight_shadowNormalBias_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_SpotLight_shadowNormalBias_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_shadowNormalBias_get) 

static bool js_cc_scene_SpotLight_size_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SpotLight_size_set,2,SWIGTYPE_float"); 
    cc_scene_SpotLight_size_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SpotLight_size_set) 

static bool js_cc_scene_SpotLight_size_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SpotLight *arg1 = (cc::scene::SpotLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SpotLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_SpotLight_size_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SpotLight_size_get) 

bool js_register_cc_scene_SpotLight(se::Object* obj) {
    auto* cls = se::Class::create("SpotLight", obj, __jsb_cc_scene_Light_proto, _SE(js_new_cc_scene_SpotLight)); 
    
    cls->defineProperty("position", _SE(js_cc_scene_SpotLight_position_get), nullptr); 
    cls->defineProperty("range", _SE(js_cc_scene_SpotLight_range_get), _SE(js_cc_scene_SpotLight_range_set)); 
    cls->defineProperty("luminance", _SE(js_cc_scene_SpotLight_luminance_get), _SE(js_cc_scene_SpotLight_luminance_set)); 
    cls->defineProperty("luminanceHDR", _SE(js_cc_scene_SpotLight_luminanceHDR_get), _SE(js_cc_scene_SpotLight_luminanceHDR_set)); 
    cls->defineProperty("luminanceLDR", _SE(js_cc_scene_SpotLight_luminanceLDR_get), _SE(js_cc_scene_SpotLight_luminanceLDR_set)); 
    cls->defineProperty("direction", _SE(js_cc_scene_SpotLight_direction_get), nullptr); 
    cls->defineProperty("spotAngle", _SE(js_cc_scene_SpotLight_spotAngle_get), _SE(js_cc_scene_SpotLight_spotAngle_set)); 
    cls->defineProperty("angle", _SE(js_cc_scene_SpotLight_angle_get), nullptr); 
    cls->defineProperty("aabb", _SE(js_cc_scene_SpotLight_aabb_get), nullptr); 
    cls->defineProperty("frustum", _SE(js_cc_scene_SpotLight_frustum_get), _SE(js_cc_scene_SpotLight_frustum_set)); 
    cls->defineProperty("shadowEnabled", _SE(js_cc_scene_SpotLight_shadowEnabled_get), _SE(js_cc_scene_SpotLight_shadowEnabled_set)); 
    cls->defineProperty("shadowPcf", _SE(js_cc_scene_SpotLight_shadowPcf_get), _SE(js_cc_scene_SpotLight_shadowPcf_set)); 
    cls->defineProperty("shadowBias", _SE(js_cc_scene_SpotLight_shadowBias_get), _SE(js_cc_scene_SpotLight_shadowBias_set)); 
    cls->defineProperty("shadowNormalBias", _SE(js_cc_scene_SpotLight_shadowNormalBias_get), _SE(js_cc_scene_SpotLight_shadowNormalBias_set)); 
    cls->defineProperty("size", _SE(js_cc_scene_SpotLight_size_get), _SE(js_cc_scene_SpotLight_size_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_SpotLight));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::SpotLight>(cls);
    
    __jsb_cc_scene_SpotLight_proto = cls->getProto();
    __jsb_cc_scene_SpotLight_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_SphereLight_class = nullptr;
se::Object* __jsb_cc_scene_SphereLight_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_SphereLight) 

// js_ctor
static bool js_new_cc_scene_SphereLight(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::SphereLight *result;
    result = (cc::scene::SphereLight *)new cc::scene::SphereLight();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_SphereLight, __jsb_cc_scene_SphereLight_class, js_delete_cc_scene_SphereLight)

static bool js_delete_cc_scene_SphereLight(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_SphereLight) 

static bool js_cc_scene_SphereLight_position_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SphereLight *arg1 = (cc::scene::SphereLight *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SphereLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SphereLight_position_set,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    cc_scene_SphereLight_position_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SphereLight_position_set) 

static bool js_cc_scene_SphereLight_position_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SphereLight *arg1 = (cc::scene::SphereLight *) NULL ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SphereLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Vec3 *) &cc_scene_SphereLight_position_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SphereLight_position_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SphereLight_position_get) 

static bool js_cc_scene_SphereLight_size_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SphereLight *arg1 = (cc::scene::SphereLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SphereLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SphereLight_size_set,2,SWIGTYPE_float"); 
    cc_scene_SphereLight_size_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SphereLight_size_set) 

static bool js_cc_scene_SphereLight_size_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SphereLight *arg1 = (cc::scene::SphereLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SphereLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_SphereLight_size_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SphereLight_size_get) 

static bool js_cc_scene_SphereLight_range_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SphereLight *arg1 = (cc::scene::SphereLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SphereLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SphereLight_range_set,2,SWIGTYPE_float"); 
    cc_scene_SphereLight_range_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SphereLight_range_set) 

static bool js_cc_scene_SphereLight_range_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SphereLight *arg1 = (cc::scene::SphereLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SphereLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_SphereLight_range_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SphereLight_range_get) 

static bool js_cc_scene_SphereLight_luminance_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SphereLight *arg1 = (cc::scene::SphereLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SphereLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SphereLight_luminance_set,2,SWIGTYPE_float"); 
    cc_scene_SphereLight_luminance_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SphereLight_luminance_set) 

static bool js_cc_scene_SphereLight_luminance_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SphereLight *arg1 = (cc::scene::SphereLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SphereLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_SphereLight_luminance_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SphereLight_luminance_get) 

static bool js_cc_scene_SphereLight_luminanceHDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SphereLight *arg1 = (cc::scene::SphereLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SphereLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SphereLight_luminanceHDR_set,2,SWIGTYPE_float"); 
    cc_scene_SphereLight_luminanceHDR_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SphereLight_luminanceHDR_set) 

static bool js_cc_scene_SphereLight_luminanceHDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SphereLight *arg1 = (cc::scene::SphereLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SphereLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_SphereLight_luminanceHDR_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SphereLight_luminanceHDR_get) 

static bool js_cc_scene_SphereLight_luminanceLDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SphereLight *arg1 = (cc::scene::SphereLight *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SphereLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "SphereLight_luminanceLDR_set,2,SWIGTYPE_float"); 
    cc_scene_SphereLight_luminanceLDR_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SphereLight_luminanceLDR_set) 

static bool js_cc_scene_SphereLight_luminanceLDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SphereLight *arg1 = (cc::scene::SphereLight *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SphereLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_SphereLight_luminanceLDR_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SphereLight_luminanceLDR_get) 

static bool js_cc_scene_SphereLight_aabb_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SphereLight *arg1 = (cc::scene::SphereLight *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SphereLight>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::geometry::AABB *) &cc_scene_SphereLight_aabb_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SphereLight_aabb_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SphereLight_aabb_get) 

bool js_register_cc_scene_SphereLight(se::Object* obj) {
    auto* cls = se::Class::create("SphereLight", obj, __jsb_cc_scene_Light_proto, _SE(js_new_cc_scene_SphereLight)); 
    
    cls->defineProperty("position", _SE(js_cc_scene_SphereLight_position_get), _SE(js_cc_scene_SphereLight_position_set)); 
    cls->defineProperty("size", _SE(js_cc_scene_SphereLight_size_get), _SE(js_cc_scene_SphereLight_size_set)); 
    cls->defineProperty("range", _SE(js_cc_scene_SphereLight_range_get), _SE(js_cc_scene_SphereLight_range_set)); 
    cls->defineProperty("luminance", _SE(js_cc_scene_SphereLight_luminance_get), _SE(js_cc_scene_SphereLight_luminance_set)); 
    cls->defineProperty("luminanceHDR", _SE(js_cc_scene_SphereLight_luminanceHDR_get), _SE(js_cc_scene_SphereLight_luminanceHDR_set)); 
    cls->defineProperty("luminanceLDR", _SE(js_cc_scene_SphereLight_luminanceLDR_get), _SE(js_cc_scene_SphereLight_luminanceLDR_set)); 
    cls->defineProperty("aabb", _SE(js_cc_scene_SphereLight_aabb_get), nullptr); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_SphereLight));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::SphereLight>(cls);
    
    __jsb_cc_scene_SphereLight_proto = cls->getProto();
    __jsb_cc_scene_SphereLight_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_InstancedAttributeBlock_class = nullptr;
se::Object* __jsb_cc_scene_InstancedAttributeBlock_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_InstancedAttributeBlock) 

static bool js_cc_scene_IInstancedAttributeBlock_buffer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::InstancedAttributeBlock *arg1 = (cc::scene::InstancedAttributeBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::InstancedAttributeBlock>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->buffer, s.thisObject());
    SE_PRECONDITION2(ok, false, "IInstancedAttributeBlock_buffer_set,2,SWIGTYPE_cc__TypedArrayTempT_uint8_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IInstancedAttributeBlock_buffer_set) 

static bool js_cc_scene_IInstancedAttributeBlock_buffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::InstancedAttributeBlock *arg1 = (cc::scene::InstancedAttributeBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::InstancedAttributeBlock>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->buffer, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IInstancedAttributeBlock_buffer_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->buffer, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IInstancedAttributeBlock_buffer_get) 

static bool js_cc_scene_IInstancedAttributeBlock_views_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::InstancedAttributeBlock *arg1 = (cc::scene::InstancedAttributeBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::InstancedAttributeBlock>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->views, s.thisObject());
    SE_PRECONDITION2(ok, false, "IInstancedAttributeBlock_views_set,2,SWIGTYPE_ccstd__vectorT_cc__TypedArray_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IInstancedAttributeBlock_views_set) 

static bool js_cc_scene_IInstancedAttributeBlock_views_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::InstancedAttributeBlock *arg1 = (cc::scene::InstancedAttributeBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::InstancedAttributeBlock>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->views, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IInstancedAttributeBlock_views_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->views, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IInstancedAttributeBlock_views_get) 

static bool js_cc_scene_IInstancedAttributeBlock_attributes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::InstancedAttributeBlock *arg1 = (cc::scene::InstancedAttributeBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::InstancedAttributeBlock>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->attributes, s.thisObject());
    SE_PRECONDITION2(ok, false, "IInstancedAttributeBlock_attributes_set,2,SWIGTYPE_ccstd__vectorT_cc__gfx__Attribute_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IInstancedAttributeBlock_attributes_set) 

static bool js_cc_scene_IInstancedAttributeBlock_attributes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::InstancedAttributeBlock *arg1 = (cc::scene::InstancedAttributeBlock *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::InstancedAttributeBlock>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->attributes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IInstancedAttributeBlock_attributes_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->attributes, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IInstancedAttributeBlock_attributes_get) 

// js_ctor
static bool js_new_cc_scene_InstancedAttributeBlock(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::InstancedAttributeBlock *result;
    result = (cc::scene::InstancedAttributeBlock *)new cc::scene::InstancedAttributeBlock();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_InstancedAttributeBlock, __jsb_cc_scene_InstancedAttributeBlock_class, js_delete_cc_scene_InstancedAttributeBlock)

static bool js_delete_cc_scene_InstancedAttributeBlock(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_InstancedAttributeBlock) 

template<>
bool sevalue_to_native(const se::Value &from, cc::scene::InstancedAttributeBlock * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::scene::InstancedAttributeBlock*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("buffer", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->buffer), ctx);
    }
    
    
    json->getProperty("views", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->views), ctx);
    }
    
    
    json->getProperty("attributes", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->attributes), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_scene_InstancedAttributeBlock(se::Object* obj) {
    auto* cls = se::Class::create("IInstancedAttributeBlock", obj, nullptr, _SE(js_new_cc_scene_InstancedAttributeBlock)); 
    
    cls->defineProperty("buffer", _SE(js_cc_scene_IInstancedAttributeBlock_buffer_get), _SE(js_cc_scene_IInstancedAttributeBlock_buffer_set)); 
    cls->defineProperty("views", _SE(js_cc_scene_IInstancedAttributeBlock_views_get), _SE(js_cc_scene_IInstancedAttributeBlock_views_set)); 
    cls->defineProperty("attributes", _SE(js_cc_scene_IInstancedAttributeBlock_attributes_get), _SE(js_cc_scene_IInstancedAttributeBlock_attributes_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_InstancedAttributeBlock));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::InstancedAttributeBlock>(cls);
    
    __jsb_cc_scene_InstancedAttributeBlock_proto = cls->getProto();
    __jsb_cc_scene_InstancedAttributeBlock_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_Model_class = nullptr;
se::Object* __jsb_cc_scene_Model_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_Model) 

// js_ctor
static bool js_new_cc_scene_Model(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::Model *result;
    result = (cc::scene::Model *)new cc::scene::Model();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_Model, __jsb_cc_scene_Model_class, js_delete_cc_scene_Model)

static bool js_delete_cc_scene_Model(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_Model) 

static bool js_cc_scene_Model_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_destroy) 

static bool js_cc_scene_Model_initSubModel(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    index_t arg2 ;
    cc::RenderingSubMesh *arg3 = (cc::RenderingSubMesh *) NULL ;
    cc::Material *arg4 = (cc::Material *) NULL ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_initSubModel,2,SWIGTYPE_int32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_initSubModel,3,SWIGTYPE_p_cc__RenderingSubMesh"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_initSubModel,4,SWIGTYPE_p_cc__Material"); 
    (arg1)->initSubModel(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_initSubModel) 

static bool js_cc_scene_Model_getMacroPatches(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    index_t arg2 ;
    ccstd::vector< cc::scene::IMacroPatch > result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_getMacroPatches,2,SWIGTYPE_int32_t"); 
    
    result = (arg1)->getMacroPatches(arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Model_getMacroPatches, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_getMacroPatches) 

static bool js_cc_scene_Model_setSubModelMaterial(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    index_t arg2 ;
    cc::Material *arg3 = (cc::Material *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_setSubModelMaterial,2,SWIGTYPE_int32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_setSubModelMaterial,3,SWIGTYPE_p_cc__Material"); 
    (arg1)->setSubModelMaterial(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_setSubModelMaterial) 

static bool js_cc_scene_Model__updateInstancedAttributes(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    ccstd::vector< cc::gfx::Attribute > *arg2 = 0 ;
    cc::scene::Pass *arg3 = (cc::scene::Pass *) NULL ;
    ccstd::vector< cc::gfx::Attribute > temp2 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model__updateInstancedAttributes,2,SWIGTYPE_p_ccstd__vectorT_cc__gfx__Attribute_t");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model__updateInstancedAttributes,3,SWIGTYPE_p_cc__scene__Pass"); 
    (arg1)->updateInstancedAttributes((ccstd::vector< cc::gfx::Attribute > const &)*arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model__updateInstancedAttributes) 

static bool js_cc_scene_Model_updateTransform(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_updateTransform,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->updateTransform(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_updateTransform) 

static bool js_cc_scene_Model_updateUBOs(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_updateUBOs,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->updateUBOs(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_updateUBOs) 

static bool js_cc_scene_Model__updateLocalDescriptors(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    index_t arg2 ;
    cc::gfx::DescriptorSet *arg3 = (cc::gfx::DescriptorSet *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model__updateLocalDescriptors,2,SWIGTYPE_int32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model__updateLocalDescriptors,3,SWIGTYPE_p_cc__gfx__DescriptorSet"); 
    (arg1)->updateLocalDescriptors(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model__updateLocalDescriptors) 

static bool js_cc_scene_Model_updateWorldBoundDescriptors(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    index_t arg2 ;
    cc::gfx::DescriptorSet *arg3 = (cc::gfx::DescriptorSet *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_updateWorldBoundDescriptors,2,SWIGTYPE_int32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_updateWorldBoundDescriptors,3,SWIGTYPE_p_cc__gfx__DescriptorSet"); 
    (arg1)->updateWorldBoundDescriptors(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_updateWorldBoundDescriptors) 

static bool js_cc_scene_Model_createBoundingShape(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    ccstd::optional< cc::Vec3 > *arg2 = 0 ;
    ccstd::optional< cc::Vec3 > *arg3 = 0 ;
    ccstd::optional< cc::Vec3 > temp2 ;
    ccstd::optional< cc::Vec3 > temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_createBoundingShape,2,SWIGTYPE_p_ccstd__optionalT_cc__Vec3_t");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_createBoundingShape,3,SWIGTYPE_p_ccstd__optionalT_cc__Vec3_t");
    arg3 = &temp3;
    
    (arg1)->createBoundingShape((ccstd::optional< cc::Vec3 > const &)*arg2,(ccstd::optional< cc::Vec3 > const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_createBoundingShape) 

static bool js_cc_scene_Model__getInstancedAttributeIndex(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    int32_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model__getInstancedAttributeIndex,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = ((cc::scene::Model const *)arg1)->getInstancedAttributeIndex((ccstd::string const &)*arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Model__getInstancedAttributeIndex, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model__getInstancedAttributeIndex) 

static bool js_cc_scene_Model_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->initialize();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_initialize) 

static bool js_cc_scene_Model_initLightingmap(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::Texture2D *arg2 = (cc::Texture2D *) NULL ;
    cc::Vec4 *arg3 = 0 ;
    cc::Vec4 temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_initLightingmap,2,SWIGTYPE_p_cc__Texture2D"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_initLightingmap,3,SWIGTYPE_p_cc__Vec4");
    arg3 = &temp3;
    
    (arg1)->initLightingmap(arg2,(cc::Vec4 const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_initLightingmap) 

static bool js_cc_scene_Model__initLocalDescriptors(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    index_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model__initLocalDescriptors,2,SWIGTYPE_int32_t"); 
    
    (arg1)->initLocalDescriptors(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model__initLocalDescriptors) 

static bool js_cc_scene_Model_initWorldBoundDescriptors(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    index_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_initWorldBoundDescriptors,2,SWIGTYPE_int32_t"); 
    
    (arg1)->initWorldBoundDescriptors(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_initWorldBoundDescriptors) 

static bool js_cc_scene_Model_onGlobalPipelineStateChanged(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    ((cc::scene::Model const *)arg1)->onGlobalPipelineStateChanged();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_onGlobalPipelineStateChanged) 

static bool js_cc_scene_Model_onMacroPatchesStateChanged(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onMacroPatchesStateChanged();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_onMacroPatchesStateChanged) 

static bool js_cc_scene_Model_onGeometryChanged(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onGeometryChanged();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_onGeometryChanged) 

static bool js_cc_scene_Model_setSubModelMesh(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    index_t arg2 ;
    cc::RenderingSubMesh *arg3 = (cc::RenderingSubMesh *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_setSubModelMesh,2,SWIGTYPE_int32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_setSubModelMesh,3,SWIGTYPE_p_cc__RenderingSubMesh"); 
    ((cc::scene::Model const *)arg1)->setSubModelMesh(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_setSubModelMesh) 

static bool js_cc_scene_Model_setInstancedAttribute(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    ccstd::string *arg2 = 0 ;
    float *arg3 = (float *) NULL ;
    uint32_t arg4 ;
    ccstd::string temp2 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_setInstancedAttribute,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_setInstancedAttribute,3,SWIGTYPE_p_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_setInstancedAttribute,4,SWIGTYPE_uint32_t"); 
    
    (arg1)->setInstancedAttribute((ccstd::string const &)*arg2,(float const *)arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_setInstancedAttribute) 

static bool js_cc_scene_Model_updateWorldBound(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->updateWorldBound();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_updateWorldBound) 

static bool js_cc_scene_Model_updateWorldBoundsForJSSkinningModel(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_updateWorldBoundsForJSSkinningModel,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_updateWorldBoundsForJSSkinningModel,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    (arg1)->updateWorldBoundsForJSSkinningModel((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_updateWorldBoundsForJSSkinningModel) 

static bool js_cc_scene_Model_updateWorldBoundsForJSBakedSkinningModel(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::geometry::AABB *arg2 = (cc::geometry::AABB *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_updateWorldBoundsForJSBakedSkinningModel,2,SWIGTYPE_p_cc__geometry__AABB"); 
    (arg1)->updateWorldBoundsForJSBakedSkinningModel(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_updateWorldBoundsForJSBakedSkinningModel) 

static bool js_cc_scene_Model_updateLightingmap(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::Texture2D *arg2 = (cc::Texture2D *) NULL ;
    cc::Vec4 *arg3 = 0 ;
    cc::Vec4 temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_updateLightingmap,2,SWIGTYPE_p_cc__Texture2D"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_updateLightingmap,3,SWIGTYPE_p_cc__Vec4");
    arg3 = &temp3;
    
    (arg1)->updateLightingmap(arg2,(cc::Vec4 const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_updateLightingmap) 

static bool js_cc_scene_Model_updateWorldBoundUBOs(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->updateWorldBoundUBOs();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_updateWorldBoundUBOs) 

static bool js_cc_scene_Model_updateLocalShadowBias(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->updateLocalShadowBias();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_updateLocalShadowBias) 

static bool js_cc_scene_Model_attachToScene(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::scene::RenderScene *arg2 = (cc::scene::RenderScene *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_attachToScene,2,SWIGTYPE_p_cc__scene__RenderScene"); 
    (arg1)->attachToScene(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_attachToScene) 

static bool js_cc_scene_Model_detachFromScene(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->detachFromScene();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_detachFromScene) 

static bool js_cc_scene_Model_setInstMatWorldIdx(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    int32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_setInstMatWorldIdx,2,SWIGTYPE_int32_t"); 
    
    (arg1)->setInstMatWorldIdx(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_setInstMatWorldIdx) 

static bool js_cc_scene_Model_setBounds(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::geometry::AABB *arg2 = (cc::geometry::AABB *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_setBounds,2,SWIGTYPE_p_cc__geometry__AABB"); 
    (arg1)->setBounds(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_setBounds) 

static bool js_cc_scene_Model_getInstMatWorldIdx(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    int32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::scene::Model const *)arg1)->getInstMatWorldIdx();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Model_getInstMatWorldIdx, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_getInstMatWorldIdx) 

static bool js_cc_scene_Model_getInstanceAttributes(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    ccstd::vector< cc::gfx::Attribute > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::gfx::Attribute > *) &((cc::scene::Model const *)arg1)->getInstanceAttributes();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Model_getInstanceAttributes, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_getInstanceAttributes) 

static bool js_cc_scene_Model_getInstancedBuffer(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    uint8_t *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (uint8_t *)((cc::scene::Model const *)arg1)->getInstancedBuffer();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Model_getInstancedBuffer, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_getInstancedBuffer) 

static bool js_cc_scene_Model_getInstancedBufferSize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::scene::Model const *)arg1)->getInstancedBufferSize();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Model_getInstancedBufferSize, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_getInstancedBufferSize) 

static bool js_cc_scene_Model_setCalledFromJS(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Model_setCalledFromJS,2,SWIGTYPE_bool"); 
    (arg1)->setCalledFromJS(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_setCalledFromJS) 

static bool js_cc_scene_Model_setInstancedAttributesViewData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    index_t arg2 ;
    index_t arg3 ;
    float arg4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_setInstancedAttributesViewData,2,SWIGTYPE_int32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_setInstancedAttributesViewData,3,SWIGTYPE_int32_t"); 
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Model_setInstancedAttributesViewData,4,SWIGTYPE_float"); 
    (arg1)->setInstancedAttributesViewData(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_setInstancedAttributesViewData) 

static bool js_cc_scene_Model_isModelImplementedInJS(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((cc::scene::Model const *)arg1)->isModelImplementedInJS();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Model_isModelImplementedInJS) 

static bool js_cc_scene_Model_scene_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::scene::RenderScene *arg2 = (cc::scene::RenderScene *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_scene_set,2,SWIGTYPE_p_cc__scene__RenderScene"); 
    cc_scene_Model_scene_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_scene_set) 

static bool js_cc_scene_Model_scene_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::scene::RenderScene *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::RenderScene *)cc_scene_Model_scene_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Model_scene_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_scene_get) 

static bool js_cc_scene_Model__subModels_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::scene::SubModel > > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::IntrusivePtr< cc::scene::SubModel > > *) &cc_scene_Model__subModels_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Model__subModels_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model__subModels_get) 

static bool js_cc_scene_Model_subModels_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::scene::SubModel > > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::IntrusivePtr< cc::scene::SubModel > > *) &cc_scene_Model_subModels_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Model_subModels_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_subModels_get) 

static bool js_cc_scene_Model_inited_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_Model_inited_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_inited_get) 

static bool js_cc_scene_Model__localDataUpdated_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Model__localDataUpdated_set,2,SWIGTYPE_bool"); 
    cc_scene_Model__localDataUpdated_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model__localDataUpdated_set) 

static bool js_cc_scene_Model__localDataUpdated_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_Model__localDataUpdated_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model__localDataUpdated_get) 

static bool js_cc_scene_Model__worldBounds_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::geometry::AABB *arg2 = (cc::geometry::AABB *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model__worldBounds_set,2,SWIGTYPE_p_cc__geometry__AABB"); 
    cc_scene_Model__worldBounds_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model__worldBounds_set) 

static bool js_cc_scene_Model__worldBounds_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::geometry::AABB *)cc_scene_Model__worldBounds_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Model__worldBounds_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model__worldBounds_get) 

static bool js_cc_scene_Model_worldBounds_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::geometry::AABB *arg2 = (cc::geometry::AABB *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_worldBounds_set,2,SWIGTYPE_p_cc__geometry__AABB"); 
    cc_scene_Model_worldBounds_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_worldBounds_set) 

static bool js_cc_scene_Model_worldBounds_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::geometry::AABB *)cc_scene_Model_worldBounds_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Model_worldBounds_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_worldBounds_get) 

static bool js_cc_scene_Model__modelBounds_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::geometry::AABB *arg2 = (cc::geometry::AABB *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model__modelBounds_set,2,SWIGTYPE_p_cc__geometry__AABB"); 
    cc_scene_Model__modelBounds_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model__modelBounds_set) 

static bool js_cc_scene_Model__modelBounds_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::geometry::AABB *)cc_scene_Model__modelBounds_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Model__modelBounds_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model__modelBounds_get) 

static bool js_cc_scene_Model_modelBounds_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::geometry::AABB *arg2 = (cc::geometry::AABB *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_modelBounds_set,2,SWIGTYPE_p_cc__geometry__AABB"); 
    cc_scene_Model_modelBounds_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_modelBounds_set) 

static bool js_cc_scene_Model_modelBounds_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::geometry::AABB *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::geometry::AABB *)cc_scene_Model_modelBounds_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Model_modelBounds_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_modelBounds_get) 

static bool js_cc_scene_Model_worldBoundBuffer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::gfx::Buffer *arg2 = (cc::gfx::Buffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_worldBoundBuffer_set,2,SWIGTYPE_p_cc__gfx__Buffer"); 
    cc_scene_Model_worldBoundBuffer_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_worldBoundBuffer_set) 

static bool js_cc_scene_Model_worldBoundBuffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::gfx::Buffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Buffer *)cc_scene_Model_worldBoundBuffer_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Model_worldBoundBuffer_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_worldBoundBuffer_get) 

static bool js_cc_scene_Model_localBuffer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::gfx::Buffer *arg2 = (cc::gfx::Buffer *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_localBuffer_set,2,SWIGTYPE_p_cc__gfx__Buffer"); 
    cc_scene_Model_localBuffer_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_localBuffer_set) 

static bool js_cc_scene_Model_localBuffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::gfx::Buffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Buffer *)cc_scene_Model_localBuffer_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Model_localBuffer_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_localBuffer_get) 

static bool js_cc_scene_Model_updateStamp_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_scene_Model_updateStamp_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Model_updateStamp_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_updateStamp_get) 

static bool js_cc_scene_Model_isInstancingEnabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_Model_isInstancingEnabled_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_isInstancingEnabled_get) 

static bool js_cc_scene_Model_receiveShadow_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Model_receiveShadow_set,2,SWIGTYPE_bool"); 
    cc_scene_Model_receiveShadow_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_receiveShadow_set) 

static bool js_cc_scene_Model_receiveShadow_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_Model_receiveShadow_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_receiveShadow_get) 

static bool js_cc_scene_Model_castShadow_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Model_castShadow_set,2,SWIGTYPE_bool"); 
    cc_scene_Model_castShadow_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_castShadow_set) 

static bool js_cc_scene_Model_castShadow_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_Model_castShadow_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_castShadow_get) 

static bool js_cc_scene_Model_shadowBias_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Model_shadowBias_set,2,SWIGTYPE_float"); 
    cc_scene_Model_shadowBias_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_shadowBias_set) 

static bool js_cc_scene_Model_shadowBias_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_Model_shadowBias_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_shadowBias_get) 

static bool js_cc_scene_Model_shadowNormalBias_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Model_shadowNormalBias_set,2,SWIGTYPE_float"); 
    cc_scene_Model_shadowNormalBias_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_shadowNormalBias_set) 

static bool js_cc_scene_Model_shadowNormalBias_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_Model_shadowNormalBias_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_shadowNormalBias_get) 

static bool js_cc_scene_Model_node_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_node_set,2,SWIGTYPE_p_cc__Node"); 
    cc_scene_Model_node_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_node_set) 

static bool js_cc_scene_Model_node_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::Node *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Node *)cc_scene_Model_node_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Model_node_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_node_get) 

static bool js_cc_scene_Model_transform_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_transform_set,2,SWIGTYPE_p_cc__Node"); 
    cc_scene_Model_transform_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_transform_set) 

static bool js_cc_scene_Model_transform_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::Node *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Node *)cc_scene_Model_transform_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Model_transform_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_transform_get) 

static bool js_cc_scene_Model_visFlags_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::Layers::Enum arg2 ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "Model_visFlags_set,2,SWIGTYPE_cc__Layers__LayerList");
    arg2 = (cc::Layers::Enum)temp2;
    cc_scene_Model_visFlags_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_visFlags_set) 

static bool js_cc_scene_Model_visFlags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::Layers::Enum result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Layers::Enum)cc_scene_Model_visFlags_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_visFlags_get) 

static bool js_cc_scene_Model_enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Model_enabled_set,2,SWIGTYPE_bool"); 
    cc_scene_Model_enabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_enabled_set) 

static bool js_cc_scene_Model_enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_Model_enabled_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_enabled_get) 

static bool js_cc_scene_Model_type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::scene::Model::Type arg2 ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "Model_type_set,2,SWIGTYPE_cc__scene__Model__Type");
    arg2 = (cc::scene::Model::Type)temp2;
    cc_scene_Model_type_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_type_set) 

static bool js_cc_scene_Model_type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::scene::Model::Type result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::Model::Type)cc_scene_Model_type_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_type_get) 

static bool js_cc_scene_Model_instancedAttributes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::scene::InstancedAttributeBlock *arg2 = 0 ;
    cc::scene::InstancedAttributeBlock temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_instancedAttributes_set,2,SWIGTYPE_p_cc__scene__InstancedAttributeBlock");
    arg2 = &temp2;
    
    cc_scene_Model_instancedAttributes_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_instancedAttributes_set) 

static bool js_cc_scene_Model_instancedAttributes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    cc::scene::InstancedAttributeBlock *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::InstancedAttributeBlock *) &cc_scene_Model_instancedAttributes_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Model_instancedAttributes_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_instancedAttributes_get) 

static bool js_cc_scene_Model_isDynamicBatching_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Model_isDynamicBatching_set,2,SWIGTYPE_bool"); 
    cc_scene_Model_isDynamicBatching_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_isDynamicBatching_set) 

static bool js_cc_scene_Model_isDynamicBatching_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_Model_isDynamicBatching_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_isDynamicBatching_get) 

static bool js_cc_scene_Model_priority_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Model_priority_set,2,SWIGTYPE_uint32_t"); 
    
    cc_scene_Model_priority_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Model_priority_set) 

static bool js_cc_scene_Model_priority_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Model *arg1 = (cc::scene::Model *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Model>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_scene_Model_priority_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Model_priority_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Model_priority_get) 

bool js_register_cc_scene_Model(se::Object* obj) {
    auto* cls = se::Class::create("Model", obj, nullptr, _SE(js_new_cc_scene_Model)); 
    
    cls->defineProperty("scene", _SE(js_cc_scene_Model_scene_get), _SE(js_cc_scene_Model_scene_set)); 
    cls->defineProperty("_subModels", _SE(js_cc_scene_Model__subModels_get), nullptr); 
    cls->defineProperty("subModels", _SE(js_cc_scene_Model_subModels_get), nullptr); 
    cls->defineProperty("inited", _SE(js_cc_scene_Model_inited_get), nullptr); 
    cls->defineProperty("_localDataUpdated", _SE(js_cc_scene_Model__localDataUpdated_get), _SE(js_cc_scene_Model__localDataUpdated_set)); 
    cls->defineProperty("_worldBounds", _SE(js_cc_scene_Model__worldBounds_get), _SE(js_cc_scene_Model__worldBounds_set)); 
    cls->defineProperty("worldBounds", _SE(js_cc_scene_Model_worldBounds_get), _SE(js_cc_scene_Model_worldBounds_set)); 
    cls->defineProperty("_modelBounds", _SE(js_cc_scene_Model__modelBounds_get), _SE(js_cc_scene_Model__modelBounds_set)); 
    cls->defineProperty("modelBounds", _SE(js_cc_scene_Model_modelBounds_get), _SE(js_cc_scene_Model_modelBounds_set)); 
    cls->defineProperty("worldBoundBuffer", _SE(js_cc_scene_Model_worldBoundBuffer_get), _SE(js_cc_scene_Model_worldBoundBuffer_set)); 
    cls->defineProperty("localBuffer", _SE(js_cc_scene_Model_localBuffer_get), _SE(js_cc_scene_Model_localBuffer_set)); 
    cls->defineProperty("updateStamp", _SE(js_cc_scene_Model_updateStamp_get), nullptr); 
    cls->defineProperty("isInstancingEnabled", _SE(js_cc_scene_Model_isInstancingEnabled_get), nullptr); 
    cls->defineProperty("receiveShadow", _SE(js_cc_scene_Model_receiveShadow_get), _SE(js_cc_scene_Model_receiveShadow_set)); 
    cls->defineProperty("castShadow", _SE(js_cc_scene_Model_castShadow_get), _SE(js_cc_scene_Model_castShadow_set)); 
    cls->defineProperty("shadowBias", _SE(js_cc_scene_Model_shadowBias_get), _SE(js_cc_scene_Model_shadowBias_set)); 
    cls->defineProperty("shadowNormalBias", _SE(js_cc_scene_Model_shadowNormalBias_get), _SE(js_cc_scene_Model_shadowNormalBias_set)); 
    cls->defineProperty("node", _SE(js_cc_scene_Model_node_get), _SE(js_cc_scene_Model_node_set)); 
    cls->defineProperty("transform", _SE(js_cc_scene_Model_transform_get), _SE(js_cc_scene_Model_transform_set)); 
    cls->defineProperty("visFlags", _SE(js_cc_scene_Model_visFlags_get), _SE(js_cc_scene_Model_visFlags_set)); 
    cls->defineProperty("enabled", _SE(js_cc_scene_Model_enabled_get), _SE(js_cc_scene_Model_enabled_set)); 
    cls->defineProperty("type", _SE(js_cc_scene_Model_type_get), _SE(js_cc_scene_Model_type_set)); 
    cls->defineProperty("instancedAttributes", _SE(js_cc_scene_Model_instancedAttributes_get), _SE(js_cc_scene_Model_instancedAttributes_set)); 
    cls->defineProperty("isDynamicBatching", _SE(js_cc_scene_Model_isDynamicBatching_get), _SE(js_cc_scene_Model_isDynamicBatching_set)); 
    cls->defineProperty("priority", _SE(js_cc_scene_Model_priority_get), _SE(js_cc_scene_Model_priority_set)); 
    
    cls->defineFunction("destroy", _SE(js_cc_scene_Model_destroy)); 
    cls->defineFunction("initSubModel", _SE(js_cc_scene_Model_initSubModel)); 
    cls->defineFunction("getMacroPatches", _SE(js_cc_scene_Model_getMacroPatches)); 
    cls->defineFunction("setSubModelMaterial", _SE(js_cc_scene_Model_setSubModelMaterial)); 
    cls->defineFunction("_updateInstancedAttributes", _SE(js_cc_scene_Model__updateInstancedAttributes)); 
    cls->defineFunction("updateTransform", _SE(js_cc_scene_Model_updateTransform)); 
    cls->defineFunction("updateUBOs", _SE(js_cc_scene_Model_updateUBOs)); 
    cls->defineFunction("_updateLocalDescriptors", _SE(js_cc_scene_Model__updateLocalDescriptors)); 
    cls->defineFunction("updateWorldBoundDescriptors", _SE(js_cc_scene_Model_updateWorldBoundDescriptors)); 
    cls->defineFunction("createBoundingShape", _SE(js_cc_scene_Model_createBoundingShape)); 
    cls->defineFunction("_getInstancedAttributeIndex", _SE(js_cc_scene_Model__getInstancedAttributeIndex)); 
    cls->defineFunction("initialize", _SE(js_cc_scene_Model_initialize)); 
    cls->defineFunction("initLightingmap", _SE(js_cc_scene_Model_initLightingmap)); 
    cls->defineFunction("_initLocalDescriptors", _SE(js_cc_scene_Model__initLocalDescriptors)); 
    cls->defineFunction("initWorldBoundDescriptors", _SE(js_cc_scene_Model_initWorldBoundDescriptors)); 
    cls->defineFunction("onGlobalPipelineStateChanged", _SE(js_cc_scene_Model_onGlobalPipelineStateChanged)); 
    cls->defineFunction("onMacroPatchesStateChanged", _SE(js_cc_scene_Model_onMacroPatchesStateChanged)); 
    cls->defineFunction("onGeometryChanged", _SE(js_cc_scene_Model_onGeometryChanged)); 
    cls->defineFunction("setSubModelMesh", _SE(js_cc_scene_Model_setSubModelMesh)); 
    cls->defineFunction("setInstancedAttribute", _SE(js_cc_scene_Model_setInstancedAttribute)); 
    cls->defineFunction("updateWorldBound", _SE(js_cc_scene_Model_updateWorldBound)); 
    cls->defineFunction("updateWorldBoundsForJSSkinningModel", _SE(js_cc_scene_Model_updateWorldBoundsForJSSkinningModel)); 
    cls->defineFunction("updateWorldBoundsForJSBakedSkinningModel", _SE(js_cc_scene_Model_updateWorldBoundsForJSBakedSkinningModel)); 
    cls->defineFunction("updateLightingmap", _SE(js_cc_scene_Model_updateLightingmap)); 
    cls->defineFunction("updateWorldBoundUBOs", _SE(js_cc_scene_Model_updateWorldBoundUBOs)); 
    cls->defineFunction("updateLocalShadowBias", _SE(js_cc_scene_Model_updateLocalShadowBias)); 
    cls->defineFunction("attachToScene", _SE(js_cc_scene_Model_attachToScene)); 
    cls->defineFunction("detachFromScene", _SE(js_cc_scene_Model_detachFromScene)); 
    cls->defineFunction("setInstMatWorldIdx", _SE(js_cc_scene_Model_setInstMatWorldIdx)); 
    cls->defineFunction("setBounds", _SE(js_cc_scene_Model_setBounds)); 
    cls->defineFunction("getInstMatWorldIdx", _SE(js_cc_scene_Model_getInstMatWorldIdx)); 
    cls->defineFunction("getInstanceAttributes", _SE(js_cc_scene_Model_getInstanceAttributes)); 
    cls->defineFunction("getInstancedBuffer", _SE(js_cc_scene_Model_getInstancedBuffer)); 
    cls->defineFunction("getInstancedBufferSize", _SE(js_cc_scene_Model_getInstancedBufferSize)); 
    cls->defineFunction("setCalledFromJS", _SE(js_cc_scene_Model_setCalledFromJS)); 
    cls->defineFunction("setInstancedAttributesViewData", _SE(js_cc_scene_Model_setInstancedAttributesViewData)); 
    cls->defineFunction("isModelImplementedInJS", _SE(js_cc_scene_Model_isModelImplementedInJS)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_Model));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::Model>(cls);
    
    __jsb_cc_scene_Model_proto = cls->getProto();
    __jsb_cc_scene_Model_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_SubModel_class = nullptr;
se::Object* __jsb_cc_scene_SubModel_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_SubModel) 

// js_ctor
static bool js_new_cc_scene_SubModel(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::SubModel *result;
    result = (cc::scene::SubModel *)new cc::scene::SubModel();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_SubModel, __jsb_cc_scene_SubModel_class, js_delete_cc_scene_SubModel)

static bool js_delete_cc_scene_SubModel(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_SubModel) 

static bool js_cc_scene_SubModel_update(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->update();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_update) 

static bool js_cc_scene_SubModel_getShader(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Shader *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubModel_getShader,2,SWIGTYPE_uint32_t"); 
    
    result = (cc::gfx::Shader *)((cc::scene::SubModel const *)arg1)->getShader(arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubModel_getShader, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_getShader) 

static bool js_cc_scene_SubModel_getPass(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    uint32_t arg2 ;
    cc::scene::Pass *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubModel_getPass,2,SWIGTYPE_uint32_t"); 
    
    result = (cc::scene::Pass *)((cc::scene::SubModel const *)arg1)->getPass(arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubModel_getPass, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_getPass) 

static bool js_cc_scene_SubModel_setWorldBoundDescriptorSet(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::gfx::DescriptorSet *arg2 = (cc::gfx::DescriptorSet *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubModel_setWorldBoundDescriptorSet,2,SWIGTYPE_p_cc__gfx__DescriptorSet"); 
    (arg1)->setWorldBoundDescriptorSet(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_setWorldBoundDescriptorSet) 

static bool js_cc_scene_SubModel_setOwner(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::scene::Model *arg2 = (cc::scene::Model *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubModel_setOwner,2,SWIGTYPE_p_cc__scene__Model"); 
    (arg1)->setOwner(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_setOwner) 

static bool js_cc_scene_SubModel_getWorldBoundDescriptorSet(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::gfx::DescriptorSet *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::DescriptorSet *)((cc::scene::SubModel const *)arg1)->getWorldBoundDescriptorSet();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubModel_getWorldBoundDescriptorSet, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_getWorldBoundDescriptorSet) 

static bool js_cc_scene_SubModel_getOwner(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::scene::Model *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::Model *)((cc::scene::SubModel const *)arg1)->getOwner();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubModel_getOwner, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_getOwner) 

static bool js_cc_scene_SubModel_getId(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::scene::SubModel const *)arg1)->getId();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubModel_getId, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_getId) 

static bool js_cc_scene_SubModel_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::RenderingSubMesh *arg2 = (cc::RenderingSubMesh *) NULL ;
    std::shared_ptr< ccstd::vector< cc::IntrusivePtr< cc::scene::Pass > > > *arg3 = 0 ;
    ccstd::vector< cc::scene::IMacroPatch > *arg4 = 0 ;
    std::shared_ptr< ccstd::vector< cc::IntrusivePtr< cc::scene::Pass > > > temp3 ;
    ccstd::vector< cc::scene::IMacroPatch > temp4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubModel_initialize,2,SWIGTYPE_p_cc__RenderingSubMesh"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubModel_initialize,3,SWIGTYPE_p_std__shared_ptrT_ccstd__vectorT_cc__IntrusivePtrT_cc__scene__Pass_t_t_t");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubModel_initialize,4,SWIGTYPE_p_ccstd__vectorT_cc__scene__IMacroPatch_t");
    arg4 = &temp4;
    
    (arg1)->initialize(arg2,(std::shared_ptr< ccstd::vector< cc::IntrusivePtr< cc::scene::Pass > > > const &)*arg3,(ccstd::vector< cc::scene::IMacroPatch > const &)*arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_initialize) 

static bool js_cc_scene_SubModel_initPlanarShadowShader(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->initPlanarShadowShader();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_initPlanarShadowShader) 

static bool js_cc_scene_SubModel_initPlanarShadowInstanceShader(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->initPlanarShadowInstanceShader();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_initPlanarShadowInstanceShader) 

static bool js_cc_scene_SubModel_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_destroy) 

static bool js_cc_scene_SubModel_onPipelineStateChanged(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onPipelineStateChanged();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_onPipelineStateChanged) 

static bool js_cc_scene_SubModel_onMacroPatchesStateChanged(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    ccstd::vector< cc::scene::IMacroPatch > *arg2 = 0 ;
    ccstd::vector< cc::scene::IMacroPatch > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubModel_onMacroPatchesStateChanged,2,SWIGTYPE_p_ccstd__vectorT_cc__scene__IMacroPatch_t");
    arg2 = &temp2;
    
    (arg1)->onMacroPatchesStateChanged((ccstd::vector< cc::scene::IMacroPatch > const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_onMacroPatchesStateChanged) 

static bool js_cc_scene_SubModel_onGeometryChanged(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onGeometryChanged();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_SubModel_onGeometryChanged) 

static bool js_cc_scene_SubModel_passes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    std::shared_ptr< ccstd::vector< cc::IntrusivePtr< cc::scene::Pass > > > *arg2 = 0 ;
    std::shared_ptr< ccstd::vector< cc::IntrusivePtr< cc::scene::Pass > > > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubModel_passes_set,2,SWIGTYPE_p_std__shared_ptrT_ccstd__vectorT_cc__IntrusivePtrT_cc__scene__Pass_t_t_t");
    arg2 = &temp2;
    
    cc_scene_SubModel_passes_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SubModel_passes_set) 

static bool js_cc_scene_SubModel_passes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    std::shared_ptr< ccstd::vector< cc::IntrusivePtr< cc::scene::Pass > > > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (std::shared_ptr< ccstd::vector< cc::IntrusivePtr< cc::scene::Pass > > > *) &cc_scene_SubModel_passes_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubModel_passes_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SubModel_passes_get) 

static bool js_cc_scene_SubModel_shaders_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::gfx::Shader > > *arg2 = 0 ;
    ccstd::vector< cc::IntrusivePtr< cc::gfx::Shader > > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubModel_shaders_set,2,SWIGTYPE_p_ccstd__vectorT_cc__IntrusivePtrT_cc__gfx__Shader_t_t");
    arg2 = &temp2;
    
    cc_scene_SubModel_shaders_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SubModel_shaders_set) 

static bool js_cc_scene_SubModel_shaders_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::gfx::Shader > > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::IntrusivePtr< cc::gfx::Shader > > *) &cc_scene_SubModel_shaders_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubModel_shaders_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SubModel_shaders_get) 

static bool js_cc_scene_SubModel_subMesh_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::RenderingSubMesh *arg2 = (cc::RenderingSubMesh *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubModel_subMesh_set,2,SWIGTYPE_p_cc__RenderingSubMesh"); 
    cc_scene_SubModel_subMesh_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SubModel_subMesh_set) 

static bool js_cc_scene_SubModel_subMesh_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::RenderingSubMesh *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::RenderingSubMesh *)cc_scene_SubModel_subMesh_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubModel_subMesh_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SubModel_subMesh_get) 

static bool js_cc_scene_SubModel_priority_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::pipeline::RenderPriority arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubModel_priority_set,2,SWIGTYPE_cc__pipeline__RenderPriority"); 
    
    cc_scene_SubModel_priority_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SubModel_priority_set) 

static bool js_cc_scene_SubModel_priority_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::pipeline::RenderPriority result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_scene_SubModel_priority_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubModel_priority_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SubModel_priority_get) 

static bool js_cc_scene_SubModel_inputAssembler_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::gfx::InputAssembler *arg2 = (cc::gfx::InputAssembler *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubModel_inputAssembler_set,2,SWIGTYPE_p_cc__gfx__InputAssembler"); 
    cc_scene_SubModel_inputAssembler_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SubModel_inputAssembler_set) 

static bool js_cc_scene_SubModel_inputAssembler_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::gfx::InputAssembler *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::InputAssembler *)cc_scene_SubModel_inputAssembler_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubModel_inputAssembler_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SubModel_inputAssembler_get) 

static bool js_cc_scene_SubModel_descriptorSet_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::gfx::DescriptorSet *arg2 = (cc::gfx::DescriptorSet *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubModel_descriptorSet_set,2,SWIGTYPE_p_cc__gfx__DescriptorSet"); 
    cc_scene_SubModel_descriptorSet_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SubModel_descriptorSet_set) 

static bool js_cc_scene_SubModel_descriptorSet_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::gfx::DescriptorSet *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::DescriptorSet *)cc_scene_SubModel_descriptorSet_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubModel_descriptorSet_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SubModel_descriptorSet_get) 

static bool js_cc_scene_SubModel_patches_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    ccstd::vector< cc::scene::IMacroPatch > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::scene::IMacroPatch > *) &cc_scene_SubModel_patches_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubModel_patches_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SubModel_patches_get) 

static bool js_cc_scene_SubModel_planarInstanceShader_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::gfx::Shader *arg2 = (cc::gfx::Shader *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubModel_planarInstanceShader_set,2,SWIGTYPE_p_cc__gfx__Shader"); 
    cc_scene_SubModel_planarInstanceShader_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SubModel_planarInstanceShader_set) 

static bool js_cc_scene_SubModel_planarInstanceShader_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::gfx::Shader *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Shader *)cc_scene_SubModel_planarInstanceShader_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubModel_planarInstanceShader_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SubModel_planarInstanceShader_get) 

static bool js_cc_scene_SubModel_planarShader_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::gfx::Shader *arg2 = (cc::gfx::Shader *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SubModel_planarShader_set,2,SWIGTYPE_p_cc__gfx__Shader"); 
    cc_scene_SubModel_planarShader_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_SubModel_planarShader_set) 

static bool js_cc_scene_SubModel_planarShader_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::SubModel *arg1 = (cc::scene::SubModel *) NULL ;
    cc::gfx::Shader *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::SubModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Shader *)cc_scene_SubModel_planarShader_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "SubModel_planarShader_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_SubModel_planarShader_get) 

bool js_register_cc_scene_SubModel(se::Object* obj) {
    auto* cls = se::Class::create("SubModel", obj, nullptr, _SE(js_new_cc_scene_SubModel)); 
    
    cls->defineProperty("passes", _SE(js_cc_scene_SubModel_passes_get), _SE(js_cc_scene_SubModel_passes_set)); 
    cls->defineProperty("shaders", _SE(js_cc_scene_SubModel_shaders_get), _SE(js_cc_scene_SubModel_shaders_set)); 
    cls->defineProperty("subMesh", _SE(js_cc_scene_SubModel_subMesh_get), _SE(js_cc_scene_SubModel_subMesh_set)); 
    cls->defineProperty("priority", _SE(js_cc_scene_SubModel_priority_get), _SE(js_cc_scene_SubModel_priority_set)); 
    cls->defineProperty("inputAssembler", _SE(js_cc_scene_SubModel_inputAssembler_get), _SE(js_cc_scene_SubModel_inputAssembler_set)); 
    cls->defineProperty("descriptorSet", _SE(js_cc_scene_SubModel_descriptorSet_get), _SE(js_cc_scene_SubModel_descriptorSet_set)); 
    cls->defineProperty("patches", _SE(js_cc_scene_SubModel_patches_get), nullptr); 
    cls->defineProperty("planarInstanceShader", _SE(js_cc_scene_SubModel_planarInstanceShader_get), _SE(js_cc_scene_SubModel_planarInstanceShader_set)); 
    cls->defineProperty("planarShader", _SE(js_cc_scene_SubModel_planarShader_get), _SE(js_cc_scene_SubModel_planarShader_set)); 
    
    cls->defineFunction("update", _SE(js_cc_scene_SubModel_update)); 
    cls->defineFunction("getShader", _SE(js_cc_scene_SubModel_getShader)); 
    cls->defineFunction("getPass", _SE(js_cc_scene_SubModel_getPass)); 
    cls->defineFunction("setWorldBoundDescriptorSet", _SE(js_cc_scene_SubModel_setWorldBoundDescriptorSet)); 
    cls->defineFunction("setOwner", _SE(js_cc_scene_SubModel_setOwner)); 
    cls->defineFunction("getWorldBoundDescriptorSet", _SE(js_cc_scene_SubModel_getWorldBoundDescriptorSet)); 
    cls->defineFunction("getOwner", _SE(js_cc_scene_SubModel_getOwner)); 
    cls->defineFunction("getId", _SE(js_cc_scene_SubModel_getId)); 
    cls->defineFunction("initialize", _SE(js_cc_scene_SubModel_initialize)); 
    cls->defineFunction("initPlanarShadowShader", _SE(js_cc_scene_SubModel_initPlanarShadowShader)); 
    cls->defineFunction("initPlanarShadowInstanceShader", _SE(js_cc_scene_SubModel_initPlanarShadowInstanceShader)); 
    cls->defineFunction("destroy", _SE(js_cc_scene_SubModel_destroy)); 
    cls->defineFunction("onPipelineStateChanged", _SE(js_cc_scene_SubModel_onPipelineStateChanged)); 
    cls->defineFunction("onMacroPatchesStateChanged", _SE(js_cc_scene_SubModel_onMacroPatchesStateChanged)); 
    cls->defineFunction("onGeometryChanged", _SE(js_cc_scene_SubModel_onGeometryChanged)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_SubModel));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::SubModel>(cls);
    
    __jsb_cc_scene_SubModel_proto = cls->getProto();
    __jsb_cc_scene_SubModel_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_PassDynamicsValue_class = nullptr;
se::Object* __jsb_cc_scene_PassDynamicsValue_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_PassDynamicsValue) 

static bool js_cc_scene_PassDynamicsValue_dirty_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::PassDynamicsValue *arg1 = (cc::scene::PassDynamicsValue *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::PassDynamicsValue>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->dirty);
    SE_PRECONDITION2(ok, false, "PassDynamicsValue_dirty_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_PassDynamicsValue_dirty_set) 

static bool js_cc_scene_PassDynamicsValue_dirty_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::PassDynamicsValue *arg1 = (cc::scene::PassDynamicsValue *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::PassDynamicsValue>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->dirty, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_PassDynamicsValue_dirty_get) 

static bool js_cc_scene_PassDynamicsValue_value_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::PassDynamicsValue *arg1 = (cc::scene::PassDynamicsValue *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::PassDynamicsValue>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->value, nullptr);
    SE_PRECONDITION2(ok, false, "PassDynamicsValue_value_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_PassDynamicsValue_value_set) 

static bool js_cc_scene_PassDynamicsValue_value_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::PassDynamicsValue *arg1 = (cc::scene::PassDynamicsValue *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::PassDynamicsValue>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->value, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_PassDynamicsValue_value_get) 

// js_ctor
static bool js_new_cc_scene_PassDynamicsValue(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::PassDynamicsValue *result;
    result = (cc::scene::PassDynamicsValue *)new cc::scene::PassDynamicsValue();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_PassDynamicsValue, __jsb_cc_scene_PassDynamicsValue_class, js_delete_cc_scene_PassDynamicsValue)

static bool js_delete_cc_scene_PassDynamicsValue(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_PassDynamicsValue) 

template<>
bool sevalue_to_native(const se::Value &from, cc::scene::PassDynamicsValue * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::scene::PassDynamicsValue*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("dirty", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dirty), ctx);
    }
    
    
    json->getProperty("value", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->value), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_scene_PassDynamicsValue(se::Object* obj) {
    auto* cls = se::Class::create("PassDynamicsValue", obj, nullptr, _SE(js_new_cc_scene_PassDynamicsValue)); 
    
    cls->defineProperty("dirty", _SE(js_cc_scene_PassDynamicsValue_dirty_get), _SE(js_cc_scene_PassDynamicsValue_dirty_set)); 
    cls->defineProperty("value", _SE(js_cc_scene_PassDynamicsValue_value_get), _SE(js_cc_scene_PassDynamicsValue_value_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_PassDynamicsValue));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::PassDynamicsValue>(cls);
    
    __jsb_cc_scene_PassDynamicsValue_proto = cls->getProto();
    __jsb_cc_scene_PassDynamicsValue_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_IBlockRef_class = nullptr;
se::Object* __jsb_cc_scene_IBlockRef_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_IBlockRef) 

static bool js_cc_scene_IBlockRef_data_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::IBlockRef *arg1 = (cc::scene::IBlockRef *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IBlockRef>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->data, s.thisObject());
    SE_PRECONDITION2(ok, false, "IBlockRef_data_set,2,SWIGTYPE_p_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IBlockRef_data_set) 

static bool js_cc_scene_IBlockRef_data_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::IBlockRef *arg1 = (cc::scene::IBlockRef *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IBlockRef>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->data, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IBlockRef_data_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->data, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IBlockRef_data_get) 

static bool js_cc_scene_IBlockRef_count_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::IBlockRef *arg1 = (cc::scene::IBlockRef *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IBlockRef>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg1->count, nullptr);
    SE_PRECONDITION2(ok, false, "IBlockRef_count_set,2,SWIGTYPE_size_t");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IBlockRef_count_set) 

static bool js_cc_scene_IBlockRef_count_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::IBlockRef *arg1 = (cc::scene::IBlockRef *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IBlockRef>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->count, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IBlockRef_count_get) 

static bool js_cc_scene_IBlockRef_offset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::IBlockRef *arg1 = (cc::scene::IBlockRef *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IBlockRef>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) unsigned int, unsigned short, unsigned long, unsigned char
    ok &= sevalue_to_native(args[0], &arg1->offset, nullptr);
    SE_PRECONDITION2(ok, false, "IBlockRef_offset_set,2,SWIGTYPE_size_t");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IBlockRef_offset_set) 

static bool js_cc_scene_IBlockRef_offset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::IBlockRef *arg1 = (cc::scene::IBlockRef *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IBlockRef>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->offset, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IBlockRef_offset_get) 

// js_ctor
static bool js_new_cc_scene_IBlockRef(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::IBlockRef *result;
    result = (cc::scene::IBlockRef *)new cc::scene::IBlockRef();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_IBlockRef, __jsb_cc_scene_IBlockRef_class, js_delete_cc_scene_IBlockRef)

static bool js_delete_cc_scene_IBlockRef(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_IBlockRef) 

template<>
bool sevalue_to_native(const se::Value &from, cc::scene::IBlockRef * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::scene::IBlockRef*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("data", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->data), ctx);
    }
    
    
    json->getProperty("count", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->count), ctx);
    }
    
    
    json->getProperty("offset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->offset), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_scene_IBlockRef(se::Object* obj) {
    auto* cls = se::Class::create("IBlockRef", obj, nullptr, _SE(js_new_cc_scene_IBlockRef)); 
    
    cls->defineProperty("data", _SE(js_cc_scene_IBlockRef_data_get), _SE(js_cc_scene_IBlockRef_data_set)); 
    cls->defineProperty("count", _SE(js_cc_scene_IBlockRef_count_get), _SE(js_cc_scene_IBlockRef_count_set)); 
    cls->defineProperty("offset", _SE(js_cc_scene_IBlockRef_offset_get), _SE(js_cc_scene_IBlockRef_offset_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_IBlockRef));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::IBlockRef>(cls);
    
    __jsb_cc_scene_IBlockRef_proto = cls->getProto();
    __jsb_cc_scene_IBlockRef_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_Pass_class = nullptr;
se::Object* __jsb_cc_scene_Pass_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_Pass) 

static bool js_cc_scene_Pass_getTypeFromHandle_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    uint32_t arg1 ;
    cc::gfx::Type result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_getTypeFromHandle,1,SWIGTYPE_uint32_t"); 
    
    result = cc::scene::Pass::getTypeFromHandle(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_getTypeFromHandle, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_getTypeFromHandle_static) 

static bool js_cc_scene_Pass_getBindingFromHandle_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    uint32_t arg1 ;
    uint32_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_getBindingFromHandle,1,SWIGTYPE_uint32_t"); 
    
    result = cc::scene::Pass::getBindingFromHandle(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_getBindingFromHandle, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_getBindingFromHandle_static) 

static bool js_cc_scene_Pass_getCountFromHandle_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    uint32_t arg1 ;
    uint32_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_getCountFromHandle,1,SWIGTYPE_uint32_t"); 
    
    result = cc::scene::Pass::getCountFromHandle(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_getCountFromHandle, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_getCountFromHandle_static) 

static bool js_cc_scene_Pass_getOffsetFromHandle_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    uint32_t arg1 ;
    uint32_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_getOffsetFromHandle,1,SWIGTYPE_uint32_t"); 
    
    result = cc::scene::Pass::getOffsetFromHandle(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_getOffsetFromHandle, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_getOffsetFromHandle_static) 

static bool js_cc_scene_Pass_fillPipelineInfo_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::IPassInfoFull *arg2 = 0 ;
    cc::IPassInfoFull temp2 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_fillPipelineInfo,1,SWIGTYPE_p_cc__scene__Pass"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_fillPipelineInfo,2,SWIGTYPE_p_cc__IPassInfoFull");
    arg2 = &temp2;
    
    cc::scene::Pass::fillPipelineInfo(arg1,(cc::IPassInfoFull const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_fillPipelineInfo_static) 

static bool js_cc_scene_Pass_getPassHash_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    ccstd::hash_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_getPassHash,1,SWIGTYPE_p_cc__scene__Pass"); 
    result = cc::scene::Pass::getPassHash(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_getPassHash, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_getPassHash_static) 

static bool js_new_cc_scene_Pass__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::scene::Pass *result;
    result = (cc::scene::Pass *)new cc::scene::Pass();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_scene_Pass__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::scene::Pass *result;
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Pass,1,SWIGTYPE_p_cc__Root"); 
    result = (cc::scene::Pass *)new cc::scene::Pass(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_Pass(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_ctor_dispatcher
    size_t argc = s.args().size();
    bool ret = false;
    
    // switch all cases by means of series of if-returns.
    
    // js_ctor_dispatch_case
    if(argc == 0) {
        ret = js_new_cc_scene_Pass__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_scene_Pass__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    
    // default:
    SE_REPORT_ERROR("Illegal arguments for construction of Pass");
    return false;
}
SE_BIND_CTOR(js_new_Pass, __jsb_cc_scene_Pass_class, js_delete_cc_scene_Pass)

static bool js_delete_cc_scene_Pass(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_Pass) 

static bool js_cc_scene_Pass_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::IPassInfoFull *arg2 = 0 ;
    cc::IPassInfoFull temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_initialize,2,SWIGTYPE_p_cc__IPassInfoFull");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::IPassInfoFull const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_initialize) 

static bool js_cc_scene_Pass_getHandle__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    ccstd::string *arg2 = 0 ;
    uint32_t arg3 ;
    cc::gfx::Type arg4 ;
    ccstd::string temp2 ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_getHandle,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_getHandle,3,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_getHandle,4,SWIGTYPE_cc__gfx__Type"); 
    
    result = ((cc::scene::Pass const *)arg1)->getHandle((ccstd::string const &)*arg2,arg3,arg4);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_getHandle, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_scene_Pass_getHandle__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    ccstd::string *arg2 = 0 ;
    uint32_t arg3 ;
    ccstd::string temp2 ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_getHandle,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_getHandle,3,SWIGTYPE_uint32_t"); 
    
    result = ((cc::scene::Pass const *)arg1)->getHandle((ccstd::string const &)*arg2,arg3);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_getHandle, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_scene_Pass_getHandle__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_getHandle,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = ((cc::scene::Pass const *)arg1)->getHandle((ccstd::string const &)*arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_getHandle, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_scene_Pass_getHandle(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_scene_Pass_getHandle__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_scene_Pass_getHandle__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_scene_Pass_getHandle__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_scene_Pass_getHandle) 

static bool js_cc_scene_Pass_getBinding(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    uint32_t result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_getBinding,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = ((cc::scene::Pass const *)arg1)->getBinding((ccstd::string const &)*arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_getBinding, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_getBinding) 

static bool js_cc_scene_Pass_setUniform(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    uint32_t arg2 ;
    cc::MaterialProperty *arg3 = 0 ;
    cc::MaterialProperty temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_setUniform,2,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_setUniform,3,SWIGTYPE_p_ccstd__variantT_ccstd__monostate_float_int32_t_cc__Vec2_cc__Vec3_cc__Vec4_cc__Color_cc__Mat3_cc__Mat4_cc__Quaternion_cc__IntrusivePtrT_cc__TextureBase_t_cc__IntrusivePtrT_cc__gfx__Texture_t_t");
    arg3 = &temp3;
    
    (arg1)->setUniform(arg2,(cc::MaterialProperty const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_setUniform) 

static bool js_cc_scene_Pass_getUniform(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    uint32_t arg2 ;
    cc::MaterialProperty *arg3 = 0 ;
    cc::MaterialProperty temp3 ;
    cc::MaterialProperty *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_getUniform,2,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_getUniform,3,SWIGTYPE_p_ccstd__variantT_ccstd__monostate_float_int32_t_cc__Vec2_cc__Vec3_cc__Vec4_cc__Color_cc__Mat3_cc__Mat4_cc__Quaternion_cc__IntrusivePtrT_cc__TextureBase_t_cc__IntrusivePtrT_cc__gfx__Texture_t_t");
    arg3 = &temp3;
    
    result = (cc::MaterialProperty *) &((cc::scene::Pass const *)arg1)->getUniform(arg2,*arg3);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_getUniform, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_getUniform) 

static bool js_cc_scene_Pass_setUniformArray(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    uint32_t arg2 ;
    cc::MaterialPropertyList *arg3 = 0 ;
    cc::MaterialPropertyList temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_setUniformArray,2,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_setUniformArray,3,SWIGTYPE_p_ccstd__vectorT_cc__MaterialProperty_t");
    arg3 = &temp3;
    
    (arg1)->setUniformArray(arg2,(cc::MaterialPropertyList const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_setUniformArray) 

static bool js_cc_scene_Pass_bindTexture__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Texture *arg3 = (cc::gfx::Texture *) NULL ;
    uint32_t arg4 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_bindTexture,2,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_bindTexture,3,SWIGTYPE_p_cc__gfx__Texture"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_bindTexture,4,SWIGTYPE_uint32_t"); 
    
    (arg1)->bindTexture(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_scene_Pass_bindTexture__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Texture *arg3 = (cc::gfx::Texture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_bindTexture,2,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_bindTexture,3,SWIGTYPE_p_cc__gfx__Texture"); 
    (arg1)->bindTexture(arg2,arg3);
    
    
    return true;
}

static bool js_cc_scene_Pass_bindTexture(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_scene_Pass_bindTexture__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_scene_Pass_bindTexture__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_scene_Pass_bindTexture) 

static bool js_cc_scene_Pass_bindSampler__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Sampler *arg3 = (cc::gfx::Sampler *) NULL ;
    uint32_t arg4 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_bindSampler,2,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_bindSampler,3,SWIGTYPE_p_cc__gfx__Sampler"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_bindSampler,4,SWIGTYPE_uint32_t"); 
    
    (arg1)->bindSampler(arg2,arg3,arg4);
    
    
    return true;
}

static bool js_cc_scene_Pass_bindSampler__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    uint32_t arg2 ;
    cc::gfx::Sampler *arg3 = (cc::gfx::Sampler *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_bindSampler,2,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_bindSampler,3,SWIGTYPE_p_cc__gfx__Sampler"); 
    (arg1)->bindSampler(arg2,arg3);
    
    
    return true;
}

static bool js_cc_scene_Pass_bindSampler(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_scene_Pass_bindSampler__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_scene_Pass_bindSampler__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_scene_Pass_bindSampler) 

static bool js_cc_scene_Pass_setDynamicState(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::gfx::DynamicStateFlagBit arg2 ;
    float arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_setDynamicState,2,SWIGTYPE_cc__gfx__DynamicStateFlagBit"); 
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Pass_setDynamicState,3,SWIGTYPE_float"); 
    (arg1)->setDynamicState(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_setDynamicState) 

static bool js_cc_scene_Pass_overridePipelineStates(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::IPassInfo *arg2 = 0 ;
    cc::PassOverrides *arg3 = 0 ;
    cc::IPassInfo temp2 ;
    cc::PassOverrides temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_overridePipelineStates,2,SWIGTYPE_p_cc__IPassInfoFull");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_overridePipelineStates,3,SWIGTYPE_p_cc__IPassStates");
    arg3 = &temp3;
    
    (arg1)->overridePipelineStates((cc::IPassInfo const &)*arg2,(cc::PassOverrides const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_overridePipelineStates) 

static bool js_cc_scene_Pass_update(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->update();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_update) 

static bool js_cc_scene_Pass_getInstancedBuffer__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    int32_t arg2 ;
    cc::pipeline::InstancedBuffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_getInstancedBuffer,2,SWIGTYPE_int32_t"); 
    
    result = (cc::pipeline::InstancedBuffer *)(arg1)->getInstancedBuffer(arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_getInstancedBuffer, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_scene_Pass_getInstancedBuffer__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::pipeline::InstancedBuffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::pipeline::InstancedBuffer *)(arg1)->getInstancedBuffer();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_getInstancedBuffer, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_scene_Pass_getInstancedBuffer(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_scene_Pass_getInstancedBuffer__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 0) {
        ok = js_cc_scene_Pass_getInstancedBuffer__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_scene_Pass_getInstancedBuffer) 

static bool js_cc_scene_Pass_getBatchedBuffer__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    int32_t arg2 ;
    cc::pipeline::BatchedBuffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_getBatchedBuffer,2,SWIGTYPE_int32_t"); 
    
    result = (cc::pipeline::BatchedBuffer *)(arg1)->getBatchedBuffer(arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_getBatchedBuffer, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_scene_Pass_getBatchedBuffer__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::pipeline::BatchedBuffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::pipeline::BatchedBuffer *)(arg1)->getBatchedBuffer();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_getBatchedBuffer, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_scene_Pass_getBatchedBuffer(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_scene_Pass_getBatchedBuffer__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 0) {
        ok = js_cc_scene_Pass_getBatchedBuffer__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_scene_Pass_getBatchedBuffer) 

static bool js_cc_scene_Pass_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_destroy) 

static bool js_cc_scene_Pass_resetUniform(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_resetUniform,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    (arg1)->resetUniform((ccstd::string const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_resetUniform) 

static bool js_cc_scene_Pass_resetTexture__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_resetTexture,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    (arg1)->resetTexture((ccstd::string const &)*arg2);
    
    
    return true;
}

static bool js_cc_scene_Pass_resetTexture__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    ccstd::string *arg2 = 0 ;
    uint32_t arg3 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_resetTexture,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_resetTexture,3,SWIGTYPE_uint32_t"); 
    
    (arg1)->resetTexture((ccstd::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_scene_Pass_resetTexture(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_scene_Pass_resetTexture__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_scene_Pass_resetTexture__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_scene_Pass_resetTexture) 

static bool js_cc_scene_Pass_resetUBOs(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->resetUBOs();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_resetUBOs) 

static bool js_cc_scene_Pass_resetTextures(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->resetTextures();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_resetTextures) 

static bool js_cc_scene_Pass_tryCompile__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->tryCompile();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_cc_scene_Pass_tryCompile__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    ccstd::optional< cc::MacroRecord > *arg2 = 0 ;
    ccstd::optional< cc::MacroRecord > temp2 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_tryCompile,2,SWIGTYPE_p_ccstd__optionalT_cc__MacroRecord_t");
    arg2 = &temp2;
    
    result = (bool)(arg1)->tryCompile((ccstd::optional< cc::MacroRecord > const &)*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_cc_scene_Pass_tryCompile(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 0) {
        ok = js_cc_scene_Pass_tryCompile__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_scene_Pass_tryCompile__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_scene_Pass_tryCompile) 

static bool js_cc_scene_Pass_getShaderVariant__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::gfx::Shader *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Shader *)(arg1)->getShaderVariant();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_getShaderVariant, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_scene_Pass_getShaderVariant__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    ccstd::vector< cc::scene::IMacroPatch > *arg2 = 0 ;
    ccstd::vector< cc::scene::IMacroPatch > temp2 ;
    cc::gfx::Shader *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Pass_getShaderVariant,2,SWIGTYPE_p_ccstd__vectorT_cc__scene__IMacroPatch_t");
    arg2 = &temp2;
    
    result = (cc::gfx::Shader *)(arg1)->getShaderVariant((ccstd::vector< cc::scene::IMacroPatch > const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_getShaderVariant, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_scene_Pass_getShaderVariant(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 0) {
        ok = js_cc_scene_Pass_getShaderVariant__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_scene_Pass_getShaderVariant__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_scene_Pass_getShaderVariant) 

static bool js_cc_scene_Pass_getPassInfoFull(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::IPassInfoFull result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::scene::Pass const *)arg1)->getPassInfoFull();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_getPassInfoFull, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_getPassInfoFull) 

static bool js_cc_scene_Pass_getRootBlock(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::ArrayBuffer *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::ArrayBuffer *)(arg1)->getRootBlock();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_getRootBlock, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_getRootBlock) 

static bool js_cc_scene_Pass__updatePassHash(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->updatePassHash();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass__updatePassHash) 

static bool js_cc_scene_Pass_beginChangeStatesSilently(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->beginChangeStatesSilently();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_beginChangeStatesSilently) 

static bool js_cc_scene_Pass_endChangeStatesSilently(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->endChangeStatesSilently();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Pass_endChangeStatesSilently) 

static bool js_cc_scene_Pass_root_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::Root *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Root *)cc_scene_Pass_root_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_root_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_root_get) 

static bool js_cc_scene_Pass_device_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::gfx::Device *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Device *)cc_scene_Pass_device_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_device_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_device_get) 

static bool js_cc_scene_Pass_shaderInfo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::IProgramInfo *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::IProgramInfo *)cc_scene_Pass_shaderInfo_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_shaderInfo_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_shaderInfo_get) 

static bool js_cc_scene_Pass_localSetLayout_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::gfx::DescriptorSetLayout *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::DescriptorSetLayout *)cc_scene_Pass_localSetLayout_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_localSetLayout_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_localSetLayout_get) 

static bool js_cc_scene_Pass_program_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    ccstd::string *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::string *) &cc_scene_Pass_program_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_program_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_program_get) 

static bool js_cc_scene_Pass_properties_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    Record< ccstd::string,cc::IPropertyInfo > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (Record< ccstd::string,cc::IPropertyInfo > *) &cc_scene_Pass_properties_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_properties_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_properties_get) 

static bool js_cc_scene_Pass_defines_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::MacroRecord *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::MacroRecord *) &cc_scene_Pass_defines_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_defines_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_defines_get) 

static bool js_cc_scene_Pass_passIndex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    index_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_scene_Pass_passIndex_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_passIndex_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_passIndex_get) 

static bool js_cc_scene_Pass_propertyIndex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    index_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_scene_Pass_propertyIndex_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_propertyIndex_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_propertyIndex_get) 

static bool js_cc_scene_Pass_dynamics_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::scene::IPassDynamics *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::IPassDynamics *) &cc_scene_Pass_dynamics_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_dynamics_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_dynamics_get) 

static bool js_cc_scene_Pass_rootBufferDirty_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_Pass_rootBufferDirty_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_rootBufferDirty_get) 

static bool js_cc_scene_Pass__rootBufferDirty_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Pass__rootBufferDirty_set,2,SWIGTYPE_bool"); 
    cc_scene_Pass__rootBufferDirty_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Pass__rootBufferDirty_set) 

static bool js_cc_scene_Pass__rootBufferDirty_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_Pass__rootBufferDirty_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass__rootBufferDirty_get) 

static bool js_cc_scene_Pass_priority_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::pipeline::RenderPriority result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_scene_Pass_priority_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_priority_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_priority_get) 

static bool js_cc_scene_Pass_primitive_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::gfx::PrimitiveMode result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_scene_Pass_primitive_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_primitive_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_primitive_get) 

static bool js_cc_scene_Pass_stage_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::pipeline::RenderPassStage result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_scene_Pass_stage_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_stage_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_stage_get) 

static bool js_cc_scene_Pass_phase_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_scene_Pass_phase_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_phase_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_phase_get) 

static bool js_cc_scene_Pass_rasterizerState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::gfx::RasterizerState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::RasterizerState *)cc_scene_Pass_rasterizerState_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_rasterizerState_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_rasterizerState_get) 

static bool js_cc_scene_Pass_depthStencilState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::gfx::DepthStencilState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::DepthStencilState *)cc_scene_Pass_depthStencilState_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_depthStencilState_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_depthStencilState_get) 

static bool js_cc_scene_Pass_blendState_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::gfx::BlendState *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::BlendState *)cc_scene_Pass_blendState_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_blendState_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_blendState_get) 

static bool js_cc_scene_Pass_dynamicStates_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::gfx::DynamicStateFlagBit result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_scene_Pass_dynamicStates_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_dynamicStates_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_dynamicStates_get) 

static bool js_cc_scene_Pass_batchingScheme_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::scene::BatchingSchemes result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::BatchingSchemes)cc_scene_Pass_batchingScheme_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_batchingScheme_get) 

static bool js_cc_scene_Pass_descriptorSet_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::gfx::DescriptorSet *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::DescriptorSet *)cc_scene_Pass_descriptorSet_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_descriptorSet_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_descriptorSet_get) 

static bool js_cc_scene_Pass_hash_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    ccstd::hash_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_scene_Pass_hash_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_hash_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_hash_get) 

static bool js_cc_scene_Pass_pipelineLayout_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::gfx::PipelineLayout *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Pass>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::PipelineLayout *)cc_scene_Pass_pipelineLayout_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Pass_pipelineLayout_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Pass_pipelineLayout_get) 

bool js_register_cc_scene_Pass(se::Object* obj) {
    auto* cls = se::Class::create("Pass", obj, nullptr, _SE(js_new_Pass)); 
    
    cls->defineProperty("root", _SE(js_cc_scene_Pass_root_get), nullptr); 
    cls->defineProperty("device", _SE(js_cc_scene_Pass_device_get), nullptr); 
    cls->defineProperty("shaderInfo", _SE(js_cc_scene_Pass_shaderInfo_get), nullptr); 
    cls->defineProperty("localSetLayout", _SE(js_cc_scene_Pass_localSetLayout_get), nullptr); 
    cls->defineProperty("program", _SE(js_cc_scene_Pass_program_get), nullptr); 
    cls->defineProperty("properties", _SE(js_cc_scene_Pass_properties_get), nullptr); 
    cls->defineProperty("defines", _SE(js_cc_scene_Pass_defines_get), nullptr); 
    cls->defineProperty("passIndex", _SE(js_cc_scene_Pass_passIndex_get), nullptr); 
    cls->defineProperty("propertyIndex", _SE(js_cc_scene_Pass_propertyIndex_get), nullptr); 
    cls->defineProperty("dynamics", _SE(js_cc_scene_Pass_dynamics_get), nullptr); 
    cls->defineProperty("rootBufferDirty", _SE(js_cc_scene_Pass_rootBufferDirty_get), nullptr); 
    cls->defineProperty("_rootBufferDirty", _SE(js_cc_scene_Pass__rootBufferDirty_get), _SE(js_cc_scene_Pass__rootBufferDirty_set)); 
    cls->defineProperty("priority", _SE(js_cc_scene_Pass_priority_get), nullptr); 
    cls->defineProperty("primitive", _SE(js_cc_scene_Pass_primitive_get), nullptr); 
    cls->defineProperty("stage", _SE(js_cc_scene_Pass_stage_get), nullptr); 
    cls->defineProperty("phase", _SE(js_cc_scene_Pass_phase_get), nullptr); 
    cls->defineProperty("rasterizerState", _SE(js_cc_scene_Pass_rasterizerState_get), nullptr); 
    cls->defineProperty("depthStencilState", _SE(js_cc_scene_Pass_depthStencilState_get), nullptr); 
    cls->defineProperty("blendState", _SE(js_cc_scene_Pass_blendState_get), nullptr); 
    cls->defineProperty("dynamicStates", _SE(js_cc_scene_Pass_dynamicStates_get), nullptr); 
    cls->defineProperty("batchingScheme", _SE(js_cc_scene_Pass_batchingScheme_get), nullptr); 
    cls->defineProperty("descriptorSet", _SE(js_cc_scene_Pass_descriptorSet_get), nullptr); 
    cls->defineProperty("hash", _SE(js_cc_scene_Pass_hash_get), nullptr); 
    cls->defineProperty("pipelineLayout", _SE(js_cc_scene_Pass_pipelineLayout_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_scene_Pass_initialize)); 
    cls->defineFunction("getHandle", _SE(js_cc_scene_Pass_getHandle)); 
    cls->defineFunction("getBinding", _SE(js_cc_scene_Pass_getBinding)); 
    cls->defineFunction("setUniform", _SE(js_cc_scene_Pass_setUniform)); 
    cls->defineFunction("getUniform", _SE(js_cc_scene_Pass_getUniform)); 
    cls->defineFunction("setUniformArray", _SE(js_cc_scene_Pass_setUniformArray)); 
    cls->defineFunction("bindTexture", _SE(js_cc_scene_Pass_bindTexture)); 
    cls->defineFunction("bindSampler", _SE(js_cc_scene_Pass_bindSampler)); 
    cls->defineFunction("setDynamicState", _SE(js_cc_scene_Pass_setDynamicState)); 
    cls->defineFunction("overridePipelineStates", _SE(js_cc_scene_Pass_overridePipelineStates)); 
    cls->defineFunction("update", _SE(js_cc_scene_Pass_update)); 
    cls->defineFunction("getInstancedBuffer", _SE(js_cc_scene_Pass_getInstancedBuffer)); 
    cls->defineFunction("getBatchedBuffer", _SE(js_cc_scene_Pass_getBatchedBuffer)); 
    cls->defineFunction("destroy", _SE(js_cc_scene_Pass_destroy)); 
    cls->defineFunction("resetUniform", _SE(js_cc_scene_Pass_resetUniform)); 
    cls->defineFunction("resetTexture", _SE(js_cc_scene_Pass_resetTexture)); 
    cls->defineFunction("resetUBOs", _SE(js_cc_scene_Pass_resetUBOs)); 
    cls->defineFunction("resetTextures", _SE(js_cc_scene_Pass_resetTextures)); 
    cls->defineFunction("tryCompile", _SE(js_cc_scene_Pass_tryCompile)); 
    cls->defineFunction("getShaderVariant", _SE(js_cc_scene_Pass_getShaderVariant)); 
    cls->defineFunction("getPassInfoFull", _SE(js_cc_scene_Pass_getPassInfoFull)); 
    cls->defineFunction("getRootBlock", _SE(js_cc_scene_Pass_getRootBlock)); 
    cls->defineFunction("_updatePassHash", _SE(js_cc_scene_Pass__updatePassHash)); 
    cls->defineFunction("beginChangeStatesSilently", _SE(js_cc_scene_Pass_beginChangeStatesSilently)); 
    cls->defineFunction("endChangeStatesSilently", _SE(js_cc_scene_Pass_endChangeStatesSilently)); 
    
    
    cls->defineStaticFunction("getTypeFromHandle", _SE(js_cc_scene_Pass_getTypeFromHandle_static)); 
    cls->defineStaticFunction("getBindingFromHandle", _SE(js_cc_scene_Pass_getBindingFromHandle_static)); 
    cls->defineStaticFunction("getCountFromHandle", _SE(js_cc_scene_Pass_getCountFromHandle_static)); 
    cls->defineStaticFunction("getOffsetFromHandle", _SE(js_cc_scene_Pass_getOffsetFromHandle_static)); 
    cls->defineStaticFunction("fillPipelineInfo", _SE(js_cc_scene_Pass_fillPipelineInfo_static)); 
    cls->defineStaticFunction("getPassHash", _SE(js_cc_scene_Pass_getPassHash_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_Pass));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::Pass>(cls);
    
    __jsb_cc_scene_Pass_proto = cls->getProto();
    __jsb_cc_scene_Pass_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_IRaycastResult_class = nullptr;
se::Object* __jsb_cc_scene_IRaycastResult_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_IRaycastResult) 

static bool js_cc_scene_IRaycastResult_node_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::IRaycastResult *arg1 = (cc::scene::IRaycastResult *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRaycastResult>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->node, s.thisObject());
    SE_PRECONDITION2(ok, false, "IRaycastResult_node_set,2,SWIGTYPE_p_cc__Node"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IRaycastResult_node_set) 

static bool js_cc_scene_IRaycastResult_node_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::IRaycastResult *arg1 = (cc::scene::IRaycastResult *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRaycastResult>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->node, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IRaycastResult_node_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->node, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IRaycastResult_node_get) 

static bool js_cc_scene_IRaycastResult_distance_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::IRaycastResult *arg1 = (cc::scene::IRaycastResult *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRaycastResult>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->distance, nullptr);
    SE_PRECONDITION2(ok, false, "IRaycastResult_distance_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IRaycastResult_distance_set) 

static bool js_cc_scene_IRaycastResult_distance_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::IRaycastResult *arg1 = (cc::scene::IRaycastResult *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRaycastResult>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->distance, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IRaycastResult_distance_get) 

// js_ctor
static bool js_new_cc_scene_IRaycastResult(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::IRaycastResult *result;
    result = (cc::scene::IRaycastResult *)new cc::scene::IRaycastResult();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_IRaycastResult, __jsb_cc_scene_IRaycastResult_class, js_delete_cc_scene_IRaycastResult)

static bool js_delete_cc_scene_IRaycastResult(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_IRaycastResult) 

template<>
bool sevalue_to_native(const se::Value &from, cc::scene::IRaycastResult * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::scene::IRaycastResult*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("node", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->node), ctx);
    }
    
    
    json->getProperty("distance", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->distance), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_scene_IRaycastResult(se::Object* obj) {
    auto* cls = se::Class::create("IRaycastResult", obj, nullptr, _SE(js_new_cc_scene_IRaycastResult)); 
    
    cls->defineProperty("node", _SE(js_cc_scene_IRaycastResult_node_get), _SE(js_cc_scene_IRaycastResult_node_set)); 
    cls->defineProperty("distance", _SE(js_cc_scene_IRaycastResult_distance_get), _SE(js_cc_scene_IRaycastResult_distance_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_IRaycastResult));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::IRaycastResult>(cls);
    
    __jsb_cc_scene_IRaycastResult_proto = cls->getProto();
    __jsb_cc_scene_IRaycastResult_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_IRenderSceneInfo_class = nullptr;
se::Object* __jsb_cc_scene_IRenderSceneInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_IRenderSceneInfo) 

static bool js_cc_scene_IRenderSceneInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::IRenderSceneInfo *arg1 = (cc::scene::IRenderSceneInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRenderSceneInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "IRenderSceneInfo_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IRenderSceneInfo_name_set) 

static bool js_cc_scene_IRenderSceneInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::IRenderSceneInfo *arg1 = (cc::scene::IRenderSceneInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRenderSceneInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IRenderSceneInfo_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IRenderSceneInfo_name_get) 

// js_ctor
static bool js_new_cc_scene_IRenderSceneInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::IRenderSceneInfo *result;
    result = (cc::scene::IRenderSceneInfo *)new cc::scene::IRenderSceneInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_IRenderSceneInfo, __jsb_cc_scene_IRenderSceneInfo_class, js_delete_cc_scene_IRenderSceneInfo)

static bool js_delete_cc_scene_IRenderSceneInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_IRenderSceneInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::scene::IRenderSceneInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::scene::IRenderSceneInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_scene_IRenderSceneInfo(se::Object* obj) {
    auto* cls = se::Class::create("IRenderSceneInfo", obj, nullptr, _SE(js_new_cc_scene_IRenderSceneInfo)); 
    
    cls->defineProperty("name", _SE(js_cc_scene_IRenderSceneInfo_name_get), _SE(js_cc_scene_IRenderSceneInfo_name_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_IRenderSceneInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::IRenderSceneInfo>(cls);
    
    __jsb_cc_scene_IRenderSceneInfo_proto = cls->getProto();
    __jsb_cc_scene_IRenderSceneInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_RenderScene_class = nullptr;
se::Object* __jsb_cc_scene_RenderScene_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_RenderScene) 

// js_ctor
static bool js_new_cc_scene_RenderScene(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::RenderScene *result;
    result = (cc::scene::RenderScene *)new cc::scene::RenderScene();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_RenderScene, __jsb_cc_scene_RenderScene_class, js_delete_cc_scene_RenderScene)

static bool js_delete_cc_scene_RenderScene(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_RenderScene) 

static bool js_cc_scene_RenderScene_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::IRenderSceneInfo *arg2 = 0 ;
    cc::scene::IRenderSceneInfo temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderScene_initialize,2,SWIGTYPE_p_cc__scene__IRenderSceneInfo");
    arg2 = &temp2;
    
    result = (bool)(arg1)->initialize((cc::scene::IRenderSceneInfo const &)*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_initialize) 

static bool js_cc_scene_RenderScene_update(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderScene_update,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->update(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_update) 

static bool js_cc_scene_RenderScene_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_destroy) 

static bool js_cc_scene_RenderScene_activate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->activate();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_activate) 

static bool js_cc_scene_RenderScene_addCamera(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderScene_addCamera,2,SWIGTYPE_p_cc__scene__Camera"); 
    (arg1)->addCamera(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_addCamera) 

static bool js_cc_scene_RenderScene_removeCamera(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderScene_removeCamera,2,SWIGTYPE_p_cc__scene__Camera"); 
    (arg1)->removeCamera(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_removeCamera) 

static bool js_cc_scene_RenderScene_removeCameras(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->removeCameras();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_removeCameras) 

static bool js_cc_scene_RenderScene_unsetMainLight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::DirectionalLight *arg2 = (cc::scene::DirectionalLight *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderScene_unsetMainLight,2,SWIGTYPE_p_cc__scene__DirectionalLight"); 
    (arg1)->unsetMainLight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_unsetMainLight) 

static bool js_cc_scene_RenderScene_addDirectionalLight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::DirectionalLight *arg2 = (cc::scene::DirectionalLight *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderScene_addDirectionalLight,2,SWIGTYPE_p_cc__scene__DirectionalLight"); 
    (arg1)->addDirectionalLight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_addDirectionalLight) 

static bool js_cc_scene_RenderScene_removeDirectionalLight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::DirectionalLight *arg2 = (cc::scene::DirectionalLight *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderScene_removeDirectionalLight,2,SWIGTYPE_p_cc__scene__DirectionalLight"); 
    (arg1)->removeDirectionalLight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_removeDirectionalLight) 

static bool js_cc_scene_RenderScene_addSphereLight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::SphereLight *arg2 = (cc::scene::SphereLight *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderScene_addSphereLight,2,SWIGTYPE_p_cc__scene__SphereLight"); 
    (arg1)->addSphereLight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_addSphereLight) 

static bool js_cc_scene_RenderScene_removeSphereLight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::SphereLight *arg2 = (cc::scene::SphereLight *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderScene_removeSphereLight,2,SWIGTYPE_p_cc__scene__SphereLight"); 
    (arg1)->removeSphereLight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_removeSphereLight) 

static bool js_cc_scene_RenderScene_removeSphereLights(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->removeSphereLights();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_removeSphereLights) 

static bool js_cc_scene_RenderScene_addSpotLight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::SpotLight *arg2 = (cc::scene::SpotLight *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderScene_addSpotLight,2,SWIGTYPE_p_cc__scene__SpotLight"); 
    (arg1)->addSpotLight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_addSpotLight) 

static bool js_cc_scene_RenderScene_removeSpotLight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::SpotLight *arg2 = (cc::scene::SpotLight *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderScene_removeSpotLight,2,SWIGTYPE_p_cc__scene__SpotLight"); 
    (arg1)->removeSpotLight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_removeSpotLight) 

static bool js_cc_scene_RenderScene_removeSpotLights(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->removeSpotLights();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_removeSpotLights) 

static bool js_cc_scene_RenderScene_addModel(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::Model *arg2 = (cc::scene::Model *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderScene_addModel,2,SWIGTYPE_p_cc__scene__Model"); 
    (arg1)->addModel(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_addModel) 

static bool js_cc_scene_RenderScene_removeModel(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::Model *arg2 = (cc::scene::Model *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderScene_removeModel,2,SWIGTYPE_p_cc__scene__Model"); 
    (arg1)->removeModel(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_removeModel) 

static bool js_cc_scene_RenderScene_removeModels(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->removeModels();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_removeModels) 

static bool js_cc_scene_RenderScene_onGlobalPipelineStateChanged(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->onGlobalPipelineStateChanged();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_onGlobalPipelineStateChanged) 

static bool js_cc_scene_RenderScene_getMainLight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::DirectionalLight *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::DirectionalLight *)((cc::scene::RenderScene const *)arg1)->getMainLight();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderScene_getMainLight, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_getMainLight) 

static bool js_cc_scene_RenderScene_setMainLight(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::DirectionalLight *arg2 = (cc::scene::DirectionalLight *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderScene_setMainLight,2,SWIGTYPE_p_cc__scene__DirectionalLight"); 
    (arg1)->setMainLight(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_setMainLight) 

static bool js_cc_scene_RenderScene_generateModelId(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    uint64_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (arg1)->generateModelId();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderScene_generateModelId, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_generateModelId) 

static bool js_cc_scene_RenderScene_getOctree(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::Octree *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::Octree *)((cc::scene::RenderScene const *)arg1)->getOctree();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderScene_getOctree, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_getOctree) 

static bool js_cc_scene_RenderScene_updateOctree(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    cc::scene::Model *arg2 = (cc::scene::Model *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderScene_updateOctree,2,SWIGTYPE_p_cc__scene__Model"); 
    (arg1)->updateOctree(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderScene_updateOctree) 

static bool js_cc_scene_RenderScene_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    ccstd::string *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::string *) &cc_scene_RenderScene_name_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderScene_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_RenderScene_name_get) 

static bool js_cc_scene_RenderScene_cameras_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::scene::Camera > > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::IntrusivePtr< cc::scene::Camera > > *) &cc_scene_RenderScene_cameras_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderScene_cameras_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_RenderScene_cameras_get) 

static bool js_cc_scene_RenderScene_sphereLights_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::scene::SphereLight > > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::IntrusivePtr< cc::scene::SphereLight > > *) &cc_scene_RenderScene_sphereLights_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderScene_sphereLights_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_RenderScene_sphereLights_get) 

static bool js_cc_scene_RenderScene_spotLights_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::scene::SpotLight > > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::IntrusivePtr< cc::scene::SpotLight > > *) &cc_scene_RenderScene_spotLights_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderScene_spotLights_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_RenderScene_spotLights_get) 

static bool js_cc_scene_RenderScene_models_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::RenderScene *arg1 = (cc::scene::RenderScene *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::scene::Model > > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::RenderScene>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::IntrusivePtr< cc::scene::Model > > *) &cc_scene_RenderScene_models_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderScene_models_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_RenderScene_models_get) 

bool js_register_cc_scene_RenderScene(se::Object* obj) {
    auto* cls = se::Class::create("RenderScene", obj, nullptr, _SE(js_new_cc_scene_RenderScene)); 
    
    cls->defineProperty("name", _SE(js_cc_scene_RenderScene_name_get), nullptr); 
    cls->defineProperty("cameras", _SE(js_cc_scene_RenderScene_cameras_get), nullptr); 
    cls->defineProperty("sphereLights", _SE(js_cc_scene_RenderScene_sphereLights_get), nullptr); 
    cls->defineProperty("spotLights", _SE(js_cc_scene_RenderScene_spotLights_get), nullptr); 
    cls->defineProperty("models", _SE(js_cc_scene_RenderScene_models_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_scene_RenderScene_initialize)); 
    cls->defineFunction("update", _SE(js_cc_scene_RenderScene_update)); 
    cls->defineFunction("destroy", _SE(js_cc_scene_RenderScene_destroy)); 
    cls->defineFunction("activate", _SE(js_cc_scene_RenderScene_activate)); 
    cls->defineFunction("addCamera", _SE(js_cc_scene_RenderScene_addCamera)); 
    cls->defineFunction("removeCamera", _SE(js_cc_scene_RenderScene_removeCamera)); 
    cls->defineFunction("removeCameras", _SE(js_cc_scene_RenderScene_removeCameras)); 
    cls->defineFunction("unsetMainLight", _SE(js_cc_scene_RenderScene_unsetMainLight)); 
    cls->defineFunction("addDirectionalLight", _SE(js_cc_scene_RenderScene_addDirectionalLight)); 
    cls->defineFunction("removeDirectionalLight", _SE(js_cc_scene_RenderScene_removeDirectionalLight)); 
    cls->defineFunction("addSphereLight", _SE(js_cc_scene_RenderScene_addSphereLight)); 
    cls->defineFunction("removeSphereLight", _SE(js_cc_scene_RenderScene_removeSphereLight)); 
    cls->defineFunction("removeSphereLights", _SE(js_cc_scene_RenderScene_removeSphereLights)); 
    cls->defineFunction("addSpotLight", _SE(js_cc_scene_RenderScene_addSpotLight)); 
    cls->defineFunction("removeSpotLight", _SE(js_cc_scene_RenderScene_removeSpotLight)); 
    cls->defineFunction("removeSpotLights", _SE(js_cc_scene_RenderScene_removeSpotLights)); 
    cls->defineFunction("addModel", _SE(js_cc_scene_RenderScene_addModel)); 
    cls->defineFunction("removeModel", _SE(js_cc_scene_RenderScene_removeModel)); 
    cls->defineFunction("removeModels", _SE(js_cc_scene_RenderScene_removeModels)); 
    cls->defineFunction("onGlobalPipelineStateChanged", _SE(js_cc_scene_RenderScene_onGlobalPipelineStateChanged)); 
    cls->defineFunction("getMainLight", _SE(js_cc_scene_RenderScene_getMainLight)); 
    cls->defineFunction("setMainLight", _SE(js_cc_scene_RenderScene_setMainLight)); 
    cls->defineFunction("generateModelId", _SE(js_cc_scene_RenderScene_generateModelId)); 
    cls->defineFunction("getOctree", _SE(js_cc_scene_RenderScene_getOctree)); 
    cls->defineFunction("updateOctree", _SE(js_cc_scene_RenderScene_updateOctree)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_RenderScene));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::RenderScene>(cls);
    
    __jsb_cc_scene_RenderScene_proto = cls->getProto();
    __jsb_cc_scene_RenderScene_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_IRenderWindowInfo_class = nullptr;
se::Object* __jsb_cc_scene_IRenderWindowInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_IRenderWindowInfo) 

static bool js_cc_scene_IRenderWindowInfo_title_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::IRenderWindowInfo *arg1 = (cc::scene::IRenderWindowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRenderWindowInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->title, s.thisObject());
    SE_PRECONDITION2(ok, false, "IRenderWindowInfo_title_set,2,SWIGTYPE_ccstd__optionalT_ccstd__string_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IRenderWindowInfo_title_set) 

static bool js_cc_scene_IRenderWindowInfo_title_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::IRenderWindowInfo *arg1 = (cc::scene::IRenderWindowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRenderWindowInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->title, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IRenderWindowInfo_title_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->title, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IRenderWindowInfo_title_get) 

static bool js_cc_scene_IRenderWindowInfo_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::IRenderWindowInfo *arg1 = (cc::scene::IRenderWindowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRenderWindowInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->width, s.thisObject());
    SE_PRECONDITION2(ok, false, "IRenderWindowInfo_width_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IRenderWindowInfo_width_set) 

static bool js_cc_scene_IRenderWindowInfo_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::IRenderWindowInfo *arg1 = (cc::scene::IRenderWindowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRenderWindowInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->width, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IRenderWindowInfo_width_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->width, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IRenderWindowInfo_width_get) 

static bool js_cc_scene_IRenderWindowInfo_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::IRenderWindowInfo *arg1 = (cc::scene::IRenderWindowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRenderWindowInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->height, s.thisObject());
    SE_PRECONDITION2(ok, false, "IRenderWindowInfo_height_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IRenderWindowInfo_height_set) 

static bool js_cc_scene_IRenderWindowInfo_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::IRenderWindowInfo *arg1 = (cc::scene::IRenderWindowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRenderWindowInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->height, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IRenderWindowInfo_height_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->height, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IRenderWindowInfo_height_get) 

static bool js_cc_scene_IRenderWindowInfo_renderPassInfo_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::IRenderWindowInfo *arg1 = (cc::scene::IRenderWindowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRenderWindowInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->renderPassInfo, s.thisObject());
    SE_PRECONDITION2(ok, false, "IRenderWindowInfo_renderPassInfo_set,2,SWIGTYPE_cc__gfx__RenderPassInfo"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IRenderWindowInfo_renderPassInfo_set) 

static bool js_cc_scene_IRenderWindowInfo_renderPassInfo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::IRenderWindowInfo *arg1 = (cc::scene::IRenderWindowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRenderWindowInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->renderPassInfo, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IRenderWindowInfo_renderPassInfo_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->renderPassInfo, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IRenderWindowInfo_renderPassInfo_get) 

static bool js_cc_scene_IRenderWindowInfo_swapchain_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::IRenderWindowInfo *arg1 = (cc::scene::IRenderWindowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRenderWindowInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->swapchain, s.thisObject());
    SE_PRECONDITION2(ok, false, "IRenderWindowInfo_swapchain_set,2,SWIGTYPE_p_cc__gfx__Swapchain"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_IRenderWindowInfo_swapchain_set) 

static bool js_cc_scene_IRenderWindowInfo_swapchain_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::IRenderWindowInfo *arg1 = (cc::scene::IRenderWindowInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::IRenderWindowInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->swapchain, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IRenderWindowInfo_swapchain_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->swapchain, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_IRenderWindowInfo_swapchain_get) 

// js_ctor
static bool js_new_cc_scene_IRenderWindowInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::IRenderWindowInfo *result;
    result = (cc::scene::IRenderWindowInfo *)new cc::scene::IRenderWindowInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_IRenderWindowInfo, __jsb_cc_scene_IRenderWindowInfo_class, js_delete_cc_scene_IRenderWindowInfo)

static bool js_delete_cc_scene_IRenderWindowInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_IRenderWindowInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::scene::IRenderWindowInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::scene::IRenderWindowInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("title", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->title), ctx);
    }
    
    
    json->getProperty("width", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->width), ctx);
    }
    
    
    json->getProperty("height", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->height), ctx);
    }
    
    
    json->getProperty("renderPassInfo", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->renderPassInfo), ctx);
    }
    
    
    json->getProperty("swapchain", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->swapchain), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_scene_IRenderWindowInfo(se::Object* obj) {
    auto* cls = se::Class::create("IRenderWindowInfo", obj, nullptr, _SE(js_new_cc_scene_IRenderWindowInfo)); 
    
    cls->defineProperty("title", _SE(js_cc_scene_IRenderWindowInfo_title_get), _SE(js_cc_scene_IRenderWindowInfo_title_set)); 
    cls->defineProperty("width", _SE(js_cc_scene_IRenderWindowInfo_width_get), _SE(js_cc_scene_IRenderWindowInfo_width_set)); 
    cls->defineProperty("height", _SE(js_cc_scene_IRenderWindowInfo_height_get), _SE(js_cc_scene_IRenderWindowInfo_height_set)); 
    cls->defineProperty("renderPassInfo", _SE(js_cc_scene_IRenderWindowInfo_renderPassInfo_get), _SE(js_cc_scene_IRenderWindowInfo_renderPassInfo_set)); 
    cls->defineProperty("swapchain", _SE(js_cc_scene_IRenderWindowInfo_swapchain_get), _SE(js_cc_scene_IRenderWindowInfo_swapchain_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_IRenderWindowInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::IRenderWindowInfo>(cls);
    
    __jsb_cc_scene_IRenderWindowInfo_proto = cls->getProto();
    __jsb_cc_scene_IRenderWindowInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_RenderWindow_class = nullptr;
se::Object* __jsb_cc_scene_RenderWindow_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_RenderWindow) 

// js_ctor
static bool js_new_cc_scene_RenderWindow(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::RenderWindow *result;
    result = (cc::scene::RenderWindow *)new cc::scene::RenderWindow();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_RenderWindow, __jsb_cc_scene_RenderWindow_class, js_delete_cc_scene_RenderWindow)

static bool js_delete_cc_scene_RenderWindow(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_RenderWindow) 

static bool js_cc_scene_RenderWindow_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderWindow *arg1 = (cc::scene::RenderWindow *) NULL ;
    cc::gfx::Device *arg2 = (cc::gfx::Device *) NULL ;
    cc::scene::IRenderWindowInfo *arg3 = 0 ;
    cc::scene::IRenderWindowInfo temp3 ;
    bool result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderWindow>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderWindow_initialize,2,SWIGTYPE_p_cc__gfx__Device"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderWindow_initialize,3,SWIGTYPE_p_cc__scene__IRenderWindowInfo");
    arg3 = &temp3;
    
    result = (bool)(arg1)->initialize(arg2,*arg3);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderWindow_initialize) 

static bool js_cc_scene_RenderWindow_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderWindow *arg1 = (cc::scene::RenderWindow *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderWindow>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderWindow_destroy) 

static bool js_cc_scene_RenderWindow_resize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderWindow *arg1 = (cc::scene::RenderWindow *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderWindow>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderWindow_resize,2,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderWindow_resize,3,SWIGTYPE_uint32_t"); 
    
    (arg1)->resize(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderWindow_resize) 

static bool js_cc_scene_RenderWindow_extractRenderCameras(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderWindow *arg1 = (cc::scene::RenderWindow *) NULL ;
    ccstd::vector< cc::scene::Camera * > *arg2 = 0 ;
    ccstd::vector< cc::scene::Camera * > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderWindow>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderWindow_extractRenderCameras,2,SWIGTYPE_p_ccstd__vectorT_cc__scene__Camera_p_t");
    arg2 = &temp2;
    
    (arg1)->extractRenderCameras(*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderWindow_extractRenderCameras) 

static bool js_cc_scene_RenderWindow_attachCamera(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderWindow *arg1 = (cc::scene::RenderWindow *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderWindow>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderWindow_attachCamera,2,SWIGTYPE_p_cc__scene__Camera"); 
    (arg1)->attachCamera(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderWindow_attachCamera) 

static bool js_cc_scene_RenderWindow_detachCamera(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderWindow *arg1 = (cc::scene::RenderWindow *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderWindow>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "RenderWindow_detachCamera,2,SWIGTYPE_p_cc__scene__Camera"); 
    (arg1)->detachCamera(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderWindow_detachCamera) 

static bool js_cc_scene_RenderWindow_clearCameras(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderWindow *arg1 = (cc::scene::RenderWindow *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderWindow>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->clearCameras();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderWindow_clearCameras) 

static bool js_cc_scene_RenderWindow_sortCameras(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::RenderWindow *arg1 = (cc::scene::RenderWindow *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::RenderWindow>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->sortCameras();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_RenderWindow_sortCameras) 

static bool js_cc_scene_RenderWindow_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::RenderWindow *arg1 = (cc::scene::RenderWindow *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::RenderWindow>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_scene_RenderWindow_width_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderWindow_width_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_RenderWindow_width_get) 

static bool js_cc_scene_RenderWindow_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::RenderWindow *arg1 = (cc::scene::RenderWindow *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::RenderWindow>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_scene_RenderWindow_height_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderWindow_height_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_RenderWindow_height_get) 

static bool js_cc_scene_RenderWindow_framebuffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::RenderWindow *arg1 = (cc::scene::RenderWindow *) NULL ;
    cc::gfx::Framebuffer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::RenderWindow>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Framebuffer *)cc_scene_RenderWindow_framebuffer_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderWindow_framebuffer_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_RenderWindow_framebuffer_get) 

static bool js_cc_scene_RenderWindow_cameras_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::RenderWindow *arg1 = (cc::scene::RenderWindow *) NULL ;
    ccstd::vector< cc::IntrusivePtr< cc::scene::Camera > > *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::RenderWindow>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::IntrusivePtr< cc::scene::Camera > > *) &cc_scene_RenderWindow_cameras_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderWindow_cameras_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_RenderWindow_cameras_get) 

static bool js_cc_scene_RenderWindow_swapchain_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::RenderWindow *arg1 = (cc::scene::RenderWindow *) NULL ;
    cc::gfx::Swapchain *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::RenderWindow>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Swapchain *)cc_scene_RenderWindow_swapchain_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "RenderWindow_swapchain_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_RenderWindow_swapchain_get) 

bool js_register_cc_scene_RenderWindow(se::Object* obj) {
    auto* cls = se::Class::create("RenderWindow", obj, nullptr, _SE(js_new_cc_scene_RenderWindow)); 
    
    cls->defineProperty("width", _SE(js_cc_scene_RenderWindow_width_get), nullptr); 
    cls->defineProperty("height", _SE(js_cc_scene_RenderWindow_height_get), nullptr); 
    cls->defineProperty("framebuffer", _SE(js_cc_scene_RenderWindow_framebuffer_get), nullptr); 
    cls->defineProperty("cameras", _SE(js_cc_scene_RenderWindow_cameras_get), nullptr); 
    cls->defineProperty("swapchain", _SE(js_cc_scene_RenderWindow_swapchain_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_scene_RenderWindow_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_scene_RenderWindow_destroy)); 
    cls->defineFunction("resize", _SE(js_cc_scene_RenderWindow_resize)); 
    cls->defineFunction("extractRenderCameras", _SE(js_cc_scene_RenderWindow_extractRenderCameras)); 
    cls->defineFunction("attachCamera", _SE(js_cc_scene_RenderWindow_attachCamera)); 
    cls->defineFunction("detachCamera", _SE(js_cc_scene_RenderWindow_detachCamera)); 
    cls->defineFunction("clearCameras", _SE(js_cc_scene_RenderWindow_clearCameras)); 
    cls->defineFunction("sortCameras", _SE(js_cc_scene_RenderWindow_sortCameras)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_RenderWindow));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::RenderWindow>(cls);
    
    __jsb_cc_scene_RenderWindow_proto = cls->getProto();
    __jsb_cc_scene_RenderWindow_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_ICameraInfo_class = nullptr;
se::Object* __jsb_cc_scene_ICameraInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_ICameraInfo) 

static bool js_cc_scene_ICameraInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "ICameraInfo_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ICameraInfo_name_set) 

static bool js_cc_scene_ICameraInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ICameraInfo_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ICameraInfo_name_get) 

static bool js_cc_scene_ICameraInfo_node_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->node, s.thisObject());
    SE_PRECONDITION2(ok, false, "ICameraInfo_node_set,2,SWIGTYPE_p_cc__Node"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ICameraInfo_node_set) 

static bool js_cc_scene_ICameraInfo_node_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->node, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ICameraInfo_node_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->node, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ICameraInfo_node_get) 

static bool js_cc_scene_ICameraInfo_projection_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "ICameraInfo_projection_set,2,SWIGTYPE_cc__scene__CameraProjection");
    arg1->projection = (cc::scene::CameraProjection)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ICameraInfo_projection_set) 

static bool js_cc_scene_ICameraInfo_projection_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->projection));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ICameraInfo_projection_get) 

static bool js_cc_scene_ICameraInfo_targetDisplay_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->targetDisplay, s.thisObject());
    SE_PRECONDITION2(ok, false, "ICameraInfo_targetDisplay_set,2,SWIGTYPE_ccstd__optionalT_uint32_t_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ICameraInfo_targetDisplay_set) 

static bool js_cc_scene_ICameraInfo_targetDisplay_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->targetDisplay, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ICameraInfo_targetDisplay_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->targetDisplay, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ICameraInfo_targetDisplay_get) 

static bool js_cc_scene_ICameraInfo_window_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->window, s.thisObject());
    SE_PRECONDITION2(ok, false, "ICameraInfo_window_set,2,SWIGTYPE_p_cc__scene__RenderWindow"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ICameraInfo_window_set) 

static bool js_cc_scene_ICameraInfo_window_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->window, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ICameraInfo_window_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->window, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ICameraInfo_window_get) 

static bool js_cc_scene_ICameraInfo_priority_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->priority, s.thisObject());
    SE_PRECONDITION2(ok, false, "ICameraInfo_priority_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ICameraInfo_priority_set) 

static bool js_cc_scene_ICameraInfo_priority_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->priority, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ICameraInfo_priority_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->priority, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ICameraInfo_priority_get) 

static bool js_cc_scene_ICameraInfo_pipeline_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->pipeline, s.thisObject());
    SE_PRECONDITION2(ok, false, "ICameraInfo_pipeline_set,2,SWIGTYPE_ccstd__optionalT_ccstd__string_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_ICameraInfo_pipeline_set) 

static bool js_cc_scene_ICameraInfo_pipeline_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::ICameraInfo *arg1 = (cc::scene::ICameraInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::ICameraInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->pipeline, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ICameraInfo_pipeline_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->pipeline, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_ICameraInfo_pipeline_get) 

// js_ctor
static bool js_new_cc_scene_ICameraInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::ICameraInfo *result;
    result = (cc::scene::ICameraInfo *)new cc::scene::ICameraInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_ICameraInfo, __jsb_cc_scene_ICameraInfo_class, js_delete_cc_scene_ICameraInfo)

static bool js_delete_cc_scene_ICameraInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_ICameraInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::scene::ICameraInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::scene::ICameraInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("node", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->node), ctx);
    }
    
    
    json->getProperty("projection", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->projection), ctx);
    }
    
    
    json->getProperty("targetDisplay", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->targetDisplay), ctx);
    }
    
    
    json->getProperty("window", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->window), ctx);
    }
    
    
    json->getProperty("priority", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->priority), ctx);
    }
    
    
    json->getProperty("pipeline", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->pipeline), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_scene_ICameraInfo(se::Object* obj) {
    auto* cls = se::Class::create("ICameraInfo", obj, nullptr, _SE(js_new_cc_scene_ICameraInfo)); 
    
    cls->defineProperty("name", _SE(js_cc_scene_ICameraInfo_name_get), _SE(js_cc_scene_ICameraInfo_name_set)); 
    cls->defineProperty("node", _SE(js_cc_scene_ICameraInfo_node_get), _SE(js_cc_scene_ICameraInfo_node_set)); 
    cls->defineProperty("projection", _SE(js_cc_scene_ICameraInfo_projection_get), _SE(js_cc_scene_ICameraInfo_projection_set)); 
    cls->defineProperty("targetDisplay", _SE(js_cc_scene_ICameraInfo_targetDisplay_get), _SE(js_cc_scene_ICameraInfo_targetDisplay_set)); 
    cls->defineProperty("window", _SE(js_cc_scene_ICameraInfo_window_get), _SE(js_cc_scene_ICameraInfo_window_set)); 
    cls->defineProperty("priority", _SE(js_cc_scene_ICameraInfo_priority_get), _SE(js_cc_scene_ICameraInfo_priority_set)); 
    cls->defineProperty("pipeline", _SE(js_cc_scene_ICameraInfo_pipeline_get), _SE(js_cc_scene_ICameraInfo_pipeline_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_ICameraInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::ICameraInfo>(cls);
    
    __jsb_cc_scene_ICameraInfo_proto = cls->getProto();
    __jsb_cc_scene_ICameraInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_Camera_class = nullptr;
se::Object* __jsb_cc_scene_Camera_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_Camera) 

static bool js_cc_scene_Camera_SKYBOX_FLAG_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    int32_t result;
    
    result = (int32_t)cc::scene::Camera::SKYBOX_FLAG;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Camera_SKYBOX_FLAG_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_SKYBOX_FLAG_get) 

// js_ctor
static bool js_new_cc_scene_Camera(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 1) {
        SE_REPORT_ERROR("js_new_cc_scene_Camera: wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    cc::scene::Camera *result;
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Camera,1,SWIGTYPE_p_cc__gfx__Device"); 
    result = (cc::scene::Camera *)new cc::scene::Camera(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_Camera, __jsb_cc_scene_Camera_class, js_delete_cc_scene_Camera)

static bool js_delete_cc_scene_Camera(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_Camera) 

static bool js_cc_scene_Camera_getStandardExposureValue_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (float)cc::scene::Camera::getStandardExposureValue();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_getStandardExposureValue_static) 

static bool js_cc_scene_Camera_getStandardLightMeterScale_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (float)cc::scene::Camera::getStandardLightMeterScale();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_getStandardLightMeterScale_static) 

static bool js_cc_scene_Camera_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::ICameraInfo *arg2 = 0 ;
    cc::scene::ICameraInfo temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Camera_initialize,2,SWIGTYPE_p_cc__scene__ICameraInfo");
    arg2 = &temp2;
    
    result = (bool)(arg1)->initialize((cc::scene::ICameraInfo const &)*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_initialize) 

static bool js_cc_scene_Camera_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_destroy) 

static bool js_cc_scene_Camera_attachToScene(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::RenderScene *arg2 = (cc::scene::RenderScene *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Camera_attachToScene,2,SWIGTYPE_p_cc__scene__RenderScene"); 
    (arg1)->attachToScene(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_attachToScene) 

static bool js_cc_scene_Camera_detachFromScene(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->detachFromScene();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_detachFromScene) 

static bool js_cc_scene_Camera_resize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Camera_resize,2,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Camera_resize,3,SWIGTYPE_uint32_t"); 
    
    (arg1)->resize(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_resize) 

static bool js_cc_scene_Camera_setFixedSize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Camera_setFixedSize,2,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Camera_setFixedSize,3,SWIGTYPE_uint32_t"); 
    
    (arg1)->setFixedSize(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_setFixedSize) 

static bool js_cc_scene_Camera_update__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Camera_update,2,SWIGTYPE_bool"); 
    (arg1)->update(arg2);
    
    
    return true;
}

static bool js_cc_scene_Camera_update__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->update();
    
    
    return true;
}

static bool js_cc_scene_Camera_update(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_scene_Camera_update__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 0) {
        ok = js_cc_scene_Camera_update__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_scene_Camera_update) 

static bool js_cc_scene_Camera_changeTargetWindow(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::RenderWindow *arg2 = (cc::scene::RenderWindow *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Camera_changeTargetWindow,2,SWIGTYPE_p_cc__scene__RenderWindow"); 
    (arg1)->changeTargetWindow(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_changeTargetWindow) 

static bool js_cc_scene_Camera_setViewportInOrientedSpace(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    Rect *arg2 = 0 ;
    Rect temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Camera_setViewportInOrientedSpace,2,SWIGTYPE_p_Rect");
    arg2 = &temp2;
    
    (arg1)->setViewportInOrientedSpace((Rect const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_setViewportInOrientedSpace) 

static bool js_cc_scene_Camera_initGeometryRenderer(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->initGeometryRenderer();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_initGeometryRenderer) 

static bool js_cc_scene_Camera_detachCamera(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->detachCamera();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Camera_detachCamera) 

static bool js_cc_scene_Camera_iso_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::CameraISO arg2 ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "Camera_iso_set,2,SWIGTYPE_cc__scene__CameraISO");
    arg2 = (cc::scene::CameraISO)temp2;
    cc_scene_Camera_iso_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_iso_set) 

static bool js_cc_scene_Camera_iso_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::CameraISO result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::CameraISO)cc_scene_Camera_iso_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_iso_get) 

static bool js_cc_scene_Camera_isoValue_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_Camera_isoValue_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_isoValue_get) 

static bool js_cc_scene_Camera_ec_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Camera_ec_set,2,SWIGTYPE_float"); 
    cc_scene_Camera_ec_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_ec_set) 

static bool js_cc_scene_Camera_ec_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_Camera_ec_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_ec_get) 

static bool js_cc_scene_Camera_exposure_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_Camera_exposure_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_exposure_get) 

static bool js_cc_scene_Camera_shutter_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::CameraShutter arg2 ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "Camera_shutter_set,2,SWIGTYPE_cc__scene__CameraShutter");
    arg2 = (cc::scene::CameraShutter)temp2;
    cc_scene_Camera_shutter_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_shutter_set) 

static bool js_cc_scene_Camera_shutter_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::CameraShutter result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::CameraShutter)cc_scene_Camera_shutter_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_shutter_get) 

static bool js_cc_scene_Camera_shutterValue_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_Camera_shutterValue_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_shutterValue_get) 

static bool js_cc_scene_Camera_apertureValue_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_Camera_apertureValue_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_apertureValue_get) 

static bool js_cc_scene_Camera_width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_scene_Camera_width_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Camera_width_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_width_get) 

static bool js_cc_scene_Camera_height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_scene_Camera_height_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Camera_height_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_height_get) 

static bool js_cc_scene_Camera_aspect_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_Camera_aspect_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_aspect_get) 

static bool js_cc_scene_Camera_scene_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::RenderScene *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::RenderScene *)cc_scene_Camera_scene_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Camera_scene_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_scene_get) 

static bool js_cc_scene_Camera_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    ccstd::string *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::string *) &cc_scene_Camera_name_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Camera_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_name_get) 

static bool js_cc_scene_Camera_window_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::RenderWindow *arg2 = (cc::scene::RenderWindow *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Camera_window_set,2,SWIGTYPE_p_cc__scene__RenderWindow"); 
    cc_scene_Camera_window_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_window_set) 

static bool js_cc_scene_Camera_window_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::RenderWindow *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::RenderWindow *)cc_scene_Camera_window_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Camera_window_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_window_get) 

static bool js_cc_scene_Camera_forward_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Camera_forward_set,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    cc_scene_Camera_forward_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_forward_set) 

static bool js_cc_scene_Camera_forward_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Vec3 *) &cc_scene_Camera_forward_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Camera_forward_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_forward_get) 

static bool js_cc_scene_Camera_aperture_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::CameraAperture arg2 ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "Camera_aperture_set,2,SWIGTYPE_cc__scene__CameraAperture");
    arg2 = (cc::scene::CameraAperture)temp2;
    cc_scene_Camera_aperture_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_aperture_set) 

static bool js_cc_scene_Camera_aperture_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::CameraAperture result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::CameraAperture)cc_scene_Camera_aperture_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_aperture_get) 

static bool js_cc_scene_Camera_position_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Camera_position_set,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    cc_scene_Camera_position_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_position_set) 

static bool js_cc_scene_Camera_position_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Vec3 *) &cc_scene_Camera_position_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Camera_position_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_position_get) 

static bool js_cc_scene_Camera_projectionType_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::CameraProjection arg2 ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "Camera_projectionType_set,2,SWIGTYPE_cc__scene__CameraProjection");
    arg2 = (cc::scene::CameraProjection)temp2;
    cc_scene_Camera_projectionType_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_projectionType_set) 

static bool js_cc_scene_Camera_projectionType_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::CameraProjection result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::CameraProjection)cc_scene_Camera_projectionType_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_projectionType_get) 

static bool js_cc_scene_Camera_fovAxis_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::CameraFOVAxis arg2 ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "Camera_fovAxis_set,2,SWIGTYPE_cc__scene__CameraFOVAxis");
    arg2 = (cc::scene::CameraFOVAxis)temp2;
    cc_scene_Camera_fovAxis_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_fovAxis_set) 

static bool js_cc_scene_Camera_fovAxis_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::scene::CameraFOVAxis result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::CameraFOVAxis)cc_scene_Camera_fovAxis_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_fovAxis_get) 

static bool js_cc_scene_Camera_fov_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Camera_fov_set,2,SWIGTYPE_float"); 
    cc_scene_Camera_fov_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_fov_set) 

static bool js_cc_scene_Camera_fov_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_Camera_fov_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_fov_get) 

static bool js_cc_scene_Camera_nearClip_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Camera_nearClip_set,2,SWIGTYPE_float"); 
    cc_scene_Camera_nearClip_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_nearClip_set) 

static bool js_cc_scene_Camera_nearClip_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_Camera_nearClip_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_nearClip_get) 

static bool js_cc_scene_Camera_farClip_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Camera_farClip_set,2,SWIGTYPE_float"); 
    cc_scene_Camera_farClip_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_farClip_set) 

static bool js_cc_scene_Camera_farClip_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_Camera_farClip_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_farClip_get) 

static bool js_cc_scene_Camera_viewport_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::Rect *arg2 = 0 ;
    cc::Rect temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Camera_viewport_set,2,SWIGTYPE_p_cc__Rect");
    arg2 = &temp2;
    
    cc_scene_Camera_viewport_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_viewport_set) 

static bool js_cc_scene_Camera_viewport_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::Rect *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Rect *) &cc_scene_Camera_viewport_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Camera_viewport_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_viewport_get) 

static bool js_cc_scene_Camera_orthoHeight_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Camera_orthoHeight_set,2,SWIGTYPE_float"); 
    cc_scene_Camera_orthoHeight_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_orthoHeight_set) 

static bool js_cc_scene_Camera_orthoHeight_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_Camera_orthoHeight_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_orthoHeight_get) 

static bool js_cc_scene_Camera_clearColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::gfx::Color *arg2 = 0 ;
    cc::gfx::Color temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Camera_clearColor_set,2,SWIGTYPE_p_cc__Color");
    arg2 = &temp2;
    
    cc_scene_Camera_clearColor_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_clearColor_set) 

static bool js_cc_scene_Camera_clearColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::gfx::Color *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::gfx::Color *) &cc_scene_Camera_clearColor_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Camera_clearColor_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_clearColor_get) 

static bool js_cc_scene_Camera_clearDepth_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Camera_clearDepth_set,2,SWIGTYPE_float"); 
    cc_scene_Camera_clearDepth_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_clearDepth_set) 

static bool js_cc_scene_Camera_clearDepth_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_Camera_clearDepth_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_clearDepth_get) 

static bool js_cc_scene_Camera_clearFlag_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::gfx::ClearFlagBit arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Camera_clearFlag_set,2,SWIGTYPE_cc__gfx__ClearFlagBit"); 
    
    cc_scene_Camera_clearFlag_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_clearFlag_set) 

static bool js_cc_scene_Camera_clearFlag_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::gfx::ClearFlagBit result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_scene_Camera_clearFlag_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Camera_clearFlag_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_clearFlag_get) 

static bool js_cc_scene_Camera_clearStencil_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Camera_clearStencil_set,2,SWIGTYPE_float"); 
    cc_scene_Camera_clearStencil_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_clearStencil_set) 

static bool js_cc_scene_Camera_clearStencil_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_Camera_clearStencil_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_clearStencil_get) 

static bool js_cc_scene_Camera_enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Camera_enabled_set,2,SWIGTYPE_bool"); 
    cc_scene_Camera_enabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_enabled_set) 

static bool js_cc_scene_Camera_enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_Camera_enabled_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_enabled_get) 

static bool js_cc_scene_Camera_frustum_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::geometry::Frustum *arg2 = 0 ;
    cc::geometry::Frustum temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Camera_frustum_set,2,SWIGTYPE_p_cc__geometry__Frustum");
    arg2 = &temp2;
    
    cc_scene_Camera_frustum_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_frustum_set) 

static bool js_cc_scene_Camera_frustum_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::geometry::Frustum *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::geometry::Frustum *) &cc_scene_Camera_frustum_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Camera_frustum_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_frustum_get) 

static bool js_cc_scene_Camera_isWindowSize_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Camera_isWindowSize_set,2,SWIGTYPE_bool"); 
    cc_scene_Camera_isWindowSize_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_isWindowSize_set) 

static bool js_cc_scene_Camera_isWindowSize_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_Camera_isWindowSize_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_isWindowSize_get) 

static bool js_cc_scene_Camera_priority_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Camera_priority_set,2,SWIGTYPE_uint32_t"); 
    
    cc_scene_Camera_priority_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_priority_set) 

static bool js_cc_scene_Camera_priority_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_scene_Camera_priority_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Camera_priority_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_priority_get) 

static bool js_cc_scene_Camera_screenScale_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Camera_screenScale_set,2,SWIGTYPE_float"); 
    cc_scene_Camera_screenScale_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_screenScale_set) 

static bool js_cc_scene_Camera_screenScale_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_Camera_screenScale_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_screenScale_get) 

static bool js_cc_scene_Camera_visibility_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Camera_visibility_set,2,SWIGTYPE_uint32_t"); 
    
    cc_scene_Camera_visibility_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_visibility_set) 

static bool js_cc_scene_Camera_visibility_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_scene_Camera_visibility_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Camera_visibility_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_visibility_get) 

static bool js_cc_scene_Camera_node_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Camera_node_set,2,SWIGTYPE_p_cc__Node"); 
    cc_scene_Camera_node_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Camera_node_set) 

static bool js_cc_scene_Camera_node_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::Node *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Node *)cc_scene_Camera_node_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Camera_node_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_node_get) 

static bool js_cc_scene_Camera_surfaceTransform_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::gfx::SurfaceTransform result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_scene_Camera_surfaceTransform_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Camera_surfaceTransform_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_surfaceTransform_get) 

static bool js_cc_scene_Camera_geometryRenderer_get(se::State& s)
{
#if CC_USE_GEOMETRY_RENDERER
    
    CC_UNUSED bool ok = true;
    cc::scene::Camera *arg1 = (cc::scene::Camera *) NULL ;
    cc::pipeline::GeometryRenderer *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Camera>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::pipeline::GeometryRenderer *)cc_scene_Camera_geometryRenderer_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Camera_geometryRenderer_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
#endif // CC_USE_GEOMETRY_RENDERER
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Camera_geometryRenderer_get) 

bool js_register_cc_scene_Camera(se::Object* obj) {
    auto* cls = se::Class::create("Camera", obj, nullptr, _SE(js_new_cc_scene_Camera)); 
    
    cls->defineProperty("iso", _SE(js_cc_scene_Camera_iso_get), _SE(js_cc_scene_Camera_iso_set)); 
    cls->defineProperty("isoValue", _SE(js_cc_scene_Camera_isoValue_get), nullptr); 
    cls->defineProperty("ec", _SE(js_cc_scene_Camera_ec_get), _SE(js_cc_scene_Camera_ec_set)); 
    cls->defineProperty("exposure", _SE(js_cc_scene_Camera_exposure_get), nullptr); 
    cls->defineProperty("shutter", _SE(js_cc_scene_Camera_shutter_get), _SE(js_cc_scene_Camera_shutter_set)); 
    cls->defineProperty("shutterValue", _SE(js_cc_scene_Camera_shutterValue_get), nullptr); 
    cls->defineProperty("apertureValue", _SE(js_cc_scene_Camera_apertureValue_get), nullptr); 
    cls->defineProperty("width", _SE(js_cc_scene_Camera_width_get), nullptr); 
    cls->defineProperty("height", _SE(js_cc_scene_Camera_height_get), nullptr); 
    cls->defineProperty("aspect", _SE(js_cc_scene_Camera_aspect_get), nullptr); 
    cls->defineProperty("scene", _SE(js_cc_scene_Camera_scene_get), nullptr); 
    cls->defineProperty("name", _SE(js_cc_scene_Camera_name_get), nullptr); 
    cls->defineProperty("window", _SE(js_cc_scene_Camera_window_get), _SE(js_cc_scene_Camera_window_set)); 
    cls->defineProperty("forward", _SE(js_cc_scene_Camera_forward_get), _SE(js_cc_scene_Camera_forward_set)); 
    cls->defineProperty("aperture", _SE(js_cc_scene_Camera_aperture_get), _SE(js_cc_scene_Camera_aperture_set)); 
    cls->defineProperty("position", _SE(js_cc_scene_Camera_position_get), _SE(js_cc_scene_Camera_position_set)); 
    cls->defineProperty("projectionType", _SE(js_cc_scene_Camera_projectionType_get), _SE(js_cc_scene_Camera_projectionType_set)); 
    cls->defineProperty("fovAxis", _SE(js_cc_scene_Camera_fovAxis_get), _SE(js_cc_scene_Camera_fovAxis_set)); 
    cls->defineProperty("fov", _SE(js_cc_scene_Camera_fov_get), _SE(js_cc_scene_Camera_fov_set)); 
    cls->defineProperty("nearClip", _SE(js_cc_scene_Camera_nearClip_get), _SE(js_cc_scene_Camera_nearClip_set)); 
    cls->defineProperty("farClip", _SE(js_cc_scene_Camera_farClip_get), _SE(js_cc_scene_Camera_farClip_set)); 
    cls->defineProperty("viewport", _SE(js_cc_scene_Camera_viewport_get), _SE(js_cc_scene_Camera_viewport_set)); 
    cls->defineProperty("orthoHeight", _SE(js_cc_scene_Camera_orthoHeight_get), _SE(js_cc_scene_Camera_orthoHeight_set)); 
    cls->defineProperty("clearColor", _SE(js_cc_scene_Camera_clearColor_get), _SE(js_cc_scene_Camera_clearColor_set)); 
    cls->defineProperty("clearDepth", _SE(js_cc_scene_Camera_clearDepth_get), _SE(js_cc_scene_Camera_clearDepth_set)); 
    cls->defineProperty("clearFlag", _SE(js_cc_scene_Camera_clearFlag_get), _SE(js_cc_scene_Camera_clearFlag_set)); 
    cls->defineProperty("clearStencil", _SE(js_cc_scene_Camera_clearStencil_get), _SE(js_cc_scene_Camera_clearStencil_set)); 
    cls->defineProperty("enabled", _SE(js_cc_scene_Camera_enabled_get), _SE(js_cc_scene_Camera_enabled_set)); 
    cls->defineProperty("frustum", _SE(js_cc_scene_Camera_frustum_get), _SE(js_cc_scene_Camera_frustum_set)); 
    cls->defineProperty("isWindowSize", _SE(js_cc_scene_Camera_isWindowSize_get), _SE(js_cc_scene_Camera_isWindowSize_set)); 
    cls->defineProperty("priority", _SE(js_cc_scene_Camera_priority_get), _SE(js_cc_scene_Camera_priority_set)); 
    cls->defineProperty("screenScale", _SE(js_cc_scene_Camera_screenScale_get), _SE(js_cc_scene_Camera_screenScale_set)); 
    cls->defineProperty("visibility", _SE(js_cc_scene_Camera_visibility_get), _SE(js_cc_scene_Camera_visibility_set)); 
    cls->defineProperty("node", _SE(js_cc_scene_Camera_node_get), _SE(js_cc_scene_Camera_node_set)); 
    cls->defineProperty("surfaceTransform", _SE(js_cc_scene_Camera_surfaceTransform_get), nullptr); 
    cls->defineProperty("geometryRenderer", _SE(js_cc_scene_Camera_geometryRenderer_get), nullptr); 
    
    cls->defineFunction("initialize", _SE(js_cc_scene_Camera_initialize)); 
    cls->defineFunction("destroy", _SE(js_cc_scene_Camera_destroy)); 
    cls->defineFunction("attachToScene", _SE(js_cc_scene_Camera_attachToScene)); 
    cls->defineFunction("detachFromScene", _SE(js_cc_scene_Camera_detachFromScene)); 
    cls->defineFunction("resize", _SE(js_cc_scene_Camera_resize)); 
    cls->defineFunction("setFixedSize", _SE(js_cc_scene_Camera_setFixedSize)); 
    cls->defineFunction("update", _SE(js_cc_scene_Camera_update)); 
    cls->defineFunction("changeTargetWindow", _SE(js_cc_scene_Camera_changeTargetWindow)); 
    cls->defineFunction("setViewportInOrientedSpace", _SE(js_cc_scene_Camera_setViewportInOrientedSpace)); 
    cls->defineFunction("initGeometryRenderer", _SE(js_cc_scene_Camera_initGeometryRenderer)); 
    cls->defineFunction("detachCamera", _SE(js_cc_scene_Camera_detachCamera)); 
    
    cls->defineStaticProperty("SKYBOX_FLAG", _SE(js_cc_scene_Camera_SKYBOX_FLAG_get), nullptr); 
    
    cls->defineStaticFunction("getStandardExposureValue", _SE(js_cc_scene_Camera_getStandardExposureValue_static)); 
    cls->defineStaticFunction("getStandardLightMeterScale", _SE(js_cc_scene_Camera_getStandardLightMeterScale_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_Camera));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::Camera>(cls);
    
    __jsb_cc_scene_Camera_proto = cls->getProto();
    __jsb_cc_scene_Camera_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_Ambient_class = nullptr;
se::Object* __jsb_cc_scene_Ambient_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_Ambient) 

static bool js_cc_scene_Ambient_SUN_ILLUM_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    float result;
    
    result = (float)(float)cc::scene::Ambient::SUN_ILLUM;
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Ambient_SUN_ILLUM_get) 

static bool js_cc_scene_Ambient_SKY_ILLUM_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    float result;
    
    result = (float)(float)cc::scene::Ambient::SKY_ILLUM;
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Ambient_SKY_ILLUM_get) 

// js_ctor
static bool js_new_cc_scene_Ambient(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::Ambient *result;
    result = (cc::scene::Ambient *)new cc::scene::Ambient();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_Ambient, __jsb_cc_scene_Ambient_class, js_delete_cc_scene_Ambient)

static bool js_delete_cc_scene_Ambient(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_Ambient) 

static bool js_cc_scene_Ambient_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Ambient *arg1 = (cc::scene::Ambient *) NULL ;
    cc::scene::AmbientInfo *arg2 = (cc::scene::AmbientInfo *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Ambient>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Ambient_initialize,2,SWIGTYPE_p_cc__scene__AmbientInfo"); 
    (arg1)->initialize(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Ambient_initialize) 

static bool js_cc_scene_Ambient_skyColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Ambient *arg1 = (cc::scene::Ambient *) NULL ;
    cc::Vec4 *arg2 = 0 ;
    cc::Vec4 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Ambient>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Ambient_skyColor_set,2,SWIGTYPE_p_cc__Vec4");
    arg2 = &temp2;
    
    cc_scene_Ambient_skyColor_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Ambient_skyColor_set) 

static bool js_cc_scene_Ambient_skyColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Ambient *arg1 = (cc::scene::Ambient *) NULL ;
    cc::Vec4 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Ambient>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Vec4 *) &cc_scene_Ambient_skyColor_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Ambient_skyColor_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Ambient_skyColor_get) 

static bool js_cc_scene_Ambient_skyIllum_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Ambient *arg1 = (cc::scene::Ambient *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Ambient>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Ambient_skyIllum_set,2,SWIGTYPE_float"); 
    cc_scene_Ambient_skyIllum_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Ambient_skyIllum_set) 

static bool js_cc_scene_Ambient_skyIllum_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Ambient *arg1 = (cc::scene::Ambient *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Ambient>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_Ambient_skyIllum_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Ambient_skyIllum_get) 

static bool js_cc_scene_Ambient_groundAlbedo_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Ambient *arg1 = (cc::scene::Ambient *) NULL ;
    cc::Vec4 *arg2 = 0 ;
    cc::Vec4 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Ambient>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Ambient_groundAlbedo_set,2,SWIGTYPE_p_cc__Vec4");
    arg2 = &temp2;
    
    cc_scene_Ambient_groundAlbedo_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Ambient_groundAlbedo_set) 

static bool js_cc_scene_Ambient_groundAlbedo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Ambient *arg1 = (cc::scene::Ambient *) NULL ;
    cc::Vec4 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Ambient>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Vec4 *) &cc_scene_Ambient_groundAlbedo_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Ambient_groundAlbedo_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Ambient_groundAlbedo_get) 

static bool js_cc_scene_Ambient_enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Ambient *arg1 = (cc::scene::Ambient *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Ambient>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Ambient_enabled_set,2,SWIGTYPE_bool"); 
    cc_scene_Ambient_enabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Ambient_enabled_set) 

static bool js_cc_scene_Ambient_enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Ambient *arg1 = (cc::scene::Ambient *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Ambient>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_Ambient_enabled_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Ambient_enabled_get) 

static bool js_cc_scene_Ambient_mipmapCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Ambient *arg1 = (cc::scene::Ambient *) NULL ;
    uint8_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Ambient>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Ambient_mipmapCount_set,2,SWIGTYPE_uint8_t"); 
    
    cc_scene_Ambient_mipmapCount_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_Ambient_mipmapCount_set) 

static bool js_cc_scene_Ambient_mipmapCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::Ambient *arg1 = (cc::scene::Ambient *) NULL ;
    uint8_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::Ambient>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_scene_Ambient_mipmapCount_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Ambient_mipmapCount_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_Ambient_mipmapCount_get) 

bool js_register_cc_scene_Ambient(se::Object* obj) {
    auto* cls = se::Class::create("Ambient", obj, nullptr, _SE(js_new_cc_scene_Ambient)); 
    
    cls->defineProperty("skyColor", _SE(js_cc_scene_Ambient_skyColor_get), _SE(js_cc_scene_Ambient_skyColor_set)); 
    cls->defineProperty("skyIllum", _SE(js_cc_scene_Ambient_skyIllum_get), _SE(js_cc_scene_Ambient_skyIllum_set)); 
    cls->defineProperty("groundAlbedo", _SE(js_cc_scene_Ambient_groundAlbedo_get), _SE(js_cc_scene_Ambient_groundAlbedo_set)); 
    cls->defineProperty("enabled", _SE(js_cc_scene_Ambient_enabled_get), _SE(js_cc_scene_Ambient_enabled_set)); 
    cls->defineProperty("mipmapCount", _SE(js_cc_scene_Ambient_mipmapCount_get), _SE(js_cc_scene_Ambient_mipmapCount_set)); 
    
    cls->defineFunction("initialize", _SE(js_cc_scene_Ambient_initialize)); 
    
    cls->defineStaticProperty("SUN_ILLUM", _SE(js_cc_scene_Ambient_SUN_ILLUM_get), nullptr); 
    cls->defineStaticProperty("SKY_ILLUM", _SE(js_cc_scene_Ambient_SKY_ILLUM_get), nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_Ambient));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::Ambient>(cls);
    
    __jsb_cc_scene_Ambient_proto = cls->getProto();
    __jsb_cc_scene_Ambient_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_AmbientInfo_class = nullptr;
se::Object* __jsb_cc_scene_AmbientInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_AmbientInfo) 

// js_ctor
static bool js_new_cc_scene_AmbientInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::AmbientInfo *result;
    result = (cc::scene::AmbientInfo *)new cc::scene::AmbientInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_AmbientInfo, __jsb_cc_scene_AmbientInfo_class, js_delete_cc_scene_AmbientInfo)

static bool js_delete_cc_scene_AmbientInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_AmbientInfo) 

static bool js_cc_scene_AmbientInfo_activate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    cc::scene::Ambient *arg2 = (cc::scene::Ambient *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "AmbientInfo_activate,2,SWIGTYPE_p_cc__scene__Ambient"); 
    (arg1)->activate(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_AmbientInfo_activate) 

static bool js_cc_scene_AmbientInfo__skyColorHDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_skyColorHDR, s.thisObject());
    SE_PRECONDITION2(ok, false, "AmbientInfo__skyColorHDR_set,2,SWIGTYPE_cc__Vec4"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo__skyColorHDR_set) 

static bool js_cc_scene_AmbientInfo__skyColorHDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_skyColorHDR, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AmbientInfo__skyColorHDR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_skyColorHDR, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo__skyColorHDR_get) 

static bool js_cc_scene_AmbientInfo__skyIllumHDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->_skyIllumHDR, nullptr);
    SE_PRECONDITION2(ok, false, "AmbientInfo__skyIllumHDR_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo__skyIllumHDR_set) 

static bool js_cc_scene_AmbientInfo__skyIllumHDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->_skyIllumHDR, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo__skyIllumHDR_get) 

static bool js_cc_scene_AmbientInfo__groundAlbedoHDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_groundAlbedoHDR, s.thisObject());
    SE_PRECONDITION2(ok, false, "AmbientInfo__groundAlbedoHDR_set,2,SWIGTYPE_cc__Vec4"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo__groundAlbedoHDR_set) 

static bool js_cc_scene_AmbientInfo__groundAlbedoHDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_groundAlbedoHDR, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AmbientInfo__groundAlbedoHDR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_groundAlbedoHDR, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo__groundAlbedoHDR_get) 

static bool js_cc_scene_AmbientInfo__skyColorLDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_skyColorLDR, s.thisObject());
    SE_PRECONDITION2(ok, false, "AmbientInfo__skyColorLDR_set,2,SWIGTYPE_cc__Vec4"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo__skyColorLDR_set) 

static bool js_cc_scene_AmbientInfo__skyColorLDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_skyColorLDR, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AmbientInfo__skyColorLDR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_skyColorLDR, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo__skyColorLDR_get) 

static bool js_cc_scene_AmbientInfo__skyIllumLDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->_skyIllumLDR, nullptr);
    SE_PRECONDITION2(ok, false, "AmbientInfo__skyIllumLDR_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo__skyIllumLDR_set) 

static bool js_cc_scene_AmbientInfo__skyIllumLDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->_skyIllumLDR, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo__skyIllumLDR_get) 

static bool js_cc_scene_AmbientInfo__groundAlbedoLDR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_groundAlbedoLDR, s.thisObject());
    SE_PRECONDITION2(ok, false, "AmbientInfo__groundAlbedoLDR_set,2,SWIGTYPE_cc__Vec4"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo__groundAlbedoLDR_set) 

static bool js_cc_scene_AmbientInfo__groundAlbedoLDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_groundAlbedoLDR, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AmbientInfo__groundAlbedoLDR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_groundAlbedoLDR, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo__groundAlbedoLDR_get) 

static bool js_cc_scene_AmbientInfo_skyColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    cc::Vec4 *arg2 = 0 ;
    cc::Vec4 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "AmbientInfo_skyColor_set,2,SWIGTYPE_p_cc__Vec4");
    arg2 = &temp2;
    
    cc_scene_AmbientInfo_skyColor_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo_skyColor_set) 

static bool js_cc_scene_AmbientInfo_skyIllum_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "AmbientInfo_skyIllum_set,2,SWIGTYPE_float"); 
    cc_scene_AmbientInfo_skyIllum_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo_skyIllum_set) 

static bool js_cc_scene_AmbientInfo_skyIllum_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_AmbientInfo_skyIllum_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo_skyIllum_get) 

static bool js_cc_scene_AmbientInfo_groundAlbedo_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    cc::Vec4 *arg2 = 0 ;
    cc::Vec4 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "AmbientInfo_groundAlbedo_set,2,SWIGTYPE_p_cc__Vec4");
    arg2 = &temp2;
    
    cc_scene_AmbientInfo_groundAlbedo_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo_groundAlbedo_set) 

static bool js_cc_scene_AmbientInfo__skyColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    cc::Vec4 *arg2 = 0 ;
    cc::Vec4 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "AmbientInfo__skyColor_set,2,SWIGTYPE_p_cc__Vec4");
    arg2 = &temp2;
    
    cc_scene_AmbientInfo__skyColor_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo__skyColor_set) 

static bool js_cc_scene_AmbientInfo__skyColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    cc::Vec4 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Vec4 *) &cc_scene_AmbientInfo__skyColor_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AmbientInfo__skyColor_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo__skyColor_get) 

static bool js_cc_scene_AmbientInfo__skyIllum_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "AmbientInfo__skyIllum_set,2,SWIGTYPE_float"); 
    cc_scene_AmbientInfo__skyIllum_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo__skyIllum_set) 

static bool js_cc_scene_AmbientInfo__skyIllum_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_AmbientInfo__skyIllum_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo__skyIllum_get) 

static bool js_cc_scene_AmbientInfo__groundAlbedo_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    cc::Vec4 *arg2 = 0 ;
    cc::Vec4 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "AmbientInfo__groundAlbedo_set,2,SWIGTYPE_p_cc__Vec4");
    arg2 = &temp2;
    
    cc_scene_AmbientInfo__groundAlbedo_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo__groundAlbedo_set) 

static bool js_cc_scene_AmbientInfo__groundAlbedo_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    cc::Vec4 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Vec4 *) &cc_scene_AmbientInfo__groundAlbedo_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AmbientInfo__groundAlbedo_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo__groundAlbedo_get) 

static bool js_cc_scene_AmbientInfo_skyColorLDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    cc::Vec4 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Vec4 *) &cc_scene_AmbientInfo_skyColorLDR_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AmbientInfo_skyColorLDR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo_skyColorLDR_get) 

static bool js_cc_scene_AmbientInfo_groundAlbedoLDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    cc::Vec4 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Vec4 *) &cc_scene_AmbientInfo_groundAlbedoLDR_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AmbientInfo_groundAlbedoLDR_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo_groundAlbedoLDR_get) 

static bool js_cc_scene_AmbientInfo_skyIllumLDR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)cc_scene_AmbientInfo_skyIllumLDR_get(arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo_skyIllumLDR_get) 

static bool js_cc_scene_AmbientInfo_skyLightingColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    cc::Color *arg2 = 0 ;
    cc::Color temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "AmbientInfo_skyLightingColor_set,2,SWIGTYPE_p_cc__Color");
    arg2 = &temp2;
    
    cc_scene_AmbientInfo_skyLightingColor_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo_skyLightingColor_set) 

static bool js_cc_scene_AmbientInfo_skyLightingColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    cc::Color *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Color *) &cc_scene_AmbientInfo_skyLightingColor_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AmbientInfo_skyLightingColor_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo_skyLightingColor_get) 

static bool js_cc_scene_AmbientInfo_groundLightingColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    cc::Color *arg2 = 0 ;
    cc::Color temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "AmbientInfo_groundLightingColor_set,2,SWIGTYPE_p_cc__Color");
    arg2 = &temp2;
    
    cc_scene_AmbientInfo_groundLightingColor_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_AmbientInfo_groundLightingColor_set) 

static bool js_cc_scene_AmbientInfo_groundLightingColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::AmbientInfo *arg1 = (cc::scene::AmbientInfo *) NULL ;
    cc::Color *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::AmbientInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Color *) &cc_scene_AmbientInfo_groundLightingColor_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AmbientInfo_groundLightingColor_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_AmbientInfo_groundLightingColor_get) 

bool js_register_cc_scene_AmbientInfo(se::Object* obj) {
    auto* cls = se::Class::create("AmbientInfo", obj, nullptr, _SE(js_new_cc_scene_AmbientInfo)); 
    
    cls->defineProperty("_skyColorHDR", _SE(js_cc_scene_AmbientInfo__skyColorHDR_get), _SE(js_cc_scene_AmbientInfo__skyColorHDR_set)); 
    cls->defineProperty("_skyIllumHDR", _SE(js_cc_scene_AmbientInfo__skyIllumHDR_get), _SE(js_cc_scene_AmbientInfo__skyIllumHDR_set)); 
    cls->defineProperty("_groundAlbedoHDR", _SE(js_cc_scene_AmbientInfo__groundAlbedoHDR_get), _SE(js_cc_scene_AmbientInfo__groundAlbedoHDR_set)); 
    cls->defineProperty("_skyColorLDR", _SE(js_cc_scene_AmbientInfo__skyColorLDR_get), _SE(js_cc_scene_AmbientInfo__skyColorLDR_set)); 
    cls->defineProperty("_skyIllumLDR", _SE(js_cc_scene_AmbientInfo__skyIllumLDR_get), _SE(js_cc_scene_AmbientInfo__skyIllumLDR_set)); 
    cls->defineProperty("_groundAlbedoLDR", _SE(js_cc_scene_AmbientInfo__groundAlbedoLDR_get), _SE(js_cc_scene_AmbientInfo__groundAlbedoLDR_set)); 
    cls->defineProperty("skyColor", nullptr, _SE(js_cc_scene_AmbientInfo_skyColor_set)); 
    cls->defineProperty("skyIllum", _SE(js_cc_scene_AmbientInfo_skyIllum_get), _SE(js_cc_scene_AmbientInfo_skyIllum_set)); 
    cls->defineProperty("groundAlbedo", nullptr, _SE(js_cc_scene_AmbientInfo_groundAlbedo_set)); 
    cls->defineProperty("_skyColor", _SE(js_cc_scene_AmbientInfo__skyColor_get), _SE(js_cc_scene_AmbientInfo__skyColor_set)); 
    cls->defineProperty("_skyIllum", _SE(js_cc_scene_AmbientInfo__skyIllum_get), _SE(js_cc_scene_AmbientInfo__skyIllum_set)); 
    cls->defineProperty("_groundAlbedo", _SE(js_cc_scene_AmbientInfo__groundAlbedo_get), _SE(js_cc_scene_AmbientInfo__groundAlbedo_set)); 
    cls->defineProperty("skyColorLDR", _SE(js_cc_scene_AmbientInfo_skyColorLDR_get), nullptr); 
    cls->defineProperty("groundAlbedoLDR", _SE(js_cc_scene_AmbientInfo_groundAlbedoLDR_get), nullptr); 
    cls->defineProperty("skyIllumLDR", _SE(js_cc_scene_AmbientInfo_skyIllumLDR_get), nullptr); 
    cls->defineProperty("skyLightingColor", _SE(js_cc_scene_AmbientInfo_skyLightingColor_get), _SE(js_cc_scene_AmbientInfo_skyLightingColor_set)); 
    cls->defineProperty("groundLightingColor", _SE(js_cc_scene_AmbientInfo_groundLightingColor_get), _SE(js_cc_scene_AmbientInfo_groundLightingColor_set)); 
    
    cls->defineFunction("activate", _SE(js_cc_scene_AmbientInfo_activate)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_AmbientInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::AmbientInfo>(cls);
    
    __jsb_cc_scene_AmbientInfo_proto = cls->getProto();
    __jsb_cc_scene_AmbientInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_PassInstance_class = nullptr;
se::Object* __jsb_cc_PassInstance_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_PassInstance) 

// js_ctor
static bool js_new_cc_PassInstance(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 2) {
        SE_REPORT_ERROR("js_new_cc_PassInstance: wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    
    cc::scene::Pass *arg1 = (cc::scene::Pass *) NULL ;
    cc::MaterialInstance *arg2 = (cc::MaterialInstance *) NULL ;
    cc::PassInstance *result;
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_PassInstance,1,SWIGTYPE_p_cc__scene__Pass"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_PassInstance,2,SWIGTYPE_p_cc__MaterialInstance"); 
    result = (cc::PassInstance *)new cc::PassInstance(arg1,arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_PassInstance, __jsb_cc_PassInstance_class, js_delete_cc_PassInstance)

static bool js_delete_cc_PassInstance(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_PassInstance) 

static bool js_cc_PassInstance_parent_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::PassInstance *arg1 = (cc::PassInstance *) NULL ;
    cc::scene::Pass *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::PassInstance>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::scene::Pass *)cc_PassInstance_parent_get(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "PassInstance_parent_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_PassInstance_parent_get) 

bool js_register_cc_PassInstance(se::Object* obj) {
    auto* cls = se::Class::create("PassInstance", obj, __jsb_cc_scene_Pass_proto, _SE(js_new_cc_PassInstance)); 
    
    cls->defineProperty("parent", _SE(js_cc_PassInstance_parent_get), nullptr); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_PassInstance));
    
    
    cls->install();
    JSBClassType::registerClass<cc::PassInstance>(cls);
    
    __jsb_cc_PassInstance_proto = cls->getProto();
    __jsb_cc_PassInstance_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IMaterialInstanceInfo_class = nullptr;
se::Object* __jsb_cc_IMaterialInstanceInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IMaterialInstanceInfo) 

static bool js_cc_IMaterialInstanceInfo_parent_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMaterialInstanceInfo *arg1 = (cc::IMaterialInstanceInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInstanceInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1->parent, s.thisObject());
    SE_PRECONDITION2(ok, false, "IMaterialInstanceInfo_parent_set,2,SWIGTYPE_p_cc__Material"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMaterialInstanceInfo_parent_set) 

static bool js_cc_IMaterialInstanceInfo_parent_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMaterialInstanceInfo *arg1 = (cc::IMaterialInstanceInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInstanceInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(arg1->parent, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IMaterialInstanceInfo_parent_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->parent, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMaterialInstanceInfo_parent_get) 

static bool js_cc_IMaterialInstanceInfo_subModelIdx_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMaterialInstanceInfo *arg1 = (cc::IMaterialInstanceInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInstanceInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->subModelIdx, s.thisObject());
    SE_PRECONDITION2(ok, false, "IMaterialInstanceInfo_subModelIdx_set,2,SWIGTYPE_int32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMaterialInstanceInfo_subModelIdx_set) 

static bool js_cc_IMaterialInstanceInfo_subModelIdx_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMaterialInstanceInfo *arg1 = (cc::IMaterialInstanceInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMaterialInstanceInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->subModelIdx, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IMaterialInstanceInfo_subModelIdx_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->subModelIdx, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMaterialInstanceInfo_subModelIdx_get) 

// js_ctor
static bool js_new_cc_IMaterialInstanceInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IMaterialInstanceInfo *result;
    result = (cc::IMaterialInstanceInfo *)new cc::IMaterialInstanceInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IMaterialInstanceInfo, __jsb_cc_IMaterialInstanceInfo_class, js_delete_cc_IMaterialInstanceInfo)

static bool js_delete_cc_IMaterialInstanceInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IMaterialInstanceInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IMaterialInstanceInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IMaterialInstanceInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("parent", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->parent), ctx);
    }
    
    
    json->getProperty("subModelIdx", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->subModelIdx), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IMaterialInstanceInfo(se::Object* obj) {
    auto* cls = se::Class::create("IMaterialInstanceInfo", obj, nullptr, _SE(js_new_cc_IMaterialInstanceInfo)); 
    
    cls->defineProperty("parent", _SE(js_cc_IMaterialInstanceInfo_parent_get), _SE(js_cc_IMaterialInstanceInfo_parent_set)); 
    cls->defineProperty("subModelIdx", _SE(js_cc_IMaterialInstanceInfo_subModelIdx_get), _SE(js_cc_IMaterialInstanceInfo_subModelIdx_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IMaterialInstanceInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IMaterialInstanceInfo>(cls);
    
    __jsb_cc_IMaterialInstanceInfo_proto = cls->getProto();
    __jsb_cc_IMaterialInstanceInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_MaterialInstance_class = nullptr;
se::Object* __jsb_cc_MaterialInstance_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_MaterialInstance) 

// js_ctor
static bool js_new_cc_MaterialInstance(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 1) {
        SE_REPORT_ERROR("js_new_cc_MaterialInstance: wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    cc::IMaterialInstanceInfo *arg1 = 0 ;
    cc::IMaterialInstanceInfo temp1 ;
    cc::MaterialInstance *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_MaterialInstance,1,SWIGTYPE_p_cc__IMaterialInstanceInfo");
    arg1 = &temp1;
    
    result = (cc::MaterialInstance *)new cc::MaterialInstance((cc::IMaterialInstanceInfo const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_MaterialInstance, __jsb_cc_MaterialInstance_class, js_delete_cc_MaterialInstance)

static bool js_cc_MaterialInstance_recompileShaders__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::MaterialInstance *arg1 = (cc::MaterialInstance *) NULL ;
    cc::MacroRecord *arg2 = 0 ;
    cc::MacroRecord temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::MaterialInstance>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "MaterialInstance_recompileShaders,2,SWIGTYPE_p_ccstd__unordered_mapT_ccstd__string_cc__MacroValue_t");
    arg2 = &temp2;
    
    (arg1)->recompileShaders((cc::MacroRecord const &)*arg2);
    
    
    return true;
}

static bool js_cc_MaterialInstance_recompileShaders__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::MaterialInstance *arg1 = (cc::MaterialInstance *) NULL ;
    cc::MacroRecord *arg2 = 0 ;
    index_t arg3 ;
    cc::MacroRecord temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::MaterialInstance>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "MaterialInstance_recompileShaders,2,SWIGTYPE_p_ccstd__unordered_mapT_ccstd__string_cc__MacroValue_t");
    arg2 = &temp2;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "MaterialInstance_recompileShaders,3,SWIGTYPE_int32_t"); 
    
    (arg1)->recompileShaders((cc::MacroRecord const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_MaterialInstance_recompileShaders(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_MaterialInstance_recompileShaders__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_MaterialInstance_recompileShaders__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_MaterialInstance_recompileShaders) 

static bool js_cc_MaterialInstance_overridePipelineStates__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::MaterialInstance *arg1 = (cc::MaterialInstance *) NULL ;
    cc::PassOverrides *arg2 = 0 ;
    cc::PassOverrides temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::MaterialInstance>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "MaterialInstance_overridePipelineStates,2,SWIGTYPE_p_cc__IPassStates");
    arg2 = &temp2;
    
    (arg1)->overridePipelineStates((cc::PassOverrides const &)*arg2);
    
    
    return true;
}

static bool js_cc_MaterialInstance_overridePipelineStates__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::MaterialInstance *arg1 = (cc::MaterialInstance *) NULL ;
    cc::PassOverrides *arg2 = 0 ;
    index_t arg3 ;
    cc::PassOverrides temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::MaterialInstance>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "MaterialInstance_overridePipelineStates,2,SWIGTYPE_p_cc__IPassStates");
    arg2 = &temp2;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "MaterialInstance_overridePipelineStates,3,SWIGTYPE_int32_t"); 
    
    (arg1)->overridePipelineStates((cc::PassOverrides const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_MaterialInstance_overridePipelineStates(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_MaterialInstance_overridePipelineStates__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_MaterialInstance_overridePipelineStates__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_MaterialInstance_overridePipelineStates) 

static bool js_cc_MaterialInstance_onPassStateChange(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MaterialInstance *arg1 = (cc::MaterialInstance *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::MaterialInstance>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "MaterialInstance_onPassStateChange,2,SWIGTYPE_bool"); 
    (arg1)->onPassStateChange(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_MaterialInstance_onPassStateChange) 

static bool js_cc_MaterialInstance_setRebuildPSOCallback(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MaterialInstance *arg1 = (cc::MaterialInstance *) NULL ;
    cc::MaterialInstance::RebuildPSOCallback *arg2 = 0 ;
    cc::MaterialInstance::RebuildPSOCallback temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::MaterialInstance>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "MaterialInstance_setRebuildPSOCallback,2,SWIGTYPE_p_std__functionT_void_fint32_t_cc__Material_pF_t");
    arg2 = &temp2;
    
    (arg1)->setRebuildPSOCallback((cc::MaterialInstance::RebuildPSOCallback const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_MaterialInstance_setRebuildPSOCallback) 

static bool js_delete_cc_MaterialInstance(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_MaterialInstance) 

bool js_register_cc_MaterialInstance(se::Object* obj) {
    auto* cls = se::Class::create("MaterialInstance", obj, __jsb_cc_Material_proto, _SE(js_new_cc_MaterialInstance)); 
    
    
    cls->defineFunction("recompileShaders", _SE(js_cc_MaterialInstance_recompileShaders)); 
    cls->defineFunction("overridePipelineStates", _SE(js_cc_MaterialInstance_overridePipelineStates)); 
    cls->defineFunction("onPassStateChange", _SE(js_cc_MaterialInstance_onPassStateChange)); 
    cls->defineFunction("setRebuildPSOCallback", _SE(js_cc_MaterialInstance_setRebuildPSOCallback)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_MaterialInstance));
    
    
    cls->install();
    JSBClassType::registerClass<cc::MaterialInstance>(cls);
    
    __jsb_cc_MaterialInstance_proto = cls->getProto();
    __jsb_cc_MaterialInstance_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_MorphModel_class = nullptr;
se::Object* __jsb_cc_MorphModel_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_MorphModel) 

// js_ctor
static bool js_new_cc_MorphModel(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::MorphModel *result;
    result = (cc::MorphModel *)new cc::MorphModel();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_MorphModel, __jsb_cc_MorphModel_class, js_delete_cc_MorphModel)

static bool js_delete_cc_MorphModel(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_MorphModel) 

static bool js_cc_MorphModel_setMorphRendering(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MorphModel *arg1 = (cc::MorphModel *) NULL ;
    cc::MorphRenderingInstance *arg2 = (cc::MorphRenderingInstance *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::MorphModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "MorphModel_setMorphRendering,2,SWIGTYPE_p_cc__MorphRenderingInstance"); 
    (arg1)->setMorphRendering(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_MorphModel_setMorphRendering) 

bool js_register_cc_MorphModel(se::Object* obj) {
    auto* cls = se::Class::create("MorphModel", obj, __jsb_cc_scene_Model_proto, _SE(js_new_cc_MorphModel)); 
    
    
    cls->defineFunction("setMorphRendering", _SE(js_cc_MorphModel_setMorphRendering)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_MorphModel));
    
    
    cls->install();
    JSBClassType::registerClass<cc::MorphModel>(cls);
    
    __jsb_cc_MorphModel_proto = cls->getProto();
    __jsb_cc_MorphModel_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_SkinningModel_class = nullptr;
se::Object* __jsb_cc_SkinningModel_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_SkinningModel) 

// js_ctor
static bool js_new_cc_SkinningModel(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::SkinningModel *result;
    result = (cc::SkinningModel *)new cc::SkinningModel();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_SkinningModel, __jsb_cc_SkinningModel_class, js_delete_cc_SkinningModel)

static bool js_delete_cc_SkinningModel(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_SkinningModel) 

static bool js_cc_SkinningModel_bindSkeleton(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SkinningModel *arg1 = (cc::SkinningModel *) NULL ;
    cc::Skeleton *arg2 = (cc::Skeleton *) NULL ;
    cc::Node *arg3 = (cc::Node *) NULL ;
    cc::Mesh *arg4 = (cc::Mesh *) NULL ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SkinningModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkinningModel_bindSkeleton,2,SWIGTYPE_p_cc__Skeleton"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkinningModel_bindSkeleton,3,SWIGTYPE_p_cc__Node"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "SkinningModel_bindSkeleton,4,SWIGTYPE_p_cc__Mesh"); 
    (arg1)->bindSkeleton(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_SkinningModel_bindSkeleton) 

bool js_register_cc_SkinningModel(se::Object* obj) {
    auto* cls = se::Class::create("SkinningModel", obj, __jsb_cc_MorphModel_proto, _SE(js_new_cc_SkinningModel)); 
    
    
    cls->defineFunction("bindSkeleton", _SE(js_cc_SkinningModel_bindSkeleton)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_SkinningModel));
    
    
    cls->install();
    JSBClassType::registerClass<cc::SkinningModel>(cls);
    
    __jsb_cc_SkinningModel_proto = cls->getProto();
    __jsb_cc_SkinningModel_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_BakedSkinningModel_class = nullptr;
se::Object* __jsb_cc_BakedSkinningModel_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_BakedSkinningModel) 

// js_ctor
static bool js_new_cc_BakedSkinningModel(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::BakedSkinningModel *result;
    result = (cc::BakedSkinningModel *)new cc::BakedSkinningModel();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_BakedSkinningModel, __jsb_cc_BakedSkinningModel_class, js_delete_cc_BakedSkinningModel)

static bool js_delete_cc_BakedSkinningModel(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_BakedSkinningModel) 

static bool js_cc_BakedSkinningModel_updateInstancedJointTextureInfo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BakedSkinningModel *arg1 = (cc::BakedSkinningModel *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BakedSkinningModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->updateInstancedJointTextureInfo();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BakedSkinningModel_updateInstancedJointTextureInfo) 

static bool js_cc_BakedSkinningModel_bindSkeleton(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BakedSkinningModel *arg1 = (cc::BakedSkinningModel *) NULL ;
    cc::Skeleton *arg2 = (cc::Skeleton *) NULL ;
    cc::Node *arg3 = (cc::Node *) NULL ;
    cc::Mesh *arg4 = (cc::Mesh *) NULL ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BakedSkinningModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BakedSkinningModel_bindSkeleton,2,SWIGTYPE_p_cc__Skeleton"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "BakedSkinningModel_bindSkeleton,3,SWIGTYPE_p_cc__Node"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "BakedSkinningModel_bindSkeleton,4,SWIGTYPE_p_cc__Mesh"); 
    (arg1)->bindSkeleton(arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BakedSkinningModel_bindSkeleton) 

static bool js_cc_BakedSkinningModel_updateModelBounds(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BakedSkinningModel *arg1 = (cc::BakedSkinningModel *) NULL ;
    cc::geometry::AABB *arg2 = (cc::geometry::AABB *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BakedSkinningModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BakedSkinningModel_updateModelBounds,2,SWIGTYPE_p_cc__geometry__AABB"); 
    (arg1)->updateModelBounds(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BakedSkinningModel_updateModelBounds) 

static bool js_cc_BakedSkinningModel_syncAnimInfoForJS(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BakedSkinningModel *arg1 = (cc::BakedSkinningModel *) NULL ;
    cc::gfx::Buffer *arg2 = (cc::gfx::Buffer *) NULL ;
    cc::Float32Array *arg3 = 0 ;
    cc::Uint8Array *arg4 = 0 ;
    cc::Float32Array temp3 ;
    cc::Uint8Array temp4 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BakedSkinningModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BakedSkinningModel_syncAnimInfoForJS,2,SWIGTYPE_p_cc__gfx__Buffer"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "BakedSkinningModel_syncAnimInfoForJS,3,SWIGTYPE_p_cc__TypedArrayTempT_float_t");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "BakedSkinningModel_syncAnimInfoForJS,4,SWIGTYPE_p_cc__TypedArrayTempT_uint8_t_t");
    arg4 = &temp4;
    
    (arg1)->syncAnimInfoForJS(arg2,(cc::Float32Array const &)*arg3,*arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BakedSkinningModel_syncAnimInfoForJS) 

static bool js_cc_BakedSkinningModel_syncDataForJS(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BakedSkinningModel *arg1 = (cc::BakedSkinningModel *) NULL ;
    ccstd::vector< ccstd::optional< cc::geometry::AABB > > *arg2 = 0 ;
    ccstd::optional< cc::geometry::AABB > *arg3 = 0 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    cc::gfx::Texture *arg8 = (cc::gfx::Texture *) NULL ;
    cc::Float32Array *arg9 = 0 ;
    ccstd::vector< ccstd::optional< cc::geometry::AABB > > temp2 ;
    ccstd::optional< cc::geometry::AABB > temp3 ;
    cc::Float32Array temp9 ;
    
    if(argc != 8) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 8);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BakedSkinningModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BakedSkinningModel_syncDataForJS,2,SWIGTYPE_p_ccstd__vectorT_ccstd__optionalT_cc__geometry__AABB_t_t");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "BakedSkinningModel_syncDataForJS,3,SWIGTYPE_p_ccstd__optionalT_cc__geometry__AABB_t");
    arg3 = &temp3;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "BakedSkinningModel_syncDataForJS,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "BakedSkinningModel_syncDataForJS,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "BakedSkinningModel_syncDataForJS,6,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg7, nullptr);
    SE_PRECONDITION2(ok, false, "BakedSkinningModel_syncDataForJS,7,SWIGTYPE_float"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[6], &arg8, s.thisObject());
    SE_PRECONDITION2(ok, false, "BakedSkinningModel_syncDataForJS,8,SWIGTYPE_p_cc__gfx__Texture"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[7], &temp9, s.thisObject());
    SE_PRECONDITION2(ok, false, "BakedSkinningModel_syncDataForJS,9,SWIGTYPE_p_cc__TypedArrayTempT_float_t");
    arg9 = &temp9;
    
    (arg1)->syncDataForJS((ccstd::vector< ccstd::optional< cc::geometry::AABB > > const &)*arg2,(ccstd::optional< cc::geometry::AABB > const &)*arg3,arg4,arg5,arg6,arg7,arg8,(cc::Float32Array const &)*arg9);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BakedSkinningModel_syncDataForJS) 

static bool js_cc_BakedSkinningModel_setUploadedAnimForJS(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::BakedSkinningModel *arg1 = (cc::BakedSkinningModel *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::BakedSkinningModel>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "BakedSkinningModel_setUploadedAnimForJS,2,SWIGTYPE_bool"); 
    (arg1)->setUploadedAnimForJS(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_BakedSkinningModel_setUploadedAnimForJS) 

bool js_register_cc_BakedSkinningModel(se::Object* obj) {
    auto* cls = se::Class::create("BakedSkinningModel", obj, __jsb_cc_MorphModel_proto, _SE(js_new_cc_BakedSkinningModel)); 
    
    
    cls->defineFunction("updateInstancedJointTextureInfo", _SE(js_cc_BakedSkinningModel_updateInstancedJointTextureInfo)); 
    cls->defineFunction("bindSkeleton", _SE(js_cc_BakedSkinningModel_bindSkeleton)); 
    cls->defineFunction("updateModelBounds", _SE(js_cc_BakedSkinningModel_updateModelBounds)); 
    cls->defineFunction("syncAnimInfoForJS", _SE(js_cc_BakedSkinningModel_syncAnimInfoForJS)); 
    cls->defineFunction("syncDataForJS", _SE(js_cc_BakedSkinningModel_syncDataForJS)); 
    cls->defineFunction("setUploadedAnimForJS", _SE(js_cc_BakedSkinningModel_setUploadedAnimForJS)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_BakedSkinningModel));
    
    
    cls->install();
    JSBClassType::registerClass<cc::BakedSkinningModel>(cls);
    
    __jsb_cc_BakedSkinningModel_proto = cls->getProto();
    __jsb_cc_BakedSkinningModel_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IDefineRecord_class = nullptr;
se::Object* __jsb_cc_IDefineRecord_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IDefineRecord) 

static bool js_cc_IDefineRecord_map_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDefineRecord *arg1 = (cc::IDefineRecord *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineRecord>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->map, s.thisObject());
    SE_PRECONDITION2(ok, false, "IDefineRecord_map_set,2,SWIGTYPE_std__functionT_int32_t_fccstd__variantT_int32_t_bool_ccstd__string_t_const_RF_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDefineRecord_map_set) 

static bool js_cc_IDefineRecord_map_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDefineRecord *arg1 = (cc::IDefineRecord *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineRecord>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->map, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IDefineRecord_map_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->map, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDefineRecord_map_get) 

static bool js_cc_IDefineRecord_offset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IDefineRecord *arg1 = (cc::IDefineRecord *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineRecord>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->offset, s.thisObject());
    SE_PRECONDITION2(ok, false, "IDefineRecord_offset_set,2,SWIGTYPE_int32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IDefineRecord_offset_set) 

static bool js_cc_IDefineRecord_offset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IDefineRecord *arg1 = (cc::IDefineRecord *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IDefineRecord>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->offset, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IDefineRecord_offset_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->offset, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IDefineRecord_offset_get) 

// js_ctor
static bool js_new_cc_IDefineRecord(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IDefineRecord *result;
    result = (cc::IDefineRecord *)new cc::IDefineRecord();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IDefineRecord, __jsb_cc_IDefineRecord_class, js_delete_cc_IDefineRecord)

static bool js_delete_cc_IDefineRecord(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IDefineRecord) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IDefineRecord * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IDefineRecord*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("map", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->map), ctx);
    }
    
    
    json->getProperty("offset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->offset), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IDefineRecord(se::Object* obj) {
    auto* cls = se::Class::create("IDefineRecord", obj, __jsb_cc_IDefineInfo_proto, _SE(js_new_cc_IDefineRecord)); 
    
    cls->defineProperty("map", _SE(js_cc_IDefineRecord_map_get), _SE(js_cc_IDefineRecord_map_set)); 
    cls->defineProperty("offset", _SE(js_cc_IDefineRecord_offset_get), _SE(js_cc_IDefineRecord_offset_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IDefineRecord));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IDefineRecord>(cls);
    
    __jsb_cc_IDefineRecord_proto = cls->getProto();
    __jsb_cc_IDefineRecord_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IMacroInfo_class = nullptr;
se::Object* __jsb_cc_IMacroInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IMacroInfo) 

static bool js_cc_IMacroInfo_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMacroInfo *arg1 = (cc::IMacroInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMacroInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->name, s.thisObject());
    SE_PRECONDITION2(ok, false, "IMacroInfo_name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMacroInfo_name_set) 

static bool js_cc_IMacroInfo_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMacroInfo *arg1 = (cc::IMacroInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMacroInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IMacroInfo_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMacroInfo_name_get) 

static bool js_cc_IMacroInfo_value_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMacroInfo *arg1 = (cc::IMacroInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMacroInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->value, s.thisObject());
    SE_PRECONDITION2(ok, false, "IMacroInfo_value_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMacroInfo_value_set) 

static bool js_cc_IMacroInfo_value_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMacroInfo *arg1 = (cc::IMacroInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMacroInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->value, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IMacroInfo_value_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->value, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMacroInfo_value_get) 

static bool js_cc_IMacroInfo_isDefault_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IMacroInfo *arg1 = (cc::IMacroInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMacroInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->isDefault);
    SE_PRECONDITION2(ok, false, "IMacroInfo_isDefault_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IMacroInfo_isDefault_set) 

static bool js_cc_IMacroInfo_isDefault_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IMacroInfo *arg1 = (cc::IMacroInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IMacroInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->isDefault, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IMacroInfo_isDefault_get) 

// js_ctor
static bool js_new_cc_IMacroInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IMacroInfo *result;
    result = (cc::IMacroInfo *)new cc::IMacroInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IMacroInfo, __jsb_cc_IMacroInfo_class, js_delete_cc_IMacroInfo)

static bool js_delete_cc_IMacroInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IMacroInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IMacroInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IMacroInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("name", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->name), ctx);
    }
    
    
    json->getProperty("value", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->value), ctx);
    }
    
    
    json->getProperty("isDefault", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->isDefault), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IMacroInfo(se::Object* obj) {
    auto* cls = se::Class::create("IMacroInfo", obj, nullptr, _SE(js_new_cc_IMacroInfo)); 
    
    cls->defineProperty("name", _SE(js_cc_IMacroInfo_name_get), _SE(js_cc_IMacroInfo_name_set)); 
    cls->defineProperty("value", _SE(js_cc_IMacroInfo_value_get), _SE(js_cc_IMacroInfo_value_set)); 
    cls->defineProperty("isDefault", _SE(js_cc_IMacroInfo_isDefault_get), _SE(js_cc_IMacroInfo_isDefault_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IMacroInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IMacroInfo>(cls);
    
    __jsb_cc_IMacroInfo_proto = cls->getProto();
    __jsb_cc_IMacroInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_IProgramInfo_class = nullptr;
se::Object* __jsb_cc_IProgramInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_IProgramInfo) 

static bool js_cc_IProgramInfo_effectName_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IProgramInfo *arg1 = (cc::IProgramInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IProgramInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->effectName, s.thisObject());
    SE_PRECONDITION2(ok, false, "IProgramInfo_effectName_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IProgramInfo_effectName_set) 

static bool js_cc_IProgramInfo_effectName_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IProgramInfo *arg1 = (cc::IProgramInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IProgramInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->effectName, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IProgramInfo_effectName_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->effectName, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IProgramInfo_effectName_get) 

static bool js_cc_IProgramInfo_defines_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IProgramInfo *arg1 = (cc::IProgramInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IProgramInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->defines, s.thisObject());
    SE_PRECONDITION2(ok, false, "IProgramInfo_defines_set,2,SWIGTYPE_ccstd__vectorT_cc__IDefineRecord_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IProgramInfo_defines_set) 

static bool js_cc_IProgramInfo_defines_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IProgramInfo *arg1 = (cc::IProgramInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IProgramInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->defines, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IProgramInfo_defines_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->defines, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IProgramInfo_defines_get) 

static bool js_cc_IProgramInfo_constantMacros_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IProgramInfo *arg1 = (cc::IProgramInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IProgramInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->constantMacros, s.thisObject());
    SE_PRECONDITION2(ok, false, "IProgramInfo_constantMacros_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IProgramInfo_constantMacros_set) 

static bool js_cc_IProgramInfo_constantMacros_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IProgramInfo *arg1 = (cc::IProgramInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IProgramInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->constantMacros, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "IProgramInfo_constantMacros_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->constantMacros, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IProgramInfo_constantMacros_get) 

static bool js_cc_IProgramInfo_uber_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IProgramInfo *arg1 = (cc::IProgramInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IProgramInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->uber);
    SE_PRECONDITION2(ok, false, "IProgramInfo_uber_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_IProgramInfo_uber_set) 

static bool js_cc_IProgramInfo_uber_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::IProgramInfo *arg1 = (cc::IProgramInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::IProgramInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->uber, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_IProgramInfo_uber_get) 

static bool js_cc_IProgramInfo_copyFrom(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IProgramInfo *arg1 = (cc::IProgramInfo *) NULL ;
    cc::IShaderInfo *arg2 = 0 ;
    cc::IShaderInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::IProgramInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "IProgramInfo_copyFrom,2,SWIGTYPE_p_cc__IShaderInfo");
    arg2 = &temp2;
    
    (arg1)->copyFrom((cc::IShaderInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_IProgramInfo_copyFrom) 

// js_ctor
static bool js_new_cc_IProgramInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::IProgramInfo *result;
    result = (cc::IProgramInfo *)new cc::IProgramInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_IProgramInfo, __jsb_cc_IProgramInfo_class, js_delete_cc_IProgramInfo)

static bool js_delete_cc_IProgramInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_IProgramInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::IProgramInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::IProgramInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("effectName", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->effectName), ctx);
    }
    
    
    json->getProperty("defines", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->defines), ctx);
    }
    
    
    json->getProperty("constantMacros", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->constantMacros), ctx);
    }
    
    
    json->getProperty("uber", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->uber), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_IProgramInfo(se::Object* obj) {
    auto* cls = se::Class::create("IProgramInfo", obj, __jsb_cc_IShaderInfo_proto, _SE(js_new_cc_IProgramInfo)); 
    
    cls->defineProperty("effectName", _SE(js_cc_IProgramInfo_effectName_get), _SE(js_cc_IProgramInfo_effectName_set)); 
    cls->defineProperty("defines", _SE(js_cc_IProgramInfo_defines_get), _SE(js_cc_IProgramInfo_defines_set)); 
    cls->defineProperty("constantMacros", _SE(js_cc_IProgramInfo_constantMacros_get), _SE(js_cc_IProgramInfo_constantMacros_set)); 
    cls->defineProperty("uber", _SE(js_cc_IProgramInfo_uber_get), _SE(js_cc_IProgramInfo_uber_set)); 
    
    cls->defineFunction("copyFrom", _SE(js_cc_IProgramInfo_copyFrom)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_IProgramInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::IProgramInfo>(cls);
    
    __jsb_cc_IProgramInfo_proto = cls->getProto();
    __jsb_cc_IProgramInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


static bool js_cc_getDeviceShaderVersion(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::gfx::Device *arg1 = (cc::gfx::Device *) NULL ;
    char *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "getDeviceShaderVersion,1,SWIGTYPE_p_cc__gfx__Device"); 
    result = (char *)cc::getDeviceShaderVersion((cc::gfx::Device const *)arg1);
    // out 6
    ok &= nativevalue_to_se(result, s.rval(), nullptr /*ctx*/);
    SE_PRECONDITION2(ok, false, "getDeviceShaderVersion, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_getDeviceShaderVersion) 

se::Class* __jsb_cc_ProgramLib_class = nullptr;
se::Object* __jsb_cc_ProgramLib_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_ProgramLib) 

static bool js_cc_ProgramLib_getInstance_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ProgramLib *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::ProgramLib *)cc::ProgramLib::getInstance();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ProgramLib_getInstance, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ProgramLib_getInstance_static) 

// js_ctor
static bool js_new_cc_ProgramLib(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::ProgramLib *result;
    result = (cc::ProgramLib *)new cc::ProgramLib();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_ProgramLib, __jsb_cc_ProgramLib_class, js_delete_cc_ProgramLib)

static bool js_delete_cc_ProgramLib(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_ProgramLib) 

static bool js_cc_ProgramLib_cpp_keyword_register(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ProgramLib *arg1 = (cc::ProgramLib *) NULL ;
    cc::EffectAsset *arg2 = (cc::EffectAsset *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ProgramLib>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ProgramLib_cpp_keyword_register,2,SWIGTYPE_p_cc__EffectAsset"); 
    (arg1)->registerEffect(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ProgramLib_cpp_keyword_register) 

static bool js_cc_ProgramLib_define(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ProgramLib *arg1 = (cc::ProgramLib *) NULL ;
    cc::IShaderInfo *arg2 = 0 ;
    cc::IShaderInfo temp2 ;
    cc::IProgramInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ProgramLib>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ProgramLib_define,2,SWIGTYPE_p_cc__IShaderInfo");
    arg2 = &temp2;
    
    result = (cc::IProgramInfo *)(arg1)->define(*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ProgramLib_define, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ProgramLib_define) 

static bool js_cc_ProgramLib_getTemplate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ProgramLib *arg1 = (cc::ProgramLib *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    cc::IProgramInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ProgramLib>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ProgramLib_getTemplate,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = (cc::IProgramInfo *)(arg1)->getTemplate((ccstd::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ProgramLib_getTemplate, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ProgramLib_getTemplate) 

static bool js_cc_ProgramLib_getTemplateInfo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ProgramLib *arg1 = (cc::ProgramLib *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    cc::ITemplateInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ProgramLib>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ProgramLib_getTemplateInfo,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = (cc::ITemplateInfo *)(arg1)->getTemplateInfo((ccstd::string const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ProgramLib_getTemplateInfo, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ProgramLib_getTemplateInfo) 

static bool js_cc_ProgramLib_getDescriptorSetLayout__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::ProgramLib *arg1 = (cc::ProgramLib *) NULL ;
    cc::gfx::Device *arg2 = (cc::gfx::Device *) NULL ;
    ccstd::string *arg3 = 0 ;
    bool arg4 ;
    ccstd::string temp3 ;
    cc::gfx::DescriptorSetLayout *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::ProgramLib>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ProgramLib_getDescriptorSetLayout,2,SWIGTYPE_p_cc__gfx__Device"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "ProgramLib_getDescriptorSetLayout,3,SWIGTYPE_p_ccstd__string");
    arg3 = &temp3;
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "ProgramLib_getDescriptorSetLayout,4,SWIGTYPE_bool"); 
    result = (cc::gfx::DescriptorSetLayout *)(arg1)->getDescriptorSetLayout(arg2,(ccstd::string const &)*arg3,arg4);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ProgramLib_getDescriptorSetLayout, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_ProgramLib_getDescriptorSetLayout__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::ProgramLib *arg1 = (cc::ProgramLib *) NULL ;
    cc::gfx::Device *arg2 = (cc::gfx::Device *) NULL ;
    ccstd::string *arg3 = 0 ;
    ccstd::string temp3 ;
    cc::gfx::DescriptorSetLayout *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::ProgramLib>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ProgramLib_getDescriptorSetLayout,2,SWIGTYPE_p_cc__gfx__Device"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "ProgramLib_getDescriptorSetLayout,3,SWIGTYPE_p_ccstd__string");
    arg3 = &temp3;
    
    result = (cc::gfx::DescriptorSetLayout *)(arg1)->getDescriptorSetLayout(arg2,(ccstd::string const &)*arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ProgramLib_getDescriptorSetLayout, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_ProgramLib_getDescriptorSetLayout(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_ProgramLib_getDescriptorSetLayout__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_ProgramLib_getDescriptorSetLayout__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_ProgramLib_getDescriptorSetLayout) 

static bool js_cc_ProgramLib_hasProgram(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ProgramLib *arg1 = (cc::ProgramLib *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ProgramLib>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ProgramLib_hasProgram,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = (bool)((cc::ProgramLib const *)arg1)->hasProgram((ccstd::string const &)*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ProgramLib_hasProgram) 

static bool js_cc_ProgramLib_getKey(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ProgramLib *arg1 = (cc::ProgramLib *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::MacroRecord *arg3 = 0 ;
    ccstd::string temp2 ;
    cc::MacroRecord temp3 ;
    ccstd::string result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ProgramLib>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ProgramLib_getKey,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "ProgramLib_getKey,3,SWIGTYPE_p_ccstd__unordered_mapT_ccstd__string_cc__MacroValue_t");
    arg3 = &temp3;
    
    result = (arg1)->getKey((ccstd::string const &)*arg2,(cc::MacroRecord const &)*arg3);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ProgramLib_getKey, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ProgramLib_getKey) 

static bool js_cc_ProgramLib_destroyShaderByDefines(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ProgramLib *arg1 = (cc::ProgramLib *) NULL ;
    cc::MacroRecord *arg2 = 0 ;
    cc::MacroRecord temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ProgramLib>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ProgramLib_destroyShaderByDefines,2,SWIGTYPE_p_ccstd__unordered_mapT_ccstd__string_cc__MacroValue_t");
    arg2 = &temp2;
    
    (arg1)->destroyShaderByDefines((cc::MacroRecord const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ProgramLib_destroyShaderByDefines) 

static bool js_cc_ProgramLib_getGFXShader__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::ProgramLib *arg1 = (cc::ProgramLib *) NULL ;
    cc::gfx::Device *arg2 = (cc::gfx::Device *) NULL ;
    ccstd::string *arg3 = 0 ;
    cc::MacroRecord *arg4 = 0 ;
    cc::render::PipelineRuntime *arg5 = (cc::render::PipelineRuntime *) NULL ;
    ccstd::string *arg6 = (ccstd::string *) NULL ;
    ccstd::string temp3 ;
    cc::MacroRecord temp4 ;
    cc::gfx::Shader *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::ProgramLib>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ProgramLib_getGFXShader,2,SWIGTYPE_p_cc__gfx__Device"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "ProgramLib_getGFXShader,3,SWIGTYPE_p_ccstd__string");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "ProgramLib_getGFXShader,4,SWIGTYPE_p_ccstd__unordered_mapT_ccstd__string_cc__MacroValue_t");
    arg4 = &temp4;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "ProgramLib_getGFXShader,5,SWIGTYPE_p_cc__render__PipelineRuntime"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "ProgramLib_getGFXShader,6,SWIGTYPE_p_ccstd__string"); 
    result = (cc::gfx::Shader *)(arg1)->getGFXShader(arg2,(ccstd::string const &)*arg3,*arg4,arg5,arg6);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ProgramLib_getGFXShader, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_ProgramLib_getGFXShader__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::ProgramLib *arg1 = (cc::ProgramLib *) NULL ;
    cc::gfx::Device *arg2 = (cc::gfx::Device *) NULL ;
    ccstd::string *arg3 = 0 ;
    cc::MacroRecord *arg4 = 0 ;
    cc::render::PipelineRuntime *arg5 = (cc::render::PipelineRuntime *) NULL ;
    ccstd::string temp3 ;
    cc::MacroRecord temp4 ;
    cc::gfx::Shader *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::ProgramLib>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ProgramLib_getGFXShader,2,SWIGTYPE_p_cc__gfx__Device"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "ProgramLib_getGFXShader,3,SWIGTYPE_p_ccstd__string");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "ProgramLib_getGFXShader,4,SWIGTYPE_p_ccstd__unordered_mapT_ccstd__string_cc__MacroValue_t");
    arg4 = &temp4;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "ProgramLib_getGFXShader,5,SWIGTYPE_p_cc__render__PipelineRuntime"); 
    result = (cc::gfx::Shader *)(arg1)->getGFXShader(arg2,(ccstd::string const &)*arg3,*arg4,arg5);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ProgramLib_getGFXShader, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_ProgramLib_getGFXShader(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 5) {
        ok = js_cc_ProgramLib_getGFXShader__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_ProgramLib_getGFXShader__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_ProgramLib_getGFXShader) 

bool js_register_cc_ProgramLib(se::Object* obj) {
    auto* cls = se::Class::create("ProgramLib", obj, nullptr, _SE(js_new_cc_ProgramLib)); 
    
    
    cls->defineFunction("register", _SE(js_cc_ProgramLib_cpp_keyword_register)); 
    cls->defineFunction("define", _SE(js_cc_ProgramLib_define)); 
    cls->defineFunction("getTemplate", _SE(js_cc_ProgramLib_getTemplate)); 
    cls->defineFunction("getTemplateInfo", _SE(js_cc_ProgramLib_getTemplateInfo)); 
    cls->defineFunction("getDescriptorSetLayout", _SE(js_cc_ProgramLib_getDescriptorSetLayout)); 
    cls->defineFunction("hasProgram", _SE(js_cc_ProgramLib_hasProgram)); 
    cls->defineFunction("getKey", _SE(js_cc_ProgramLib_getKey)); 
    cls->defineFunction("destroyShaderByDefines", _SE(js_cc_ProgramLib_destroyShaderByDefines)); 
    cls->defineFunction("getGFXShader", _SE(js_cc_ProgramLib_getGFXShader)); 
    
    
    cls->defineStaticFunction("getInstance", _SE(js_cc_ProgramLib_getInstance_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_ProgramLib));
    
    
    cls->install();
    JSBClassType::registerClass<cc::ProgramLib>(cls);
    
    __jsb_cc_ProgramLib_proto = cls->getProto();
    __jsb_cc_ProgramLib_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_OctreeInfo_class = nullptr;
se::Object* __jsb_cc_scene_OctreeInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_OctreeInfo) 

// js_ctor
static bool js_new_cc_scene_OctreeInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::OctreeInfo *result;
    result = (cc::scene::OctreeInfo *)new cc::scene::OctreeInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_OctreeInfo, __jsb_cc_scene_OctreeInfo_class, js_delete_cc_scene_OctreeInfo)

static bool js_delete_cc_scene_OctreeInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_OctreeInfo) 

static bool js_cc_scene_OctreeInfo_activate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    cc::scene::Octree *arg2 = (cc::scene::Octree *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "OctreeInfo_activate,2,SWIGTYPE_p_cc__scene__Octree"); 
    (arg1)->activate(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_OctreeInfo_activate) 

static bool js_cc_scene_OctreeInfo__enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->_enabled);
    SE_PRECONDITION2(ok, false, "OctreeInfo__enabled_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_OctreeInfo__enabled_set) 

static bool js_cc_scene_OctreeInfo__enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->_enabled, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_OctreeInfo__enabled_get) 

static bool js_cc_scene_OctreeInfo__minPos_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_minPos, s.thisObject());
    SE_PRECONDITION2(ok, false, "OctreeInfo__minPos_set,2,SWIGTYPE_cc__Vec3"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_OctreeInfo__minPos_set) 

static bool js_cc_scene_OctreeInfo__minPos_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_minPos, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "OctreeInfo__minPos_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_minPos, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_OctreeInfo__minPos_get) 

static bool js_cc_scene_OctreeInfo__maxPos_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_maxPos, s.thisObject());
    SE_PRECONDITION2(ok, false, "OctreeInfo__maxPos_set,2,SWIGTYPE_cc__Vec3"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_OctreeInfo__maxPos_set) 

static bool js_cc_scene_OctreeInfo__maxPos_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_maxPos, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "OctreeInfo__maxPos_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_maxPos, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_OctreeInfo__maxPos_get) 

static bool js_cc_scene_OctreeInfo__depth_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_depth, s.thisObject());
    SE_PRECONDITION2(ok, false, "OctreeInfo__depth_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_OctreeInfo__depth_set) 

static bool js_cc_scene_OctreeInfo__depth_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_depth, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "OctreeInfo__depth_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_depth, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_OctreeInfo__depth_get) 

static bool js_cc_scene_OctreeInfo_enabled_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "OctreeInfo_enabled_set,2,SWIGTYPE_bool"); 
    cc_scene_OctreeInfo_enabled_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_OctreeInfo_enabled_set) 

static bool js_cc_scene_OctreeInfo_enabled_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_scene_OctreeInfo_enabled_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_OctreeInfo_enabled_get) 

static bool js_cc_scene_OctreeInfo_minPos_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "OctreeInfo_minPos_set,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    cc_scene_OctreeInfo_minPos_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_OctreeInfo_minPos_set) 

static bool js_cc_scene_OctreeInfo_minPos_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Vec3 *) &cc_scene_OctreeInfo_minPos_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "OctreeInfo_minPos_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_OctreeInfo_minPos_get) 

static bool js_cc_scene_OctreeInfo_maxPos_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "OctreeInfo_maxPos_set,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    cc_scene_OctreeInfo_maxPos_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_OctreeInfo_maxPos_set) 

static bool js_cc_scene_OctreeInfo_maxPos_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Vec3 *) &cc_scene_OctreeInfo_maxPos_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "OctreeInfo_maxPos_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_OctreeInfo_maxPos_get) 

static bool js_cc_scene_OctreeInfo_depth_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "OctreeInfo_depth_set,2,SWIGTYPE_uint32_t"); 
    
    cc_scene_OctreeInfo_depth_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_OctreeInfo_depth_set) 

static bool js_cc_scene_OctreeInfo_depth_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::OctreeInfo *arg1 = (cc::scene::OctreeInfo *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::OctreeInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = cc_scene_OctreeInfo_depth_get(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "OctreeInfo_depth_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_OctreeInfo_depth_get) 

bool js_register_cc_scene_OctreeInfo(se::Object* obj) {
    auto* cls = se::Class::create("OctreeInfo", obj, nullptr, _SE(js_new_cc_scene_OctreeInfo)); 
    
    cls->defineProperty("_enabled", _SE(js_cc_scene_OctreeInfo__enabled_get), _SE(js_cc_scene_OctreeInfo__enabled_set)); 
    cls->defineProperty("_minPos", _SE(js_cc_scene_OctreeInfo__minPos_get), _SE(js_cc_scene_OctreeInfo__minPos_set)); 
    cls->defineProperty("_maxPos", _SE(js_cc_scene_OctreeInfo__maxPos_get), _SE(js_cc_scene_OctreeInfo__maxPos_set)); 
    cls->defineProperty("_depth", _SE(js_cc_scene_OctreeInfo__depth_get), _SE(js_cc_scene_OctreeInfo__depth_set)); 
    cls->defineProperty("enabled", _SE(js_cc_scene_OctreeInfo_enabled_get), _SE(js_cc_scene_OctreeInfo_enabled_set)); 
    cls->defineProperty("minPos", _SE(js_cc_scene_OctreeInfo_minPos_get), _SE(js_cc_scene_OctreeInfo_minPos_set)); 
    cls->defineProperty("maxPos", _SE(js_cc_scene_OctreeInfo_maxPos_get), _SE(js_cc_scene_OctreeInfo_maxPos_set)); 
    cls->defineProperty("depth", _SE(js_cc_scene_OctreeInfo_depth_get), _SE(js_cc_scene_OctreeInfo_depth_set)); 
    
    cls->defineFunction("activate", _SE(js_cc_scene_OctreeInfo_activate)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_OctreeInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::OctreeInfo>(cls);
    
    __jsb_cc_scene_OctreeInfo_proto = cls->getProto();
    __jsb_cc_scene_OctreeInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_BBox_class = nullptr;
se::Object* __jsb_cc_scene_BBox_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_BBox) 

static bool js_cc_scene_BBox_min_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::BBox *arg1 = (cc::scene::BBox *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::BBox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->min, s.thisObject());
    SE_PRECONDITION2(ok, false, "BBox_min_set,2,SWIGTYPE_cc__Vec3"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_BBox_min_set) 

static bool js_cc_scene_BBox_min_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::BBox *arg1 = (cc::scene::BBox *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::BBox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->min, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BBox_min_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->min, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_BBox_min_get) 

static bool js_cc_scene_BBox_max_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::BBox *arg1 = (cc::scene::BBox *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::BBox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->max, s.thisObject());
    SE_PRECONDITION2(ok, false, "BBox_max_set,2,SWIGTYPE_cc__Vec3"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_scene_BBox_max_set) 

static bool js_cc_scene_BBox_max_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::scene::BBox *arg1 = (cc::scene::BBox *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::scene::BBox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->max, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BBox_max_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->max, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_scene_BBox_max_get) 

static bool js_new_cc_scene_BBox__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::scene::BBox *result;
    result = (cc::scene::BBox *)new cc::scene::BBox();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_scene_BBox__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::AABB *arg1 = 0 ;
    cc::geometry::AABB temp1 ;
    cc::scene::BBox *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_BBox,1,SWIGTYPE_p_cc__geometry__AABB");
    arg1 = &temp1;
    
    result = (cc::scene::BBox *)new cc::scene::BBox((cc::geometry::AABB const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_scene_BBox__SWIG_2(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::Vec3 *arg1 = 0 ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp1 ;
    cc::Vec3 temp2 ;
    cc::scene::BBox *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_BBox,1,SWIGTYPE_p_cc__Vec3");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_BBox,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    result = (cc::scene::BBox *)new cc::scene::BBox((cc::Vec3 const &)*arg1,(cc::Vec3 const &)*arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_BBox(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_ctor_dispatcher
    size_t argc = s.args().size();
    bool ret = false;
    
    // switch all cases by means of series of if-returns.
    
    // js_ctor_dispatch_case
    if(argc == 0) {
        ret = js_new_cc_scene_BBox__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_scene_BBox__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 2) {
        ret = js_new_cc_scene_BBox__SWIG_2(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    
    // default:
    SE_REPORT_ERROR("Illegal arguments for construction of BBox");
    return false;
}
SE_BIND_CTOR(js_new_BBox, __jsb_cc_scene_BBox_class, js_delete_cc_scene_BBox)

static bool js_cc_scene_BBox_getCenter(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::BBox *arg1 = (cc::scene::BBox *) NULL ;
    cc::Vec3 result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::BBox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::scene::BBox const *)arg1)->getCenter();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "BBox_getCenter, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_BBox_getCenter) 

static bool js_cc_scene_BBox_contain__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::BBox *arg1 = (cc::scene::BBox *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::BBox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BBox_contain,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    result = (bool)((cc::scene::BBox const *)arg1)->contain((cc::Vec3 const &)*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_cc_scene_BBox_contain__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::scene::BBox *arg1 = (cc::scene::BBox *) NULL ;
    cc::scene::BBox *arg2 = 0 ;
    cc::scene::BBox temp2 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::scene::BBox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BBox_contain,2,SWIGTYPE_p_cc__scene__BBox");
    arg2 = &temp2;
    
    result = (bool)((cc::scene::BBox const *)arg1)->contain((cc::scene::BBox const &)*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_cc_scene_BBox_contain(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_scene_BBox_contain__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_scene_BBox_contain__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_scene_BBox_contain) 

static bool js_cc_scene_BBox_intersect(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::BBox *arg1 = (cc::scene::BBox *) NULL ;
    cc::scene::BBox *arg2 = 0 ;
    cc::scene::BBox temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::BBox>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "BBox_intersect,2,SWIGTYPE_p_cc__scene__BBox");
    arg2 = &temp2;
    
    result = (bool)((cc::scene::BBox const *)arg1)->intersect((cc::scene::BBox const &)*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_BBox_intersect) 

static bool js_delete_cc_scene_BBox(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_BBox) 

template<>
bool sevalue_to_native(const se::Value &from, cc::scene::BBox * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::scene::BBox*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("min", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->min), ctx);
    }
    
    
    json->getProperty("max", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->max), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_scene_BBox(se::Object* obj) {
    auto* cls = se::Class::create("BBox", obj, nullptr, _SE(js_new_BBox)); 
    
    cls->defineProperty("min", _SE(js_cc_scene_BBox_min_get), _SE(js_cc_scene_BBox_min_set)); 
    cls->defineProperty("max", _SE(js_cc_scene_BBox_max_get), _SE(js_cc_scene_BBox_max_set)); 
    
    cls->defineFunction("getCenter", _SE(js_cc_scene_BBox_getCenter)); 
    cls->defineFunction("contain", _SE(js_cc_scene_BBox_contain)); 
    cls->defineFunction("intersect", _SE(js_cc_scene_BBox_intersect)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_BBox));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::BBox>(cls);
    
    __jsb_cc_scene_BBox_proto = cls->getProto();
    __jsb_cc_scene_BBox_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_OctreeNode_class = nullptr;
se::Object* __jsb_cc_scene_OctreeNode_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_OctreeNode) 

bool js_register_cc_scene_OctreeNode(se::Object* obj) {
    auto* cls = se::Class::create("OctreeNode", obj, nullptr, nullptr); 
    
    
    
    
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::OctreeNode>(cls);
    
    __jsb_cc_scene_OctreeNode_proto = cls->getProto();
    __jsb_cc_scene_OctreeNode_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_scene_Octree_class = nullptr;
se::Object* __jsb_cc_scene_Octree_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_scene_Octree) 

// js_ctor
static bool js_new_cc_scene_Octree(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::scene::Octree *result;
    result = (cc::scene::Octree *)new cc::scene::Octree();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_scene_Octree, __jsb_cc_scene_Octree_class, js_delete_cc_scene_Octree)

static bool js_delete_cc_scene_Octree(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_scene_Octree) 

static bool js_cc_scene_Octree_initialize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    cc::scene::OctreeInfo *arg2 = 0 ;
    cc::scene::OctreeInfo temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Octree_initialize,2,SWIGTYPE_p_cc__scene__OctreeInfo");
    arg2 = &temp2;
    
    (arg1)->initialize((cc::scene::OctreeInfo const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_initialize) 

static bool js_cc_scene_Octree_setEnabled(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Octree_setEnabled,2,SWIGTYPE_bool"); 
    (arg1)->setEnabled(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_setEnabled) 

static bool js_cc_scene_Octree_isEnabled(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((cc::scene::Octree const *)arg1)->isEnabled();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_isEnabled) 

static bool js_cc_scene_Octree_setMinPos(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Octree_setMinPos,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    (arg1)->setMinPos((cc::Vec3 const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_setMinPos) 

static bool js_cc_scene_Octree_getMinPos(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    cc::Vec3 *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Vec3 *) &((cc::scene::Octree const *)arg1)->getMinPos();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Octree_getMinPos, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_getMinPos) 

static bool js_cc_scene_Octree_setMaxPos(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Octree_setMaxPos,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    (arg1)->setMaxPos((cc::Vec3 const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_setMaxPos) 

static bool js_cc_scene_Octree_getMaxPos(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    cc::Vec3 *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Vec3 *) &((cc::scene::Octree const *)arg1)->getMaxPos();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Octree_getMaxPos, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_getMaxPos) 

static bool js_cc_scene_Octree_resize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    uint32_t arg4 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Octree_resize,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Octree_resize,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Octree_resize,4,SWIGTYPE_uint32_t"); 
    
    (arg1)->resize((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_resize) 

static bool js_cc_scene_Octree_insert(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    cc::scene::Model *arg2 = (cc::scene::Model *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Octree_insert,2,SWIGTYPE_p_cc__scene__Model"); 
    (arg1)->insert(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_insert) 

static bool js_cc_scene_Octree_remove(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    cc::scene::Model *arg2 = (cc::scene::Model *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Octree_remove,2,SWIGTYPE_p_cc__scene__Model"); 
    (arg1)->remove(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_remove) 

static bool js_cc_scene_Octree_update(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    cc::scene::Model *arg2 = (cc::scene::Model *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Octree_update,2,SWIGTYPE_p_cc__scene__Model"); 
    (arg1)->update(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_update) 

static bool js_cc_scene_Octree_setMaxDepth(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Octree_setMaxDepth,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->setMaxDepth(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_setMaxDepth) 

static bool js_cc_scene_Octree_getMaxDepth(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::scene::Octree const *)arg1)->getMaxDepth();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Octree_getMaxDepth, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_getMaxDepth) 

static bool js_cc_scene_Octree_queryVisibility(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::scene::Octree *arg1 = (cc::scene::Octree *) NULL ;
    cc::scene::Camera *arg2 = (cc::scene::Camera *) NULL ;
    cc::geometry::Frustum *arg3 = 0 ;
    bool arg4 ;
    ccstd::vector< cc::scene::Model * > *arg5 = 0 ;
    cc::geometry::Frustum temp3 ;
    ccstd::vector< cc::scene::Model * > temp5 ;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::scene::Octree>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Octree_queryVisibility,2,SWIGTYPE_p_cc__scene__Camera"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Octree_queryVisibility,3,SWIGTYPE_p_cc__geometry__Frustum");
    arg3 = &temp3;
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[2], &arg4);
    SE_PRECONDITION2(ok, false, "Octree_queryVisibility,4,SWIGTYPE_bool"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Octree_queryVisibility,5,SWIGTYPE_p_ccstd__vectorT_cc__scene__Model_p_t");
    arg5 = &temp5;
    
    ((cc::scene::Octree const *)arg1)->queryVisibility(arg2,(cc::geometry::Frustum const &)*arg3,arg4,*arg5);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_scene_Octree_queryVisibility) 

bool js_register_cc_scene_Octree(se::Object* obj) {
    auto* cls = se::Class::create("Octree", obj, nullptr, _SE(js_new_cc_scene_Octree)); 
    
    
    cls->defineFunction("initialize", _SE(js_cc_scene_Octree_initialize)); 
    cls->defineFunction("setEnabled", _SE(js_cc_scene_Octree_setEnabled)); 
    cls->defineFunction("isEnabled", _SE(js_cc_scene_Octree_isEnabled)); 
    cls->defineFunction("setMinPos", _SE(js_cc_scene_Octree_setMinPos)); 
    cls->defineFunction("getMinPos", _SE(js_cc_scene_Octree_getMinPos)); 
    cls->defineFunction("setMaxPos", _SE(js_cc_scene_Octree_setMaxPos)); 
    cls->defineFunction("getMaxPos", _SE(js_cc_scene_Octree_getMaxPos)); 
    cls->defineFunction("resize", _SE(js_cc_scene_Octree_resize)); 
    cls->defineFunction("insert", _SE(js_cc_scene_Octree_insert)); 
    cls->defineFunction("remove", _SE(js_cc_scene_Octree_remove)); 
    cls->defineFunction("update", _SE(js_cc_scene_Octree_update)); 
    cls->defineFunction("setMaxDepth", _SE(js_cc_scene_Octree_setMaxDepth)); 
    cls->defineFunction("getMaxDepth", _SE(js_cc_scene_Octree_getMaxDepth)); 
    cls->defineFunction("queryVisibility", _SE(js_cc_scene_Octree_queryVisibility)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_scene_Octree));
    
    
    cls->install();
    JSBClassType::registerClass<cc::scene::Octree>(cls);
    
    __jsb_cc_scene_Octree_proto = cls->getProto();
    __jsb_cc_scene_Octree_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}




bool register_all_scene(se::Object* obj) {
    // Get the ns
    se::Value nsVal;
    if (!obj->getProperty("jsb", &nsVal, true))
    {
        se::HandleObject jsobj(se::Object::createPlainObject());
        nsVal.setObject(jsobj);
        obj->setProperty("jsb", nsVal);
    }
    se::Object* ns = nsVal.toObject();
    /* Register classes */
    js_register_cc_Layers(ns); 
    js_register_cc_BaseNode(ns); 
    js_register_cc_Node(ns); 
    js_register_cc_Node_UserData(ns); 
    js_register_cc_Scene(ns); 
    js_register_cc_SceneGlobals(ns); 
    js_register_cc_DebugViewConfig(ns); 
    js_register_cc_Root(ns); 
    js_register_cc_scene_IMacroPatch(ns); 
    js_register_cc_scene_Light(ns); 
    js_register_cc_scene_Fog(ns); 
    js_register_cc_scene_FogInfo(ns); 
    js_register_cc_scene_ShadowsInfo(ns); 
    js_register_cc_scene_Shadows(ns); 
    js_register_cc_scene_SkyboxInfo(ns); 
    js_register_cc_scene_Skybox(ns); 
    js_register_cc_scene_DirectionalLight(ns); 
    js_register_cc_scene_SpotLight(ns); 
    js_register_cc_scene_SphereLight(ns); 
    js_register_cc_scene_InstancedAttributeBlock(ns); 
    js_register_cc_scene_Model(ns); 
    js_register_cc_scene_SubModel(ns); 
    js_register_cc_scene_PassDynamicsValue(ns); 
    js_register_cc_scene_IBlockRef(ns); 
    js_register_cc_scene_Pass(ns); 
    js_register_cc_scene_IRaycastResult(ns); 
    js_register_cc_scene_IRenderSceneInfo(ns); 
    js_register_cc_scene_RenderScene(ns); 
    js_register_cc_scene_IRenderWindowInfo(ns); 
    js_register_cc_scene_RenderWindow(ns); 
    js_register_cc_scene_ICameraInfo(ns); 
    js_register_cc_scene_Camera(ns); 
    js_register_cc_scene_Ambient(ns); 
    js_register_cc_scene_AmbientInfo(ns); 
    js_register_cc_PassInstance(ns); 
    js_register_cc_IMaterialInstanceInfo(ns); 
    js_register_cc_MaterialInstance(ns); 
    js_register_cc_MorphModel(ns); 
    js_register_cc_SkinningModel(ns); 
    js_register_cc_BakedSkinningModel(ns); 
    js_register_cc_IDefineRecord(ns); 
    js_register_cc_IMacroInfo(ns); 
    js_register_cc_IProgramInfo(ns); 
    js_register_cc_ProgramLib(ns); 
    js_register_cc_scene_OctreeInfo(ns); 
    js_register_cc_scene_BBox(ns); 
    js_register_cc_scene_OctreeNode(ns); 
    js_register_cc_scene_Octree(ns); 
    
    /* Register global variables & global functions */
    
    
    
    return true;
}

// clang-format on
